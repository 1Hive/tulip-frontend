{"ast":null,"code":"import { useMemo } from 'react';\nimport { useQuery } from 'urql';\nimport { useHNYBalanceOfPolling } from './useCourtContracts';\nimport { useCourtConfig } from '../providers/CourtConfig'; // queries\n\nimport { OpenTasks } from '../queries/tasks';\nimport { CourtConfig, FeeMovements, JurorsRegistryModule } from '../queries/court';\nimport { AllDisputes, SingleDispute } from '../queries/disputes';\nimport { AppealsByMaker, AppealsByTaker } from '../queries/appeals';\nimport { JurorHNYBalances, JurorTreasuryBalances } from '../queries/balances';\nimport { JurorDraftsFrom, JurorDraftsRewards } from '../queries/jurorDrafts'; // utils\n\nimport { bigNum } from '../lib/math-utils';\nimport { dayjs, toMs } from '../utils/date-utils';\nimport { groupMovements } from '../utils/anj-movement-utils';\nimport { transformAppealDataAttributes } from '../utils/appeal-utils';\nimport { transformRoundDataAttributes, transformDisputeDataAttributes } from '../utils/dispute-utils';\nimport { transformJurorDataAttributes } from '../utils/juror-draft-utils';\nimport { transformClaimedFeesDataAttributes } from '../utils/subscription-utils';\nimport { getModuleAddress, transformCourtConfigDataAttributes } from '../utils/court-utils'; // types\n\nimport { CourtModuleType } from '../types/court-module-types';\nimport { JurorLastFeeWithdrawal } from '../queries/juror';\nconst NO_AMOUNT = bigNum(0);\n\nfunction useQuerySub(query, variables = {}, options = {}) {\n  return useQuery({\n    query: query,\n    variables: variables,\n    requestPolicy: 'cache-and-network',\n    pollInterval: 13 * 1000,\n    ...options\n  });\n} // Subscription to get juror's active, inactive and\n// locked balances and all 24 hrs movements\n\n\nfunction useJuror(jurorId) {\n  // get 24hs from current time (seconds)\n  const yesterday = dayjs().subtract(1, 'day').unix();\n  const [{\n    data,\n    error\n  }] = useQuerySub(JurorHNYBalances, {\n    id: jurorId.toLowerCase(),\n    from: yesterday\n  });\n  return {\n    data,\n    error\n  };\n} // Subscription to get all treasury balances of juror with id `jurorId`\n\n\nfunction useJurorTreasuryBalances(jurorId) {\n  const [{\n    data,\n    error\n  }] = useQuerySub(JurorTreasuryBalances, {\n    owner: jurorId.toLowerCase()\n  });\n  return {\n    data,\n    error\n  };\n}\n/**\r\n * Subscribes to all juror balances as well as to the latest 24h movements and all subscription fees claimed by the juror\r\n * @param {String} jurorId Address of the juror\r\n * @returns {Object} Object containing al juror balances (Wallet, Inactive, Active, Locked, Deactivation Process, Treasury),\r\n * latest 24h movements and all subscription fees claimed by the juror\r\n */\n\n\nexport function useJurorBalancesSubscription(jurorId) {\n  const walletBalance = useHNYBalanceOfPolling(jurorId); // Juror ANJ balances, 24h movements and subscritpion claimed fees\n\n  const {\n    data: jurorData,\n    error: jurorError\n  } = useJuror(jurorId);\n  const {\n    data: treasuryBalancesData,\n    error: treasuryBalancesError\n  } = useJurorTreasuryBalances(jurorId);\n  const errors = [jurorError, treasuryBalancesError].filter(err => err);\n  const {\n    anjBalances,\n    anjMovements,\n    claimedSubscriptionFees,\n    treasury\n  } = useMemo(() => {\n    // Means it's still fetching\n    if (!jurorData || !treasuryBalancesData) {\n      return {};\n    } // If the juror is null then means that the connnected account is not a juror but we are already done fetching\n    // We set 0 as default values\n\n\n    const {\n      activeBalance = NO_AMOUNT,\n      anjMovements = [],\n      availableBalance = NO_AMOUNT,\n      claimedSubscriptionFees = [],\n      deactivationBalance = NO_AMOUNT,\n      lockedBalance = NO_AMOUNT\n    } = jurorData.juror || {};\n    const {\n      treasuryBalances = []\n    } = treasuryBalancesData || {};\n    return {\n      anjBalances: {\n        walletBalance,\n        activeBalance: bigNum(activeBalance),\n        deactivationBalance: bigNum(deactivationBalance),\n        inactiveBalance: bigNum(availableBalance),\n        lockedBalance: bigNum(lockedBalance)\n      },\n      anjMovements: groupMovements(anjMovements),\n      claimedSubscriptionFees: claimedSubscriptionFees.map(transformClaimedFeesDataAttributes),\n      treasury: treasuryBalances.map(balance => ({ ...balance,\n        amount: bigNum(balance.amount)\n      }))\n    };\n  }, [jurorData, treasuryBalancesData, walletBalance]);\n  return {\n    anjBalances,\n    anjMovements,\n    claimedSubscriptionFees,\n    treasury,\n    fetching: !anjBalances && errors.length === 0,\n    errors\n  };\n}\n/**\r\n * Subscribes to the court configuration data\r\n * @param {String} courtAddress Adrress of the court contract\r\n * @returns {Object} Court configuration data\r\n */\n\nexport function useCourtConfigSubscription(courtAddress) {\n  const [{\n    data\n  }] = useQuerySub(CourtConfig, {\n    id: courtAddress.toLowerCase()\n  }); // TODO: handle possible errors\n\n  const courtConfig = useMemo(() => (data === null || data === void 0 ? void 0 : data.courtConfig) ? transformCourtConfigDataAttributes(data.courtConfig) : null, [data]);\n  return courtConfig;\n}\n/**\r\n * Subscribes to the dispute with id == `id`\r\n * @param {String} id Id of the dispute\r\n * @returns {Object} Dispute by `id`\r\n */\n\nexport function useSingleDisputeSubscription(id) {\n  const [{\n    data,\n    error\n  }] = useQuerySub(SingleDispute, {\n    id\n  });\n  const dispute = useMemo(() => data && data.dispute ? transformDisputeDataAttributes(data.dispute) : null, [data]);\n  return {\n    dispute,\n    fetching: !data && !error,\n    error\n  };\n}\n/**\r\n * Subscribes to all existing disputes on the court\r\n * @returns {Object} All disputes\r\n */\n\nexport function useDisputesSubscription() {\n  const courtConfig = useCourtConfig();\n  const [{\n    data,\n    error\n  }] = useQuerySub(AllDisputes);\n  const disputes = useMemo(() => (data === null || data === void 0 ? void 0 : data.disputes) ? data.disputes.map(dispute => transformDisputeDataAttributes(dispute, courtConfig)) : null, [courtConfig, data]);\n  return {\n    disputes,\n    fetching: !data && !error,\n    error\n  };\n}\n/**\r\n * Subscribe to all `jurorId` drafts for the current term\r\n * @param {String} jurorId Address of the juror\r\n * @param {Number} termStartTime Start time of the term inseconds\r\n * @param {Boolean} pause Tells whether to pause the subscription or not\r\n * @returns {Object} All `jurorId` drafts for the current term\r\n */\n\nexport function useCurrentTermJurorDraftsSubscription(jurorId, termStartTime, pause) {\n  const [result] = useQuerySub(JurorDraftsFrom, {\n    id: jurorId.toLowerCase(),\n    from: termStartTime\n  }, {\n    pause\n  });\n  const {\n    juror\n  } = result.data || {};\n  return juror && juror.drafts ? juror.drafts : [];\n}\n/**\r\n * Subscribes to all `jurorId` drafts\r\n * @dev This subscription is useful to get all rewards pending for claiming as well\r\n * as for the amount of locked HNY a juror has per dispute\r\n * Ideally we would check that the round is not settled but we cannot do nested filters for now\r\n *\r\n * @param {String} jurorId Address of the juror\r\n * @returns {Object} All `jurorId` drafts\r\n */\n\nexport function useJurorDraftsRewardsSubscription(jurorId) {\n  const [{\n    data,\n    error\n  }] = useQuerySub(JurorDraftsRewards, {\n    id: jurorId.toLowerCase()\n  });\n  const jurorDrafts = useMemo(() => {\n    var _data$juror;\n\n    if (!data) {\n      return null;\n    }\n\n    return ((_data$juror = data.juror) === null || _data$juror === void 0 ? void 0 : _data$juror.drafts.map(transformJurorDataAttributes)) || [];\n  }, [data]);\n  return {\n    jurorDrafts,\n    fetching: !jurorDrafts && !error,\n    error\n  };\n}\n\nfunction useAppealsByMaker(jurorId) {\n  const [{\n    data,\n    error\n  }] = useQuerySub(AppealsByMaker, {\n    maker: jurorId.toLowerCase()\n  });\n  return {\n    data,\n    error\n  };\n}\n\nfunction useAppealsByTaker(jurorId) {\n  const [{\n    data,\n    error\n  }] = useQuerySub(AppealsByTaker, {\n    taker: jurorId.toLowerCase()\n  });\n  return {\n    data,\n    error\n  };\n}\n/**\r\n * Subscribes to all `jurorId` appeal collaterals\r\n * @dev Since we cannot do or operators on graphql queries, we need to get appeals by taker and maker separately\r\n *\r\n * @param {String} jurorId Address of the juror\r\n * @returns {Object} All `jurorId` appeal collaterals\r\n */\n\n\nexport function useAppealsByUserSubscription(jurorId) {\n  const {\n    data: makerAppealsData,\n    error: makerAppealsError\n  } = useAppealsByMaker(jurorId);\n  const {\n    data: takerAppealsData,\n    error: takerAppealsError\n  } = useAppealsByTaker(jurorId);\n  const appeals = useMemo(() => {\n    if (!makerAppealsData || !takerAppealsData) {\n      return null;\n    }\n\n    const makerAppeals = makerAppealsData.appeals;\n    const takerAppeals = takerAppealsData.appeals;\n    return [...makerAppeals, ...takerAppeals].map(transformAppealDataAttributes);\n  }, [makerAppealsData, takerAppealsData]);\n  const errors = [makerAppealsError, takerAppealsError].filter(err => err);\n  return {\n    appeals,\n    fetching: !appeals && errors.length === 0,\n    errors\n  };\n}\nexport function useTasksSubscription() {\n  // 1- Committing, 4-Confirming Appeal , 5- Ended\n  const subscriptionVariables = {\n    state: [1, 4]\n  };\n  const [{\n    data,\n    error\n  }] = useQuerySub(OpenTasks, subscriptionVariables);\n  const tasks = (data === null || data === void 0 ? void 0 : data.adjudicationRounds.map(transformRoundDataAttributes)) || null;\n  return {\n    tasks,\n    fetching: !data && !error,\n    error\n  };\n}\nexport function useJurorRegistrySubscription() {\n  const {\n    modules\n  } = useCourtConfig();\n  const jurorRegistryAddress = getModuleAddress(modules, CourtModuleType.JurorsRegistry);\n  const [{\n    data,\n    error\n  }] = useQuerySub(JurorsRegistryModule, {\n    id: jurorRegistryAddress\n  });\n  const jurorRegistryStats = (data === null || data === void 0 ? void 0 : data.jurorsRegistryModule) || null;\n  return {\n    data: jurorRegistryStats,\n    error\n  };\n}\nexport function useTotalRewardsSubscription() {\n  const [{\n    data,\n    error\n  }] = useQuerySub(FeeMovements);\n  const rewards = (data === null || data === void 0 ? void 0 : data.feeMovements) || null;\n  return {\n    data: rewards,\n    error\n  };\n}\n/**\r\n * Queries for the last withdrawal fee movement time made by the given juror\r\n * @param {String} jurorId Address of the juror\r\n * @returns {Number} Juror's last withdrawal fee movement date in unix time\r\n */\n\nexport function useJurorLastWithdrawalTimeSubscription(jurorId) {\n  const [{\n    data\n  }] = useQuerySub(JurorLastFeeWithdrawal, {\n    owner: jurorId === null || jurorId === void 0 ? void 0 : jurorId.toLowerCase()\n  }, {\n    pause: !jurorId\n  });\n\n  if (!data) {\n    return null;\n  }\n\n  if (data.feeMovements.length === 0) {\n    return -1;\n  }\n\n  return toMs(data.feeMovements[0].createdAt);\n}","map":{"version":3,"sources":["/Users/fabianmolina/Documents/1hive/tulip-frontend/src/hooks/subscription-hooks.js"],"names":["useMemo","useQuery","useHNYBalanceOfPolling","useCourtConfig","OpenTasks","CourtConfig","FeeMovements","JurorsRegistryModule","AllDisputes","SingleDispute","AppealsByMaker","AppealsByTaker","JurorHNYBalances","JurorTreasuryBalances","JurorDraftsFrom","JurorDraftsRewards","bigNum","dayjs","toMs","groupMovements","transformAppealDataAttributes","transformRoundDataAttributes","transformDisputeDataAttributes","transformJurorDataAttributes","transformClaimedFeesDataAttributes","getModuleAddress","transformCourtConfigDataAttributes","CourtModuleType","JurorLastFeeWithdrawal","NO_AMOUNT","useQuerySub","query","variables","options","requestPolicy","pollInterval","useJuror","jurorId","yesterday","subtract","unix","data","error","id","toLowerCase","from","useJurorTreasuryBalances","owner","useJurorBalancesSubscription","walletBalance","jurorData","jurorError","treasuryBalancesData","treasuryBalancesError","errors","filter","err","anjBalances","anjMovements","claimedSubscriptionFees","treasury","activeBalance","availableBalance","deactivationBalance","lockedBalance","juror","treasuryBalances","inactiveBalance","map","balance","amount","fetching","length","useCourtConfigSubscription","courtAddress","courtConfig","useSingleDisputeSubscription","dispute","useDisputesSubscription","disputes","useCurrentTermJurorDraftsSubscription","termStartTime","pause","result","drafts","useJurorDraftsRewardsSubscription","jurorDrafts","useAppealsByMaker","maker","useAppealsByTaker","taker","useAppealsByUserSubscription","makerAppealsData","makerAppealsError","takerAppealsData","takerAppealsError","appeals","makerAppeals","takerAppeals","useTasksSubscription","subscriptionVariables","state","tasks","adjudicationRounds","useJurorRegistrySubscription","modules","jurorRegistryAddress","JurorsRegistry","jurorRegistryStats","jurorsRegistryModule","useTotalRewardsSubscription","rewards","feeMovements","useJurorLastWithdrawalTimeSubscription","createdAt"],"mappings":"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","sourcesContent":["import { useMemo } from 'react'\r\nimport { useQuery } from 'urql'\r\nimport { useHNYBalanceOfPolling } from './useCourtContracts'\r\nimport { useCourtConfig } from '../providers/CourtConfig'\r\n\r\n// queries\r\nimport { OpenTasks } from '../queries/tasks'\r\nimport {\r\n  CourtConfig,\r\n  FeeMovements,\r\n  JurorsRegistryModule,\r\n} from '../queries/court'\r\nimport { AllDisputes, SingleDispute } from '../queries/disputes'\r\nimport { AppealsByMaker, AppealsByTaker } from '../queries/appeals'\r\n\r\nimport { JurorHNYBalances, JurorTreasuryBalances } from '../queries/balances'\r\nimport { JurorDraftsFrom, JurorDraftsRewards } from '../queries/jurorDrafts'\r\n\r\n// utils\r\nimport { bigNum } from '../lib/math-utils'\r\nimport { dayjs, toMs } from '../utils/date-utils'\r\nimport { groupMovements } from '../utils/anj-movement-utils'\r\nimport { transformAppealDataAttributes } from '../utils/appeal-utils'\r\nimport {\r\n  transformRoundDataAttributes,\r\n  transformDisputeDataAttributes,\r\n} from '../utils/dispute-utils'\r\nimport { transformJurorDataAttributes } from '../utils/juror-draft-utils'\r\nimport { transformClaimedFeesDataAttributes } from '../utils/subscription-utils'\r\nimport {\r\n  getModuleAddress,\r\n  transformCourtConfigDataAttributes,\r\n} from '../utils/court-utils'\r\n\r\n// types\r\nimport { CourtModuleType } from '../types/court-module-types'\r\nimport { JurorLastFeeWithdrawal } from '../queries/juror'\r\n\r\nconst NO_AMOUNT = bigNum(0)\r\n\r\nfunction useQuerySub(query, variables = {}, options = {}) {\r\n  return useQuery({\r\n    query: query,\r\n    variables: variables,\r\n    requestPolicy: 'cache-and-network',\r\n    pollInterval: 13 * 1000,\r\n    ...options,\r\n  })\r\n}\r\n\r\n// Subscription to get juror's active, inactive and\r\n// locked balances and all 24 hrs movements\r\nfunction useJuror(jurorId) {\r\n  // get 24hs from current time (seconds)\r\n  const yesterday = dayjs()\r\n    .subtract(1, 'day')\r\n    .unix()\r\n\r\n  const [{ data, error }] = useQuerySub(JurorHNYBalances, {\r\n    id: jurorId.toLowerCase(),\r\n    from: yesterday,\r\n  })\r\n\r\n  return { data, error }\r\n}\r\n\r\n// Subscription to get all treasury balances of juror with id `jurorId`\r\nfunction useJurorTreasuryBalances(jurorId) {\r\n  const [{ data, error }] = useQuerySub(JurorTreasuryBalances, {\r\n    owner: jurorId.toLowerCase(),\r\n  })\r\n  return { data, error }\r\n}\r\n\r\n/**\r\n * Subscribes to all juror balances as well as to the latest 24h movements and all subscription fees claimed by the juror\r\n * @param {String} jurorId Address of the juror\r\n * @returns {Object} Object containing al juror balances (Wallet, Inactive, Active, Locked, Deactivation Process, Treasury),\r\n * latest 24h movements and all subscription fees claimed by the juror\r\n */\r\nexport function useJurorBalancesSubscription(jurorId) {\r\n  const walletBalance = useHNYBalanceOfPolling(jurorId)\r\n  // Juror ANJ balances, 24h movements and subscritpion claimed fees\r\n  const { data: jurorData, error: jurorError } = useJuror(jurorId)\r\n  const {\r\n    data: treasuryBalancesData,\r\n    error: treasuryBalancesError,\r\n  } = useJurorTreasuryBalances(jurorId)\r\n\r\n  const errors = [jurorError, treasuryBalancesError].filter(err => err)\r\n\r\n  const {\r\n    anjBalances,\r\n    anjMovements,\r\n    claimedSubscriptionFees,\r\n    treasury,\r\n  } = useMemo(() => {\r\n    // Means it's still fetching\r\n    if (!jurorData || !treasuryBalancesData) {\r\n      return {}\r\n    }\r\n\r\n    // If the juror is null then means that the connnected account is not a juror but we are already done fetching\r\n    // We set 0 as default values\r\n    const {\r\n      activeBalance = NO_AMOUNT,\r\n      anjMovements = [],\r\n      availableBalance = NO_AMOUNT,\r\n      claimedSubscriptionFees = [],\r\n      deactivationBalance = NO_AMOUNT,\r\n      lockedBalance = NO_AMOUNT,\r\n    } = jurorData.juror || {}\r\n\r\n    const { treasuryBalances = [] } = treasuryBalancesData || {}\r\n\r\n    return {\r\n      anjBalances: {\r\n        walletBalance,\r\n        activeBalance: bigNum(activeBalance),\r\n        deactivationBalance: bigNum(deactivationBalance),\r\n        inactiveBalance: bigNum(availableBalance),\r\n        lockedBalance: bigNum(lockedBalance),\r\n      },\r\n      anjMovements: groupMovements(anjMovements),\r\n      claimedSubscriptionFees: claimedSubscriptionFees.map(\r\n        transformClaimedFeesDataAttributes\r\n      ),\r\n      treasury: treasuryBalances.map(balance => ({\r\n        ...balance,\r\n        amount: bigNum(balance.amount),\r\n      })),\r\n    }\r\n  }, [jurorData, treasuryBalancesData, walletBalance])\r\n\r\n  return {\r\n    anjBalances,\r\n    anjMovements,\r\n    claimedSubscriptionFees,\r\n    treasury,\r\n    fetching: !anjBalances && errors.length === 0,\r\n    errors,\r\n  }\r\n}\r\n\r\n/**\r\n * Subscribes to the court configuration data\r\n * @param {String} courtAddress Adrress of the court contract\r\n * @returns {Object} Court configuration data\r\n */\r\nexport function useCourtConfigSubscription(courtAddress) {\r\n  const [{ data }] = useQuerySub(CourtConfig, {\r\n    id: courtAddress.toLowerCase(),\r\n  })\r\n\r\n  // TODO: handle possible errors\r\n  const courtConfig = useMemo(\r\n    () =>\r\n      data?.courtConfig\r\n        ? transformCourtConfigDataAttributes(data.courtConfig)\r\n        : null,\r\n    [data]\r\n  )\r\n\r\n  return courtConfig\r\n}\r\n\r\n/**\r\n * Subscribes to the dispute with id == `id`\r\n * @param {String} id Id of the dispute\r\n * @returns {Object} Dispute by `id`\r\n */\r\nexport function useSingleDisputeSubscription(id) {\r\n  const [{ data, error }] = useQuerySub(SingleDispute, { id })\r\n\r\n  const dispute = useMemo(\r\n    () =>\r\n      data && data.dispute\r\n        ? transformDisputeDataAttributes(data.dispute)\r\n        : null,\r\n    [data]\r\n  )\r\n\r\n  return { dispute, fetching: !data && !error, error }\r\n}\r\n\r\n/**\r\n * Subscribes to all existing disputes on the court\r\n * @returns {Object} All disputes\r\n */\r\nexport function useDisputesSubscription() {\r\n  const courtConfig = useCourtConfig()\r\n  const [{ data, error }] = useQuerySub(AllDisputes)\r\n\r\n  const disputes = useMemo(\r\n    () =>\r\n      data?.disputes\r\n        ? data.disputes.map(dispute =>\r\n            transformDisputeDataAttributes(dispute, courtConfig)\r\n          )\r\n        : null,\r\n    [courtConfig, data]\r\n  )\r\n\r\n  return { disputes, fetching: !data && !error, error }\r\n}\r\n\r\n/**\r\n * Subscribe to all `jurorId` drafts for the current term\r\n * @param {String} jurorId Address of the juror\r\n * @param {Number} termStartTime Start time of the term inseconds\r\n * @param {Boolean} pause Tells whether to pause the subscription or not\r\n * @returns {Object} All `jurorId` drafts for the current term\r\n */\r\nexport function useCurrentTermJurorDraftsSubscription(\r\n  jurorId,\r\n  termStartTime,\r\n  pause\r\n) {\r\n  const [result] = useQuerySub(\r\n    JurorDraftsFrom,\r\n    { id: jurorId.toLowerCase(), from: termStartTime },\r\n    { pause }\r\n  )\r\n\r\n  const { juror } = result.data || {}\r\n  return juror && juror.drafts ? juror.drafts : []\r\n}\r\n\r\n/**\r\n * Subscribes to all `jurorId` drafts\r\n * @dev This subscription is useful to get all rewards pending for claiming as well\r\n * as for the amount of locked HNY a juror has per dispute\r\n * Ideally we would check that the round is not settled but we cannot do nested filters for now\r\n *\r\n * @param {String} jurorId Address of the juror\r\n * @returns {Object} All `jurorId` drafts\r\n */\r\nexport function useJurorDraftsRewardsSubscription(jurorId) {\r\n  const [{ data, error }] = useQuerySub(JurorDraftsRewards, {\r\n    id: jurorId.toLowerCase(),\r\n  })\r\n\r\n  const jurorDrafts = useMemo(() => {\r\n    if (!data) {\r\n      return null\r\n    }\r\n\r\n    return data.juror?.drafts.map(transformJurorDataAttributes) || []\r\n  }, [data])\r\n\r\n  return { jurorDrafts, fetching: !jurorDrafts && !error, error }\r\n}\r\n\r\nfunction useAppealsByMaker(jurorId) {\r\n  const [{ data, error }] = useQuerySub(AppealsByMaker, {\r\n    maker: jurorId.toLowerCase(),\r\n  })\r\n  return { data, error }\r\n}\r\n\r\nfunction useAppealsByTaker(jurorId) {\r\n  const [{ data, error }] = useQuerySub(AppealsByTaker, {\r\n    taker: jurorId.toLowerCase(),\r\n  })\r\n  return { data, error }\r\n}\r\n\r\n/**\r\n * Subscribes to all `jurorId` appeal collaterals\r\n * @dev Since we cannot do or operators on graphql queries, we need to get appeals by taker and maker separately\r\n *\r\n * @param {String} jurorId Address of the juror\r\n * @returns {Object} All `jurorId` appeal collaterals\r\n */\r\nexport function useAppealsByUserSubscription(jurorId) {\r\n  const {\r\n    data: makerAppealsData,\r\n    error: makerAppealsError,\r\n  } = useAppealsByMaker(jurorId)\r\n  const {\r\n    data: takerAppealsData,\r\n    error: takerAppealsError,\r\n  } = useAppealsByTaker(jurorId)\r\n\r\n  const appeals = useMemo(() => {\r\n    if (!makerAppealsData || !takerAppealsData) {\r\n      return null\r\n    }\r\n\r\n    const makerAppeals = makerAppealsData.appeals\r\n    const takerAppeals = takerAppealsData.appeals\r\n\r\n    return [...makerAppeals, ...takerAppeals].map(transformAppealDataAttributes)\r\n  }, [makerAppealsData, takerAppealsData])\r\n\r\n  const errors = [makerAppealsError, takerAppealsError].filter(err => err)\r\n\r\n  return { appeals, fetching: !appeals && errors.length === 0, errors }\r\n}\r\n\r\nexport function useTasksSubscription() {\r\n  // 1- Committing, 4-Confirming Appeal , 5- Ended\r\n  const subscriptionVariables = { state: [1, 4] }\r\n\r\n  const [{ data, error }] = useQuerySub(OpenTasks, subscriptionVariables)\r\n\r\n  const tasks =\r\n    data?.adjudicationRounds.map(transformRoundDataAttributes) || null\r\n\r\n  return { tasks, fetching: !data && !error, error }\r\n}\r\n\r\nexport function useJurorRegistrySubscription() {\r\n  const { modules } = useCourtConfig()\r\n  const jurorRegistryAddress = getModuleAddress(\r\n    modules,\r\n    CourtModuleType.JurorsRegistry\r\n  )\r\n\r\n  const [{ data, error }] = useQuerySub(JurorsRegistryModule, {\r\n    id: jurorRegistryAddress,\r\n  })\r\n\r\n  const jurorRegistryStats = data?.jurorsRegistryModule || null\r\n\r\n  return { data: jurorRegistryStats, error }\r\n}\r\n\r\nexport function useTotalRewardsSubscription() {\r\n  const [{ data, error }] = useQuerySub(FeeMovements)\r\n\r\n  const rewards = data?.feeMovements || null\r\n\r\n  return { data: rewards, error }\r\n}\r\n\r\n/**\r\n * Queries for the last withdrawal fee movement time made by the given juror\r\n * @param {String} jurorId Address of the juror\r\n * @returns {Number} Juror's last withdrawal fee movement date in unix time\r\n */\r\nexport function useJurorLastWithdrawalTimeSubscription(jurorId) {\r\n  const [{ data }] = useQuerySub(\r\n    JurorLastFeeWithdrawal,\r\n    { owner: jurorId?.toLowerCase() },\r\n    { pause: !jurorId }\r\n  )\r\n\r\n  if (!data) {\r\n    return null\r\n  }\r\n\r\n  if (data.feeMovements.length === 0) {\r\n    return -1\r\n  }\r\n\r\n  return toMs(data.feeMovements[0].createdAt)\r\n}\r\n"]},"metadata":{},"sourceType":"module"}