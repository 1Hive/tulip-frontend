{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _createForOfIteratorHelper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _toArray = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toArray\");\n\nvar _awaitAsyncGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _wrapAsyncGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar _asyncIterator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar isIpfs = require('is-ipfs');\n\nvar CID = require('cids');\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar TimeoutController = require('timeout-abort-controller');\n\nvar anySignal = require('any-signal');\n\nvar parseDuration = require('parse-duration');\n\nvar Key = require('interface-datastore').Key;\n\nvar _require2 = require('./errors'),\n    TimeoutError = _require2.TimeoutError;\n\nvar ERR_BAD_PATH = 'ERR_BAD_PATH';\nexports.OFFLINE_ERROR = 'This command must be run in online mode. Try running \\'ipfs daemon\\' first.';\nexports.MFS_FILE_TYPES = {\n  file: 0,\n  directory: 1,\n  'hamt-sharded-directory': 1\n};\nexports.MFS_ROOT_KEY = new Key('/local/filesroot');\nexports.MFS_MAX_CHUNK_SIZE = 262144;\nexports.MFS_MAX_LINKS = 174;\n/**\n * Break an ipfs-path down into it's hash and an array of links.\n *\n * examples:\n *  b58Hash -> { hash: 'b58Hash', links: [] }\n *  b58Hash/mercury/venus -> { hash: 'b58Hash', links: ['mercury', 'venus']}\n *  /ipfs/b58Hash/links/by/name -> { hash: 'b58Hash', links: ['links', 'by', 'name'] }\n *\n * @param  {String} ipfsPath An ipfs-path\n * @return {Object}            { hash: base58 string, links: [string], ?err: Error }\n * @throws on an invalid @param ipfsPath\n */\n\nfunction parseIpfsPath(ipfsPath) {\n  ipfsPath = ipfsPath.replace(/^\\/ipfs\\//, '');\n  var matched = ipfsPath.match(/([^/]+(?:\\/[^/]+)*)\\/?$/);\n\n  if (!matched) {\n    throw new Error('invalid ipfs ref path');\n  }\n\n  var _matched$1$split = matched[1].split('/'),\n      _matched$1$split2 = _toArray(_matched$1$split),\n      hash = _matched$1$split2[0],\n      links = _matched$1$split2.slice(1); // check that a CID can be constructed with the hash\n\n\n  if (isIpfs.cid(hash)) {\n    return {\n      hash: hash,\n      links: links\n    };\n  } else {\n    throw new Error('invalid ipfs ref path');\n  }\n}\n/**\n * Returns a well-formed ipfs Path.\n * The returned path will always be prefixed with /ipfs/ or /ipns/.\n *\n * @param  {String} pathStr An ipfs-path, or ipns-path or a cid\n * @return {String} ipfs-path or ipns-path\n * @throws on an invalid @param ipfsPath\n */\n\n\nvar normalizePath = function normalizePath(pathStr) {\n  if (isIpfs.cid(pathStr)) {\n    return \"/ipfs/\".concat(new CID(pathStr));\n  } else if (isIpfs.path(pathStr)) {\n    return pathStr;\n  } else {\n    throw Object.assign(new Error(\"invalid path: \".concat(pathStr)), {\n      code: ERR_BAD_PATH\n    });\n  }\n}; // TODO: do we need both normalizePath and normalizeCidPath?\n\n\nvar normalizeCidPath = function normalizeCidPath(path) {\n  if (Buffer.isBuffer(path)) {\n    return new CID(path).toString();\n  }\n\n  if (CID.isCID(path)) {\n    return path.toString();\n  }\n\n  if (path.indexOf('/ipfs/') === 0) {\n    path = path.substring('/ipfs/'.length);\n  }\n\n  if (path.charAt(path.length - 1) === '/') {\n    path = path.substring(0, path.length - 1);\n  }\n\n  return path;\n};\n/**\n * Resolve various styles of an ipfs-path to the hash of the target node.\n * Follows links in the path.\n *\n * Accepts formats:\n *  - <base58 string>\n *  - <base58 string>/link/to/venus\n *  - /ipfs/<base58 string>/link/to/pluto\n *  - multihash Buffer\n *  - Arrays of the above\n *\n * @param {Dag} dag The IPFS dag api\n * @param {Array<CID|string>} ipfsPaths A single or collection of ipfs-paths\n * @param {Object} [options] Optional options passed directly to dag.resolve\n * @return {Promise<Array<CID>>}\n */\n\n\nvar resolvePath = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(dag, ipfsPaths, options) {\n    var cids, _iterator2, _step2, path, _parseIpfsPath, hash, links, cid, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, _value2, value, linkName;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            options = options || {};\n\n            if (!Array.isArray(ipfsPaths)) {\n              ipfsPaths = [ipfsPaths];\n            }\n\n            cids = [];\n            _iterator2 = _createForOfIteratorHelper(ipfsPaths);\n            _context.prev = 4;\n\n            _iterator2.s();\n\n          case 6:\n            if ((_step2 = _iterator2.n()).done) {\n              _context.next = 59;\n              break;\n            }\n\n            path = _step2.value;\n\n            if (!isIpfs.cid(path)) {\n              _context.next = 11;\n              break;\n            }\n\n            cids.push(new CID(path));\n            return _context.abrupt(\"continue\", 57);\n\n          case 11:\n            _parseIpfsPath = parseIpfsPath(path), hash = _parseIpfsPath.hash, links = _parseIpfsPath.links;\n\n            if (links.length) {\n              _context.next = 15;\n              break;\n            }\n\n            cids.push(new CID(hash));\n            return _context.abrupt(\"continue\", 57);\n\n          case 15:\n            cid = new CID(hash);\n            _context.prev = 16;\n            _iteratorNormalCompletion = true;\n            _didIteratorError = false;\n            _context.prev = 19;\n            _iterator = _asyncIterator(dag.resolve(path, options));\n\n          case 21:\n            _context.next = 23;\n            return _iterator.next();\n\n          case 23:\n            _step = _context.sent;\n            _iteratorNormalCompletion = _step.done;\n            _context.next = 27;\n            return _step.value;\n\n          case 27:\n            _value = _context.sent;\n\n            if (_iteratorNormalCompletion) {\n              _context.next = 34;\n              break;\n            }\n\n            _value2 = _value, value = _value2.value;\n\n            if (CID.isCID(value)) {\n              cid = value;\n            }\n\n          case 31:\n            _iteratorNormalCompletion = true;\n            _context.next = 21;\n            break;\n\n          case 34:\n            _context.next = 40;\n            break;\n\n          case 36:\n            _context.prev = 36;\n            _context.t0 = _context[\"catch\"](19);\n            _didIteratorError = true;\n            _iteratorError = _context.t0;\n\n          case 40:\n            _context.prev = 40;\n            _context.prev = 41;\n\n            if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n              _context.next = 45;\n              break;\n            }\n\n            _context.next = 45;\n            return _iterator.return();\n\n          case 45:\n            _context.prev = 45;\n\n            if (!_didIteratorError) {\n              _context.next = 48;\n              break;\n            }\n\n            throw _iteratorError;\n\n          case 48:\n            return _context.finish(45);\n\n          case 49:\n            return _context.finish(40);\n\n          case 50:\n            _context.next = 56;\n            break;\n\n          case 52:\n            _context.prev = 52;\n            _context.t1 = _context[\"catch\"](16);\n\n            // TODO: add error codes to IPLD\n            if (_context.t1.message.startsWith('Object has no property')) {\n              linkName = _context.t1.message.replace('Object has no property \\'', '').slice(0, -1);\n              _context.t1.message = \"no link named \\\"\".concat(linkName, \"\\\" under \").concat(cid);\n              _context.t1.code = 'ERR_NO_LINK';\n            }\n\n            throw _context.t1;\n\n          case 56:\n            cids.push(cid);\n\n          case 57:\n            _context.next = 6;\n            break;\n\n          case 59:\n            _context.next = 64;\n            break;\n\n          case 61:\n            _context.prev = 61;\n            _context.t2 = _context[\"catch\"](4);\n\n            _iterator2.e(_context.t2);\n\n          case 64:\n            _context.prev = 64;\n\n            _iterator2.f();\n\n            return _context.finish(64);\n\n          case 67:\n            return _context.abrupt(\"return\", cids);\n\n          case 68:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[4, 61, 64, 67], [16, 52], [19, 36, 40, 50], [41,, 45, 49]]);\n  }));\n\n  return function resolvePath(_x, _x2, _x3) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nvar mapFile = function mapFile(file, options) {\n  options = options || {};\n  var output = {\n    cid: file.cid,\n    path: file.path,\n    name: file.name,\n    depth: file.path.split('/').length,\n    size: 0,\n    type: 'dir'\n  };\n\n  if (file.unixfs) {\n    if (file.unixfs.type === 'file') {\n      output.size = file.unixfs.fileSize();\n      output.type = 'file';\n\n      if (options.includeContent) {\n        output.content = file.content();\n      }\n    }\n\n    output.mode = file.unixfs.mode;\n    output.mtime = file.unixfs.mtime;\n  }\n\n  return output;\n};\n\nfunction withTimeoutOption(fn, optionsArgIndex) {\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var options = args[optionsArgIndex == null ? args.length - 1 : optionsArgIndex];\n    if (!options || !options.timeout) return fn.apply(void 0, args);\n    var timeout = typeof options.timeout === 'string' ? parseDuration(options.timeout) : options.timeout;\n    var controller = new TimeoutController(timeout);\n    options.signal = anySignal([options.signal, controller.signal]);\n    var fnRes = fn.apply(void 0, args);\n    var timeoutPromise = new Promise(function (resolve, reject) {\n      controller.signal.addEventListener('abort', function () {\n        reject(new TimeoutError());\n      });\n    });\n    var start = Date.now();\n\n    var maybeThrowTimeoutError = function maybeThrowTimeoutError() {\n      if (controller.signal.aborted) {\n        throw new TimeoutError();\n      }\n\n      var timeTaken = Date.now() - start; // if we have starved the event loop by adding microtasks, we could have\n      // timed out already but the TimeoutController will never know because it's\n      // setTimeout will not fire until we stop adding microtasks\n\n      if (timeTaken > timeout) {\n        controller.abort();\n        throw new TimeoutError();\n      }\n    };\n\n    if (fnRes[Symbol.asyncIterator]) {\n      return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var it, _yield$_awaitAsyncGen, value, done;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                it = fnRes[Symbol.asyncIterator]();\n                _context2.prev = 1;\n\n              case 2:\n                if (!true) {\n                  _context2.next = 15;\n                  break;\n                }\n\n                _context2.next = 5;\n                return _awaitAsyncGenerator(Promise.race([it.next(), timeoutPromise]));\n\n              case 5:\n                _yield$_awaitAsyncGen = _context2.sent;\n                value = _yield$_awaitAsyncGen.value;\n                done = _yield$_awaitAsyncGen.done;\n\n                if (!done) {\n                  _context2.next = 10;\n                  break;\n                }\n\n                return _context2.abrupt(\"break\", 15);\n\n              case 10:\n                maybeThrowTimeoutError();\n                _context2.next = 13;\n                return value;\n\n              case 13:\n                _context2.next = 2;\n                break;\n\n              case 15:\n                _context2.next = 21;\n                break;\n\n              case 17:\n                _context2.prev = 17;\n                _context2.t0 = _context2[\"catch\"](1);\n                maybeThrowTimeoutError();\n                throw _context2.t0;\n\n              case 21:\n                _context2.prev = 21;\n                controller.clear();\n\n                if (it.return) {\n                  it.return();\n                }\n\n                return _context2.finish(21);\n\n              case 25:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, null, [[1, 17, 21, 25]]);\n      }))();\n    }\n\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n      var res;\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.prev = 0;\n              _context3.next = 3;\n              return Promise.race([fnRes, timeoutPromise]);\n\n            case 3:\n              res = _context3.sent;\n              maybeThrowTimeoutError();\n              return _context3.abrupt(\"return\", res);\n\n            case 8:\n              _context3.prev = 8;\n              _context3.t0 = _context3[\"catch\"](0);\n              maybeThrowTimeoutError();\n              throw _context3.t0;\n\n            case 12:\n              _context3.prev = 12;\n              controller.clear();\n              return _context3.finish(12);\n\n            case 15:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3, null, [[0, 8, 12, 15]]);\n    }))();\n  };\n}\n\nexports.normalizePath = normalizePath;\nexports.normalizeCidPath = normalizeCidPath;\nexports.parseIpfsPath = parseIpfsPath;\nexports.resolvePath = resolvePath;\nexports.mapFile = mapFile;\nexports.withTimeoutOption = withTimeoutOption;","map":null,"metadata":{},"sourceType":"script"}