{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar _require2 = require('nanoid'),\n    nanoid = _require2.nanoid;\n\nvar withIs = require('class-is');\n\nvar pathSepS = '/';\nvar pathSepB = Buffer.from(pathSepS);\nvar pathSep = pathSepB[0];\n/**\n * A Key represents the unique identifier of an object.\n * Our Key scheme is inspired by file systems and Google App Engine key model.\n * Keys are meant to be unique across a system. Keys are hierarchical,\n * incorporating more and more specific namespaces. Thus keys can be deemed\n * 'children' or 'ancestors' of other keys:\n * - `new Key('/Comedy')`\n * - `new Key('/Comedy/MontyPython')`\n * Also, every namespace can be parametrized to embed relevant object\n * information. For example, the Key `name` (most specific namespace) could\n * include the object type:\n * - `new Key('/Comedy/MontyPython/Actor:JohnCleese')`\n * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop')`\n * - `new Key('/Comedy/MontyPython/Sketch:CheeseShop/Character:Mousebender')`\n *\n */\n\nvar Key = /*#__PURE__*/function () {\n  function Key(s, clean) {\n    _classCallCheck(this, Key);\n\n    if (typeof s === 'string') {\n      this._buf = Buffer.from(s);\n    } else if (Buffer.isBuffer(s)) {\n      this._buf = s;\n    }\n\n    if (clean == null) {\n      clean = true;\n    }\n\n    if (clean) {\n      this.clean();\n    }\n\n    if (this._buf.length === 0 || this._buf[0] !== pathSep) {\n      throw new Error('Invalid key');\n    }\n  }\n  /**\n   * Convert to the string representation\n   *\n   * @param {string} [encoding='utf8']\n   * @returns {string}\n   */\n\n\n  _createClass(Key, [{\n    key: \"toString\",\n    value: function toString(encoding) {\n      return this._buf.toString(encoding || 'utf8');\n    }\n    /**\n     * Return the buffer representation of the key\n     *\n     * @returns {Buffer}\n     */\n\n  }, {\n    key: \"toBuffer\",\n    value: function toBuffer() {\n      return this._buf;\n    }\n    /**\n     * @returns {String}\n     */\n\n  }, {\n    key: Symbol.toStringTag,\n    get: function get() {\n      return \"Key(\".concat(this.toString(), \")\");\n    }\n    /**\n     * Constructs a key out of a namespace array.\n     *\n     * @param {Array<string>} list\n     * @returns {Key}\n     *\n     * @example\n     * Key.withNamespaces(['one', 'two'])\n     * // => Key('/one/two')\n     *\n     */\n\n  }, {\n    key: \"clean\",\n    value:\n    /**\n     * Cleanup the current key\n     *\n     * @returns {void}\n     */\n    function clean() {\n      if (!this._buf || this._buf.length === 0) {\n        this._buf = Buffer.from(pathSepS);\n      }\n\n      if (this._buf[0] !== pathSep) {\n        this._buf = Buffer.concat([pathSepB, this._buf]);\n      } // normalize does not remove trailing slashes\n\n\n      while (this._buf.length > 1 && this._buf[this._buf.length - 1] === pathSep) {\n        this._buf = this._buf.slice(0, -1);\n      }\n    }\n    /**\n     * Check if the given key is sorted lower than ourself.\n     *\n     * @param {Key} key\n     * @returns {bool}\n     */\n\n  }, {\n    key: \"less\",\n    value: function less(key) {\n      var list1 = this.list();\n      var list2 = key.list();\n\n      for (var i = 0; i < list1.length; i++) {\n        if (list2.length < i + 1) {\n          return false;\n        }\n\n        var c1 = list1[i];\n        var c2 = list2[i];\n\n        if (c1 < c2) {\n          return true;\n        } else if (c1 > c2) {\n          return false;\n        }\n      }\n\n      return list1.length < list2.length;\n    }\n    /**\n     * Returns the key with all parts in reversed order.\n     *\n     * @returns {Key}\n     *\n     * @example\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').reverse()\n     * // => Key('/Actor:JohnCleese/MontyPython/Comedy')\n     */\n\n  }, {\n    key: \"reverse\",\n    value: function reverse() {\n      return Key.withNamespaces(this.list().slice().reverse());\n    }\n    /**\n     * Returns the `namespaces` making up this Key.\n     *\n     * @returns {Array<string>}\n     */\n\n  }, {\n    key: \"namespaces\",\n    value: function namespaces() {\n      return this.list();\n    }\n    /** Returns the \"base\" namespace of this key.\n     *\n     * @returns {string}\n     *\n     * @example\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').baseNamespace()\n     * // => 'Actor:JohnCleese'\n     *\n     */\n\n  }, {\n    key: \"baseNamespace\",\n    value: function baseNamespace() {\n      var ns = this.namespaces();\n      return ns[ns.length - 1];\n    }\n    /**\n     * Returns the `list` representation of this key.\n     *\n     * @returns {Array<string>}\n     *\n     * @example\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').list()\n     * // => ['Comedy', 'MontyPythong', 'Actor:JohnCleese']\n     *\n     */\n\n  }, {\n    key: \"list\",\n    value: function list() {\n      return this.toString().split(pathSepS).slice(1);\n    }\n    /**\n     * Returns the \"type\" of this key (value of last namespace).\n     *\n     * @returns {string}\n     *\n     * @example\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').type()\n     * // => 'Actor'\n     *\n     */\n\n  }, {\n    key: \"type\",\n    value: function type() {\n      return namespaceType(this.baseNamespace());\n    }\n    /**\n     * Returns the \"name\" of this key (field of last namespace).\n     *\n     * @returns {string}\n     *\n     * @example\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').name()\n     * // => 'JohnCleese'\n     */\n\n  }, {\n    key: \"name\",\n    value: function name() {\n      return namespaceValue(this.baseNamespace());\n    }\n    /**\n     * Returns an \"instance\" of this type key (appends value to namespace).\n     *\n     * @param {string} s\n     * @returns {Key}\n     *\n     * @example\n     * new Key('/Comedy/MontyPython/Actor').instance('JohnClesse')\n     * // => Key('/Comedy/MontyPython/Actor:JohnCleese')\n     */\n\n  }, {\n    key: \"instance\",\n    value: function instance(s) {\n      return new _Key(this.toString() + ':' + s);\n    }\n    /**\n     * Returns the \"path\" of this key (parent + type).\n     *\n     * @returns {Key}\n     *\n     * @example\n     * new Key('/Comedy/MontyPython/Actor:JohnCleese').path()\n     * // => Key('/Comedy/MontyPython/Actor')\n     *\n     */\n\n  }, {\n    key: \"path\",\n    value: function path() {\n      var p = this.parent().toString();\n\n      if (!p.endsWith(pathSepS)) {\n        p += pathSepS;\n      }\n\n      p += this.type();\n      return new _Key(p);\n    }\n    /**\n     * Returns the `parent` Key of this Key.\n     *\n     * @returns {Key}\n     *\n     * @example\n     * new Key(\"/Comedy/MontyPython/Actor:JohnCleese\").parent()\n     * // => Key(\"/Comedy/MontyPython\")\n     *\n     */\n\n  }, {\n    key: \"parent\",\n    value: function parent() {\n      var list = this.list();\n\n      if (list.length === 1) {\n        return new _Key(pathSepS);\n      }\n\n      return new _Key(list.slice(0, -1).join(pathSepS));\n    }\n    /**\n     * Returns the `child` Key of this Key.\n     *\n     * @param {Key} key\n     * @returns {Key}\n     *\n     * @example\n     * new Key('/Comedy/MontyPython').child(new Key('Actor:JohnCleese'))\n     * // => Key('/Comedy/MontyPython/Actor:JohnCleese')\n     *\n     */\n\n  }, {\n    key: \"child\",\n    value: function child(key) {\n      if (this.toString() === pathSepS) {\n        return key;\n      } else if (key.toString() === pathSepS) {\n        return this;\n      }\n\n      return new _Key(this.toString() + key.toString(), false);\n    }\n    /**\n     * Returns whether this key is a prefix of `other`\n     *\n     * @param {Key} other\n     * @returns {bool}\n     *\n     * @example\n     * new Key('/Comedy').isAncestorOf('/Comedy/MontyPython')\n     * // => true\n     *\n     */\n\n  }, {\n    key: \"isAncestorOf\",\n    value: function isAncestorOf(other) {\n      if (other.toString() === this.toString()) {\n        return false;\n      }\n\n      return other.toString().startsWith(this.toString());\n    }\n    /**\n     * Returns whether this key is a contains another as prefix.\n     *\n     * @param {Key} other\n     * @returns {bool}\n     *\n     * @example\n     * new Key('/Comedy/MontyPython').isDecendantOf('/Comedy')\n     * // => true\n     *\n     */\n\n  }, {\n    key: \"isDecendantOf\",\n    value: function isDecendantOf(other) {\n      if (other.toString() === this.toString()) {\n        return false;\n      }\n\n      return this.toString().startsWith(other.toString());\n    }\n    /**\n     * Returns wether this key has only one namespace.\n     *\n     * @returns {bool}\n     *\n     */\n\n  }, {\n    key: \"isTopLevel\",\n    value: function isTopLevel() {\n      return this.list().length === 1;\n    }\n    /**\n     * Concats one or more Keys into one new Key.\n     *\n     * @param {Array<Key>} keys\n     * @returns {Key}\n     */\n\n  }, {\n    key: \"concat\",\n    value: function concat() {\n      for (var _len = arguments.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {\n        keys[_key] = arguments[_key];\n      }\n\n      return Key.withNamespaces([].concat(_toConsumableArray(this.namespaces()), _toConsumableArray(flatten(keys.map(function (key) {\n        return key.namespaces();\n      })))));\n    }\n  }], [{\n    key: \"withNamespaces\",\n    value: function withNamespaces(list) {\n      return new _Key(list.join(pathSepS));\n    }\n    /**\n     * Returns a randomly (uuid) generated key.\n     *\n     * @returns {Key}\n     *\n     * @example\n     * Key.random()\n     * // => Key('/f98719ea086343f7b71f32ea9d9d521d')\n     *\n     */\n\n  }, {\n    key: \"random\",\n    value: function random() {\n      return new _Key(nanoid().replace(/-/g, ''));\n    }\n  }]);\n\n  return Key;\n}();\n/**\n * The first component of a namespace. `foo` in `foo:bar`\n *\n * @param {string} ns\n * @returns {string}\n */\n\n\nfunction namespaceType(ns) {\n  var parts = ns.split(':');\n\n  if (parts.length < 2) {\n    return '';\n  }\n\n  return parts.slice(0, -1).join(':');\n}\n/**\n * The last component of a namespace, `baz` in `foo:bar:baz`.\n *\n * @param {string} ns\n * @returns {string}\n */\n\n\nfunction namespaceValue(ns) {\n  var parts = ns.split(':');\n  return parts[parts.length - 1];\n}\n/**\n * Flatten array of arrays (only one level)\n * @param {Array<Array>} arr\n * @return {*}\n */\n\n\nfunction flatten(arr) {\n  var _ref;\n\n  return (_ref = []).concat.apply(_ref, _toConsumableArray(arr));\n}\n\nvar _Key = withIs(Key, {\n  className: 'Key',\n  symbolName: '@ipfs/interface-datastore/key'\n});\n\nmodule.exports = _Key;","map":null,"metadata":{},"sourceType":"script"}