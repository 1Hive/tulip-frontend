{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar slicedToArray = require('./slicedToArray-a8a77f0e.js');\n\nrequire('./unsupportedIterableToArray-f175acfa.js');\n\nvar React = require('react');\n\nvar A_DAY = 1000 * 60 * 60 * 24;\n\nfunction cachedMap() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref$expireAfter = _ref.expireAfter,\n      expireAfter = _ref$expireAfter === void 0 ? A_DAY : _ref$expireAfter,\n      _ref$size = _ref.size,\n      size = _ref$size === void 0 ? 100 : _ref$size;\n\n  var cache = new Map(); // Delete the first (oldest) entry if we are above `size`. `cache.size`\n  // should never be greater than `size + 1`, so no need for a loop here.\n\n  function trim() {\n    if (cache.size > size) {\n      cache.delete(cache.keys().next().value);\n    }\n  } // We are using delete() then set() to reset the position everytime the\n  // access is refreshed. That way, the oldest entry is always at the first\n  // position and we don’t need to iterate over the entire cache to find it.\n\n\n  function update(key, value, lastAccess) {\n    cache.delete(key);\n    cache.set(key, {\n      value: value,\n      lastAccess: lastAccess\n    });\n    trim();\n  }\n\n  function get(key) {\n    var now = new Date();\n    var cachedEntry = cache.get(key);\n\n    if (!cachedEntry) {\n      return null;\n    } // Expired: delete the entry\n\n\n    if (now - cachedEntry.lastAccess > expireAfter) {\n      cache.delete(key);\n      return null;\n    }\n\n    update(key, cachedEntry.value, now);\n    return cachedEntry.value;\n  }\n\n  function set(key, value) {\n    update(key, value, new Date());\n  }\n\n  return {\n    clear: function clear() {\n      return cache.clear();\n    },\n    delete: function _delete(key) {\n      return cache.delete(key);\n    },\n    get: get,\n    set: set\n  };\n}\n\nvar srcCache = cachedMap(); // Check if a remote image exists and can be loaded within a specific amount of time.\n\nfunction useImageExists(src) {\n  var timeUntilFallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 50;\n\n  var _useState = React.useState(false),\n      _useState2 = slicedToArray.slicedToArray(_useState, 2),\n      exists = _useState2[0],\n      setExists = _useState2[1];\n\n  var _useState3 = React.useState(true),\n      _useState4 = slicedToArray.slicedToArray(_useState3, 2),\n      loading = _useState4[0],\n      setLoading = _useState4[1];\n\n  var _useState5 = React.useState(false),\n      _useState6 = slicedToArray.slicedToArray(_useState5, 2),\n      displayFallback = _useState6[0],\n      setDisplayFallback = _useState6[1];\n\n  React.useEffect(function () {\n    var image = new Image();\n    var fallbackTimer = setTimeout(function () {\n      return setDisplayFallback(true);\n    }, timeUntilFallback);\n\n    var init = function init() {\n      if (!src) {\n        setExists(false);\n        setLoading(false);\n        return;\n      }\n\n      if (srcCache.get(src)) {\n        success();\n        return;\n      }\n\n      setExists(false);\n      setLoading(true); // TODO: ensure only one image is loading at a time for a given src.\n\n      image.addEventListener('load', success);\n      image.src = src;\n    };\n\n    var success = function success() {\n      setLoading(false);\n      setExists(true);\n      srcCache.set(src, true);\n      done();\n    };\n\n    var done = function done() {\n      clearTimeout(fallbackTimer);\n\n      if (image) {\n        image.removeEventListener('load', success);\n        image = null;\n      }\n    };\n\n    init();\n    return done;\n  }, [src, timeUntilFallback]);\n  return React.useMemo(function () {\n    return {\n      src: src,\n      displayFallback: displayFallback,\n      exists: exists,\n      loading: loading\n    };\n  }, [src, displayFallback, exists, loading]);\n} // render prop\n\n\nvar ImageExists = function ImageExists(_ref) {\n  var timeUntilFallback = _ref.timeUntilFallback,\n      src = _ref.src,\n      children = _ref.children;\n  return children(useImageExists(src, timeUntilFallback));\n};\n\nexports.ImageExists = ImageExists;\nexports.useImageExists = useImageExists;","map":{"version":3,"sources":["../src/lib/cached-map.js","../src/hooks/useImageExists.js"],"names":["A_DAY","expireAfter","size","cache","value","lastAccess","trim","now","cachedEntry","update","clear","delete","get","set","srcCache","cachedMap","timeUntilFallback","exists","setExists","useState","loading","setLoading","displayFallback","setDisplayFallback","useEffect","image","fallbackTimer","setTimeout","init","success","done","clearTimeout","useMemo","src","ImageExists","children","useImageExists"],"mappings":"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","sourcesContent":["const A_DAY = 1000 * 60 * 60 * 24\n\nfunction cachedMap({ expireAfter = A_DAY, size = 100 } = {}) {\n  const cache = new Map()\n\n  // Delete the first (oldest) entry if we are above `size`. `cache.size`\n  // should never be greater than `size + 1`, so no need for a loop here.\n  function trim() {\n    if (cache.size > size) {\n      cache.delete(cache.keys().next().value)\n    }\n  }\n\n  // We are using delete() then set() to reset the position everytime the\n  // access is refreshed. That way, the oldest entry is always at the first\n  // position and we don’t need to iterate over the entire cache to find it.\n  function update(key, value, lastAccess) {\n    cache.delete(key)\n    cache.set(key, { value, lastAccess })\n    trim()\n  }\n\n  function get(key) {\n    const now = new Date()\n\n    const cachedEntry = cache.get(key)\n\n    if (!cachedEntry) {\n      return null\n    }\n\n    // Expired: delete the entry\n    if (now - cachedEntry.lastAccess > expireAfter) {\n      cache.delete(key)\n      return null\n    }\n\n    update(key, cachedEntry.value, now)\n\n    return cachedEntry.value\n  }\n\n  function set(key, value) {\n    update(key, value, new Date())\n  }\n\n  return {\n    clear: () => cache.clear(),\n    delete: key => cache.delete(key),\n    get,\n    set,\n  }\n}\n\nexport default cachedMap\n","import { useEffect, useMemo, useState } from 'react'\nimport cachedMap from '../lib/cached-map'\n\nconst srcCache = cachedMap()\n\n// Check if a remote image exists and can be loaded within a specific amount of time.\nexport function useImageExists(src, timeUntilFallback = 50) {\n  const [exists, setExists] = useState(false)\n  const [loading, setLoading] = useState(true)\n  const [displayFallback, setDisplayFallback] = useState(false)\n\n  useEffect(() => {\n    let image = new Image()\n    const fallbackTimer = setTimeout(\n      () => setDisplayFallback(true),\n      timeUntilFallback\n    )\n\n    const init = () => {\n      if (!src) {\n        setExists(false)\n        setLoading(false)\n        return\n      }\n\n      if (srcCache.get(src)) {\n        success()\n        return\n      }\n\n      setExists(false)\n      setLoading(true)\n\n      // TODO: ensure only one image is loading at a time for a given src.\n      image.addEventListener('load', success)\n      image.src = src\n    }\n\n    const success = () => {\n      setLoading(false)\n      setExists(true)\n      srcCache.set(src, true)\n      done()\n    }\n\n    const done = () => {\n      clearTimeout(fallbackTimer)\n      if (image) {\n        image.removeEventListener('load', success)\n        image = null\n      }\n    }\n\n    init()\n\n    return done\n  }, [src, timeUntilFallback])\n\n  return useMemo(() => {\n    return { src, displayFallback, exists, loading }\n  }, [src, displayFallback, exists, loading])\n}\n\n// render prop\nexport const ImageExists = ({ timeUntilFallback, src, children }) =>\n  children(useImageExists(src, timeUntilFallback))\n"]},"metadata":{},"sourceType":"script"}