{"ast":null,"code":"'use strict';\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar errors = __importStar(require(\"../errors\"));\n\nvar bytes_1 = require(\"./bytes\");\n\nvar utf8_1 = require(\"./utf8\");\n\nvar keccak256_1 = require(\"./keccak256\"); ///////////////////////////////\n\n\nvar Zeros = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\nvar Partition = new RegExp(\"^((.*)\\\\.)?([^.]+)$\");\nvar UseSTD3ASCIIRules = new RegExp(\"^[a-z0-9.-]*$\");\n\nfunction namehash(name) {\n  if (typeof name !== 'string') {\n    errors.throwError('invalid address - ' + String(name), errors.INVALID_ARGUMENT, {\n      argument: 'name',\n      value: name\n    });\n  }\n\n  name = name.toLowerCase(); // Supporting the full UTF-8 space requires additional (and large)\n  // libraries, so for now we simply do not support them.\n  // It should be fairly easy in the future to support systems with\n  // String.normalize, but that is future work.\n\n  if (!name.match(UseSTD3ASCIIRules)) {\n    errors.throwError('contains invalid UseSTD3ASCIIRules characters', errors.INVALID_ARGUMENT, {\n      argument: 'name',\n      value: name\n    });\n  }\n\n  var result = Zeros;\n\n  while (name.length) {\n    var partition = name.match(Partition);\n    var label = utf8_1.toUtf8Bytes(partition[3]);\n    result = keccak256_1.keccak256(bytes_1.concat([result, keccak256_1.keccak256(label)]));\n    name = partition[2] || '';\n  }\n\n  return bytes_1.hexlify(result);\n}\n\nexports.namehash = namehash;\n\nfunction id(text) {\n  return keccak256_1.keccak256(utf8_1.toUtf8Bytes(text));\n}\n\nexports.id = id;\n\nfunction hashMessage(message) {\n  return keccak256_1.keccak256(bytes_1.concat([utf8_1.toUtf8Bytes('\\x19Ethereum Signed Message:\\n'), utf8_1.toUtf8Bytes(String(message.length)), typeof message === 'string' ? utf8_1.toUtf8Bytes(message) : message]));\n}\n\nexports.hashMessage = hashMessage;","map":null,"metadata":{},"sourceType":"script"}