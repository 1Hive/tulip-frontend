{"ast":null,"code":"/*!\n * aead.js - aead for bcrypto\n * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Resources:\n *   https://tools.ietf.org/html/rfc7539#section-2.8\n *   https://github.com/openssh/openssh-portable\n */\n'use strict';\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar assert = require('../internal/assert');\n\nvar ChaCha20 = require('./chacha20');\n\nvar Poly1305 = require('./poly1305');\n/**\n * AEAD\n */\n\n\nvar AEAD = /*#__PURE__*/function () {\n  /**\n   * Create an AEAD context.\n   * @constructor\n   */\n  function AEAD() {\n    _classCallCheck(this, AEAD);\n\n    this.chacha = new ChaCha20();\n    this.poly = new Poly1305();\n    this.key = Buffer.alloc(64);\n    this.mode = -1;\n    this.aadLen = 0;\n    this.cipherLen = 0;\n  }\n  /**\n   * Initialize the AEAD with a key and iv.\n   * @param {Buffer} key\n   * @param {Buffer} iv - IV / packet sequence number.\n   */\n\n\n  _createClass(AEAD, [{\n    key: \"init\",\n    value: function init(key, iv) {\n      assert(Buffer.isBuffer(key));\n      assert(Buffer.isBuffer(iv));\n      this.key.fill(0x00);\n      this.chacha.init(key, iv, 0);\n      this.chacha.encrypt(this.key);\n      this.poly.init(this.key);\n      this.mode = 0;\n      this.aadLen = 0;\n      this.cipherLen = 0;\n      return this;\n    }\n    /**\n     * Update the aad (will be finalized\n     * on an encrypt/decrypt call).\n     * @param {Buffer} aad\n     */\n\n  }, {\n    key: \"aad\",\n    value: function aad(data) {\n      if (this.mode === -1) throw new Error('Context is not initialized.');\n      if (this.mode !== 0) throw new Error('Invalid state for aad.');\n      this.poly.update(data);\n      this.aadLen += data.length;\n      return this;\n    }\n    /**\n     * Encrypt a piece of data.\n     * @param {Buffer} data\n     */\n\n  }, {\n    key: \"encrypt\",\n    value: function encrypt(data) {\n      if (this.mode === -1) throw new Error('Context is not initialized.');\n      if (this.mode !== 0 && this.mode !== 1) throw new Error('Invalid state for encrypt.');\n\n      if (this.mode === 0) {\n        this._pad16(this.aadLen);\n\n        this.mode = 1;\n      }\n\n      this.chacha.encrypt(data);\n      this.poly.update(data);\n      this.cipherLen += data.length;\n      return data;\n    }\n    /**\n     * Decrypt a piece of data.\n     * @param {Buffer} data\n     */\n\n  }, {\n    key: \"decrypt\",\n    value: function decrypt(data) {\n      assert(Buffer.isBuffer(data));\n      if (this.mode === -1) throw new Error('Context is not initialized.');\n      if (this.mode !== 0 && this.mode !== 2) throw new Error('Invalid state for decrypt.');\n\n      if (this.mode === 0) {\n        this._pad16(this.aadLen);\n\n        this.mode = 2;\n      }\n\n      this.cipherLen += data.length;\n      this.poly.update(data);\n      this.chacha.encrypt(data);\n      return data;\n    }\n    /**\n     * Authenticate data without decrypting.\n     * @param {Buffer} data\n     */\n\n  }, {\n    key: \"auth\",\n    value: function auth(data) {\n      assert(Buffer.isBuffer(data));\n      if (this.mode === -1) throw new Error('Context is not initialized.');\n      if (this.mode !== 0 && this.mode !== 3) throw new Error('Invalid state for auth.');\n\n      if (this.mode === 0) {\n        this._pad16(this.aadLen);\n\n        this.mode = 3;\n      }\n\n      this.cipherLen += data.length;\n      this.poly.update(data);\n      return data;\n    }\n    /**\n     * Finalize the aead and generate a MAC.\n     * @returns {Buffer} MAC\n     */\n\n  }, {\n    key: \"final\",\n    value: function final() {\n      if (this.mode === -1) throw new Error('Context is not initialized.');\n      var len = Buffer.allocUnsafe(16);\n      writeU64(len, this.aadLen, 0);\n      writeU64(len, this.cipherLen, 8);\n      if (this.mode === 0) this._pad16(this.aadLen);\n\n      this._pad16(this.cipherLen);\n\n      this.poly.update(len);\n      var mac = this.poly.final();\n      this.destroy();\n      return mac;\n    }\n    /**\n     * Destroy the context.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.chacha.destroy();\n      this.poly.destroy();\n\n      for (var i = 0; i < 64; i++) {\n        this.key[i] = 0;\n      }\n\n      this.mode = -1;\n      this.aadLen = 0;\n      this.cipherLen = 0;\n      return this;\n    }\n    /**\n     * Finalize and verify MAC against tag.\n     * @param {Buffer} tag\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"verify\",\n    value: function verify(tag) {\n      assert(Buffer.isBuffer(tag));\n      assert(tag.length === 16);\n      var mac = this.final();\n      var z = 0;\n\n      for (var i = 0; i < 16; i++) {\n        z |= mac[i] ^ tag[i];\n      }\n\n      return z - 1 >>> 31 !== 0;\n    }\n    /**\n     * Pad a chunk before updating mac.\n     * @private\n     * @param {Number} size\n     */\n\n  }, {\n    key: \"_pad16\",\n    value: function _pad16(size) {\n      var pos = size & 15;\n      if (pos === 0) return;\n      var pad = Buffer.allocUnsafe(16 - pos);\n      pad.fill(0x00);\n      this.poly.update(pad);\n    }\n    /**\n     * Encrypt a piece of data.\n     * @param {Buffer} key\n     * @param {Buffer} iv\n     * @param {Buffer} msg\n     * @param {Buffer?} aad\n     * @returns {Buffer} tag\n     */\n\n  }], [{\n    key: \"encrypt\",\n    value: function encrypt(key, iv, msg, aad) {\n      var aead = new AEAD();\n      aead.init(key, iv);\n      if (aad) aead.aad(aad);\n      aead.encrypt(msg);\n      return aead.final();\n    }\n    /**\n     * Decrypt a piece of data.\n     * @param {Buffer} key\n     * @param {Buffer} iv\n     * @param {Buffer} msg\n     * @param {Buffer} tag\n     * @param {Buffer?} aad\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"decrypt\",\n    value: function decrypt(key, iv, msg, tag, aad) {\n      var aead = new AEAD();\n      aead.init(key, iv);\n      if (aad) aead.aad(aad);\n      aead.decrypt(msg);\n      return aead.verify(tag);\n    }\n    /**\n     * Authenticate data without decrypting.\n     * @param {Buffer} key\n     * @param {Buffer} iv\n     * @param {Buffer} msg\n     * @param {Buffer} tag\n     * @param {Buffer?} aad\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"auth\",\n    value: function auth(key, iv, msg, tag, aad) {\n      var aead = new AEAD();\n      aead.init(key, iv);\n      if (aad) aead.aad(aad);\n      aead.auth(msg);\n      return aead.verify(tag);\n    }\n  }]);\n\n  return AEAD;\n}();\n/*\n * Static\n */\n\n\nAEAD.native = ChaCha20.native;\n/*\n * Helpers\n */\n\nfunction writeU32(dst, num, off) {\n  dst[off++] = num;\n  num >>>= 8;\n  dst[off++] = num;\n  num >>>= 8;\n  dst[off++] = num;\n  num >>>= 8;\n  dst[off++] = num;\n  return off;\n}\n\nfunction writeU64(dst, num, off) {\n  var hi = num * (1 / 0x100000000) >>> 0;\n  var lo = num >>> 0;\n  writeU32(dst, lo, off + 0);\n  writeU32(dst, hi, off + 4);\n  return off + 8;\n}\n/*\n * Expose\n */\n\n\nmodule.exports = AEAD;","map":null,"metadata":{},"sourceType":"script"}