{"ast":null,"code":"/*!\n * bn.js - big numbers for bcrypto\n * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Parts of this software are based on indutny/bn.js:\n *   Copyright (c) 2015, Fedor Indutny (MIT License).\n *   https://github.com/indutny/bn.js\n *\n * Parts of this software are based on golang/go:\n *   Copyright (c) 2009, The Go Authors. All rights reserved.\n *   https://github.com/golang/go\n *\n * Parts of this software are based on openssl/openssl:\n *   Copyright (c) 1998-2018, The OpenSSL Project (Apache License v2.0).\n *   Copyright (c) 1995-1998, Eric A. Young, Tim J. Hudson. All rights reserved.\n *   https://github.com/openssl/openssl\n *\n * Parts of this software are based on libgmp:\n *   Copyright (c) 1991-1997, 1999-2014, Free Software Foundation, Inc.\n *   https://gmplib.org/\n *\n * Parts of this software are based on v8/v8:\n *   Copyright (c) 2017, The V8 Project Authors (BSD-Style License).\n *   https://github.com/v8/v8\n *\n * Resources:\n *   https://github.com/indutny/bn.js/blob/master/lib/bn.js\n *   https://github.com/indutny/miller-rabin/blob/master/lib/mr.js\n *   https://github.com/golang/go/blob/master/src/math/big/int.go\n *   https://github.com/golang/go/blob/master/src/math/big/nat.go\n *   https://github.com/golang/go/blob/master/src/math/big/prime.go\n *   https://github.com/openssl/openssl/tree/master/crypto/bn\n *   https://github.com/openssl/openssl/blob/master/crypto/bn/bn_kron.c\n *   https://github.com/gnutls/nettle/blob/master/mini-gmp.c\n *   https://github.com/v8/v8/blob/master/src/objects/bigint.cc\n */\n\n/* eslint valid-typeof: \"off\" */\n'use strict';\n\nconst {\n  custom\n} = require('../internal/custom');\n/*\n * Constants\n */\n\n\nconst zeros = ['', '0', '00', '000', '0000', '00000', '000000', '0000000', '00000000', '000000000', '0000000000', '00000000000', '000000000000', '0000000000000', '00000000000000', '000000000000000', '0000000000000000', '00000000000000000', '000000000000000000', '0000000000000000000', '00000000000000000000', '000000000000000000000', '0000000000000000000000', '00000000000000000000000', '000000000000000000000000', '0000000000000000000000000'];\nconst groupSizes = [0x00, 0x19, 0x10, 0x0c, 0x0b, 0x0a, 0x09, 0x08, 0x08, 0x07, 0x07, 0x07, 0x07, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05];\nconst groupBases = [0x00000000, 0x02000000, 0x0290d741, 0x01000000, 0x02e90edd, 0x039aa400, 0x0267bf47, 0x01000000, 0x0290d741, 0x00989680, 0x012959c3, 0x0222c000, 0x03bd7765, 0x0072e440, 0x00adcea1, 0x01000000, 0x01704f61, 0x0206fc40, 0x02cddcf9, 0x03d09000, 0x003e5185, 0x004ea360, 0x006235f7, 0x00798000, 0x009502f9, 0x00b54ba0, 0x00daf26b, 0x01069c00, 0x0138f9ad, 0x0172c9e0, 0x01b4d89f, 0x02000000, 0x025528a1, 0x02b54a20, 0x03216b93, 0x039aa400];\nconst primes = {\n  p192: null,\n  p224: null,\n  p521: null,\n  k256: null,\n  p25519: null,\n  p448: null\n};\nconst modes = {\n  NONE: 0,\n  QUO: 1,\n  REM: 2,\n  BOTH: 3,\n  EUCLID: 4,\n  ALL: 7\n};\nconst WND_WIDTH = 4;\nconst WND_SIZE = 1 << WND_WIDTH - 1;\nconst HAS_BIGINT = typeof BigInt === 'function';\n/**\n * BN\n */\n\nclass BN {\n  constructor(num, base, endian) {\n    this.words = [0];\n    this.length = 1;\n    this.negative = 0;\n    this.red = null;\n    this.from(num, base, endian);\n  }\n  /*\n   * Addition Engine\n   */\n\n\n  _iadd(a, b) {\n    let carry = 0;\n    let i = 0; // a.length > b.length\n\n    if (a.length < b.length) [a, b] = [b, a];\n    if (a !== this) this._alloc(a.length);\n\n    for (; i < b.length; i++) {\n      const r = (a.words[i] | 0) + (b.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n\n    for (; carry !== 0 && i < a.length; i++) {\n      const r = (a.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n\n    this.length = a.length;\n\n    if (carry !== 0) {\n      this._alloc(this.length + 1);\n\n      this.words[this.length++] = carry;\n    } else if (a !== this) {\n      // Copy the rest of the words.\n      for (; i < a.length; i++) this.words[i] = a.words[i];\n    } // Note: we shouldn't need to strip here.\n\n\n    return this;\n  }\n\n  _iaddn(num) {\n    this.words[0] += num;\n    if (this.words[0] < 0x4000000) return this; // Carry.\n\n    let i = 0;\n\n    this._alloc(this.length + 1);\n\n    this.words[this.length] = 0;\n\n    for (; i < this.length && this.words[i] >= 0x4000000; i++) {\n      this.words[i] -= 0x4000000;\n      this.words[i + 1] += 1;\n    }\n\n    this.length = Math.max(this.length, i + 1); // Note: we shouldn't need to strip here.\n\n    return this;\n  }\n  /*\n   * Addition\n   */\n\n\n  iadd(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n\n    if (this.negative === num.negative) {\n      // x + y == x + y\n      // (-x) + (-y) == -(x + y)\n      this._iadd(this, num);\n    } else {\n      // x + (-y) == x - y == -(y - x)\n      // (-x) + y == y - x == -(x - y)\n      const cmp = this.ucmp(num); // x + (-x) == (-x) + x == 0\n\n      if (cmp === 0) {\n        this.words[0] = 0;\n        this.length = 1;\n        this.negative = 0;\n        return this;\n      }\n\n      if (cmp < 0) {\n        this._isub(num, this);\n\n        this.negative ^= 1;\n      } else {\n        this._isub(this, num);\n      }\n    }\n\n    return this;\n  }\n\n  iaddn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    const negative = num < 0 | 0;\n    if (negative) num = -num;\n\n    if (this.negative === negative) {\n      // x + y == x + y\n      // (-x) + (-y) == -(x + y)\n      this._iaddn(num);\n    } else {\n      // x + (-y) == x - y == -(y - x)\n      // (-x) + y == y - x == -(x - y)\n      if (this.length === 1 && this.words[0] < num) {\n        this.words[0] = num - this.words[0];\n        this.negative ^= 1;\n      } else {\n        this._isubn(num);\n      }\n    }\n\n    return this;\n  }\n\n  add(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    if (num.length > this.length) return num.clone().iadd(this);\n    return this.clone().iadd(num);\n  }\n\n  addn(num) {\n    return this.clone().iaddn(num);\n  }\n  /*\n   * Subtraction Engine\n   */\n\n\n  _isub(a, b) {\n    let carry = 0;\n    let i = 0; // a > b\n\n    assert(a.length >= b.length);\n    if (a !== this) this._alloc(a.length);\n\n    for (; i < b.length; i++) {\n      const r = (a.words[i] | 0) - (b.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n\n    for (; carry !== 0 && i < a.length; i++) {\n      const r = (a.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n\n    assert(carry === 0); // Copy rest of the words.\n\n    if (a !== this) {\n      for (; i < a.length; i++) this.words[i] = a.words[i];\n    }\n\n    this.length = Math.max(this.length, i);\n    return this._strip();\n  }\n\n  _isubn(num) {\n    this.words[0] -= num;\n    if (this.words[0] >= 0) return this._normalize();\n    assert(this.length !== 1); // Carry.\n\n    this._alloc(this.length + 1);\n\n    for (let i = 0; i < this.length && this.words[i] < 0; i++) {\n      this.words[i] += 0x4000000;\n      this.words[i + 1] -= 1;\n    }\n\n    this.words[this.length] = 0;\n    return this._strip();\n  }\n  /*\n   * Subtraction\n   */\n\n\n  isub(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n\n    if (this.negative !== num.negative) {\n      // x - (-y) == x + y\n      // (-x) - y == -(x + y)\n      this._iadd(this, num);\n    } else {\n      // x - y == x - y == -(y - x)\n      // (-x) - (-y) == y - x == -(x - y)\n      const cmp = this.ucmp(num); // x - x == 0\n\n      if (cmp === 0) {\n        this.words[0] = 0;\n        this.length = 1;\n        this.negative = 0;\n        return this;\n      }\n\n      if (cmp < 0) {\n        this._isub(num, this);\n\n        this.negative ^= 1;\n      } else {\n        this._isub(this, num);\n      }\n    }\n\n    return this;\n  }\n\n  isubn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    const negative = num < 0 | 0;\n    if (negative) num = -num;\n\n    if (this.negative !== negative) {\n      // x - (-y) == x + y\n      // (-x) - y == -(x + y)\n      this._iaddn(num);\n    } else {\n      // x - y == x - y == -(y - x)\n      // (-x) - (-y) == y - x == -(x - y)\n      if (this.length === 1 && this.words[0] < num) {\n        this.words[0] = num - this.words[0];\n        this.negative ^= 1;\n      } else {\n        this._isubn(num);\n      }\n    }\n\n    return this;\n  }\n\n  sub(num) {\n    return this.clone().isub(num);\n  }\n\n  subn(num) {\n    return this.clone().isubn(num);\n  }\n  /*\n   * Multiplication Engine\n   */\n\n\n  _mul(num, out) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    enforce(BN.isBN(out), 'out', 'bignum');\n    if (this.length === 10 && num.length === 10) return comb10MulTo(this, num, out);\n    const len = this.length + num.length;\n    if (len < 63) return smallMulTo(this, num, out);\n    if (len < 1024) return bigMulTo(this, num, out);\n    return jumboMulTo(this, num, out);\n  }\n  /*\n   * Multiplication\n   */\n\n\n  imul(num) {\n    return this.mul(num)._move(this);\n  }\n\n  imuln(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    const neg = num < 0 | 0;\n    if (neg) num = -num; // Carry.\n\n    let carry = 0;\n\n    for (let i = 0; i < this.length; i++) {\n      const w = this.words[i] * num;\n      const lo = (w & 0x3ffffff) + (carry & 0x3ffffff);\n      carry >>= 26;\n      carry += w / 0x4000000 | 0;\n      carry += lo >>> 26;\n      this.words[i] = lo & 0x3ffffff;\n    }\n\n    this.negative ^= neg;\n\n    if (carry !== 0) {\n      this._alloc(this.length + 1);\n\n      this.words[this.length++] = carry;\n    } else {\n      this._strip();\n    }\n\n    return this;\n  }\n\n  mul(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    const len = this.length + num.length;\n    const out = new BN();\n    out.words = new Array(len);\n\n    for (let i = 0; i < len; i++) out.words[i] = 0;\n\n    return this._mul(num, out);\n  }\n\n  muln(num) {\n    return this.clone().imuln(num);\n  }\n  /*\n   * Multiplication + Shift\n   */\n\n\n  mulShift(num, bits) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    enforce(bits >>> 0 === bits, 'bits', 'uint32');\n    const r = this.mul(num);\n    const b = r.utestn(bits - 1);\n    r.iushrn(bits);\n    if (this.negative ^ num.negative) return r.isubn(b);\n    return r.iaddn(b);\n  }\n  /*\n   * Division Engine\n   */\n\n\n  _div(num, flags) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    assert((flags & modes.ALL) === flags);\n    assert(flags !== modes.NONE);\n    const a = this;\n    const b = num;\n    nonzero(!b.isZero());\n    if (a.isZero()) return [new BN(0), new BN(0)];\n    const as = a.negative;\n    const bs = b.negative;\n    a.negative = 0;\n    b.negative = 0;\n    let q = null;\n    let r = null;\n\n    if (a.ucmp(b) < 0) {\n      if (flags & modes.QUO) q = new BN(0);\n      if (flags & modes.REM) r = a.clone();\n    } else if (b.length === 1) {\n      if (flags & modes.QUO) q = a.quon(b.words[0]);\n      if (flags & modes.REM) r = a.remn(b.words[0]);\n    } else {\n      [q, r] = a._wordDiv(b, flags);\n    }\n\n    a.negative = as;\n    b.negative = bs;\n\n    if (flags & modes.QUO) {\n      q.negative = a.negative ^ b.negative;\n\n      q._normalize();\n    }\n\n    if (flags & modes.REM) {\n      r.negative = a.negative;\n\n      r._normalize();\n    }\n\n    if (flags & modes.EUCLID) {\n      if (flags & modes.QUO) {\n        assert((flags & modes.REM) !== 0);\n\n        if (r.negative !== 0) {\n          if (b.negative !== 0) q.iaddn(1);else q.isubn(1);\n        }\n      }\n\n      if (flags & modes.REM) {\n        if (r.negative !== 0) {\n          if (b.negative !== 0) r.isub(b);else r.iadd(b);\n        }\n      }\n    }\n\n    return [q, r];\n  }\n\n  _wordDiv(num, flags) {\n    let a = this.clone();\n    let b = num;\n    let q = null;\n    let hi; // Normalize.\n\n    const word = b.words[b.length - 1] | 0;\n    const shift = 26 - countBits(word);\n\n    if (shift !== 0) {\n      b = b.clone();\n      a.iushln(shift);\n      b.iushln(shift);\n      hi = b.words[b.length - 1] | 0;\n    } else {\n      hi = word;\n    } // Initialize quotient.\n\n\n    const m = a.length - b.length;\n    assert(m >= 0);\n\n    if (flags & modes.QUO) {\n      q = new BN(0);\n      q.length = m + 1;\n      q.words = new Array(q.length);\n\n      for (let i = 0; i < q.length; i++) q.words[i] = 0;\n    } // Diff.\n\n\n    const d = a.clone();\n\n    d._ishlnsubmul(b, 1, m);\n\n    if (d.negative === 0) {\n      if (q) q.words[m] = 1;\n      a = d;\n    } // Divide.\n\n\n    for (let j = m - 1; j >= 0; j--) {\n      const ahi = a.words[b.length + j];\n      const alo = a.words[b.length + j - 1];\n      const quo = (ahi * 0x4000000 + alo) / hi | 0;\n      let qj = Math.min(quo, 0x3ffffff);\n\n      a._ishlnsubmul(b, qj, j);\n\n      while (a.negative !== 0) {\n        qj -= 1;\n        a.negative = 0;\n\n        a._ishlnsubmul(b, 1, j);\n\n        a.ineg();\n      }\n\n      if (q) q.words[j] = qj;\n    } // Strip.\n\n\n    if (q) q._strip(); // Denormalize.\n    // Note: we shouldn't need to strip `a` here.\n\n    if (flags & modes.REM && shift !== 0) a.iushrn(shift);\n    return [q, a];\n  }\n\n  _ishlnsubmul(num, mul, shift) {\n    let carry = 0;\n    let i = 0;\n\n    this._expand(num.length + shift);\n\n    for (; i < num.length; i++) {\n      const k = (this.words[i + shift] | 0) + carry;\n      const r = num.words[i] * mul;\n      const w = k - (r & 0x3ffffff);\n      carry = (w >> 26) - (r / 0x4000000 | 0);\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n\n    for (; i < this.length - shift; i++) {\n      const w = (this.words[i + shift] | 0) + carry;\n      carry = w >> 26;\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n\n    if (carry === 0) return this._strip(); // Subtraction overflow.\n\n    assert(carry === -1);\n    carry = 0;\n\n    for (let i = 0; i < this.length; i++) {\n      const w = -(this.words[i] | 0) + carry;\n      carry = w >> 26;\n      this.words[i] = w & 0x3ffffff;\n    }\n\n    this.negative = 1;\n    return this._strip();\n  }\n  /*\n   * Truncation Division + Modulo\n   */\n\n\n  quorem(num) {\n    return this._div(num, modes.BOTH);\n  }\n  /*\n   * Truncation Division\n   */\n\n\n  iquo(num) {\n    return this.quo(num)._move(this);\n  }\n\n  iquon(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    nonzero(num !== 0);\n    const neg = num < 0 | 0;\n    if (neg) num = -num;\n    let carry = 0;\n\n    for (let i = this.length - 1; i >= 0; i--) {\n      const w = (this.words[i] | 0) + carry * 0x4000000;\n      this.words[i] = w / num | 0;\n      carry = w % num;\n    }\n\n    this.negative ^= neg;\n    return this._strip();\n  }\n\n  quo(num) {\n    return this._div(num, modes.QUO)[0];\n  }\n\n  quon(num) {\n    return this.clone().iquon(num);\n  }\n  /*\n   * Truncation Modulo\n   */\n\n\n  irem(num) {\n    return this.rem(num)._move(this);\n  }\n\n  iremn(num) {\n    let m = this.remrn(num);\n    if (m < 0) m = -m;\n    this.words[0] = m;\n    this.length = 1;\n    return this._normalize();\n  }\n\n  rem(num) {\n    return this._div(num, modes.REM)[1];\n  }\n\n  remn(num) {\n    return this.clone().iremn(num);\n  }\n\n  remrn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    nonzero(num !== 0);\n    if (num < 0) num = -num;\n    const p = (1 << 26) % num;\n    let acc = 0;\n\n    for (let i = this.length - 1; i >= 0; i--) acc = (p * acc + (this.words[i] | 0)) % num;\n\n    return this.negative !== 0 ? -acc | 0 : acc;\n  }\n  /*\n   * Euclidean Division + Modulo\n   */\n\n\n  divmod(num) {\n    return this._div(num, modes.BOTH | modes.EUCLID);\n  }\n  /*\n   * Euclidean Division\n   */\n\n\n  idiv(num) {\n    return this.div(num)._move(this);\n  }\n\n  idivn(num) {\n    if (this.negative === 0) return this.iquon(num);\n    const r = this.remrn(num);\n    this.iquon(num);\n\n    if (r < 0) {\n      if (num < 0) this.iaddn(1);else this.isubn(1);\n    }\n\n    return this;\n  }\n\n  div(num) {\n    return this._div(num, modes.BOTH | modes.EUCLID)[0];\n  }\n\n  divn(num) {\n    return this.clone().idivn(num);\n  }\n  /*\n   * Euclidean Modulo\n   */\n\n\n  imod(num) {\n    if (this.ucmp(num) < 0) {\n      if (this.negative !== 0) {\n        this._isub(num, this);\n\n        this.negative = 0;\n      }\n\n      return this;\n    }\n\n    return this.mod(num)._move(this);\n  }\n\n  imodn(num) {\n    this.words[0] = this.modrn(num);\n    this.length = 1;\n    this.negative = 0;\n    return this;\n  }\n\n  mod(num) {\n    return this._div(num, modes.REM | modes.EUCLID)[1];\n  }\n\n  modn(num) {\n    return this.clone().imodn(num);\n  }\n\n  modrn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    let r = this.remrn(num);\n\n    if (r < 0) {\n      if (num < 0) r -= num;else r += num;\n    }\n\n    return r;\n  }\n  /*\n   * Round Division\n   */\n\n\n  divRound(num) {\n    const [q, r] = this.quorem(num); // Fast case - exact division.\n\n    if (r.isZero()) return q;\n    const bit = num.words[0] & 1;\n    num.iushrn(1);\n    const cmp = r.ucmp(num);\n    num.iushln(1);\n    num.words[0] |= bit; // Round down.\n\n    if (cmp < 0 || num.isOdd() && cmp === 0) return q; // Round up.\n\n    if (this.negative ^ num.negative) return q.isubn(1);\n    return q.iaddn(1);\n  }\n  /*\n   * Exponentiation\n   */\n\n\n  ipow(num) {\n    return this.pow(num)._move(this);\n  }\n\n  ipown(num) {\n    return this.pown(num)._move(this);\n  }\n\n  pow(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    let b = countBits(num.words[num.length - 1]);\n    let r = new BN(1);\n\n    for (let i = num.length - 1; i >= 0; i--) {\n      const word = num.words[i];\n\n      for (let j = b - 1; j >= 0; j--) {\n        r = r.sqr();\n        if (word >> j & 1) r = r.mul(this);\n      }\n\n      b = 26;\n    }\n\n    return r;\n  }\n\n  pown(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    if (num < 0) num = -num;\n    if (num === 0) return new BN(1);\n    if (num === 1) return this.clone();\n    const bits = countBits(num);\n    let r = this;\n\n    for (let i = bits - 2; i >= 0; i--) {\n      r = r.sqr();\n      if (num >> i & 1) r = r.mul(this);\n    }\n\n    return r;\n  }\n\n  isqr() {\n    return this.imul(this);\n  }\n\n  sqr() {\n    return this.mul(this);\n  }\n  /*\n   * Roots Engine\n   */\n\n\n  _rootrem(pow, rem) {\n    enforce(pow >>> 0 === pow, 'num', 'uint32');\n    if (pow === 0) throw new RangeError('Zeroth root.');\n    if (~pow & this.negative) throw new RangeError('Negative with even root.');\n    if (this.ucmpn(1) <= 0) return [this.clone(), new BN(0)];\n    let u = new BN(0);\n    let t = BN.shift(1, this.bitLength() / pow + 1 | 0);\n    let v, r;\n    if (this.negative !== 0) t.ineg();\n\n    if (pow === 2) {\n      do {\n        u = t;\n        t = this.quo(u);\n        t.iadd(u);\n        t.iushrn(1);\n      } while (t.ucmp(u) < 0);\n    } else {\n      do {\n        u = t;\n        t = u.pown(pow - 1);\n        t = this.quo(t);\n        v = u.muln(pow - 1);\n        t.iadd(v);\n        t = t.quon(pow);\n      } while (t.ucmp(u) < 0);\n    }\n\n    if (rem) {\n      t = u.pown(pow);\n      r = this.sub(t);\n    }\n\n    return [u, r];\n  }\n  /*\n   * Roots\n   */\n\n\n  rootrem(pow) {\n    return this._rootrem(pow, 1);\n  }\n\n  iroot(pow) {\n    return this.root(pow)._move(this);\n  }\n\n  root(pow) {\n    return this._rootrem(pow, 0)[0];\n  }\n\n  isPower(pow) {\n    enforce(pow >>> 0 === pow, 'num', 'uint32');\n    if (pow === 0 || ~pow & this.negative) return false;\n    const [, r] = this.rootrem(pow);\n    return r.sign() === 0;\n  }\n\n  sqrtrem() {\n    return this.rootrem(2);\n  }\n\n  isqrt() {\n    return this.sqrt()._move(this);\n  }\n\n  sqrt() {\n    return this.root(2);\n  }\n\n  isSquare() {\n    return this.isPower(2);\n  }\n  /*\n   * AND\n   */\n\n\n  iand(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    let x = this;\n    let y = num;\n    if (x === y) return x;\n    if ((x.negative | y.negative) === 0) return x.iuand(y);\n\n    if ((x.negative & y.negative) === 1) {\n      // (-x) & (-y) == ~(x-1) & ~(y-1)\n      //             == ~((x-1) | (y-1))\n      //             == -(((x-1) | (y-1)) + 1)\n      x.iaddn(1);\n      y.iaddn(1);\n      x.iuor(y);\n      x.isubn(1);\n      y.isubn(1);\n      return x;\n    } // Assume x is the positive number.\n\n\n    if (x.negative !== 0) [x, y] = [y.clone(), x]; // x & (-y) == x & ~(y-1)\n    //          == x & ~(y-1)\n\n    const width = x.bitLength();\n    y.iaddn(1);\n    y.inotn(width);\n    x.iuand(y);\n    y.inotn(width);\n    y.isubn(1);\n    return x._move(this);\n  }\n\n  iandn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    if ((this.negative | num < 0) !== 0) return this.iand(new BN(num));\n    this.words[0] &= num;\n    this.length = 1;\n    return this;\n  }\n\n  and(num) {\n    return this.clone().iand(num);\n  }\n\n  andn(num) {\n    return this.clone().iandn(num);\n  }\n\n  andrn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n\n    if ((this.negative | num < 0) !== 0) {\n      const n = this.iand(new BN(num));\n      if (n.length > 1) throw new RangeError('Number exceeds 26 bits.');\n      return n.negative !== 0 ? -n.words[0] : n.words[0];\n    }\n\n    return this.words[0] & num;\n  }\n  /*\n   * Unsigned AND\n   */\n\n\n  iuand(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    this.length = Math.min(this.length, num.length);\n\n    for (let i = 0; i < this.length; i++) this.words[i] &= num.words[i];\n\n    return this._strip();\n  }\n\n  iuandn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    this.words[0] &= Math.abs(num);\n    this.length = 1;\n    return this._normalize();\n  }\n\n  uand(num) {\n    return this.clone().iuand(num);\n  }\n\n  uandn(num) {\n    return this.clone().iuandn(num);\n  }\n\n  uandrn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    const n = this.words[0] & Math.abs(num);\n    return this.negative !== 0 ? -n | 0 : n;\n  }\n  /*\n   * OR\n   */\n\n\n  ior(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    let x = this;\n    let y = num;\n    if (x === y) return x;\n    if ((x.negative | y.negative) === 0) return x.iuor(y);\n\n    if ((x.negative & y.negative) === 1) {\n      // (-x) | (-y) == ~(x-1) | ~(y-1)\n      //             == ~((x-1) & (y-1))\n      //             == -(((x-1) & (y-1)) + 1)\n      x.iaddn(1);\n      y.iaddn(1);\n      x.iuand(y);\n      x.isubn(1);\n      y.isubn(1);\n      return x;\n    } // Assume x is the positive number.\n\n\n    y = y.clone();\n    if (x.negative !== 0) [x, y] = [y, x]; // x | (-y) == x | ~(y-1)\n    //          == ~((y-1) & ~x)\n    //          == -(((y-1) & ~x) + 1)\n\n    y.iaddn(1);\n    x.inotn(y.bitLength());\n    y.iuand(x);\n    y.isubn(1);\n    return y._move(this);\n  }\n\n  iorn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    if ((this.negative | num < 0) !== 0) return this.ior(new BN(num));\n    this.words[0] |= num;\n    return this;\n  }\n\n  or(num) {\n    return this.clone().ior(num);\n  }\n\n  orn(num) {\n    return this.clone().iorn(num);\n  }\n  /*\n   * Unsigned OR\n   */\n\n\n  iuor(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n\n    this._expand(num.length);\n\n    for (let i = 0; i < num.length; i++) this.words[i] |= num.words[i]; // Note: we shouldn't need to strip here.\n\n\n    return this;\n  }\n\n  iuorn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    this.words[0] |= Math.abs(num);\n    return this;\n  }\n\n  uor(num) {\n    return this.clone().iuor(num);\n  }\n\n  uorn(num) {\n    return this.clone().iuorn(num);\n  }\n  /*\n   * XOR\n   */\n\n\n  ixor(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    let x = this;\n    let y = num;\n\n    if (x === y) {\n      x.words[0] = 0;\n      x.length = 1;\n      x.negative = 0;\n      return x;\n    }\n\n    if ((x.negative | y.negative) === 0) return x.iuxor(y);\n\n    if ((x.negative & y.negative) === 1) {\n      // (-x) ^ (-y) == ~(x-1) ^ ~(y-1)\n      //             == (x-1) ^ (y-1)\n      x.iaddn(1);\n      y.iaddn(1);\n      x.iuxor(y);\n      x.ineg();\n      y.isubn(1);\n      return x;\n    } // Assume x is the positive number.\n\n\n    if (x.negative !== 0) [x, y] = [y.clone(), x]; // x ^ (-y) == x ^ ~(y-1)\n    //          == ~(x ^ (y-1))\n    //          == -((x ^ (y-1)) + 1)\n\n    y.iaddn(1);\n    x.iuxor(y);\n    x.iaddn(1);\n    x.ineg();\n    y.isubn(1);\n    return x._move(this);\n  }\n\n  ixorn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    if ((this.negative | num < 0) !== 0) return this.ixor(new BN(num));\n    this.words[0] ^= num;\n    return this;\n  }\n\n  xor(num) {\n    return this.clone().ixor(num);\n  }\n\n  xorn(num) {\n    return this.clone().ixorn(num);\n  }\n  /*\n   * Unsigned XOR\n   */\n\n\n  iuxor(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    let a = this;\n    let b = num;\n    if (a.length < b.length) [a, b] = [b, a];\n    let i = 0;\n\n    for (; i < b.length; i++) this.words[i] = a.words[i] ^ b.words[i];\n\n    if (a !== this) {\n      this._alloc(a.length);\n\n      for (; i < a.length; i++) this.words[i] = a.words[i];\n    }\n\n    this.length = a.length;\n    return this._strip();\n  }\n\n  iuxorn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    this.words[0] ^= Math.abs(num);\n    return this._normalize();\n  }\n\n  uxor(num) {\n    return this.clone().iuxor(num);\n  }\n\n  uxorn(num) {\n    return this.clone().iuxorn(num);\n  }\n  /*\n   * NOT\n   */\n\n\n  inot() {\n    if (this.negative !== 0) {\n      // ~(-x) == ~(~(x-1)) == x-1\n      this.ineg().isubn(1);\n    } else {\n      // ~x == -x-1 == -(x+1)\n      this.iaddn(1).ineg();\n    }\n\n    return this;\n  }\n\n  not() {\n    return this.clone().inot();\n  }\n\n  inotn(width) {\n    enforce(width >>> 0 === width, 'width', 'uint32');\n    const r = width % 26;\n    let s = Math.ceil(width / 26);\n    let i = 0; // Extend the buffer with leading zeroes.\n\n    this._expand(s);\n\n    if (r > 0) s -= 1; // Handle complete words.\n\n    for (; i < s; i++) this.words[i] ^= 0x3ffffff; // Handle the residue.\n\n\n    if (r > 0) this.words[i] ^= (1 << r) - 1; // And remove leading zeroes.\n\n    return this._strip();\n  }\n\n  notn(width) {\n    return this.clone().inotn(width);\n  }\n  /*\n   * Left Shift\n   */\n\n\n  ishl(num) {\n    enforce(BN.isBN(num), 'bits', 'bignum');\n    enforce(num.bitLength() <= 32, 'bits', 'uint32');\n    return this.ishln(num.toNumber());\n  }\n\n  ishln(bits) {\n    return this.iushln(bits);\n  }\n\n  shl(num) {\n    return this.clone().ishl(num);\n  }\n\n  shln(bits) {\n    return this.clone().ishln(bits);\n  }\n  /*\n   * Unsigned Left Shift\n   */\n\n\n  iushl(num) {\n    enforce(BN.isBN(num), 'bits', 'bignum');\n    enforce(num.bitLength() <= 32, 'bits', 'uint32');\n    return this.iushln(num.toNumber());\n  }\n\n  iushln(bits) {\n    enforce(bits >>> 0 === bits, 'bits', 'uint32');\n    const r = bits % 26;\n    const s = (bits - r) / 26;\n    const mask = (1 << r) - 1 << 26 - r;\n\n    if (r !== 0) {\n      let carry = 0;\n\n      for (let i = 0; i < this.length; i++) {\n        const ncarry = this.words[i] & mask;\n        const c = (this.words[i] | 0) - ncarry << r;\n        this.words[i] = c | carry;\n        carry = ncarry >>> 26 - r;\n      }\n\n      if (carry !== 0) {\n        this._alloc(this.length + 1);\n\n        this.words[this.length++] = carry;\n      }\n    }\n\n    if (s !== 0) {\n      this._alloc(this.length + s);\n\n      for (let i = this.length - 1; i >= 0; i--) this.words[i + s] = this.words[i];\n\n      for (let i = 0; i < s; i++) this.words[i] = 0;\n\n      this.length += s;\n    }\n\n    return this._strip();\n  }\n\n  ushl(num) {\n    return this.clone().iushl(num);\n  }\n\n  ushln(bits) {\n    return this.clone().iushln(bits);\n  }\n  /*\n   * Right Shift Engine\n   */\n\n\n  _split(bits, output) {\n    const r = bits % 26;\n    const s = Math.min((bits - r) / 26, this.length);\n    const mask = (1 << r) - 1; // Extended mode, copy masked part.\n\n    if (output) {\n      output._alloc(s);\n\n      for (let i = 0; i < s; i++) output.words[i] = this.words[i];\n\n      output.length = s;\n    }\n\n    if (s === 0) {// No-op, we should not move anything at all.\n    } else if (this.length > s) {\n      this.length -= s;\n\n      for (let i = 0; i < this.length; i++) this.words[i] = this.words[i + s];\n    } else {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    let carry = 0;\n\n    if (r !== 0) {\n      for (let i = this.length - 1; i >= 0; i--) {\n        const word = this.words[i] | 0;\n        this.words[i] = carry << 26 - r | word >>> r;\n        carry = word & mask;\n      }\n    } // Push carried bits as a mask.\n\n\n    if (output) {\n      if (carry !== 0) {\n        output._alloc(output.length + 1);\n\n        output.words[output.length++] = carry;\n      } else {\n        if (output.length === 0) output.words[output.length++] = 0;\n\n        output._strip();\n      }\n    }\n\n    return this._strip();\n  }\n  /*\n   * Right Shift\n   */\n\n\n  ishr(num) {\n    enforce(BN.isBN(num), 'bits', 'bignum');\n    enforce(num.bitLength() <= 32, 'bits', 'uint32');\n    return this.ishrn(num.toNumber());\n  }\n\n  ishrn(bits) {\n    enforce(bits >>> 0 === bits, 'bits', 'uint32');\n\n    if (this.negative !== 0) {\n      // (-x) >> y == ~(x-1) >> y\n      //           == ~((x-1) >> y)\n      //           == -(((x-1) >> y) + 1)\n      this.iaddn(1);\n      this.iushrn(bits);\n      this.isubn(1);\n      return this;\n    }\n\n    return this.iushrn(bits);\n  }\n\n  shr(num) {\n    return this.clone().ishr(num);\n  }\n\n  shrn(bits) {\n    return this.clone().ishrn(bits);\n  }\n  /*\n   * Unsigned Right Shift\n   */\n\n\n  iushr(num) {\n    enforce(BN.isBN(num), 'bits', 'bignum');\n    enforce(num.bitLength() <= 32, 'bits', 'uint32');\n    return this.iushrn(num.toNumber());\n  }\n\n  iushrn(bits) {\n    enforce(bits >>> 0 === bits, 'bits', 'uint32');\n    return this._split(bits, null);\n  }\n\n  ushr(num) {\n    return this.clone().iushr(num);\n  }\n\n  ushrn(bits) {\n    return this.clone().iushrn(bits);\n  }\n  /*\n   * Bit Manipulation\n   */\n\n\n  setn(bit, val) {\n    enforce(bit >>> 0 === bit, 'bit', 'uint32');\n\n    if (this.negative !== 0) {\n      this.iaddn(1);\n      this.usetn(bit, !val);\n      this.isubn(1);\n      return this;\n    }\n\n    return this.usetn(bit, val);\n  }\n\n  usetn(bit, val) {\n    enforce(bit >>> 0 === bit, 'bit', 'uint32');\n    const r = bit % 26;\n    const s = (bit - r) / 26;\n\n    this._expand(s + 1);\n\n    if (val) this.words[s] |= 1 << r;else this.words[s] &= ~(1 << r);\n    return this._strip();\n  }\n\n  testn(bit) {\n    enforce(bit >>> 0 === bit, 'bit', 'uint32');\n    const r = bit % 26;\n    const s = (bit - r) / 26; // Fast case: bit is much higher than all existing words.\n\n    if (this.length <= s) return this.negative; // Check bit and return.\n\n    const w = this.words[s];\n    const val = w >> r & 1;\n\n    if (this.negative !== 0) {\n      if (r > 0 && w & (1 << r) - 1) return val ^ 1;\n      let j = s;\n\n      while (j--) {\n        if (this.words[j] > 0) return val ^ 1;\n      }\n    }\n\n    return val;\n  }\n\n  utestn(bit) {\n    enforce(bit >>> 0 === bit, 'bit', 'uint32');\n    const r = bit % 26;\n    const s = (bit - r) / 26; // Fast case: bit is much higher than all existing words.\n\n    if (this.length <= s) return 0; // Check bit and return.\n\n    return this.words[s] >> r & 1;\n  }\n\n  imaskn(bits) {\n    enforce(bits >>> 0 === bits, 'bits', 'uint32');\n\n    if (this.negative !== 0) {\n      this.iaddn(1);\n      this.inotn(bits + 1);\n      this.ineg();\n    }\n\n    return this.iumaskn(bits);\n  }\n\n  maskn(bits) {\n    return this.clone().imaskn(bits);\n  }\n\n  iumaskn(bits) {\n    enforce(bits >>> 0 === bits, 'bits', 'uint32');\n    const r = bits % 26;\n    let s = (bits - r) / 26;\n    if (this.length <= s) return this;\n    if (r !== 0) s += 1;\n    this.length = Math.min(s, this.length);\n    if (r !== 0) this.words[this.length - 1] &= (1 << r) - 1;\n    if (this.length === 0) this.words[this.length++] = 0;\n    return this._strip();\n  }\n\n  umaskn(bits) {\n    return this.clone().iumaskn(bits);\n  }\n\n  andln(num) {\n    return this.words[0] & num;\n  }\n\n  bit(pos) {\n    return this.utestn(pos);\n  }\n\n  bits(pos, width) {\n    enforce(pos >>> 0 === pos, 'pos', 'uint32');\n    enforce(width >>> 0 === width, 'width', 'uint32');\n    enforce(width <= 26, 'width', 'width');\n    const shift = pos % 26;\n    const index = (pos - shift) / 26;\n    if (index >= this.length) return 0;\n    let bits = this.words[index] >> shift & (1 << width) - 1;\n\n    if (shift + width > 26 && index + 1 < this.length) {\n      const more = shift + width - 26;\n      const next = this.words[index + 1] & (1 << more) - 1;\n      bits |= next << 26 - shift;\n    }\n\n    return bits;\n  }\n  /*\n   * Negation\n   */\n\n\n  ineg() {\n    if (!this.isZero()) this.negative ^= 1;\n    return this;\n  }\n\n  neg() {\n    return this.clone().ineg();\n  }\n\n  iabs() {\n    this.negative = 0;\n    return this;\n  }\n\n  abs() {\n    return this.clone().iabs();\n  }\n  /*\n   * Comparison\n   */\n\n\n  cmp(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    if (this.negative !== num.negative) return num.negative - this.negative;\n    const res = this.ucmp(num);\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  }\n\n  cmpn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    const negative = num < 0 | 0;\n    if (this.negative !== negative) return negative - this.negative;\n    const res = this.ucmpn(num);\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  }\n\n  eq(num) {\n    return this.cmp(num) === 0;\n  }\n\n  eqn(num) {\n    return this.cmpn(num) === 0;\n  }\n\n  gt(num) {\n    return this.cmp(num) > 0;\n  }\n\n  gtn(num) {\n    return this.cmpn(num) > 0;\n  }\n\n  gte(num) {\n    return this.cmp(num) >= 0;\n  }\n\n  gten(num) {\n    return this.cmpn(num) >= 0;\n  }\n\n  lt(num) {\n    return this.cmp(num) < 0;\n  }\n\n  ltn(num) {\n    return this.cmpn(num) < 0;\n  }\n\n  lte(num) {\n    return this.cmp(num) <= 0;\n  }\n\n  lten(num) {\n    return this.cmpn(num) <= 0;\n  }\n\n  sign() {\n    if (this.negative !== 0) return -1;\n    if (this.length === 1 && this.words[0] === 0) return 0;\n    return 1;\n  }\n\n  isZero() {\n    return this.length === 1 && this.words[0] === 0;\n  }\n\n  isNeg() {\n    return this.negative !== 0;\n  }\n\n  isPos() {\n    return this.negative === 0;\n  }\n\n  isOdd() {\n    return (this.words[0] & 1) === 1;\n  }\n\n  isEven() {\n    return (this.words[0] & 1) === 0;\n  }\n  /*\n   * Unsigned Comparison\n   */\n\n\n  ucmp(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    if (this.length < num.length) return -1;\n    if (this.length > num.length) return 1;\n\n    for (let i = this.length - 1; i >= 0; i--) {\n      const a = this.words[i] | 0;\n      const b = num.words[i] | 0;\n      if (a === b) continue;\n      return (a > b) - (a < b);\n    }\n\n    return 0;\n  }\n\n  ucmpn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    if (this.length > 1) return 1;\n    const w = this.words[0] | 0;\n    if (num < 0) num = -num;\n    return (w > num) - (w < num);\n  }\n  /*\n   * Number Theoretic Functions\n   */\n\n\n  legendre(num) {\n    const red = HAS_BIGINT ? BN.red(num) : BN.mont(num);\n    return this.toRed(red).redLegendre();\n  }\n\n  jacobi(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    if (num.isZero() || num.isEven()) throw new Error('jacobi: `num` must be odd.');\n\n    let a = this._cloneNormal();\n\n    let b = num.clone();\n    let j = 1;\n\n    if (b.isNeg()) {\n      if (a.isNeg()) j = -1;\n      b.ineg();\n    }\n\n    for (;;) {\n      if (b.cmpn(1) === 0) return j;\n      if (a.isZero()) return 0;\n      a.imod(b);\n      if (a.isZero()) return 0;\n      const s = a.zeroBits();\n\n      if (s & 1) {\n        const bmod8 = b.andln(7);\n        if (bmod8 === 3 || bmod8 === 5) j = -j;\n      }\n\n      const c = a.iushrn(s);\n      if (b.andln(3) === 3 && c.andln(3) === 3) j = -j;\n      a = b;\n      b = c;\n    }\n  }\n\n  kronecker(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    const table = [0, 1, 0, -1, 0, -1, 0, 1];\n\n    let a = this._cloneNormal();\n\n    let b = num.clone();\n    let s = 1;\n    if (b.isZero()) return a.ucmpn(1) === 0 ? s : 0;\n    if (!a.isOdd() && !b.isOdd()) return 0;\n    const z = b.zeroBits();\n    b.iushrn(z);\n    if (z & 1) s = table[a.andln(7)];\n\n    if (b.isNeg()) {\n      if (a.isNeg()) s = -s;\n      b.ineg();\n    }\n\n    for (;;) {\n      if (a.isZero()) return b.cmpn(1) === 0 ? s : 0;\n      const z = a.zeroBits();\n      a.iushrn(z);\n      if (z & 1) s *= table[b.andln(7)];\n      const w = a.words[0] ^ a.negative * 0x3ffffff;\n      if (w & b.words[0] & 2) s = -s;\n      b.imod(a);\n      [a, b] = [b, a];\n      b.negative = 0;\n    }\n  }\n\n  igcd(num) {\n    return this.gcd(num)._move(this);\n  }\n\n  gcd(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    if (this.isZero()) return num.abs();\n    if (num.isZero()) return this.abs();\n    let a = this.clone();\n    let b = num.clone();\n    a.negative = 0;\n    b.negative = 0; // Remove common factor of two.\n\n    const shift = a._factor2(b);\n\n    if (shift !== 0) {\n      a.iushrn(shift);\n      b.iushrn(shift);\n    }\n\n    for (;;) {\n      const az = a.zeroBits();\n      const bz = b.zeroBits();\n      if (az !== 0) a.iushrn(az);\n      if (bz !== 0) b.iushrn(bz);\n      const cmp = a.ucmp(b);\n\n      if (cmp < 0) {\n        // a > b\n        [a, b] = [b, a];\n      } else if (cmp === 0 || b.ucmpn(1) === 0) {\n        // Break if a == b.\n        // Break if b == 1 to avoid repeated subtraction.\n        break;\n      }\n\n      a._isub(a, b);\n    }\n\n    return b.iushln(shift);\n  }\n\n  ilcm(num) {\n    return this.lcm(num)._move(this);\n  }\n\n  lcm(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    if (this.isZero() || num.isZero()) return new BN(0);\n    return this.quo(this.gcd(num)).mul(num).iabs();\n  }\n\n  egcd(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n\n    if (this.isZero()) {\n      return [new BN(0), new BN(num.sign()), num.abs()];\n    }\n\n    if (num.isZero()) {\n      return [new BN(this.sign()), new BN(0), this.abs()];\n    }\n\n    const x = this.clone();\n    const y = num.clone();\n    x.negative = 0;\n    y.negative = 0; // A * x + B * y = x\n\n    const A = new BN(1);\n    const B = new BN(0); // C * x + D * y = y\n\n    const C = new BN(0);\n    const D = new BN(1); // Remove common factor of two.\n\n    const g = x._factor2(y);\n\n    if (g !== 0) {\n      x.iushrn(g);\n      y.iushrn(g);\n    }\n\n    const yp = y.clone();\n    const xp = x.clone();\n\n    while (!x.isZero()) {\n      let i = 0;\n\n      for (let im = 1; (x.words[0] & im) === 0 && i < 26; im <<= 1) i += 1;\n\n      if (i > 0) {\n        x.iushrn(i);\n\n        while (i > 0) {\n          if (A.isOdd() || B.isOdd()) {\n            A.iadd(yp);\n            B.isub(xp);\n          }\n\n          A.iushrn(1);\n          B.iushrn(1);\n          i -= 1;\n        }\n      }\n\n      let j = 0;\n\n      for (let jm = 1; (y.words[0] & jm) === 0 && j < 26; jm <<= 1) j += 1;\n\n      if (j > 0) {\n        y.iushrn(j);\n\n        while (j > 0) {\n          if (C.isOdd() || D.isOdd()) {\n            C.iadd(yp);\n            D.isub(xp);\n          }\n\n          C.iushrn(1);\n          D.iushrn(1);\n          j -= 1;\n        }\n      }\n\n      if (x.cmp(y) >= 0) {\n        x.isub(y);\n        A.isub(C);\n        B.isub(D);\n      } else {\n        y.isub(x);\n        C.isub(A);\n        D.isub(B);\n      }\n    }\n\n    if (this.negative !== 0) C.ineg();\n    if (num.negative !== 0) D.ineg();\n    return [C, D, y.iushln(g)];\n  }\n\n  iinvert(num) {\n    return this.invert(num)._move(this);\n  }\n\n  invert(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    range(num.sign() > 0, 'invert');\n    if (num.cmpn(1) === 0) throw new RangeError('Not invertible.');\n    const [s,, g] = this.egcd(num);\n    if (g.cmpn(1) !== 0) throw new RangeError('Not invertible.');\n    return s.imod(num);\n  }\n\n  ifermat(num) {\n    return this.fermat(num)._move(this);\n  }\n\n  fermat(num) {\n    const red = HAS_BIGINT ? BN.red(num) : BN.mont(num);\n    return this.toRed(red).redFermat().fromRed();\n  }\n\n  ipowm(y, m, mont) {\n    return this.powm(y, m, mont)._move(this);\n  }\n\n  powm(y, m, mont) {\n    const red = !HAS_BIGINT && mont ? BN.mont(m) : BN.red(m);\n    return this.toRed(red).redPow(y).fromRed();\n  }\n\n  ipowmn(y, m, mont) {\n    return this.powmn(y, m, mont)._move(this);\n  }\n\n  powmn(y, m, mont) {\n    const red = mont ? BN.mont(m) : BN.red(m);\n    return this.toRed(red).redPown(y).fromRed();\n  }\n\n  isqrtm(p) {\n    return this.sqrtm(p)._move(this);\n  }\n\n  sqrtm(p) {\n    enforce(BN.isBN(p), 'p', 'bignum');\n    let red;\n\n    if (p.andln(3) === 3 || p.andln(7) === 5) {\n      // Probably not worth the setup.\n      red = BN.red(p);\n    } else {\n      red = BN.mont(p);\n    }\n\n    return this.toRed(red).redSqrt().fromRed();\n  }\n\n  isqrtpq(p, q) {\n    return this.sqrtpq(p, q)._move(this);\n  }\n\n  sqrtpq(p, q) {\n    const sp = this.sqrtm(p);\n    const sq = this.sqrtm(q);\n    const [mp, mq] = p.egcd(q);\n    const lhs = sq.mul(mp).mul(p);\n    const rhs = sp.mul(mq).mul(q);\n    const n = p.mul(q);\n    return lhs.iadd(rhs).imod(n);\n  }\n  /*\n   * Primality Testing\n   */\n\n\n  isPrime(rng, reps, limit) {\n    enforce(reps >>> 0 === reps, 'reps', 'uint32');\n    if (!this.isPrimeMR(rng, reps + 1, true)) return false;\n    if (!this.isPrimeLucas(limit)) return false;\n    return true;\n  }\n\n  isPrimeMR(rng, reps, force2 = false) {\n    enforce(reps >>> 0 === reps, 'reps', 'uint32');\n    enforce(reps > 0, 'reps', 'integer');\n    enforce(typeof force2 === 'boolean', 'force2', 'boolean');\n    const n = this;\n\n    if (n.cmpn(7) < 0) {\n      return n.cmpn(2) === 0 || n.cmpn(3) === 0 || n.cmpn(5) === 0;\n    }\n\n    if (n.isEven()) return false;\n    const nm1 = n.subn(1);\n    const nm3 = nm1.subn(2);\n    const k = nm1.zeroBits();\n    const q = nm1.ushrn(k);\n    const red = BN.red(n);\n    const rnm1 = nm1.toRed(red);\n    const rone = new BN(1).toRed(red);\n\n    next: for (let i = 0; i < reps; i++) {\n      let x;\n\n      if (i === reps - 1 && force2) {\n        x = new BN(2);\n      } else {\n        x = BN.random(rng, 0, nm3);\n        x.iaddn(2);\n      }\n\n      let y = x.toRed(red).redPow(q);\n      if (y.cmp(rone) === 0 || y.cmp(rnm1) === 0) continue;\n\n      for (let j = 1; j < k; j++) {\n        y = y.redSqr();\n        if (y.cmp(rnm1) === 0) continue next;\n        if (y.cmp(rone) === 0) return false;\n      }\n\n      return false;\n    }\n\n    return true;\n  }\n\n  isPrimeLucas(limit = 0) {\n    enforce(limit >>> 0 === limit, 'limit', 'uint32');\n    const n = this; // Ignore 0 and 1.\n\n    if (n.cmpn(1) <= 0) return false; // Two is the only even prime.\n\n    if (n.isEven()) return n.cmpn(2) === 0;\n    let p = 3;\n\n    for (;;) {\n      if (p > 10000) {\n        // Thought to be impossible.\n        throw new Error(`Cannot find (D/n) = -1 for ${n.toString(10)}.`);\n      }\n\n      if (limit !== 0 && p > limit) {\n        // Optional DoS limit.\n        return false;\n      }\n\n      const d = new BN(p * p - 4);\n      const j = d.jacobi(n);\n      if (j === -1) break;\n      if (j === 0) return n.cmpn(p + 2) === 0;\n\n      if (p === 40) {\n        if (n.isSquare()) return false;\n      }\n\n      p += 1;\n    }\n\n    const s = n.addn(1);\n    const r = s.zeroBits();\n    const nm2 = n.subn(2);\n    let x = new BN(2);\n    let y = new BN(p);\n    s.iushrn(r);\n\n    for (let i = s.bitLength(); i >= 0; i--) {\n      if (s.utestn(i)) {\n        x = x.mul(y).iadd(n).isubn(p).imod(n);\n        y = y.sqr().iadd(nm2).imod(n);\n      } else {\n        y = y.mul(x).iadd(n).isubn(p).imod(n);\n        x = x.sqr().iadd(nm2).imod(n);\n      }\n    }\n\n    if (x.cmpn(2) === 0 || x.cmp(nm2) === 0) {\n      let a = x.muln(p);\n      let b = y.ushln(1);\n      if (a.cmp(b) < 0) [a, b] = [b, a];\n      if (a.isub(b).imod(n).isZero()) return true;\n    }\n\n    for (let t = 0; t < r - 1; t++) {\n      if (x.isZero()) return true;\n      if (x.cmpn(2) === 0) return false;\n      x = x.sqr().isubn(2).imod(n);\n    }\n\n    return false;\n  }\n  /*\n   * Twos Complement\n   */\n\n\n  toTwos(width) {\n    if (this.negative !== 0) return this.abs().inotn(width).iaddn(1);\n    return this.clone();\n  }\n\n  fromTwos(width) {\n    enforce(width >>> 0 === width, 'width', 'uint32');\n    range(width > 0, 'width');\n    if (this.testn(width - 1)) return this.notn(width).iaddn(1).ineg();\n    return this.clone();\n  }\n  /*\n   * Reduction Context\n   */\n\n\n  toRed(ctx) {\n    enforce(ctx instanceof Red, 'ctx', 'reduction context');\n    if (this.red) throw new Error('Already in reduction context.');\n    return ctx.convertTo(this);\n  }\n\n  fromRed() {\n    red(this.red, 'fromRed');\n    return this.red.convertFrom(this);\n  }\n\n  forceRed(ctx) {\n    enforce(ctx instanceof Red, 'ctx', 'reduction context');\n\n    if (this.red) {\n      if (!ctx.m.eq(this.red.m) || ctx.mont !== this.red.mont) throw new Error('Already in reduction context.');\n    } else {\n      range(this.negative === 0, 'red');\n      range(this.ucmp(ctx.m) < 0, 'red');\n    }\n\n    return this.clone()._forceRed(ctx);\n  }\n\n  redIAdd(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    red(this.red, 'redIAdd');\n    return this.red.iadd(this, num);\n  }\n\n  redAdd(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    red(this.red, 'redAdd');\n    return this.red.add(this, num);\n  }\n\n  redIAddn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    red(this.red, 'redIAddn');\n    return this.red.iaddn(this, num);\n  }\n\n  redAddn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    red(this.red, 'redAddn');\n    return this.red.addn(this, num);\n  }\n\n  redISub(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    red(this.red, 'redISub');\n    return this.red.isub(this, num);\n  }\n\n  redSub(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    red(this.red, 'redSub');\n    return this.red.sub(this, num);\n  }\n\n  redISubn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    red(this.red, 'redISubn');\n    return this.red.isubn(this, num);\n  }\n\n  redSubn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    red(this.red, 'redSubn');\n    return this.red.subn(this, num);\n  }\n\n  redIMul(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    red(this.red, 'redIMul');\n    return this.red.imul(this, num);\n  }\n\n  redMul(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    red(this.red, 'redMul');\n    return this.red.mul(this, num);\n  }\n\n  redIMuln(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    red(this.red, 'redIMuln');\n    return this.red.imuln(this, num);\n  }\n\n  redMuln(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    red(this.red, 'redMuln');\n    return this.red.muln(this, num);\n  }\n\n  redIDiv(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    red(this.red, 'redIDiv');\n    return this.red.idiv(this, num);\n  }\n\n  redDiv(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    red(this.red, 'redDiv');\n    return this.red.div(this, num);\n  }\n\n  redIDivn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    red(this.red, 'redIDivn');\n    return this.red.idivn(this, num);\n  }\n\n  redDivn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    red(this.red, 'redDivn');\n    return this.red.divn(this, num);\n  }\n\n  redIPow(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    red(this.red, 'redIPow');\n    nonred(!num.red, 'redIPow');\n    return this.red.ipow(this, num);\n  }\n\n  redPow(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    red(this.red, 'redPow');\n    nonred(!num.red, 'redPow');\n    return this.red.pow(this, num);\n  }\n\n  redIPown(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    red(this.red, 'redIPown');\n    return this.red.ipown(this, num);\n  }\n\n  redPown(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    red(this.red, 'redPown');\n    return this.red.pown(this, num);\n  }\n\n  redISqr() {\n    red(this.red, 'redISqr');\n    return this.red.isqr(this);\n  }\n\n  redSqr() {\n    red(this.red, 'redSqr');\n    return this.red.sqr(this);\n  }\n\n  redISqrt() {\n    red(this.red, 'redISqrt');\n    return this.red.isqrt(this);\n  }\n\n  redSqrt() {\n    red(this.red, 'redSqrt');\n    return this.red.sqrt(this);\n  }\n\n  redIDivSqrt(v) {\n    red(this.red, 'redIDivSqrt');\n    return this.red.idivsqrt(this, v);\n  }\n\n  redDivSqrt(v) {\n    red(this.red, 'redDivSqrt');\n    return this.red.divsqrt(this, v);\n  }\n\n  redIsSquare() {\n    red(this.red, 'redIsSquare');\n    return this.red.isSquare(this);\n  }\n\n  redIShl(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    red(this.red, 'redIShl');\n    nonred(!num.red, 'redIShl');\n    return this.red.ishl(this, num);\n  }\n\n  redShl(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    red(this.red, 'redShl');\n    nonred(!num.red, 'redShl');\n    return this.red.shl(this, num);\n  }\n\n  redIShln(num) {\n    enforce(num >>> 0 === num, 'num', 'uint32');\n    red(this.red, 'redIShln');\n    return this.red.ishln(this, num);\n  }\n\n  redShln(num) {\n    enforce(num >>> 0 === num, 'num', 'uint32');\n    red(this.red, 'redShln');\n    return this.red.shln(this, num);\n  }\n\n  redINeg() {\n    red(this.red, 'redINeg');\n    return this.red.ineg(this);\n  }\n\n  redNeg() {\n    red(this.red, 'redNeg');\n    return this.red.neg(this);\n  }\n\n  redEq(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    red(this.red, 'redEq');\n    return this.red.eq(this, num);\n  }\n\n  redEqn(num) {\n    enforce(isSMI(num), 'num', 'smi');\n    red(this.red, 'redEqn');\n    return this.red.eqn(this, num);\n  }\n\n  redIsHigh() {\n    red(this.red, 'redIsHigh');\n    return this.red.isHigh(this);\n  }\n\n  redIsLow() {\n    red(this.red, 'redIsLow');\n    return this.red.isLow(this);\n  }\n\n  redIsOdd() {\n    red(this.red, 'redIsOdd');\n    return this.red.isOdd(this);\n  }\n\n  redIsEven() {\n    red(this.red, 'redIsEven');\n    return this.red.isEven(this);\n  }\n\n  redLegendre() {\n    red(this.red, 'redLegendre');\n    return this.red.legendre(this);\n  }\n\n  redJacobi() {\n    red(this.red, 'redJacobi');\n    return this.red.jacobi(this);\n  }\n\n  redKronecker() {\n    red(this.red, 'redKronecker');\n    return this.red.kronecker(this);\n  }\n\n  redIInvert() {\n    red(this.red, 'redIInvert');\n    return this.red.iinvert(this);\n  }\n\n  redInvert() {\n    red(this.red, 'redInvert');\n    return this.red.invert(this);\n  }\n\n  redIFermat() {\n    red(this.red, 'redIFermat');\n    return this.red.ifermat(this);\n  }\n\n  redFermat() {\n    red(this.red, 'redFermat');\n    return this.red.fermat(this);\n  }\n  /*\n   * Internal\n   */\n\n\n  _move(dest) {\n    dest.words = this.words;\n    dest.length = this.length;\n    dest.negative = this.negative;\n    dest.red = this.red;\n    return dest;\n  }\n\n  _alloc(size) {\n    while (this.words.length < size) this.words.push(0);\n\n    return this;\n  }\n\n  _expand(size) {\n    this._alloc(size);\n\n    while (this.length < size) this.words[this.length++] = 0;\n\n    return this;\n  }\n\n  _strip() {\n    while (this.length > 1 && this.words[this.length - 1] === 0) this.length -= 1;\n\n    return this._normalize();\n  }\n\n  _normalize() {\n    assert(this.length > 0); // -0 = 0\n\n    if (this.length === 1 && this.words[0] === 0) this.negative = 0;\n    return this;\n  }\n\n  _check() {\n    // We never have a zero length number.\n    assert(this.length > 0); // Cannot exceed array bounds.\n\n    assert(this.length <= this.words.length);\n\n    if (this.length === 1) {\n      // Must be normalized.\n      if (this.words[0] === 0) assert(this.negative === 0);\n      return this;\n    } // Must be stripped.\n\n\n    assert(this.words[this.length - 1] !== 0);\n    return this;\n  }\n\n  _invertp(p) {\n    enforce(BN.isBN(p), 'p', 'bignum');\n    assert(this.negative === 0);\n    assert(p.sign() > 0);\n    if (this.isZero() || p.cmpn(1) === 0) throw new RangeError('Not invertible.');\n    const a = this.clone();\n    const b = p.clone();\n    const x1 = new BN(1);\n    const x2 = new BN(0);\n    const delta = b.clone();\n\n    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {\n      let i = 0;\n\n      for (let im = 1; (a.words[0] & im) === 0 && i < 26; im <<= 1) i += 1;\n\n      if (i > 0) {\n        a.iushrn(i);\n\n        while (i > 0) {\n          if (x1.isOdd()) x1.iadd(delta);\n          x1.iushrn(1);\n          i -= 1;\n        }\n      }\n\n      let j = 0;\n\n      for (let jm = 1; (b.words[0] & jm) === 0 && j < 26; jm <<= 1) j += 1;\n\n      if (j > 0) {\n        b.iushrn(j);\n\n        while (j > 0) {\n          if (x2.isOdd()) x2.iadd(delta);\n          x2.iushrn(1);\n          j -= 1;\n        }\n      }\n\n      if (a.cmp(b) >= 0) {\n        a.isub(b);\n        x1.isub(x2);\n      } else {\n        b.isub(a);\n        x2.isub(x1);\n      }\n    } // Quick reduction (typically +/- 2P).\n\n\n    const res = a.cmpn(1) === 0 ? x1 : x2;\n\n    if (res.ucmp(p) >= 0) {\n      res._isub(res, p);\n\n      if (res.ucmp(p) >= 0) res._isub(res, p);\n    }\n\n    if (res.isNeg()) res.iadd(p);\n    return res;\n  }\n\n  _factor2(num) {\n    // Find common factor of two.\n    // Expects inputs to be non-zero.\n    if ((this.words[0] | num.words[0]) & 1) return 0;\n    const len = Math.min(this.length, num.length);\n    let r = 0;\n\n    for (let i = 0; i < len; i++) {\n      const b = zeroBits(this.words[i] | num.words[i]);\n      r += b;\n      if (b !== 26) break;\n    }\n\n    return r;\n  }\n\n  _cloneNormal() {\n    return this.red ? this.fromRed() : this.clone();\n  }\n\n  _forceRed(ctx) {\n    this.red = ctx;\n    return this;\n  }\n  /*\n   * Helpers\n   */\n\n\n  clone() {\n    const copy = new BN();\n    copy.words = new Array(this.length);\n\n    for (let i = 0; i < this.length; i++) copy.words[i] = this.words[i];\n\n    copy.length = this.length;\n    copy.negative = this.negative;\n    copy.red = this.red;\n    return copy;\n  }\n\n  inject(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n\n    this._alloc(num.length);\n\n    for (let i = 0; i < num.length; i++) this.words[i] = num.words[i];\n\n    this.length = num.length;\n    this.negative = num.negative;\n    this.red = num.red;\n    return this;\n  }\n\n  set(num, endian) {\n    return this.fromNumber(num, endian);\n  }\n\n  swap(num) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    const x = this;\n    const y = num;\n    [x.words, y.words] = [y.words, x.words];\n    [x.length, y.length] = [y.length, x.length];\n    [x.negative, y.negative] = [y.negative, x.negative];\n    [x.red, y.red] = [y.red, x.red];\n    return x;\n  }\n\n  reverse() {\n    const neg = this.negative;\n    this.fromBuffer(this.toBuffer('be'), 'le');\n    this.negative = neg;\n    return this;\n  }\n\n  byteLength() {\n    return Math.ceil(this.bitLength() / 8);\n  }\n\n  bitLength() {\n    const w = this.words[this.length - 1];\n    const hi = countBits(w);\n    return (this.length - 1) * 26 + hi;\n  }\n\n  zeroBits() {\n    if (this.isZero()) return 0;\n    if (this.isOdd()) return 0;\n    let r = 0;\n\n    for (let i = 0; i < this.length; i++) {\n      const b = zeroBits(this.words[i]);\n      r += b;\n      if (b !== 26) break;\n    }\n\n    return r;\n  }\n\n  isSafe() {\n    if (this.length <= 2) return true;\n    if (this.length === 3 && this.words[2] === 0x01) return true;\n    return false;\n  }\n\n  word(pos) {\n    enforce(pos >>> 0 === pos, 'pos', 'uint32');\n    if (pos >= this.length) return 0;\n    return this.words[pos];\n  }\n\n  [custom]() {\n    let prefix = 'BN';\n    if (this.red) prefix = 'BN-R';\n    return `<${prefix}: ${this.toString(10)}>`;\n  }\n  /*\n   * Constant Time\n   */\n\n\n  csign() {\n    return this.negative * -2 + 1 - this.czero();\n  }\n\n  czero() {\n    const zword = this.words[0] - 1 >>> 31;\n    return this.length - 2 >>> 31 & zword;\n  }\n\n  cneg() {\n    return this.negative;\n  }\n\n  cpos() {\n    return this.negative ^ 1;\n  }\n\n  ceq(num) {\n    enforce(BN.isBN(num), 'num', 'bignum'); // Assumes `num` is the \"constant size\"\n    // parameter. Note that constant size\n    // doesn't necessarily mean secret.\n\n    let z = 0;\n\n    for (let i = 0; i < num.length; i++) z |= this.words[i % this.length] ^ num.words[i];\n\n    z |= this.length ^ num.length;\n    z |= this.negative ^ num.negative;\n    return z - 1 >>> 31;\n  }\n\n  ceqn(num) {\n    const neg = num >> 31 & 1;\n    const word = (num | 0) * (-neg | 1) & 0x3ffffff;\n    let z = 0;\n    z |= this.words[0] ^ word;\n    z |= this.length ^ 1;\n    z |= this.negative ^ neg;\n    return z - 1 >>> 31;\n  }\n\n  cswap(num, flag) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    const x = this;\n    const y = num;\n    const cond = (flag >> 31 | -flag >> 31) & 1;\n    const mask = -cond & 0x3ffffff;\n\n    x._alloc(y.words.length);\n\n    y._alloc(x.words.length);\n\n    for (let i = 0; i < x.words.length; i++) {\n      const word = (x.words[i] ^ y.words[i]) & mask;\n      x.words[i] ^= word;\n      y.words[i] ^= word;\n    }\n\n    const length = (x.length ^ y.length) & mask;\n    const negative = (x.negative ^ y.negative) & mask;\n    x.length ^= length;\n    y.length ^= length;\n    x.negative ^= negative;\n    y.negative ^= negative;\n    return this;\n  }\n\n  cinject(num, flag) {\n    enforce(BN.isBN(num), 'num', 'bignum');\n    const x = this;\n    const y = num;\n    const cond = (flag >> 31 | -flag >> 31) & 1;\n    const mask0 = cond - 1 & 0x3ffffff;\n    const mask1 = ~(cond - 1) & 0x3ffffff;\n\n    x._alloc(y.length);\n\n    for (let i = 0; i < y.length; i++) x.words[i] = x.words[i] & mask0 | y.words[i] & mask1;\n\n    x.length = x.length & mask0 | y.length & mask1;\n    x.negative = x.negative & mask0 | y.negative & mask1;\n    return this;\n  }\n\n  cset(num, flag) {\n    const cond = (flag >> 31 | -flag >> 31) & 1;\n    const mask0 = cond - 1 & 0x3ffffff;\n    const mask1 = ~(cond - 1) & 0x3ffffff;\n    const neg = num >> 31 & 1;\n    const word = (num | 0) * (-neg | 1) & 0x3ffffff;\n    this.words[0] = this.words[0] & mask0 | word & mask1;\n    this.length = this.length & mask0 | 1 & mask1;\n    this.negative = this.negative & mask0 | neg & mask1;\n    return this;\n  }\n  /*\n   * Conversion\n   */\n\n\n  toNumber() {\n    let num = this.words[0];\n\n    if (this.length === 2) {\n      num += this.words[1] * 0x4000000;\n    } else if (this.length === 3 && this.words[2] === 0x01) {\n      // Note: at this stage it is known that the top bit is set.\n      num += 0x10000000000000 + this.words[1] * 0x4000000;\n    } else if (this.length > 2) {\n      throw new RangeError('Number can only safely store up to 53 bits.');\n    }\n\n    return this.negative !== 0 ? -num : num;\n  }\n\n  toDouble() {\n    let num = 0;\n\n    for (let i = this.length - 1; i >= 0; i--) num = num * 0x4000000 + this.words[i];\n\n    return this.negative !== 0 ? -num : num;\n  }\n\n  valueOf() {\n    return this.toDouble();\n  }\n\n  toBigInt() {\n    if (!HAS_BIGINT) throw new Error('BigInt is not supported!');\n    const s52 = BigInt(52);\n    const s26 = BigInt(26);\n    let i = this.length - 1;\n    let num = BigInt(0);\n\n    for (; i >= 1; i -= 2) {\n      const hi = this.words[i] * 0x4000000;\n      const lo = this.words[i - 1];\n      num = num << s52 | BigInt(hi + lo);\n    }\n\n    if (i >= 0) num = num << s26 | BigInt(this.words[0]);\n    return this.negative !== 0 ? -num : num;\n  }\n\n  toBool() {\n    return !this.isZero();\n  }\n\n  toString(base, padding) {\n    base = getBase(base);\n    if (padding == null) padding = 0;\n    if (padding === 0) padding = 1;\n    enforce(base >>> 0 === base, 'base', 'uint32');\n    enforce(padding >>> 0 === padding, 'padding', 'uint32');\n    if (base < 2 || base > 36) throw new RangeError('Base ranges between 2 and 36.');\n\n    this._check();\n\n    if (base === 16) {\n      let out = '';\n      let off = 0;\n      let carry = 0;\n\n      for (let i = 0; i < this.length; i++) {\n        const w = this.words[i];\n        const word = ((w << off | carry) & 0xffffff).toString(16);\n        carry = w >>> 24 - off & 0xffffff;\n        if (carry !== 0 || i !== this.length - 1) out = zeros[6 - word.length] + word + out;else out = word + out;\n        off += 2;\n\n        if (off >= 26) {\n          off -= 26;\n          i -= 1;\n        }\n      }\n\n      if (carry !== 0) out = carry.toString(16) + out;\n\n      while (out.length % padding !== 0) out = '0' + out;\n\n      if (this.negative !== 0) out = '-' + out;\n      return out;\n    }\n\n    const groupSize = groupSizes[base - 1];\n    const groupBase = groupBases[base - 1];\n    const c = this.clone();\n    let out = '';\n    c.negative = 0;\n\n    while (!c.isZero()) {\n      const r = c.remrn(groupBase).toString(base);\n      c.iquon(groupBase);\n      if (!c.isZero()) out = zeros[groupSize - r.length] + r + out;else out = r + out;\n    }\n\n    if (this.isZero()) out = '0';\n\n    while (out.length % padding !== 0) out = '0' + out;\n\n    if (this.negative !== 0) out = '-' + out;\n    return out;\n  }\n\n  toJSON() {\n    return this.toString(16, 2);\n  }\n\n  toArray(endian, length) {\n    return this.toArrayLike(Array, endian, length);\n  }\n\n  toBuffer(endian, length) {\n    return this.toArrayLike(Buffer, endian, length);\n  }\n\n  toArrayLike(ArrayType, endian, length) {\n    if (endian == null) endian = 'be';\n    if (length == null) length = 0;\n    enforce(typeof ArrayType === 'function', 'ArrayType', 'function');\n    enforce(endian === 'be' || endian === 'le', 'endian', 'endianness');\n    enforce(length >>> 0 === length, 'length', 'uint32');\n\n    this._check();\n\n    const bytes = this.byteLength();\n    const size = length || Math.max(1, bytes);\n    if (bytes > size) throw new RangeError('Byte array longer than desired length.');\n    const res = allocate(ArrayType, size); // See: https://github.com/indutny/bn.js/pull/222\n\n    if (endian === 'be') {\n      let pos = res.length - 1;\n      let carry = 0;\n\n      for (let i = 0; i < this.length; i++) {\n        const shift = (i & 3) << 1;\n        const word = this.words[i] << shift | carry;\n        res[pos--] = word & 0xff;\n        if (pos >= 0) res[pos--] = word >>> 8 & 0xff;\n        if (pos >= 0) res[pos--] = word >>> 16 & 0xff;\n\n        if (shift === 6) {\n          if (pos >= 0) res[pos--] = word >>> 24 & 0xff;\n          carry = 0;\n        } else {\n          carry = word >>> 24;\n        }\n      }\n\n      if (pos >= 0) {\n        res[pos--] = carry;\n\n        while (pos >= 0) res[pos--] = 0;\n\n        carry = 0;\n      }\n\n      assert(carry === 0);\n    } else {\n      let pos = 0;\n      let carry = 0;\n\n      for (let i = 0; i < this.length; i++) {\n        const shift = (i & 3) << 1;\n        const word = this.words[i] << shift | carry;\n        res[pos++] = word & 0xff;\n        if (pos < res.length) res[pos++] = word >>> 8 & 0xff;\n        if (pos < res.length) res[pos++] = word >>> 16 & 0xff;\n\n        if (shift === 6) {\n          if (pos < res.length) res[pos++] = word >>> 24 & 0xff;\n          carry = 0;\n        } else {\n          carry = word >>> 24;\n        }\n      }\n\n      if (pos < res.length) {\n        res[pos++] = carry;\n\n        while (pos < res.length) res[pos++] = 0;\n\n        carry = 0;\n      }\n\n      assert(carry === 0);\n    }\n\n    return res;\n  }\n\n  encode(endian, length) {\n    return this.toBuffer(endian, length);\n  }\n  /*\n   * Instantiation\n   */\n\n\n  of(num, endian) {\n    return this.fromNumber(num, endian);\n  }\n\n  fromNumber(num, endian) {\n    if (endian == null) endian = 'be';\n    enforce(isInteger(num), 'num', 'integer');\n    enforce(endian === 'be' || endian === 'le', 'endian', 'endianness');\n    const neg = num < 0 | 0;\n    if (neg) num = -num;\n\n    if (num < 0x4000000) {\n      this.words[0] = num & 0x3ffffff;\n      this.length = 1;\n    } else if (num < 0x10000000000000) {\n      this.words = [num & 0x3ffffff, num / 0x4000000 & 0x3ffffff];\n      this.length = 2;\n    } else {\n      this.words = [num & 0x3ffffff, num / 0x4000000 & 0x3ffffff, 1];\n      this.length = 3;\n    }\n\n    this.negative = neg;\n    if (endian === 'le') this.reverse();\n    return this;\n  }\n\n  fromDouble(num, endian) {\n    if (endian == null) endian = 'be';\n    enforce(typeof num === 'number', 'num', 'double');\n    enforce(endian === 'be' || endian === 'le', 'endian', 'endianness');\n    if (!isFinite(num)) num = 0;\n    const neg = num <= -1 | 0;\n    if (num < 0) num = -num;\n    num = Math.floor(num);\n    this.words = [];\n\n    while (num > 0) {\n      const lo = num % 0x4000000;\n      const hi = (num - lo) / 0x4000000;\n      this.words.push(lo);\n      num = hi;\n    }\n\n    if (this.words.length === 0) this.words.push(0);\n    this.length = this.words.length;\n    this.negative = neg;\n    if (endian === 'le') this.reverse();\n    return this;\n  }\n\n  fromBigInt(num, endian) {\n    if (endian == null) endian = 'be';\n    enforce(typeof num === 'bigint', 'num', 'bigint');\n    enforce(endian === 'be' || endian === 'le', 'endian', 'endianness');\n    if (!HAS_BIGINT) throw new Error('BigInt is not supported!'); // You know the implementation has a\n    // problem when strings are twice\n    // as fast as bigints.\n\n    const start = num < BigInt(0) | 0;\n\n    this._fromHex(num.toString(16), start);\n\n    this.negative = start;\n    if (endian === 'le') this.reverse();\n    return this;\n  }\n\n  fromBool(value) {\n    enforce(typeof value === 'boolean', 'value', 'boolean');\n    this.words[0] = value | 0;\n    this.length = 1;\n    this.negative = 0;\n    return this;\n  }\n\n  fromString(str, base, endian) {\n    if (base === 'le' || base === 'be') [base, endian] = [endian, base];\n    base = getBase(base);\n    if (endian == null) endian = 'be';\n    enforce(typeof str === 'string', 'string', 'string');\n    enforce(base >>> 0 === base, 'base', 'uint32');\n    enforce(endian === 'be' || endian === 'le', 'endian', 'endianness');\n    if (base < 2 || base > 36) throw new Error('Base ranges between 2 and 36.');\n    str = str.replace(/\\s+/g, '');\n    let start = 0;\n    if (str.length > 0 && str.charCodeAt(0) === 0x2d) start = 1;\n    if (base === 16) this._fromHex(str, start);else this._fromBase(str, base, start);\n    this.negative = start;\n\n    this._normalize();\n\n    if (endian === 'le') this.reverse();\n    return this;\n  }\n\n  _fromHex(str, start) {\n    this.length = Math.max(2, Math.ceil((str.length - start) / 6));\n    this.words = new Array(this.length);\n\n    for (let i = 0; i < this.length; i++) this.words[i] = 0; // Scan 24-bit chunks and add them to the number.\n\n\n    let off = 0;\n    let i = str.length - 6;\n    let j = 0;\n\n    for (; i >= start; i -= 6) {\n      const w = parseHex(str, i, i + 6);\n      this.words[j] |= w << off & 0x3ffffff; // `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb.\n\n      this.words[j + 1] |= w >>> 26 - off & 0x3fffff;\n      off += 24;\n\n      if (off >= 26) {\n        off -= 26;\n        j += 1;\n      }\n    }\n\n    if (i + 6 !== start) {\n      const w = parseHex(str, start, i + 6);\n      this.words[j] |= w << off & 0x3ffffff;\n      this.words[j + 1] |= w >>> 26 - off & 0x3fffff;\n    }\n\n    return this._strip();\n  }\n\n  _fromBase(str, base, start) {\n    // Initialize as zero.\n    this.words[0] = 0;\n    this.length = 1;\n    this.negative = 0; // Find length of limb in base.\n\n    let limbLen = 0;\n    let limbPow = 1;\n\n    for (; limbPow <= 0x3ffffff; limbPow *= base) limbLen += 1;\n\n    limbLen -= 1;\n    limbPow = limbPow / base | 0;\n    const total = str.length - start;\n    const mod = total % limbLen;\n    const end = Math.min(total, total - mod) + start;\n    let i = start;\n\n    for (; i < end; i += limbLen) {\n      const word = parseBase(str, i, i + limbLen, base);\n      this.imuln(limbPow);\n\n      this._iaddn(word);\n    }\n\n    if (mod !== 0) {\n      const pow = Math.pow(base, mod);\n      const word = parseBase(str, i, str.length, base);\n      this.imuln(pow);\n\n      this._iaddn(word);\n    }\n\n    return this;\n  }\n\n  fromJSON(json) {\n    if (BN.isBN(json)) {\n      if (json.red) return json.fromRed();\n      return json.clone();\n    }\n\n    if (Array.isArray(json)) {\n      for (const chunk of json) enforce(typeof chunk === 'string', 'chunk', 'string');\n\n      json = json.join('');\n    }\n\n    return this.fromString(json, 16);\n  }\n\n  fromBN(num) {\n    return this.inject(num);\n  }\n\n  fromArray(data, endian) {\n    enforce(Array.isArray(data), 'data', 'array');\n    return this.fromArrayLike(data, endian);\n  }\n\n  fromBuffer(data, endian) {\n    enforce(Buffer.isBuffer(data), 'data', 'buffer');\n    return this.fromArrayLike(data, endian);\n  }\n\n  fromArrayLike(data, endian) {\n    if (endian == null) endian = 'be';\n    enforce(data && data.length >>> 0 === data.length, 'data', 'array-like');\n    enforce(endian === 'be' || endian === 'le', 'endian', 'endianness');\n\n    if (data.length === 0) {\n      this.words[0] = 0;\n      this.length = 1;\n      this.negative = 0;\n      return this;\n    }\n\n    this.length = Math.max(2, Math.ceil(data.length / 3));\n    this.words = new Array(this.length);\n    this.negative = 0;\n\n    for (let i = 0; i < this.length; i++) this.words[i] = 0;\n\n    const left = data.length % 3;\n    let off = 0;\n    let j = 0;\n    let w = 0;\n\n    if (endian === 'be') {\n      for (let i = data.length - 1; i >= 2; i -= 3) {\n        const w = data[i] | data[i - 1] << 8 | data[i - 2] << 16;\n        this.words[j] |= w << off & 0x3ffffff;\n        this.words[j + 1] = w >>> 26 - off & 0x3ffffff;\n        off += 24;\n\n        if (off >= 26) {\n          off -= 26;\n          j += 1;\n        }\n      }\n\n      switch (left) {\n        case 2:\n          w = data[1] | data[0] << 8;\n          break;\n\n        case 1:\n          w = data[0];\n          break;\n      }\n    } else {\n      const len = data.length - left;\n\n      for (let i = 0; i < len; i += 3) {\n        const w = data[i] | data[i + 1] << 8 | data[i + 2] << 16;\n        this.words[j] |= w << off & 0x3ffffff;\n        this.words[j + 1] = w >>> 26 - off & 0x3ffffff;\n        off += 24;\n\n        if (off >= 26) {\n          off -= 26;\n          j += 1;\n        }\n      }\n\n      switch (left) {\n        case 2:\n          w = data[len] | data[len + 1] << 8;\n          break;\n\n        case 1:\n          w = data[len];\n          break;\n      }\n    }\n\n    if (left > 0) {\n      this.words[j] |= w << off & 0x3ffffff;\n      this.words[j + 1] = w >>> 26 - off & 0x3ffffff;\n    }\n\n    return this._strip();\n  }\n\n  decode(data, endian) {\n    return this.fromBuffer(data, endian);\n  }\n\n  from(num, base, endian) {\n    if (num == null) return this;\n    if (base === 'le' || base === 'be') [base, endian] = [endian, base];\n    if (typeof num === 'number') return this.fromNumber(num, endian);\n    if (typeof num === 'bigint') return this.fromBigInt(num, endian);\n    if (typeof num === 'string') return this.fromString(num, base, endian);\n\n    if (typeof num === 'object') {\n      if (BN.isBN(num)) return this.fromBN(num, endian);\n      if (num.length >>> 0 === num.length) return this.fromArrayLike(num, endian);\n    }\n\n    if (typeof num === 'boolean') return this.fromBool(num);\n    throw new TypeError('Non-numeric object passed to BN.');\n  }\n  /*\n   * Static Methods\n   */\n\n\n  static min(...args) {\n    let min = null;\n\n    for (const num of args) {\n      enforce(BN.isBN(num), 'num', 'bignum');\n      if (!min || num.cmp(min) < 0) min = num;\n    }\n\n    return min || new BN(0);\n  }\n\n  static max(...args) {\n    let max = null;\n\n    for (const num of args) {\n      enforce(BN.isBN(num), 'num', 'bignum');\n      if (!max || num.cmp(max) > 0) max = num;\n    }\n\n    return max || new BN(0);\n  }\n\n  static cmp(a, b) {\n    enforce(BN.isBN(a), 'a', 'bignum');\n    return a.cmp(b);\n  }\n\n  static ucmp(a, b) {\n    enforce(BN.isBN(a), 'a', 'bignum');\n    return a.ucmp(b);\n  }\n\n  static red(num) {\n    return new Red(num);\n  }\n\n  static barrett(num) {\n    return new Barrett(num);\n  }\n\n  static mont(num) {\n    return new Mont(num);\n  }\n\n  static _prime(name) {\n    if (primes[name]) return primes[name];\n    let prime;\n    if (name === 'p192') prime = new P192();else if (name === 'p224') prime = new P224();else if (name === 'p521') prime = new P521();else if (name === 'k256') prime = new K256();else if (name === 'p25519') prime = new P25519();else if (name === 'p448') prime = new P448();else throw new Error(`Unknown prime: \"${name}\".`);\n    primes[name] = prime;\n    return prime;\n  }\n\n  static prime(name) {\n    return BN._prime(name).p.clone();\n  }\n\n  static pow(num, exp) {\n    if (num === 2) return BN.shift(1, exp);\n    return new BN().fromNumber(num).pown(exp);\n  }\n\n  static shift(num, bits) {\n    if (num === 1) return new BN(0).usetn(bits, 1);\n    return new BN().fromNumber(num).ishln(bits);\n  }\n\n  static mask(bits) {\n    return BN.shift(1, bits).isubn(1);\n  }\n\n  static randomBits(rng, bits) {\n    enforce(rng != null, 'rng', 'rng');\n    enforce(bits >>> 0 === bits, 'bits', 'uint32');\n\n    if (typeof rng === 'object') {\n      enforce(typeof rng.randomBytes === 'function', 'rng', 'rng');\n      const size = bits + 7 >>> 3;\n      const total = size * 8;\n      const bytes = rng.randomBytes(size);\n      enforce(Buffer.isBuffer(bytes), 'bytes', 'buffer');\n      if (bytes.length !== size) throw new RangeError('Invalid number of bytes returned from RNG.');\n      const num = BN.fromBuffer(bytes);\n      if (total > bits) num.iushrn(total - bits);\n      return num;\n    }\n\n    enforce(typeof rng === 'function', 'rng', 'rng');\n    const num = rng(bits);\n    enforce(BN.isBN(num), 'num', 'bignum');\n    range(num.negative === 0, 'RNG');\n    nonred(!num.red, 'RNG');\n    if (num.bitLength() > bits) throw new RangeError('Invalid number of bits returned from RNG.');\n    return num;\n  }\n\n  static random(rng, min, max) {\n    min = BN.cast(min, 16);\n    max = BN.cast(max, 16);\n    if (min.cmp(max) > 0) throw new RangeError('Minimum cannot be greater than maximum.');\n    const space = max.sub(min).iabs();\n    const bits = space.bitLength();\n    if (bits === 0) return min.clone();\n\n    for (;;) {\n      const num = BN.randomBits(rng, bits); // Maximum is _exclusive_!\n\n      if (num.cmp(space) >= 0) continue; // Minimum is _inclusive_!\n\n      num.iadd(min);\n      return num;\n    }\n  }\n\n  static of(num, endian) {\n    return new BN().of(num, endian);\n  }\n\n  static fromNumber(num, endian) {\n    return new BN().fromNumber(num, endian);\n  }\n\n  static fromDouble(num, endian) {\n    return new BN().fromDouble(num, endian);\n  }\n\n  static fromBigInt(num, endian) {\n    return new BN().fromBigInt(num, endian);\n  }\n\n  static fromBool(value) {\n    return new BN().fromBool(value);\n  }\n\n  static fromString(str, base, endian) {\n    return new BN().fromString(str, base, endian);\n  }\n\n  static fromJSON(json) {\n    return new BN().fromJSON(json);\n  }\n\n  static fromBN(num) {\n    return new BN().fromBN(num);\n  }\n\n  static fromArray(data, endian) {\n    return new BN().fromArray(data, endian);\n  }\n\n  static fromBuffer(data, endian) {\n    return new BN().fromBuffer(data, endian);\n  }\n\n  static fromArrayLike(data, endian) {\n    return new BN().fromArrayLike(data, endian);\n  }\n\n  static decode(data, endian) {\n    return new BN().decode(data, endian);\n  }\n\n  static from(num, base, endian) {\n    return new BN().from(num, base, endian);\n  }\n\n  static cast(num, base, endian) {\n    if (BN.isBN(num)) return num;\n    return new BN(num, base, endian);\n  }\n\n  static isBN(obj) {\n    return obj instanceof BN;\n  }\n\n}\n/*\n * Static\n */\n\n\nBN.BN = BN;\nBN.wordSize = 26;\nBN.native = 0;\n/**\n * Prime\n */\n\nclass Prime {\n  constructor(name, p) {\n    // P = 2^N - K\n    this.name = name;\n    this.p = new BN(p, 16);\n    this.n = this.p.bitLength();\n    this.k = BN.shift(1, this.n).isub(this.p);\n    this.lo = this.p.clone();\n    this.one = this.p.clone();\n  }\n\n  ireduce(num) {\n    // Assumes that `num` is less than `P^2`:\n    // num = HI * (2^N - K) + HI * K + LO = HI * K + LO (mod P)\n    const neg = num.negative !== 0; // Track bits.\n\n    let bits = num.bitLength(); // Must be less than P^2.\n\n    assert(bits <= this.n * 2); // Ensure positive.\n\n    num.negative = 0; // Reduce.\n\n    while (bits > this.n) {\n      // lo = num & ((1 << n) - 1)\n      // num = num >> n\n      this.split(num, this.lo); // num = num * K\n\n      this.imulK(num); // num = num + lo\n\n      num._iadd(num, this.lo); // bits = bitlen(num)\n\n\n      bits = num.bitLength();\n    } // Final reduction.\n\n\n    const cmp = bits < this.n ? -1 : num.ucmp(this.p);\n\n    if (cmp === 0) {\n      num.words[0] = 0;\n      num.length = 1;\n    } else if (cmp > 0) {\n      num._isub(num, this.p);\n    } else {// Note: we shouldn't need to strip here.\n    } // Adjust sign.\n\n\n    if (neg && !num.isZero()) num._isub(this.p, num);\n    return num;\n  }\n\n  split(input, out) {\n    input._split(this.n, out);\n  }\n\n  imulK(num) {\n    return num.imul(this.k);\n  }\n\n}\n/**\n * P192\n */\n\n\nclass P192 extends Prime {\n  constructor() {\n    // 2^192 - 2^64 - 1 (= 3 mod 4)\n    super('p192', 'ffffffff ffffffff ffffffff fffffffe' + 'ffffffff ffffffff');\n  }\n\n  imulK(num) {\n    // K = 0x10000000000000001\n    // K = 2^64 + 1\n    const one = this.one.inject(num);\n    return num.iushln(64)._iadd(num, one);\n  }\n\n}\n/**\n * P224\n */\n\n\nclass P224 extends Prime {\n  constructor() {\n    // 2^224 - 2^96 + 1 (no congruence)\n    super('p224', 'ffffffff ffffffff ffffffff ffffffff' + '00000000 00000000 00000001');\n  }\n\n  imulK(num) {\n    // K = 0xffffffffffffffffffffffff\n    // K = 2^96 - 1\n    const one = this.one.inject(num);\n    return num.iushln(96)._isub(num, one);\n  }\n\n}\n/**\n * P521\n */\n\n\nclass P521 extends Prime {\n  constructor() {\n    // 2^521 - 1 (= 3 mod 4)\n    super('p521', '000001ff ffffffff ffffffff ffffffff' + 'ffffffff ffffffff ffffffff ffffffff' + 'ffffffff ffffffff ffffffff ffffffff' + 'ffffffff ffffffff ffffffff ffffffff' + 'ffffffff');\n  }\n\n  imulK(num) {\n    // K = 0x01\n    return num;\n  }\n\n}\n/**\n * K256\n */\n\n\nclass K256 extends Prime {\n  constructor() {\n    // 2^256 - 2^32 - 977 (= 3 mod 4)\n    super('k256', 'ffffffff ffffffff ffffffff ffffffff' + 'ffffffff ffffffff fffffffe fffffc2f');\n  }\n\n  split(input, output) {\n    // 256 = 9 * 26 + 22\n    const mask = 0x3fffff;\n    const len = Math.min(input.length, 9);\n\n    output._alloc(len + 1);\n\n    for (let i = 0; i < len; i++) output.words[i] = input.words[i];\n\n    output.length = len;\n\n    if (input.length <= 9) {\n      output._strip();\n\n      input.words[0] = 0;\n      input.length = 1;\n      return;\n    } // Shift by 9 limbs.\n\n\n    let prev = input.words[9];\n    let i = 10;\n    output.words[output.length++] = prev & mask;\n\n    output._strip();\n\n    for (; i < input.length; i++) {\n      const next = input.words[i] | 0;\n      input.words[i - 10] = (next & mask) << 4 | prev >>> 22;\n      prev = next;\n    }\n\n    prev >>>= 22;\n    input.words[i - 10] = prev;\n    if (prev === 0 && input.length > 10) input.length -= 10;else input.length -= 9;\n\n    input._strip(); // Unsure if we need this.\n\n  }\n\n  imulK(num) {\n    // K = 0x1000003d1 = [0x40, 0x3d1]\n    // K = 2^32 + 977\n    num._expand(num.length + 2); // Bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390\n\n\n    let lo = 0;\n\n    for (let i = 0; i < num.length; i++) {\n      const w = num.words[i];\n      lo += w * 0x3d1;\n      num.words[i] = lo & 0x3ffffff;\n      lo = w * 0x40 + Math.floor(lo / 0x4000000);\n    } // Fast length reduction.\n\n\n    if (num.words[num.length - 1] === 0) {\n      num.length -= 1;\n      if (num.words[num.length - 1] === 0) num.length -= 1;\n    } // Note: we shouldn't need to strip here.\n\n\n    return num;\n  }\n\n}\n/**\n * P25519\n */\n\n\nclass P25519 extends Prime {\n  constructor() {\n    // 2^255 - 19 (= 5 mod 8)\n    super('p25519', '7fffffff ffffffff ffffffff ffffffff' + 'ffffffff ffffffff ffffffff ffffffed');\n  }\n\n  imulK(num) {\n    // K = 0x13\n    let carry = 0;\n\n    for (let i = 0; i < num.length; i++) {\n      const w = num.words[i] * 0x13 + carry;\n      carry = w >>> 26;\n      num.words[i] = w & 0x3ffffff;\n    }\n\n    if (carry !== 0) {\n      num._alloc(num.length + 1);\n\n      num.words[num.length++] = carry;\n    } // Note: we shouldn't need to strip here.\n\n\n    return num;\n  }\n\n}\n/**\n * P448\n */\n\n\nclass P448 extends Prime {\n  constructor() {\n    // 2^448 - 2^224 - 1 (= 3 mod 4)\n    super('p448', 'ffffffff ffffffff ffffffff ffffffff' + 'ffffffff ffffffff fffffffe ffffffff' + 'ffffffff ffffffff ffffffff ffffffff' + 'ffffffff ffffffff');\n  }\n\n  imulK(num) {\n    // K = 0x100000000000000000000000000000000000000000000000000000001\n    // K = 2^224 + 1\n    const one = this.one.inject(num);\n    return num.iushln(224)._iadd(num, one);\n  }\n\n}\n/**\n * Reduction Engine\n */\n\n\nclass Red {\n  constructor(m) {\n    let prime = null;\n\n    if (typeof m === 'string') {\n      prime = BN._prime(m);\n      m = prime.p;\n    }\n\n    enforce(BN.isBN(m), 'm', 'bignum');\n    nonred(!m.red, 'reduction');\n    range(m.sign() > 0, 'reduction');\n    this.m = m;\n    this.prime = prime;\n    this.mb = null;\n    this.sm1 = null;\n  }\n\n  _verify1(a) {\n    range(a.negative === 0, 'red');\n    red(a.red != null, 'red');\n  }\n\n  _verify2(a, b) {\n    range((a.negative | b.negative) === 0, 'red');\n    red(a.red != null && a.red === b.red, 'red');\n  }\n\n  get mont() {\n    return false;\n  }\n\n  get coprime() {\n    return false;\n  }\n\n  precompute() {\n    // Precompute `sqrt(-1)` for primes congruent to 5 mod 8.\n    if (this.sm1 === null && this.m.andln(7) === 5) {\n      const x = new BN(2).toRed(this);\n      const e = this.m.subn(1).iushrn(2); // sqrt(-1) = 2^((p - 1) / 4) mod p\n\n      this.sm1 = this.pow(x, e);\n    }\n\n    return this;\n  }\n\n  convertTo(num) {\n    const res = num.mod(this.m);\n    res.red = this;\n    return res;\n  }\n\n  convertFrom(num) {\n    const res = num.clone();\n    res.red = null;\n    return res;\n  }\n\n  intTo(a) {\n    return a;\n  }\n\n  intFrom(a) {\n    return a;\n  }\n\n  imod(a) {\n    if (this.prime) return this.prime.ireduce(a)._forceRed(this);\n    return a.imod(this.m)._forceRed(this);\n  }\n\n  iadd(a, b) {\n    this._verify2(a, b);\n\n    a._iadd(a, b);\n\n    if (a.ucmp(this.m) >= 0) a._isub(a, this.m);\n    return a;\n  }\n\n  add(a, b) {\n    if (a.length < b.length) return this.iadd(b.clone(), a);\n    return this.iadd(a.clone(), b);\n  }\n\n  iaddn(a, num) {\n    this._verify1(a);\n\n    if (num < 0) return this.isubn(a, -num);\n    if (this.m.length === 1) num %= this.m.words[0];\n\n    a._iaddn(num);\n\n    if (a.ucmp(this.m) >= 0) a._isub(a, this.m);\n    return a;\n  }\n\n  addn(a, num) {\n    return this.iaddn(a.clone(), num);\n  }\n\n  isub(a, b) {\n    this._verify2(a, b); //  0: a - a mod m == 0\n    // -1: a - b mod m == m - (b - a)\n    // +1: a - b mod m == a - b\n\n\n    const cmp = a.ucmp(b);\n\n    if (cmp === 0) {\n      a.words[0] = 0;\n      a.length = 1;\n      return a;\n    }\n\n    if (cmp < 0) {\n      a._isub(b, a);\n\n      a._isub(this.m, a);\n    } else {\n      a._isub(a, b);\n    }\n\n    return a;\n  }\n\n  sub(a, b) {\n    return this.isub(a.clone(), b);\n  }\n\n  isubn(a, num) {\n    this._verify1(a);\n\n    if (num < 0) return this.iaddn(a, -num);\n    if (this.m.length === 1) num %= this.m.words[0]; //  <: a - b mod m == m - (b - a)\n    // >=: a - b mod m == a - b\n\n    if (a.length === 1 && a.words[0] < num) {\n      a.words[0] = num - a.words[0];\n\n      a._isub(this.m, a);\n    } else {\n      a._isubn(num);\n    }\n\n    return a;\n  }\n\n  subn(a, num) {\n    return this.isubn(a.clone(), num);\n  }\n\n  imul(a, b) {\n    this._verify2(a, b);\n\n    return this.imod(a.imul(b));\n  }\n\n  mul(a, b) {\n    this._verify2(a, b);\n\n    return this.imod(a.mul(b));\n  }\n\n  imuln(a, num) {\n    this._verify1(a);\n\n    if (a.isZero()) return a;\n\n    if (num === 0) {\n      a.words[0] = 0;\n      a.length = 1;\n      return a;\n    }\n\n    const neg = num < 0;\n    if (neg) num = -num;\n    if (this.m.length === 1) num %= this.m.words[0];\n    a.imuln(num);\n\n    if (num <= 16) {\n      // Quick reduction.\n      while (a.ucmp(this.m) >= 0) a._isub(a, this.m);\n    } else {\n      this.imod(a);\n    }\n\n    if (neg) this.ineg(a);\n    return a;\n  }\n\n  muln(a, num) {\n    return this.imuln(a.clone(), num);\n  }\n\n  idiv(a, b) {\n    return this.div(a, b)._move(a);\n  }\n\n  div(a, b) {\n    return this.mul(a, this.invert(b));\n  }\n\n  idivn(a, num) {\n    return this.divn(a, num)._move(a);\n  }\n\n  divn(a, num) {\n    return this.div(a, this.convertTo(new BN(num)));\n  }\n\n  ipow(a, num) {\n    return this.pow(a, num)._move(a);\n  }\n\n  pow(a, num) {\n    this._verify1(a);\n\n    if (num.isNeg()) a = this.invert(a); // Small exponent.\n\n    if (num.length === 1) return this.pown(a, num.words[0]); // Call out to BigInt.\n\n    if (HAS_BIGINT && !this.prime) return this.powInt(a, num); // Otherwise, a BN implementation.\n\n    return this.powNum(a, num);\n  }\n\n  powNum(a, num) {\n    // Sliding window.\n    const wnd = new Array(WND_SIZE);\n    wnd[0] = this.sqrn(a, WND_WIDTH - 1);\n    wnd[1] = this.mul(wnd[0], a);\n\n    for (let i = 2; i < WND_SIZE; i++) wnd[i] = this.mul(wnd[i - 1], a);\n\n    let i = num.bitLength();\n    let r = new BN(1).toRed(this);\n\n    while (i >= WND_WIDTH) {\n      const pos = i - WND_WIDTH;\n      const bits = num.bits(pos, WND_WIDTH);\n\n      if (bits < WND_SIZE) {\n        r = this.sqr(r);\n        i -= 1;\n        continue;\n      }\n\n      r = this.sqrn(r, WND_WIDTH);\n      r = this.mul(r, wnd[bits & ~WND_SIZE]);\n      i = pos;\n    }\n\n    if (i > 0) {\n      const bits = num.bits(0, i);\n\n      while (i--) {\n        r = this.sqr(r);\n        if (bits >> i & 1) r = this.mul(r, a);\n      }\n    }\n\n    return r;\n  }\n\n  powInt(a, num) {\n    if (this.mb === null) this.mb = this.m.toBigInt();\n    const x = this.intFrom(a.toBigInt());\n    const y = powInt(x, num, this.mb);\n    const z = this.intTo(y);\n    return BN.fromBigInt(z)._forceRed(this);\n  }\n\n  sqrn(a, n) {\n    for (let i = 0; i < n; i++) a = this.sqr(a);\n\n    return a;\n  }\n\n  ipown(a, num) {\n    return this.pown(a, num)._move(a);\n  }\n\n  pown(a, num) {\n    this._verify1(a);\n\n    if (num < 0) {\n      a = this.invert(a);\n      num = -num;\n    }\n\n    if (num === 0) return new BN(1).toRed(this);\n    if (num === 1) return a.clone();\n    const bits = countBits(num);\n    let r = a;\n\n    for (let i = bits - 2; i >= 0; i--) {\n      r = this.sqr(r);\n      if (num >> i & 1) r = this.mul(r, a);\n    }\n\n    return r;\n  }\n\n  isqr(a) {\n    return this.imul(a, a);\n  }\n\n  sqr(a) {\n    return this.mul(a, a);\n  }\n\n  isqrt(x) {\n    return this.sqrt(x)._move(x);\n  }\n\n  sqrt(x) {\n    this._verify1(x); // Fast case (p = 3 mod 4).\n\n\n    if (this.m.andln(3) === 3) return this.sqrt3mod4(x); // Fast case (p = 5 mod 8).\n\n    if (this.m.andln(7) === 5) {\n      if (this.sm1 != null) return this.sqrt5mod8sm1(x);\n      return this.sqrt5mod8(x);\n    } // Slow case (Tonelli-Shanks).\n\n\n    return this.sqrt0(x);\n  }\n\n  sqrt3mod4(x) {\n    const e = this.m.addn(1).iushrn(2); // (p + 1) / 4\n\n    const b = this.pow(x, e);\n    if (!this.sqr(b).eq(x)) throw new Error('X is not a square mod P.');\n    return b;\n  }\n\n  sqrt5mod8(x) {\n    // Atkin's Algorithm.\n    const one = new BN(1).toRed(this);\n    const e = this.m.ushrn(3); // (p - 5) / 8\n\n    const x2 = this.add(x, x);\n    const alpha = this.pow(x2, e);\n    const beta = this.mul(x2, this.sqr(alpha));\n    const b = this.mul(this.mul(alpha, x), this.isub(beta, one));\n    if (!this.sqr(b).eq(x)) throw new Error('X is not a square mod P.');\n    return b;\n  }\n\n  sqrt5mod8sm1(x) {\n    const e = this.m.addn(3).iushrn(3); // (p + 3) / 8\n\n    const b = this.pow(x, e);\n    if (this.sqr(b).eq(x)) return b;\n    const c = this.mul(b, this.sm1);\n    if (this.sqr(c).eq(x)) return c;\n    throw new Error('X is not a square mod P.');\n  }\n\n  sqrt0(x) {\n    if (this.m.cmpn(1) === 0 || !this.m.isOdd()) throw new Error('Invalid prime.');\n\n    switch (this.jacobi(x)) {\n      case -1:\n        throw new Error('X is not a square mod P.');\n\n      case 0:\n        return new BN(0)._forceRed(this);\n\n      case 1:\n        break;\n    }\n\n    const one = new BN(1).toRed(this);\n    const s = this.m.subn(1);\n    const e = s.zeroBits();\n    s.iushrn(e);\n    const n = new BN(2).toRed(this);\n\n    while (this.jacobi(n) !== -1) this.iadd(n, one);\n\n    let b = this.pow(x, s);\n    let g = this.pow(n, s);\n    let y = this.pow(x, s.iaddn(1).iushrn(1));\n    let k = e;\n\n    for (;;) {\n      let t = b;\n      let m = 0;\n\n      while (t.cmp(one) !== 0 && m < k) {\n        t = this.sqr(t);\n        m += 1;\n      }\n\n      if (m === 0) break;\n      assert(m < k);\n      t = this.sqrn(g, k - m - 1);\n      g = this.sqr(t);\n      y = this.mul(y, t);\n      b = this.mul(b, g);\n      k = m;\n    }\n\n    return y;\n  }\n\n  idivsqrt(u, v) {\n    return this.divsqrt(u, v)._move(u);\n  }\n\n  divsqrt(u, v) {\n    this._verify2(u, v); // v = 0\n\n\n    if (v.isZero()) throw new RangeError('Not invertible.'); // p = 3 mod 4\n\n    if (this.m.andln(3) === 3) return this.divsqrt3mod4(u, v); // p = 5 mod 8\n\n    if (this.sm1 != null && this.m.andln(7) === 5) return this.divsqrt5mod8(u, v);\n    return this.sqrt(this.div(u, v));\n  }\n\n  divsqrt3mod4(u, v) {\n    // x = u^3 * v * (u^5 * v^3)^((p - 3) / 4) mod p\n    const e = this.m.subn(3).iushrn(2);\n    const u2 = this.sqr(u);\n    const u3 = this.mul(u2, u);\n    const u5 = this.mul(u3, u2);\n    const v3 = this.mul(this.sqr(v), v);\n    const p = this.pow(this.mul(u5, v3), e);\n    const x = this.mul(this.mul(u3, v), p);\n    const c = this.mul(v, this.sqr(x));\n    if (c.cmp(u) === 0) return x;\n    throw new Error('X is not a square mod P.');\n  }\n\n  divsqrt5mod8(u, v) {\n    // x = u * v^3 * (u * v^7)^((p - 5) / 8) mod p\n    const e = this.m.subn(5).iushrn(3);\n    const v3 = this.mul(this.sqr(v), v);\n    const v7 = this.mul(this.sqr(v3), v);\n    const p = this.pow(this.mul(u, v7), e);\n    const x = this.mul(this.mul(u, v3), p);\n    const c = this.mul(v, this.sqr(x));\n    if (c.cmp(u) === 0) return x;\n    if (this.ineg(c).cmp(u) === 0) return this.mul(x, this.sm1);\n    throw new Error('X is not a square mod P.');\n  }\n\n  isSquare(a) {\n    let symbol;\n    if (this.prime || this.coprime) symbol = this.legendre(a);else if (this.m.isOdd()) symbol = this.jacobi(a);else symbol = this.kronecker(a);\n    return Boolean(~symbol >>> 31);\n  }\n\n  ishl(a, num) {\n    this._verify1(a);\n\n    return this.imod(a.iushl(num));\n  }\n\n  shl(a, num) {\n    return this.ishl(a.clone(), num);\n  }\n\n  ishln(a, num) {\n    this._verify1(a);\n\n    a.iushln(num);\n\n    if (num <= 4) {\n      // Quick reduction.\n      while (a.ucmp(this.m) >= 0) a._isub(a, this.m);\n    } else {\n      this.imod(a);\n    }\n\n    return a;\n  }\n\n  shln(a, num) {\n    return this.ishln(a.clone(), num);\n  }\n\n  ineg(a) {\n    this._verify1(a);\n\n    if (!a.isZero()) a._isub(this.m, a);\n    return a;\n  }\n\n  neg(a) {\n    return this.ineg(a.clone());\n  }\n\n  eq(a, b) {\n    this._verify2(a, b);\n\n    return a.ucmp(b) === 0;\n  }\n\n  eqn(a, num) {\n    this._verify1(a);\n\n    if (this.m.length === 1) {\n      num %= this.m.words[0];\n      if (num < 0) num += this.m.words[0];\n      return a.ucmpn(num) === 0;\n    }\n\n    if (num < 0) {\n      this.m._isubn(-num);\n\n      const cmp = a.ucmp(this.m);\n\n      this.m._iaddn(-num);\n\n      return cmp === 0;\n    }\n\n    return a.ucmpn(num) === 0;\n  }\n\n  isHigh(a) {\n    return !this.isLow(a);\n  }\n\n  isLow(a) {\n    this._verify1(a);\n\n    return a.ucmp(this.m.ushrn(1)) <= 0;\n  }\n\n  isOdd(a) {\n    this._verify1(a);\n\n    return a.isOdd();\n  }\n\n  isEven(a) {\n    this._verify1(a);\n\n    return a.isEven();\n  }\n\n  legendre(num) {\n    this._verify1(num);\n\n    if (this.m.isEven()) throw new Error('legendre: `num` must be odd.'); // Euler's criterion.\n\n    const e = this.m.subn(1).iushrn(1); // (p - 1) / 2\n\n    const symbol = this.pow(num, e);\n    const one = new BN(1).toRed(this);\n    const a = symbol.czero();\n    const b = symbol.ceq(one);\n    const c = symbol.ceq(this.ineg(one)); // Must be one of these.\n\n    if ((a | b | c) === 0) throw new Error('Invalid prime.'); // Cannot be multiple.\n\n    assert(a + b + c === 1); // 0, 1, or -1.\n\n    return b - c;\n  }\n\n  jacobi(a) {\n    this._verify1(a);\n\n    return a.jacobi(this.m);\n  }\n\n  kronecker(a) {\n    this._verify1(a);\n\n    return a.kronecker(this.m);\n  }\n\n  iinvert(a) {\n    return this.invert(a)._move(a);\n  }\n\n  invert(a) {\n    this._verify1(a);\n\n    if (this.prime) return this.imod(a._invertp(this.m));\n    return a.invert(this.m)._forceRed(this);\n  }\n\n  ifermat(a) {\n    return this.fermat(a)._move(a);\n  }\n\n  fermat(a) {\n    this._verify1(a);\n\n    if (a.isZero() || this.m.cmpn(1) === 0) throw new RangeError('Not invertible.'); // Invert using fermat's little theorem.\n\n    return this.pow(a, this.m.subn(2));\n  }\n\n  [custom]() {\n    if (this.prime) return `<Red: ${this.prime.name}>`;\n    return `<Red: ${this.m.toString(10)}>`;\n  }\n\n}\n/**\n * Barrett Engine\n */\n\n\nclass Barrett extends Red {\n  constructor(m) {\n    super(m);\n    this.prime = null;\n    this.n = this.m.bitLength();\n    if (this.n % 26 !== 0) this.n += 26 - this.n % 26;\n    this.k = this.n * 2;\n    this.w = this.k / 26;\n    this.b = BN.shift(1, this.k).div(this.m);\n  }\n\n  convertTo(num) {\n    if (num.length > this.w) return super.convertTo(num);\n    return this.imod(num.clone());\n  }\n\n  _shift(q) {\n    let i = 0;\n    let j = this.w;\n\n    while (j < q.length) q.words[i++] = q.words[j++];\n\n    if (i === 0) q.words[i++] = 0;\n    q.length = i;\n  }\n\n  imod(a) {\n    const neg = a.negative;\n    assert(a.length <= this.w);\n    a.negative = 0;\n    const q = a.mul(this.b); // Shift right by `k` bits.\n\n    this._shift(q);\n\n    a._isub(a, q.mul(this.m));\n\n    if (a.ucmp(this.m) >= 0) a._isub(a, this.m);\n    if (neg && !a.isZero()) a._isub(this.m, a);\n    a.red = this;\n    return a;\n  }\n\n}\n/**\n * Montgomery Engine\n */\n\n\nclass Mont extends Red {\n  constructor(m) {\n    super(m);\n    this.prime = null;\n    this.n = this.m.bitLength();\n    if (this.n % 26 !== 0) this.n += 26 - this.n % 26;\n    this.r = BN.shift(1, this.n);\n    this.r2 = BN.shift(1, this.n * 2).imod(this.m);\n    this.ri = this.r._invertp(this.m).imod(this.m);\n    this.mi = this.r.mul(this.ri).isubn(1).div(this.m);\n    this.rib = null;\n  }\n\n  get mont() {\n    return true;\n  }\n\n  get coprime() {\n    return true;\n  }\n\n  convertTo(num) {\n    return this.imod(num.ushln(this.n));\n  }\n\n  convertFrom(num) {\n    const r = this.imod(num.mul(this.ri));\n    r.red = null;\n    return r;\n  }\n\n  intTo(a) {\n    return (a << BigInt(this.n)) % this.mb;\n  }\n\n  intFrom(a) {\n    if (this.rib === null) this.rib = this.ri.toBigInt();\n    return a * this.rib % this.mb;\n  }\n\n  iaddn(a, num) {\n    return this.iadd(a, this.convertTo(new BN(num)));\n  }\n\n  isubn(a, num) {\n    return this.isub(a, this.convertTo(new BN(num)));\n  }\n\n  imul(a, b) {\n    return this.mul(a, b)._move(a);\n  }\n\n  mul(a, b) {\n    this._verify2(a, b);\n\n    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);\n    const t = a.mul(b);\n    const c = t.umaskn(this.n).mul(this.mi).iumaskn(this.n);\n    const u = t.iadd(c.mul(this.m)).iushrn(this.n);\n    if (u.ucmp(this.m) >= 0) u._isub(u, this.m);\n    return u._forceRed(this);\n  }\n\n  imuln(a, num) {\n    this._verify1(a);\n\n    if (a.isZero()) return a;\n\n    if (num === 0) {\n      a.words[0] = 0;\n      a.length = 1;\n      return a;\n    }\n\n    const neg = num < 0;\n    if (neg) num = -num;\n    if (this.m.length === 1) num %= this.m.words[0];\n    const bits = countBits(num); // Potentially compute with additions.\n    // This avoids an expensive division.\n\n    if (bits > 5) {\n      // Slow case (num > 31).\n      this.imul(a, this.convertTo(new BN(num)));\n    } else if ((num & num - 1) === 0) {\n      // Optimize for powers of two.\n      for (let i = 0; i < bits - 1; i++) this.iadd(a, a);\n    } else {\n      // Multiply left to right.\n      const c = a.clone();\n\n      for (let i = bits - 2; i >= 0; i--) {\n        this.iadd(a, a);\n        if (num >> i & 1) this.iadd(a, c);\n      }\n    }\n\n    if (neg) this.ineg(a);\n    return a;\n  }\n\n  eqn(a, num) {\n    this._verify1(a);\n\n    if (num === 0) return a.isZero();\n    return a.ucmp(this.convertTo(new BN(num))) === 0;\n  }\n\n  isLow(a) {\n    this._verify1(a);\n\n    return this.convertFrom(a).ucmp(this.m.ushrn(1)) <= 0;\n  }\n\n  isOdd(a) {\n    this._verify1(a);\n\n    return this.convertFrom(a).isOdd();\n  }\n\n  isEven(a) {\n    this._verify1(a);\n\n    return this.convertFrom(a).isEven();\n  }\n\n  invert(a) {\n    this._verify1(a); // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R\n\n\n    return this.imod(a._invertp(this.m).mul(this.r2));\n  }\n\n}\n/*\n * Helpers\n */\n\n\nfunction makeError(Error, msg, start) {\n  const err = new Error(msg);\n  if (Error.captureStackTrace) Error.captureStackTrace(err, start);\n  return err;\n}\n\nfunction assert(value, message) {\n  if (!value) {\n    const msg = message || 'Assertion failed.';\n    throw makeError(Error, msg, assert);\n  }\n}\n\nfunction enforce(value, name, type) {\n  if (!value) {\n    const msg = `\"${name}\" must be a(n) ${type}.`;\n    throw makeError(TypeError, msg, enforce);\n  }\n}\n\nfunction range(value, name) {\n  if (!value) {\n    const msg = `\"${name}\" only works with positive numbers.`;\n    throw makeError(RangeError, msg, range);\n  }\n}\n\nfunction red(value, name) {\n  if (!value) {\n    const msg = `\"${name}\" only works with red numbers.`;\n    throw makeError(TypeError, msg, red);\n  }\n}\n\nfunction nonred(value, name) {\n  if (!value) {\n    const msg = `\"${name}\" only works with normal numbers.`;\n    throw makeError(TypeError, msg, nonred);\n  }\n}\n\nfunction nonzero(value) {\n  if (!value) {\n    const msg = 'Cannot divide by zero.';\n    throw makeError(RangeError, msg, nonzero);\n  }\n}\n\nfunction isInteger(num) {\n  return Number.isSafeInteger(num);\n}\n\nfunction isSMI(num) {\n  return isInteger(num) && num >= -0x3ffffff && num <= 0x3ffffff;\n}\n\nfunction allocate(ArrayType, size) {\n  if (ArrayType.allocUnsafeSlow) return ArrayType.allocUnsafeSlow(size);\n  return new ArrayType(size);\n}\n\nfunction getBase(base) {\n  if (base == null) return 10;\n  if (typeof base === 'number') return base;\n\n  switch (base) {\n    case 'bin':\n      return 2;\n\n    case 'oct':\n      return 8;\n\n    case 'dec':\n      return 10;\n\n    case 'hex':\n      return 16;\n  }\n\n  return 0;\n}\n/*\n * Internal\n */\n\n\nfunction countBits(w) {\n  if (Math.clz32) return 32 - Math.clz32(w);\n  let t = w;\n  let r = 0;\n\n  if (t >= 0x1000) {\n    r += 13;\n    t >>>= 13;\n  }\n\n  if (t >= 0x40) {\n    r += 7;\n    t >>>= 7;\n  }\n\n  if (t >= 0x8) {\n    r += 4;\n    t >>>= 4;\n  }\n\n  if (t >= 0x02) {\n    r += 2;\n    t >>>= 2;\n  }\n\n  return r + t;\n}\n\nfunction zeroBits(w) {\n  // Shortcut.\n  if (w === 0) return 26;\n  let t = w;\n  let r = 0;\n\n  if ((t & 0x1fff) === 0) {\n    r += 13;\n    t >>>= 13;\n  }\n\n  if ((t & 0x7f) === 0) {\n    r += 7;\n    t >>>= 7;\n  }\n\n  if ((t & 0xf) === 0) {\n    r += 4;\n    t >>>= 4;\n  }\n\n  if ((t & 0x3) === 0) {\n    r += 2;\n    t >>>= 2;\n  }\n\n  if ((t & 0x1) === 0) r += 1;\n  return r;\n}\n\nfunction parseHex(str, start, end) {\n  const len = Math.min(str.length, end);\n  let r = 0;\n  let z = 0;\n\n  for (let i = start; i < len; i++) {\n    const c = str.charCodeAt(i) - 48;\n    r <<= 4;\n    let b;\n\n    if (c >= 49 && c <= 54) {\n      // 'a' - 'f'\n      b = c - 49 + 0xa;\n    } else if (c >= 17 && c <= 22) {\n      // 'A' - 'F'\n      b = c - 17 + 0xa;\n    } else {\n      // '0' - '9'\n      b = c;\n    }\n\n    r |= b;\n    z |= b;\n  }\n\n  if (z & ~15) throw new Error('Invalid string.');\n  return r;\n}\n\nfunction parseBase(str, start, end, mul) {\n  const len = Math.min(str.length, end);\n  let r = 0;\n\n  for (let i = start; i < len; i++) {\n    const c = str.charCodeAt(i) - 48;\n    r *= mul;\n    let b;\n\n    if (c >= 49) {\n      // 'a'\n      b = c - 49 + 0xa;\n    } else if (c >= 17) {\n      // 'A'\n      b = c - 17 + 0xa;\n    } else {\n      // '0' - '9'\n      b = c;\n    }\n\n    if (c < 0 || c > 207 || b >= mul) throw new Error('Invalid string.');\n    r += b;\n  }\n\n  return r;\n}\n/*\n * Exponentiation (bigint)\n */\n\n\nfunction powInt(x, e, m) {\n  // Sliding window.\n  const wnd = new Array(WND_SIZE);\n  wnd[0] = sqrn(x, WND_WIDTH - 1, m);\n  wnd[1] = wnd[0] * x;\n\n  for (let i = 2; i < WND_SIZE; i++) wnd[i] = wnd[i - 1] * x % m;\n\n  let i = e.bitLength();\n  let r = BigInt(1);\n\n  while (i >= WND_WIDTH) {\n    const pos = i - WND_WIDTH;\n    const bits = e.bits(pos, WND_WIDTH);\n\n    if (bits < WND_SIZE) {\n      r = r * r % m;\n      i -= 1;\n      continue;\n    }\n\n    r = sqrn(r, WND_WIDTH, m);\n    r = r * wnd[bits & ~WND_SIZE] % m;\n    i = pos;\n  }\n\n  if (i > 0) {\n    const bits = e.bits(0, i);\n\n    while (i--) {\n      r = r * r % m;\n      if (bits >> i & 1) r = r * x % m;\n    }\n  }\n\n  return r;\n}\n\nfunction sqrn(x, n, m) {\n  for (let i = 0; i < n; i++) x = x * x % m;\n\n  return x;\n}\n/*\n * Multiplication\n */\n\n\nfunction smallMulTo(self, num, out) {\n  const len = self.length + num.length;\n  out.negative = self.negative ^ num.negative;\n\n  out._alloc(len);\n\n  out.length = len; // Peel one iteration (compiler can't\n  // do it, because of code complexity).\n\n  const a = self.words[0];\n  const b = num.words[0];\n  const r = a * b;\n  const lo = r & 0x3ffffff;\n  let carry = r / 0x4000000 | 0;\n  let k = 1;\n  out.words[0] = lo;\n\n  for (; k < out.length - 1; k++) {\n    // Sum all words with the same\n    // `i + j = k` and accumulate\n    // `ncarry`, note that ncarry\n    // could be >= 0x3ffffff.\n    let ncarry = carry >>> 26;\n    let rword = carry & 0x3ffffff;\n    const min = Math.max(0, k - self.length + 1);\n    const max = Math.min(k, num.length - 1);\n\n    for (let j = min; j <= max; j++) {\n      const i = k - j;\n      const a = self.words[i];\n      const b = num.words[j];\n      const r = a * b + rword;\n      ncarry += r / 0x4000000 | 0;\n      rword = r & 0x3ffffff;\n    }\n\n    out.words[k] = rword | 0;\n    carry = ncarry | 0;\n  }\n\n  if (carry !== 0) out.words[k] = carry | 0;else out.length -= 1;\n  return out._strip();\n}\n\nfunction bigMulTo(self, num, out) {\n  const len = self.length + num.length;\n  out.negative = self.negative ^ num.negative;\n\n  out._alloc(len);\n\n  out.length = len;\n  let carry = 0;\n  let hncarry = 0;\n  let k = 0;\n\n  for (; k < out.length - 1; k++) {\n    // Sum all words with the same\n    // `i + j = k` and accumulate\n    // `ncarry`, note that ncarry\n    // could be >= 0x3ffffff.\n    let ncarry = hncarry;\n    hncarry = 0;\n    let rword = carry & 0x3ffffff;\n    const min = Math.max(0, k - self.length + 1);\n    const max = Math.min(k, num.length - 1);\n\n    for (let j = min; j <= max; j++) {\n      const i = k - j;\n      const a = self.words[i];\n      const b = num.words[j];\n      const r = a * b;\n      let lo = r & 0x3ffffff;\n      ncarry = ncarry + (r / 0x4000000 | 0) | 0;\n      lo = lo + rword | 0;\n      rword = lo & 0x3ffffff;\n      ncarry = ncarry + (lo >>> 26) | 0;\n      hncarry += ncarry >>> 26;\n      ncarry &= 0x3ffffff;\n    }\n\n    out.words[k] = rword;\n    carry = ncarry;\n    ncarry = hncarry;\n  }\n\n  if (carry !== 0) out.words[k] = carry;else out.length -= 1;\n  return out._strip();\n}\n\nfunction jumboMulTo(x, y, out) {\n  // v8 has a 2147483519 bit max (~256mb).\n  if (!HAS_BIGINT || x.length + y.length > 82595519) return bigMulTo(x, y, out);\n  const zero = BigInt(0);\n  const mask = BigInt(0x3ffffff);\n  const shift = BigInt(26);\n  let z = x.toBigInt() * y.toBigInt();\n  const neg = z < zero | 0;\n  if (neg) z = -z;\n  let i = 0;\n\n  while (z > zero) {\n    out.words[i++] = Number(z & mask);\n    z >>= shift;\n  }\n\n  if (i === 0) out.words[i++] = 0;\n  out.length = i;\n  out.negative = neg;\n  return out;\n}\n\nfunction comb10MulTo(self, num, out) {\n  const a = self.words;\n  const b = num.words;\n  const o = out.words;\n  const a0 = a[0] | 0;\n  const al0 = a0 & 0x1fff;\n  const ah0 = a0 >>> 13;\n  const a1 = a[1] | 0;\n  const al1 = a1 & 0x1fff;\n  const ah1 = a1 >>> 13;\n  const a2 = a[2] | 0;\n  const al2 = a2 & 0x1fff;\n  const ah2 = a2 >>> 13;\n  const a3 = a[3] | 0;\n  const al3 = a3 & 0x1fff;\n  const ah3 = a3 >>> 13;\n  const a4 = a[4] | 0;\n  const al4 = a4 & 0x1fff;\n  const ah4 = a4 >>> 13;\n  const a5 = a[5] | 0;\n  const al5 = a5 & 0x1fff;\n  const ah5 = a5 >>> 13;\n  const a6 = a[6] | 0;\n  const al6 = a6 & 0x1fff;\n  const ah6 = a6 >>> 13;\n  const a7 = a[7] | 0;\n  const al7 = a7 & 0x1fff;\n  const ah7 = a7 >>> 13;\n  const a8 = a[8] | 0;\n  const al8 = a8 & 0x1fff;\n  const ah8 = a8 >>> 13;\n  const a9 = a[9] | 0;\n  const al9 = a9 & 0x1fff;\n  const ah9 = a9 >>> 13;\n  const b0 = b[0] | 0;\n  const bl0 = b0 & 0x1fff;\n  const bh0 = b0 >>> 13;\n  const b1 = b[1] | 0;\n  const bl1 = b1 & 0x1fff;\n  const bh1 = b1 >>> 13;\n  const b2 = b[2] | 0;\n  const bl2 = b2 & 0x1fff;\n  const bh2 = b2 >>> 13;\n  const b3 = b[3] | 0;\n  const bl3 = b3 & 0x1fff;\n  const bh3 = b3 >>> 13;\n  const b4 = b[4] | 0;\n  const bl4 = b4 & 0x1fff;\n  const bh4 = b4 >>> 13;\n  const b5 = b[5] | 0;\n  const bl5 = b5 & 0x1fff;\n  const bh5 = b5 >>> 13;\n  const b6 = b[6] | 0;\n  const bl6 = b6 & 0x1fff;\n  const bh6 = b6 >>> 13;\n  const b7 = b[7] | 0;\n  const bl7 = b7 & 0x1fff;\n  const bh7 = b7 >>> 13;\n  const b8 = b[8] | 0;\n  const bl8 = b8 & 0x1fff;\n  const bh8 = b8 >>> 13;\n  const b9 = b[9] | 0;\n  const bl9 = b9 & 0x1fff;\n  const bh9 = b9 >>> 13;\n  let c = 0;\n  let lo, mid, hi;\n  out.negative = self.negative ^ num.negative;\n\n  out._alloc(20);\n\n  out.length = 19;\n  /* k = 0 */\n\n  lo = Math.imul(al0, bl0);\n  mid = Math.imul(al0, bh0);\n  mid = mid + Math.imul(ah0, bl0) | 0;\n  hi = Math.imul(ah0, bh0);\n  let w0 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n  c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;\n  w0 &= 0x3ffffff;\n  /* k = 1 */\n\n  lo = Math.imul(al1, bl0);\n  mid = Math.imul(al1, bh0);\n  mid = mid + Math.imul(ah1, bl0) | 0;\n  hi = Math.imul(ah1, bh0);\n  lo = lo + Math.imul(al0, bl1) | 0;\n  mid = mid + Math.imul(al0, bh1) | 0;\n  mid = mid + Math.imul(ah0, bl1) | 0;\n  hi = hi + Math.imul(ah0, bh1) | 0;\n  let w1 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n  c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;\n  w1 &= 0x3ffffff;\n  /* k = 2 */\n\n  lo = Math.imul(al2, bl0);\n  mid = Math.imul(al2, bh0);\n  mid = mid + Math.imul(ah2, bl0) | 0;\n  hi = Math.imul(ah2, bh0);\n  lo = lo + Math.imul(al1, bl1) | 0;\n  mid = mid + Math.imul(al1, bh1) | 0;\n  mid = mid + Math.imul(ah1, bl1) | 0;\n  hi = hi + Math.imul(ah1, bh1) | 0;\n  lo = lo + Math.imul(al0, bl2) | 0;\n  mid = mid + Math.imul(al0, bh2) | 0;\n  mid = mid + Math.imul(ah0, bl2) | 0;\n  hi = hi + Math.imul(ah0, bh2) | 0;\n  let w2 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n  c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;\n  w2 &= 0x3ffffff;\n  /* k = 3 */\n\n  lo = Math.imul(al3, bl0);\n  mid = Math.imul(al3, bh0);\n  mid = mid + Math.imul(ah3, bl0) | 0;\n  hi = Math.imul(ah3, bh0);\n  lo = lo + Math.imul(al2, bl1) | 0;\n  mid = mid + Math.imul(al2, bh1) | 0;\n  mid = mid + Math.imul(ah2, bl1) | 0;\n  hi = hi + Math.imul(ah2, bh1) | 0;\n  lo = lo + Math.imul(al1, bl2) | 0;\n  mid = mid + Math.imul(al1, bh2) | 0;\n  mid = mid + Math.imul(ah1, bl2) | 0;\n  hi = hi + Math.imul(ah1, bh2) | 0;\n  lo = lo + Math.imul(al0, bl3) | 0;\n  mid = mid + Math.imul(al0, bh3) | 0;\n  mid = mid + Math.imul(ah0, bl3) | 0;\n  hi = hi + Math.imul(ah0, bh3) | 0;\n  let w3 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n  c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;\n  w3 &= 0x3ffffff;\n  /* k = 4 */\n\n  lo = Math.imul(al4, bl0);\n  mid = Math.imul(al4, bh0);\n  mid = mid + Math.imul(ah4, bl0) | 0;\n  hi = Math.imul(ah4, bh0);\n  lo = lo + Math.imul(al3, bl1) | 0;\n  mid = mid + Math.imul(al3, bh1) | 0;\n  mid = mid + Math.imul(ah3, bl1) | 0;\n  hi = hi + Math.imul(ah3, bh1) | 0;\n  lo = lo + Math.imul(al2, bl2) | 0;\n  mid = mid + Math.imul(al2, bh2) | 0;\n  mid = mid + Math.imul(ah2, bl2) | 0;\n  hi = hi + Math.imul(ah2, bh2) | 0;\n  lo = lo + Math.imul(al1, bl3) | 0;\n  mid = mid + Math.imul(al1, bh3) | 0;\n  mid = mid + Math.imul(ah1, bl3) | 0;\n  hi = hi + Math.imul(ah1, bh3) | 0;\n  lo = lo + Math.imul(al0, bl4) | 0;\n  mid = mid + Math.imul(al0, bh4) | 0;\n  mid = mid + Math.imul(ah0, bl4) | 0;\n  hi = hi + Math.imul(ah0, bh4) | 0;\n  let w4 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n  c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;\n  w4 &= 0x3ffffff;\n  /* k = 5 */\n\n  lo = Math.imul(al5, bl0);\n  mid = Math.imul(al5, bh0);\n  mid = mid + Math.imul(ah5, bl0) | 0;\n  hi = Math.imul(ah5, bh0);\n  lo = lo + Math.imul(al4, bl1) | 0;\n  mid = mid + Math.imul(al4, bh1) | 0;\n  mid = mid + Math.imul(ah4, bl1) | 0;\n  hi = hi + Math.imul(ah4, bh1) | 0;\n  lo = lo + Math.imul(al3, bl2) | 0;\n  mid = mid + Math.imul(al3, bh2) | 0;\n  mid = mid + Math.imul(ah3, bl2) | 0;\n  hi = hi + Math.imul(ah3, bh2) | 0;\n  lo = lo + Math.imul(al2, bl3) | 0;\n  mid = mid + Math.imul(al2, bh3) | 0;\n  mid = mid + Math.imul(ah2, bl3) | 0;\n  hi = hi + Math.imul(ah2, bh3) | 0;\n  lo = lo + Math.imul(al1, bl4) | 0;\n  mid = mid + Math.imul(al1, bh4) | 0;\n  mid = mid + Math.imul(ah1, bl4) | 0;\n  hi = hi + Math.imul(ah1, bh4) | 0;\n  lo = lo + Math.imul(al0, bl5) | 0;\n  mid = mid + Math.imul(al0, bh5) | 0;\n  mid = mid + Math.imul(ah0, bl5) | 0;\n  hi = hi + Math.imul(ah0, bh5) | 0;\n  let w5 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n  c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;\n  w5 &= 0x3ffffff;\n  /* k = 6 */\n\n  lo = Math.imul(al6, bl0);\n  mid = Math.imul(al6, bh0);\n  mid = mid + Math.imul(ah6, bl0) | 0;\n  hi = Math.imul(ah6, bh0);\n  lo = lo + Math.imul(al5, bl1) | 0;\n  mid = mid + Math.imul(al5, bh1) | 0;\n  mid = mid + Math.imul(ah5, bl1) | 0;\n  hi = hi + Math.imul(ah5, bh1) | 0;\n  lo = lo + Math.imul(al4, bl2) | 0;\n  mid = mid + Math.imul(al4, bh2) | 0;\n  mid = mid + Math.imul(ah4, bl2) | 0;\n  hi = hi + Math.imul(ah4, bh2) | 0;\n  lo = lo + Math.imul(al3, bl3) | 0;\n  mid = mid + Math.imul(al3, bh3) | 0;\n  mid = mid + Math.imul(ah3, bl3) | 0;\n  hi = hi + Math.imul(ah3, bh3) | 0;\n  lo = lo + Math.imul(al2, bl4) | 0;\n  mid = mid + Math.imul(al2, bh4) | 0;\n  mid = mid + Math.imul(ah2, bl4) | 0;\n  hi = hi + Math.imul(ah2, bh4) | 0;\n  lo = lo + Math.imul(al1, bl5) | 0;\n  mid = mid + Math.imul(al1, bh5) | 0;\n  mid = mid + Math.imul(ah1, bl5) | 0;\n  hi = hi + Math.imul(ah1, bh5) | 0;\n  lo = lo + Math.imul(al0, bl6) | 0;\n  mid = mid + Math.imul(al0, bh6) | 0;\n  mid = mid + Math.imul(ah0, bl6) | 0;\n  hi = hi + Math.imul(ah0, bh6) | 0;\n  let w6 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n  c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;\n  w6 &= 0x3ffffff;\n  /* k = 7 */\n\n  lo = Math.imul(al7, bl0);\n  mid = Math.imul(al7, bh0);\n  mid = mid + Math.imul(ah7, bl0) | 0;\n  hi = Math.imul(ah7, bh0);\n  lo = lo + Math.imul(al6, bl1) | 0;\n  mid = mid + Math.imul(al6, bh1) | 0;\n  mid = mid + Math.imul(ah6, bl1) | 0;\n  hi = hi + Math.imul(ah6, bh1) | 0;\n  lo = lo + Math.imul(al5, bl2) | 0;\n  mid = mid + Math.imul(al5, bh2) | 0;\n  mid = mid + Math.imul(ah5, bl2) | 0;\n  hi = hi + Math.imul(ah5, bh2) | 0;\n  lo = lo + Math.imul(al4, bl3) | 0;\n  mid = mid + Math.imul(al4, bh3) | 0;\n  mid = mid + Math.imul(ah4, bl3) | 0;\n  hi = hi + Math.imul(ah4, bh3) | 0;\n  lo = lo + Math.imul(al3, bl4) | 0;\n  mid = mid + Math.imul(al3, bh4) | 0;\n  mid = mid + Math.imul(ah3, bl4) | 0;\n  hi = hi + Math.imul(ah3, bh4) | 0;\n  lo = lo + Math.imul(al2, bl5) | 0;\n  mid = mid + Math.imul(al2, bh5) | 0;\n  mid = mid + Math.imul(ah2, bl5) | 0;\n  hi = hi + Math.imul(ah2, bh5) | 0;\n  lo = lo + Math.imul(al1, bl6) | 0;\n  mid = mid + Math.imul(al1, bh6) | 0;\n  mid = mid + Math.imul(ah1, bl6) | 0;\n  hi = hi + Math.imul(ah1, bh6) | 0;\n  lo = lo + Math.imul(al0, bl7) | 0;\n  mid = mid + Math.imul(al0, bh7) | 0;\n  mid = mid + Math.imul(ah0, bl7) | 0;\n  hi = hi + Math.imul(ah0, bh7) | 0;\n  let w7 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n  c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;\n  w7 &= 0x3ffffff;\n  /* k = 8 */\n\n  lo = Math.imul(al8, bl0);\n  mid = Math.imul(al8, bh0);\n  mid = mid + Math.imul(ah8, bl0) | 0;\n  hi = Math.imul(ah8, bh0);\n  lo = lo + Math.imul(al7, bl1) | 0;\n  mid = mid + Math.imul(al7, bh1) | 0;\n  mid = mid + Math.imul(ah7, bl1) | 0;\n  hi = hi + Math.imul(ah7, bh1) | 0;\n  lo = lo + Math.imul(al6, bl2) | 0;\n  mid = mid + Math.imul(al6, bh2) | 0;\n  mid = mid + Math.imul(ah6, bl2) | 0;\n  hi = hi + Math.imul(ah6, bh2) | 0;\n  lo = lo + Math.imul(al5, bl3) | 0;\n  mid = mid + Math.imul(al5, bh3) | 0;\n  mid = mid + Math.imul(ah5, bl3) | 0;\n  hi = hi + Math.imul(ah5, bh3) | 0;\n  lo = lo + Math.imul(al4, bl4) | 0;\n  mid = mid + Math.imul(al4, bh4) | 0;\n  mid = mid + Math.imul(ah4, bl4) | 0;\n  hi = hi + Math.imul(ah4, bh4) | 0;\n  lo = lo + Math.imul(al3, bl5) | 0;\n  mid = mid + Math.imul(al3, bh5) | 0;\n  mid = mid + Math.imul(ah3, bl5) | 0;\n  hi = hi + Math.imul(ah3, bh5) | 0;\n  lo = lo + Math.imul(al2, bl6) | 0;\n  mid = mid + Math.imul(al2, bh6) | 0;\n  mid = mid + Math.imul(ah2, bl6) | 0;\n  hi = hi + Math.imul(ah2, bh6) | 0;\n  lo = lo + Math.imul(al1, bl7) | 0;\n  mid = mid + Math.imul(al1, bh7) | 0;\n  mid = mid + Math.imul(ah1, bl7) | 0;\n  hi = hi + Math.imul(ah1, bh7) | 0;\n  lo = lo + Math.imul(al0, bl8) | 0;\n  mid = mid + Math.imul(al0, bh8) | 0;\n  mid = mid + Math.imul(ah0, bl8) | 0;\n  hi = hi + Math.imul(ah0, bh8) | 0;\n  let w8 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n  c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;\n  w8 &= 0x3ffffff;\n  /* k = 9 */\n\n  lo = Math.imul(al9, bl0);\n  mid = Math.imul(al9, bh0);\n  mid = mid + Math.imul(ah9, bl0) | 0;\n  hi = Math.imul(ah9, bh0);\n  lo = lo + Math.imul(al8, bl1) | 0;\n  mid = mid + Math.imul(al8, bh1) | 0;\n  mid = mid + Math.imul(ah8, bl1) | 0;\n  hi = hi + Math.imul(ah8, bh1) | 0;\n  lo = lo + Math.imul(al7, bl2) | 0;\n  mid = mid + Math.imul(al7, bh2) | 0;\n  mid = mid + Math.imul(ah7, bl2) | 0;\n  hi = hi + Math.imul(ah7, bh2) | 0;\n  lo = lo + Math.imul(al6, bl3) | 0;\n  mid = mid + Math.imul(al6, bh3) | 0;\n  mid = mid + Math.imul(ah6, bl3) | 0;\n  hi = hi + Math.imul(ah6, bh3) | 0;\n  lo = lo + Math.imul(al5, bl4) | 0;\n  mid = mid + Math.imul(al5, bh4) | 0;\n  mid = mid + Math.imul(ah5, bl4) | 0;\n  hi = hi + Math.imul(ah5, bh4) | 0;\n  lo = lo + Math.imul(al4, bl5) | 0;\n  mid = mid + Math.imul(al4, bh5) | 0;\n  mid = mid + Math.imul(ah4, bl5) | 0;\n  hi = hi + Math.imul(ah4, bh5) | 0;\n  lo = lo + Math.imul(al3, bl6) | 0;\n  mid = mid + Math.imul(al3, bh6) | 0;\n  mid = mid + Math.imul(ah3, bl6) | 0;\n  hi = hi + Math.imul(ah3, bh6) | 0;\n  lo = lo + Math.imul(al2, bl7) | 0;\n  mid = mid + Math.imul(al2, bh7) | 0;\n  mid = mid + Math.imul(ah2, bl7) | 0;\n  hi = hi + Math.imul(ah2, bh7) | 0;\n  lo = lo + Math.imul(al1, bl8) | 0;\n  mid = mid + Math.imul(al1, bh8) | 0;\n  mid = mid + Math.imul(ah1, bl8) | 0;\n  hi = hi + Math.imul(ah1, bh8) | 0;\n  lo = lo + Math.imul(al0, bl9) | 0;\n  mid = mid + Math.imul(al0, bh9) | 0;\n  mid = mid + Math.imul(ah0, bl9) | 0;\n  hi = hi + Math.imul(ah0, bh9) | 0;\n  let w9 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n  c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;\n  w9 &= 0x3ffffff;\n  /* k = 10 */\n\n  lo = Math.imul(al9, bl1);\n  mid = Math.imul(al9, bh1);\n  mid = mid + Math.imul(ah9, bl1) | 0;\n  hi = Math.imul(ah9, bh1);\n  lo = lo + Math.imul(al8, bl2) | 0;\n  mid = mid + Math.imul(al8, bh2) | 0;\n  mid = mid + Math.imul(ah8, bl2) | 0;\n  hi = hi + Math.imul(ah8, bh2) | 0;\n  lo = lo + Math.imul(al7, bl3) | 0;\n  mid = mid + Math.imul(al7, bh3) | 0;\n  mid = mid + Math.imul(ah7, bl3) | 0;\n  hi = hi + Math.imul(ah7, bh3) | 0;\n  lo = lo + Math.imul(al6, bl4) | 0;\n  mid = mid + Math.imul(al6, bh4) | 0;\n  mid = mid + Math.imul(ah6, bl4) | 0;\n  hi = hi + Math.imul(ah6, bh4) | 0;\n  lo = lo + Math.imul(al5, bl5) | 0;\n  mid = mid + Math.imul(al5, bh5) | 0;\n  mid = mid + Math.imul(ah5, bl5) | 0;\n  hi = hi + Math.imul(ah5, bh5) | 0;\n  lo = lo + Math.imul(al4, bl6) | 0;\n  mid = mid + Math.imul(al4, bh6) | 0;\n  mid = mid + Math.imul(ah4, bl6) | 0;\n  hi = hi + Math.imul(ah4, bh6) | 0;\n  lo = lo + Math.imul(al3, bl7) | 0;\n  mid = mid + Math.imul(al3, bh7) | 0;\n  mid = mid + Math.imul(ah3, bl7) | 0;\n  hi = hi + Math.imul(ah3, bh7) | 0;\n  lo = lo + Math.imul(al2, bl8) | 0;\n  mid = mid + Math.imul(al2, bh8) | 0;\n  mid = mid + Math.imul(ah2, bl8) | 0;\n  hi = hi + Math.imul(ah2, bh8) | 0;\n  lo = lo + Math.imul(al1, bl9) | 0;\n  mid = mid + Math.imul(al1, bh9) | 0;\n  mid = mid + Math.imul(ah1, bl9) | 0;\n  hi = hi + Math.imul(ah1, bh9) | 0;\n  let w10 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n  c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;\n  w10 &= 0x3ffffff;\n  /* k = 11 */\n\n  lo = Math.imul(al9, bl2);\n  mid = Math.imul(al9, bh2);\n  mid = mid + Math.imul(ah9, bl2) | 0;\n  hi = Math.imul(ah9, bh2);\n  lo = lo + Math.imul(al8, bl3) | 0;\n  mid = mid + Math.imul(al8, bh3) | 0;\n  mid = mid + Math.imul(ah8, bl3) | 0;\n  hi = hi + Math.imul(ah8, bh3) | 0;\n  lo = lo + Math.imul(al7, bl4) | 0;\n  mid = mid + Math.imul(al7, bh4) | 0;\n  mid = mid + Math.imul(ah7, bl4) | 0;\n  hi = hi + Math.imul(ah7, bh4) | 0;\n  lo = lo + Math.imul(al6, bl5) | 0;\n  mid = mid + Math.imul(al6, bh5) | 0;\n  mid = mid + Math.imul(ah6, bl5) | 0;\n  hi = hi + Math.imul(ah6, bh5) | 0;\n  lo = lo + Math.imul(al5, bl6) | 0;\n  mid = mid + Math.imul(al5, bh6) | 0;\n  mid = mid + Math.imul(ah5, bl6) | 0;\n  hi = hi + Math.imul(ah5, bh6) | 0;\n  lo = lo + Math.imul(al4, bl7) | 0;\n  mid = mid + Math.imul(al4, bh7) | 0;\n  mid = mid + Math.imul(ah4, bl7) | 0;\n  hi = hi + Math.imul(ah4, bh7) | 0;\n  lo = lo + Math.imul(al3, bl8) | 0;\n  mid = mid + Math.imul(al3, bh8) | 0;\n  mid = mid + Math.imul(ah3, bl8) | 0;\n  hi = hi + Math.imul(ah3, bh8) | 0;\n  lo = lo + Math.imul(al2, bl9) | 0;\n  mid = mid + Math.imul(al2, bh9) | 0;\n  mid = mid + Math.imul(ah2, bl9) | 0;\n  hi = hi + Math.imul(ah2, bh9) | 0;\n  let w11 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n  c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;\n  w11 &= 0x3ffffff;\n  /* k = 12 */\n\n  lo = Math.imul(al9, bl3);\n  mid = Math.imul(al9, bh3);\n  mid = mid + Math.imul(ah9, bl3) | 0;\n  hi = Math.imul(ah9, bh3);\n  lo = lo + Math.imul(al8, bl4) | 0;\n  mid = mid + Math.imul(al8, bh4) | 0;\n  mid = mid + Math.imul(ah8, bl4) | 0;\n  hi = hi + Math.imul(ah8, bh4) | 0;\n  lo = lo + Math.imul(al7, bl5) | 0;\n  mid = mid + Math.imul(al7, bh5) | 0;\n  mid = mid + Math.imul(ah7, bl5) | 0;\n  hi = hi + Math.imul(ah7, bh5) | 0;\n  lo = lo + Math.imul(al6, bl6) | 0;\n  mid = mid + Math.imul(al6, bh6) | 0;\n  mid = mid + Math.imul(ah6, bl6) | 0;\n  hi = hi + Math.imul(ah6, bh6) | 0;\n  lo = lo + Math.imul(al5, bl7) | 0;\n  mid = mid + Math.imul(al5, bh7) | 0;\n  mid = mid + Math.imul(ah5, bl7) | 0;\n  hi = hi + Math.imul(ah5, bh7) | 0;\n  lo = lo + Math.imul(al4, bl8) | 0;\n  mid = mid + Math.imul(al4, bh8) | 0;\n  mid = mid + Math.imul(ah4, bl8) | 0;\n  hi = hi + Math.imul(ah4, bh8) | 0;\n  lo = lo + Math.imul(al3, bl9) | 0;\n  mid = mid + Math.imul(al3, bh9) | 0;\n  mid = mid + Math.imul(ah3, bl9) | 0;\n  hi = hi + Math.imul(ah3, bh9) | 0;\n  let w12 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n  c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;\n  w12 &= 0x3ffffff;\n  /* k = 13 */\n\n  lo = Math.imul(al9, bl4);\n  mid = Math.imul(al9, bh4);\n  mid = mid + Math.imul(ah9, bl4) | 0;\n  hi = Math.imul(ah9, bh4);\n  lo = lo + Math.imul(al8, bl5) | 0;\n  mid = mid + Math.imul(al8, bh5) | 0;\n  mid = mid + Math.imul(ah8, bl5) | 0;\n  hi = hi + Math.imul(ah8, bh5) | 0;\n  lo = lo + Math.imul(al7, bl6) | 0;\n  mid = mid + Math.imul(al7, bh6) | 0;\n  mid = mid + Math.imul(ah7, bl6) | 0;\n  hi = hi + Math.imul(ah7, bh6) | 0;\n  lo = lo + Math.imul(al6, bl7) | 0;\n  mid = mid + Math.imul(al6, bh7) | 0;\n  mid = mid + Math.imul(ah6, bl7) | 0;\n  hi = hi + Math.imul(ah6, bh7) | 0;\n  lo = lo + Math.imul(al5, bl8) | 0;\n  mid = mid + Math.imul(al5, bh8) | 0;\n  mid = mid + Math.imul(ah5, bl8) | 0;\n  hi = hi + Math.imul(ah5, bh8) | 0;\n  lo = lo + Math.imul(al4, bl9) | 0;\n  mid = mid + Math.imul(al4, bh9) | 0;\n  mid = mid + Math.imul(ah4, bl9) | 0;\n  hi = hi + Math.imul(ah4, bh9) | 0;\n  let w13 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n  c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;\n  w13 &= 0x3ffffff;\n  /* k = 14 */\n\n  lo = Math.imul(al9, bl5);\n  mid = Math.imul(al9, bh5);\n  mid = mid + Math.imul(ah9, bl5) | 0;\n  hi = Math.imul(ah9, bh5);\n  lo = lo + Math.imul(al8, bl6) | 0;\n  mid = mid + Math.imul(al8, bh6) | 0;\n  mid = mid + Math.imul(ah8, bl6) | 0;\n  hi = hi + Math.imul(ah8, bh6) | 0;\n  lo = lo + Math.imul(al7, bl7) | 0;\n  mid = mid + Math.imul(al7, bh7) | 0;\n  mid = mid + Math.imul(ah7, bl7) | 0;\n  hi = hi + Math.imul(ah7, bh7) | 0;\n  lo = lo + Math.imul(al6, bl8) | 0;\n  mid = mid + Math.imul(al6, bh8) | 0;\n  mid = mid + Math.imul(ah6, bl8) | 0;\n  hi = hi + Math.imul(ah6, bh8) | 0;\n  lo = lo + Math.imul(al5, bl9) | 0;\n  mid = mid + Math.imul(al5, bh9) | 0;\n  mid = mid + Math.imul(ah5, bl9) | 0;\n  hi = hi + Math.imul(ah5, bh9) | 0;\n  let w14 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n  c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;\n  w14 &= 0x3ffffff;\n  /* k = 15 */\n\n  lo = Math.imul(al9, bl6);\n  mid = Math.imul(al9, bh6);\n  mid = mid + Math.imul(ah9, bl6) | 0;\n  hi = Math.imul(ah9, bh6);\n  lo = lo + Math.imul(al8, bl7) | 0;\n  mid = mid + Math.imul(al8, bh7) | 0;\n  mid = mid + Math.imul(ah8, bl7) | 0;\n  hi = hi + Math.imul(ah8, bh7) | 0;\n  lo = lo + Math.imul(al7, bl8) | 0;\n  mid = mid + Math.imul(al7, bh8) | 0;\n  mid = mid + Math.imul(ah7, bl8) | 0;\n  hi = hi + Math.imul(ah7, bh8) | 0;\n  lo = lo + Math.imul(al6, bl9) | 0;\n  mid = mid + Math.imul(al6, bh9) | 0;\n  mid = mid + Math.imul(ah6, bl9) | 0;\n  hi = hi + Math.imul(ah6, bh9) | 0;\n  let w15 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n  c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;\n  w15 &= 0x3ffffff;\n  /* k = 16 */\n\n  lo = Math.imul(al9, bl7);\n  mid = Math.imul(al9, bh7);\n  mid = mid + Math.imul(ah9, bl7) | 0;\n  hi = Math.imul(ah9, bh7);\n  lo = lo + Math.imul(al8, bl8) | 0;\n  mid = mid + Math.imul(al8, bh8) | 0;\n  mid = mid + Math.imul(ah8, bl8) | 0;\n  hi = hi + Math.imul(ah8, bh8) | 0;\n  lo = lo + Math.imul(al7, bl9) | 0;\n  mid = mid + Math.imul(al7, bh9) | 0;\n  mid = mid + Math.imul(ah7, bl9) | 0;\n  hi = hi + Math.imul(ah7, bh9) | 0;\n  let w16 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n  c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;\n  w16 &= 0x3ffffff;\n  /* k = 17 */\n\n  lo = Math.imul(al9, bl8);\n  mid = Math.imul(al9, bh8);\n  mid = mid + Math.imul(ah9, bl8) | 0;\n  hi = Math.imul(ah9, bh8);\n  lo = lo + Math.imul(al8, bl9) | 0;\n  mid = mid + Math.imul(al8, bh9) | 0;\n  mid = mid + Math.imul(ah8, bl9) | 0;\n  hi = hi + Math.imul(ah8, bh9) | 0;\n  let w17 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n  c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;\n  w17 &= 0x3ffffff;\n  /* k = 18 */\n\n  lo = Math.imul(al9, bl9);\n  mid = Math.imul(al9, bh9);\n  mid = mid + Math.imul(ah9, bl9) | 0;\n  hi = Math.imul(ah9, bh9);\n  let w18 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n  c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;\n  w18 &= 0x3ffffff;\n  o[0] = w0;\n  o[1] = w1;\n  o[2] = w2;\n  o[3] = w3;\n  o[4] = w4;\n  o[5] = w5;\n  o[6] = w6;\n  o[7] = w7;\n  o[8] = w8;\n  o[9] = w9;\n  o[10] = w10;\n  o[11] = w11;\n  o[12] = w12;\n  o[13] = w13;\n  o[14] = w14;\n  o[15] = w15;\n  o[16] = w16;\n  o[17] = w17;\n  o[18] = w18;\n\n  if (c !== 0) {\n    o[19] = c;\n    out.length += 1;\n  } // Note: we shouldn't need to strip here.\n\n\n  return out;\n} // Polyfill comb.\n\n\nif (!Math.imul) comb10MulTo = smallMulTo;\n/*\n * Expose\n */\n\nBN.Red = Red;\nmodule.exports = BN;","map":null,"metadata":{},"sourceType":"script"}