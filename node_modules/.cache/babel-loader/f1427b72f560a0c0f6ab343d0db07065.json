{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _require = require('./utils'),\n    difference = _require.difference;\n\nvar EventEmitter = require('events');\n\nvar DEFAULT_OPTIONS = {\n  start: true,\n  pollInterval: 1000\n};\n\nvar IpfsPubsubPeerMonitor = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(IpfsPubsubPeerMonitor, _EventEmitter);\n\n  var _super = _createSuper(IpfsPubsubPeerMonitor);\n\n  function IpfsPubsubPeerMonitor(ipfsPubsub, topic, options) {\n    var _this;\n\n    _classCallCheck(this, IpfsPubsubPeerMonitor);\n\n    _this = _super.call(this);\n    _this._pubsub = ipfsPubsub;\n    _this._topic = topic;\n    _this._options = Object.assign({}, DEFAULT_OPTIONS, options);\n    _this._peers = [];\n    _this._interval = null;\n    if (_this._options.start) _this.start();\n    return _this;\n  }\n\n  _createClass(IpfsPubsubPeerMonitor, [{\n    key: \"started\",\n    get: function get() {\n      return this._interval !== null;\n    },\n    set: function set(val) {\n      throw new Error(\"'started' is read-only\");\n    }\n  }, {\n    key: \"start\",\n    value: function start() {\n      if (this._interval) this.stop();\n      this._interval = setInterval(this._pollPeers.bind(this), this._options.pollInterval);\n\n      this._pollPeers();\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      clearInterval(this._interval);\n      this._interval = null;\n      this.removeAllListeners('error');\n      this.removeAllListeners('join');\n      this.removeAllListeners('leave');\n    }\n  }, {\n    key: \"getPeers\",\n    value: function () {\n      var _getPeers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this._pubsub.peers(this._topic);\n\n              case 2:\n                this._peers = _context.sent;\n                return _context.abrupt(\"return\", this._peers.slice());\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getPeers() {\n        return _getPeers.apply(this, arguments);\n      }\n\n      return getPeers;\n    }()\n  }, {\n    key: \"hasPeer\",\n    value: function hasPeer(peer) {\n      return this._peers.includes(peer);\n    }\n  }, {\n    key: \"_pollPeers\",\n    value: function () {\n      var _pollPeers2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var peers;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.prev = 0;\n                _context2.next = 3;\n                return this._pubsub.peers(this._topic);\n\n              case 3:\n                peers = _context2.sent;\n\n                IpfsPubsubPeerMonitor._emitJoinsAndLeaves(new Set(this._peers), new Set(peers), this);\n\n                this._peers = peers;\n                _context2.next = 12;\n                break;\n\n              case 8:\n                _context2.prev = 8;\n                _context2.t0 = _context2[\"catch\"](0);\n                clearInterval(this._interval);\n                this.emit('error', _context2.t0);\n\n              case 12:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[0, 8]]);\n      }));\n\n      function _pollPeers() {\n        return _pollPeers2.apply(this, arguments);\n      }\n\n      return _pollPeers;\n    }()\n  }], [{\n    key: \"_emitJoinsAndLeaves\",\n    value: function _emitJoinsAndLeaves(oldValues, newValues, events) {\n      var emitJoin = function emitJoin(addedPeer) {\n        return events.emit('join', addedPeer);\n      };\n\n      var emitLeave = function emitLeave(removedPeer) {\n        return events.emit('leave', removedPeer);\n      };\n\n      difference(newValues, oldValues).forEach(emitJoin);\n      difference(oldValues, newValues).forEach(emitLeave);\n    }\n  }]);\n\n  return IpfsPubsubPeerMonitor;\n}(EventEmitter);\n\nmodule.exports = IpfsPubsubPeerMonitor;","map":null,"metadata":{},"sourceType":"script"}