{"ast":null,"code":"'use strict';\n\nconst PeerId = require('peer-id');\n\nconst {\n  Key,\n  Errors\n} = require('interface-datastore');\n\nconst errcode = require('err-code');\n\nconst debug = require('debug');\n\nconst log = debug('ipfs:ipns:publisher');\nlog.error = debug('ipfs:ipns:publisher:error');\n\nconst ipns = require('ipns');\n\nconst ERR_NOT_FOUND = Errors.notFoundError().code;\nconst defaultRecordLifetime = 60 * 60 * 1000; // IpnsPublisher is capable of publishing and resolving names to the IPFS routing system.\n\nclass IpnsPublisher {\n  constructor(routing, datastore) {\n    this._routing = routing;\n    this._datastore = datastore;\n  } // publish record with a eol\n\n\n  async publishWithEOL(privKey, value, lifetime) {\n    if (!privKey || !privKey.bytes) {\n      throw errcode(new Error('invalid private key'), 'ERR_INVALID_PRIVATE_KEY');\n    }\n\n    const peerId = await PeerId.createFromPrivKey(privKey.bytes);\n    const record = await this._updateOrCreateRecord(privKey, value, lifetime, peerId);\n    return this._putRecordToRouting(record, peerId);\n  } // Accepts a keypair, as well as a value (ipfsPath), and publishes it out to the routing system\n\n\n  async publish(privKey, value) {\n    // eslint-disable-line require-await\n    return this.publishWithEOL(privKey, value, defaultRecordLifetime);\n  }\n\n  async _putRecordToRouting(record, peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      const errMsg = 'peerId received is not valid';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID');\n    }\n\n    const publicKey = peerId._pubKey;\n    const embedPublicKeyRecord = await ipns.embedPublicKey(publicKey, record);\n    const keys = ipns.getIdKeys(peerId.toBytes());\n    await this._publishEntry(keys.routingKey, embedPublicKeyRecord || record, peerId); // Publish the public key to support old go-ipfs nodes that are looking for it in the routing\n    // We will be able to deprecate this part in the future, since the public keys will be only\n    // in IPNS record and the peerId.\n\n    await this._publishPublicKey(keys.routingPubKey, publicKey);\n    return embedPublicKeyRecord || record;\n  }\n\n  async _publishEntry(key, entry) {\n    if (!Key.isKey(key)) {\n      const errMsg = 'datastore key does not have a valid format';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY');\n    }\n\n    let entryData;\n\n    try {\n      // Marshal record\n      entryData = ipns.marshal(entry);\n    } catch (err) {\n      log.error(err);\n      throw err;\n    } // Add record to routing (buffer key)\n\n\n    try {\n      const res = await this._routing.put(key.toBuffer(), entryData);\n      log(`ipns record for ${key.toString('base64')} was stored in the routing`);\n      return res;\n    } catch (err) {\n      const errMsg = `ipns record for ${key.toString('base64')} could not be stored in the routing`;\n      log.error(errMsg);\n      log.error(err);\n      throw errcode(new Error(errMsg), 'ERR_PUTTING_TO_ROUTING');\n    }\n  }\n\n  async _publishPublicKey(key, publicKey) {\n    if (!Key.isKey(key)) {\n      const errMsg = 'datastore key does not have a valid format';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY');\n    }\n\n    if (!publicKey || !publicKey.bytes) {\n      const errMsg = 'one or more of the provided parameters are not defined';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_UNDEFINED_PARAMETER');\n    } // Add public key to routing (buffer key)\n\n\n    try {\n      const res = await this._routing.put(key.toBuffer(), publicKey.bytes);\n      log(`public key for ${key.toString('base64')} was stored in the routing`);\n      return res;\n    } catch (err) {\n      const errMsg = `public key for ${key.toString('base64')} could not be stored in the routing`;\n      log.error(errMsg);\n      log.error(err);\n      throw errcode(new Error(errMsg), 'ERR_PUTTING_TO_ROUTING');\n    }\n  } // Returns the record this node has published corresponding to the given peer ID.\n  // If `checkRouting` is true and we have no existing record, this method will check the routing system for any existing records.\n\n\n  async _getPublished(peerId, options) {\n    if (!PeerId.isPeerId(peerId)) {\n      const errMsg = 'peerId received is not valid';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID');\n    }\n\n    options = options || {};\n    const checkRouting = options.checkRouting !== false;\n\n    try {\n      const dsVal = await this._datastore.get(ipns.getLocalKey(peerId.id)); // unmarshal data\n\n      return this._unmarshalData(dsVal);\n    } catch (err) {\n      if (err.code !== ERR_NOT_FOUND) {\n        const errMsg = `unexpected error getting the ipns record ${peerId.id} from datastore`;\n        log.error(errMsg);\n        throw errcode(new Error(errMsg), 'ERR_UNEXPECTED_DATASTORE_RESPONSE');\n      }\n\n      if (!checkRouting) {\n        throw errcode(err);\n      } // Try to get from routing\n\n\n      try {\n        const keys = ipns.getIdKeys(peerId.toBytes());\n        const res = await this._routing.get(keys.routingKey.toBuffer()); // unmarshal data\n\n        return this._unmarshalData(res);\n      } catch (err) {\n        log.error(err);\n        throw err;\n      }\n    }\n  }\n\n  _unmarshalData(data) {\n    try {\n      return ipns.unmarshal(data);\n    } catch (err) {\n      throw errcode(err, 'ERR_INVALID_RECORD_DATA');\n    }\n  }\n\n  async _updateOrCreateRecord(privKey, value, validity, peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      const errMsg = 'peerId received is not valid';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID');\n    }\n\n    const getPublishedOptions = {\n      checkRouting: true\n    };\n    let record;\n\n    try {\n      record = await this._getPublished(peerId, getPublishedOptions);\n    } catch (err) {\n      if (err.code !== ERR_NOT_FOUND) {\n        const errMsg = `unexpected error when determining the last published IPNS record for ${peerId.id}`;\n        log.error(errMsg);\n        throw errcode(new Error(errMsg), 'ERR_DETERMINING_PUBLISHED_RECORD');\n      }\n    } // Determinate the record sequence number\n\n\n    let seqNumber = 0;\n\n    if (record && record.sequence !== undefined) {\n      seqNumber = record.value.toString() !== value ? record.sequence + 1 : record.sequence;\n    }\n\n    let entryData;\n\n    try {\n      // Create record\n      entryData = await ipns.create(privKey, value, seqNumber, validity);\n    } catch (err) {\n      const errMsg = `ipns record for ${value} could not be created`;\n      log.error(err);\n      throw errcode(new Error(errMsg), 'ERR_CREATING_IPNS_RECORD');\n    } // TODO IMPROVEMENT - set ttl (still experimental feature for go)\n\n\n    try {\n      // Marshal record\n      const data = ipns.marshal(entryData); // Store the new record\n\n      await this._datastore.put(ipns.getLocalKey(peerId.id), data);\n      log(`ipns record for ${value} was stored in the datastore`);\n      return entryData;\n    } catch (err) {\n      const errMsg = `ipns record for ${value} could not be stored in the datastore`;\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_STORING_IN_DATASTORE');\n    }\n  }\n\n}\n\nIpnsPublisher.defaultRecordLifetime = defaultRecordLifetime;\nexports = module.exports = IpnsPublisher;","map":null,"metadata":{},"sourceType":"script"}