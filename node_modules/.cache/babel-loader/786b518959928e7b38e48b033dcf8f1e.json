{"ast":null,"code":"\"use strict\"; // Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Package binary provides functions for encoding and decoding numbers in byte arrays.\n */\n\nvar int_1 = require(\"@stablelib/int\"); // TODO(dchest): add asserts for correct value ranges and array offsets.\n\n/**\n * Reads 2 bytes from array starting at offset as big-endian\n * signed 16-bit integer and returns it.\n */\n\n\nfunction readInt16BE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  return (array[offset + 0] << 8 | array[offset + 1]) << 16 >> 16;\n}\n\nexports.readInt16BE = readInt16BE;\n/**\n * Reads 2 bytes from array starting at offset as big-endian\n * unsigned 16-bit integer and returns it.\n */\n\nfunction readUint16BE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  return (array[offset + 0] << 8 | array[offset + 1]) >>> 0;\n}\n\nexports.readUint16BE = readUint16BE;\n/**\n * Reads 2 bytes from array starting at offset as little-endian\n * signed 16-bit integer and returns it.\n */\n\nfunction readInt16LE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  return (array[offset + 1] << 8 | array[offset]) << 16 >> 16;\n}\n\nexports.readInt16LE = readInt16LE;\n/**\n * Reads 2 bytes from array starting at offset as little-endian\n * unsigned 16-bit integer and returns it.\n */\n\nfunction readUint16LE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  return (array[offset + 1] << 8 | array[offset]) >>> 0;\n}\n\nexports.readUint16LE = readUint16LE;\n/**\n * Writes 2-byte big-endian representation of 16-bit unsigned\n * value to byte array starting at offset.\n *\n * If byte array is not given, creates a new 2-byte one.\n *\n * Returns the output byte array.\n */\n\nfunction writeUint16BE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(2);\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  out[offset + 0] = value >>> 8;\n  out[offset + 1] = value >>> 0;\n  return out;\n}\n\nexports.writeUint16BE = writeUint16BE;\nexports.writeInt16BE = writeUint16BE;\n/**\n * Writes 2-byte little-endian representation of 16-bit unsigned\n * value to array starting at offset.\n *\n * If byte array is not given, creates a new 2-byte one.\n *\n * Returns the output byte array.\n */\n\nfunction writeUint16LE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(2);\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  out[offset + 0] = value >>> 0;\n  out[offset + 1] = value >>> 8;\n  return out;\n}\n\nexports.writeUint16LE = writeUint16LE;\nexports.writeInt16LE = writeUint16LE;\n/**\n * Reads 4 bytes from array starting at offset as big-endian\n * signed 32-bit integer and returns it.\n */\n\nfunction readInt32BE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  return array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3];\n}\n\nexports.readInt32BE = readInt32BE;\n/**\n * Reads 4 bytes from array starting at offset as big-endian\n * unsigned 32-bit integer and returns it.\n */\n\nfunction readUint32BE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  return (array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3]) >>> 0;\n}\n\nexports.readUint32BE = readUint32BE;\n/**\n * Reads 4 bytes from array starting at offset as little-endian\n * signed 32-bit integer and returns it.\n */\n\nfunction readInt32LE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  return array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset];\n}\n\nexports.readInt32LE = readInt32LE;\n/**\n * Reads 4 bytes from array starting at offset as little-endian\n * unsigned 32-bit integer and returns it.\n */\n\nfunction readUint32LE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  return (array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset]) >>> 0;\n}\n\nexports.readUint32LE = readUint32LE;\n/**\n * Writes 4-byte big-endian representation of 32-bit unsigned\n * value to byte array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\n\nfunction writeUint32BE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(4);\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  out[offset + 0] = value >>> 24;\n  out[offset + 1] = value >>> 16;\n  out[offset + 2] = value >>> 8;\n  out[offset + 3] = value >>> 0;\n  return out;\n}\n\nexports.writeUint32BE = writeUint32BE;\nexports.writeInt32BE = writeUint32BE;\n/**\n * Writes 4-byte little-endian representation of 32-bit unsigned\n * value to array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\n\nfunction writeUint32LE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(4);\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  out[offset + 0] = value >>> 0;\n  out[offset + 1] = value >>> 8;\n  out[offset + 2] = value >>> 16;\n  out[offset + 3] = value >>> 24;\n  return out;\n}\n\nexports.writeUint32LE = writeUint32LE;\nexports.writeInt32LE = writeUint32LE;\n/**\n * Reads 8 bytes from array starting at offset as big-endian\n * signed 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports exact\n * numbers in range -9007199254740991 to 9007199254740991.\n * If the number stored in the byte array is outside this range,\n * the result is not exact.\n */\n\nfunction readInt64BE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  var hi = readInt32BE(array, offset);\n  var lo = readInt32BE(array, offset + 4);\n  return hi * 0x100000000 + lo - (lo >> 31) * 0x100000000;\n}\n\nexports.readInt64BE = readInt64BE;\n/**\n * Reads 8 bytes from array starting at offset as big-endian\n * unsigned 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.\n */\n\nfunction readUint64BE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  var hi = readUint32BE(array, offset);\n  var lo = readUint32BE(array, offset + 4);\n  return hi * 0x100000000 + lo;\n}\n\nexports.readUint64BE = readUint64BE;\n/**\n * Reads 8 bytes from array starting at offset as little-endian\n * signed 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports exact\n * numbers in range -9007199254740991 to 9007199254740991.\n * If the number stored in the byte array is outside this range,\n * the result is not exact.\n */\n\nfunction readInt64LE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  var lo = readInt32LE(array, offset);\n  var hi = readInt32LE(array, offset + 4);\n  return hi * 0x100000000 + lo - (lo >> 31) * 0x100000000;\n}\n\nexports.readInt64LE = readInt64LE;\n/**\n * Reads 8 bytes from array starting at offset as little-endian\n * unsigned 64-bit integer and returns it.\n *\n * IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.\n */\n\nfunction readUint64LE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  var lo = readUint32LE(array, offset);\n  var hi = readUint32LE(array, offset + 4);\n  return hi * 0x100000000 + lo;\n}\n\nexports.readUint64LE = readUint64LE;\n/**\n * Writes 8-byte big-endian representation of 64-bit unsigned\n * value to byte array starting at offset.\n *\n * Due to JavaScript limitation, supports values up to 2^53-1.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\n\nfunction writeUint64BE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(8);\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  writeUint32BE(value / 0x100000000 >>> 0, out, offset);\n  writeUint32BE(value >>> 0, out, offset + 4);\n  return out;\n}\n\nexports.writeUint64BE = writeUint64BE;\nexports.writeInt64BE = writeUint64BE;\n/**\n * Writes 8-byte little-endian representation of 64-bit unsigned\n * value to byte array starting at offset.\n *\n * Due to JavaScript limitation, supports values up to 2^53-1.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\n\nfunction writeUint64LE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(8);\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  writeUint32LE(value >>> 0, out, offset);\n  writeUint32LE(value / 0x100000000 >>> 0, out, offset + 4);\n  return out;\n}\n\nexports.writeUint64LE = writeUint64LE;\nexports.writeInt64LE = writeUint64LE;\n/**\n * Reads bytes from array starting at offset as big-endian\n * unsigned bitLen-bit integer and returns it.\n *\n * Supports bit lengths divisible by 8, up to 48.\n */\n\nfunction readUintBE(bitLength, array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  } // TODO(dchest): implement support for bitLengths non-divisible by 8\n\n\n  if (bitLength % 8 !== 0) {\n    throw new Error(\"readUintBE supports only bitLengths divisible by 8\");\n  }\n\n  if (bitLength / 8 > array.length - offset) {\n    throw new Error(\"readUintBE: array is too short for the given bitLength\");\n  }\n\n  var result = 0;\n  var mul = 1;\n\n  for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {\n    result += array[i] * mul;\n    mul *= 256;\n  }\n\n  return result;\n}\n\nexports.readUintBE = readUintBE;\n/**\n * Reads bytes from array starting at offset as little-endian\n * unsigned bitLen-bit integer and returns it.\n *\n * Supports bit lengths divisible by 8, up to 48.\n */\n\nfunction readUintLE(bitLength, array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  } // TODO(dchest): implement support for bitLengths non-divisible by 8\n\n\n  if (bitLength % 8 !== 0) {\n    throw new Error(\"readUintLE supports only bitLengths divisible by 8\");\n  }\n\n  if (bitLength / 8 > array.length - offset) {\n    throw new Error(\"readUintLE: array is too short for the given bitLength\");\n  }\n\n  var result = 0;\n  var mul = 1;\n\n  for (var i = offset; i < offset + bitLength / 8; i++) {\n    result += array[i] * mul;\n    mul *= 256;\n  }\n\n  return result;\n}\n\nexports.readUintLE = readUintLE;\n/**\n * Writes a big-endian representation of bitLen-bit unsigned\n * value to array starting at offset.\n *\n * Supports bit lengths divisible by 8, up to 48.\n *\n * If byte array is not given, creates a new one.\n *\n * Returns the output byte array.\n */\n\nfunction writeUintBE(bitLength, value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(bitLength / 8);\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  } // TODO(dchest): implement support for bitLengths non-divisible by 8\n\n\n  if (bitLength % 8 !== 0) {\n    throw new Error(\"writeUintBE supports only bitLengths divisible by 8\");\n  }\n\n  if (!int_1.isSafeInteger(value)) {\n    throw new Error(\"writeUintBE value must be an integer\");\n  }\n\n  var div = 1;\n\n  for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {\n    out[i] = value / div & 0xff;\n    div *= 256;\n  }\n\n  return out;\n}\n\nexports.writeUintBE = writeUintBE;\n/**\n * Writes a little-endian representation of bitLen-bit unsigned\n * value to array starting at offset.\n *\n * Supports bit lengths divisible by 8, up to 48.\n *\n * If byte array is not given, creates a new one.\n *\n * Returns the output byte array.\n */\n\nfunction writeUintLE(bitLength, value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(bitLength / 8);\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  } // TODO(dchest): implement support for bitLengths non-divisible by 8\n\n\n  if (bitLength % 8 !== 0) {\n    throw new Error(\"writeUintLE supports only bitLengths divisible by 8\");\n  }\n\n  if (!int_1.isSafeInteger(value)) {\n    throw new Error(\"writeUintLE value must be an integer\");\n  }\n\n  var div = 1;\n\n  for (var i = offset; i < offset + bitLength / 8; i++) {\n    out[i] = value / div & 0xff;\n    div *= 256;\n  }\n\n  return out;\n}\n\nexports.writeUintLE = writeUintLE;\n/**\n * Reads 4 bytes from array starting at offset as big-endian\n * 32-bit floating-point number and returns it.\n */\n\nfunction readFloat32BE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n  return view.getFloat32(offset);\n}\n\nexports.readFloat32BE = readFloat32BE;\n/**\n * Reads 4 bytes from array starting at offset as little-endian\n * 32-bit floating-point number and returns it.\n */\n\nfunction readFloat32LE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n  return view.getFloat32(offset, true);\n}\n\nexports.readFloat32LE = readFloat32LE;\n/**\n * Reads 8 bytes from array starting at offset as big-endian\n * 64-bit floating-point number (\"double\") and returns it.\n */\n\nfunction readFloat64BE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n  return view.getFloat64(offset);\n}\n\nexports.readFloat64BE = readFloat64BE;\n/**\n * Reads 8 bytes from array starting at offset as little-endian\n * 64-bit floating-point number (\"double\") and returns it.\n */\n\nfunction readFloat64LE(array, offset) {\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);\n  return view.getFloat64(offset, true);\n}\n\nexports.readFloat64LE = readFloat64LE;\n/**\n * Writes 4-byte big-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\n\nfunction writeFloat32BE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(4);\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n  view.setFloat32(offset, value);\n  return out;\n}\n\nexports.writeFloat32BE = writeFloat32BE;\n/**\n * Writes 4-byte little-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 4-byte one.\n *\n * Returns the output byte array.\n */\n\nfunction writeFloat32LE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(4);\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n  view.setFloat32(offset, value, true);\n  return out;\n}\n\nexports.writeFloat32LE = writeFloat32LE;\n/**\n * Writes 8-byte big-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\n\nfunction writeFloat64BE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(8);\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n  view.setFloat64(offset, value);\n  return out;\n}\n\nexports.writeFloat64BE = writeFloat64BE;\n/**\n * Writes 8-byte little-endian floating-point representation of value\n * to byte array starting at offset.\n *\n * If byte array is not given, creates a new 8-byte one.\n *\n * Returns the output byte array.\n */\n\nfunction writeFloat64LE(value, out, offset) {\n  if (out === void 0) {\n    out = new Uint8Array(8);\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);\n  view.setFloat64(offset, value, true);\n  return out;\n}\n\nexports.writeFloat64LE = writeFloat64LE;","map":null,"metadata":{},"sourceType":"script"}