{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tweetnacl_1 = __importDefault(require(\"tweetnacl\"));\n\nvar tweetnacl_util_1 = __importDefault(require(\"tweetnacl-util\"));\n\nvar hdnode_1 = require(\"@ethersproject/hdnode\");\n\nvar wallet_1 = require(\"@ethersproject/wallet\");\n\nvar did_jwt_1 = require(\"did-jwt\");\n\nvar js_sha256_1 = require(\"js-sha256\");\n\nvar elliptic_1 = require(\"elliptic\");\n\nvar crypto_1 = require(\"./crypto\");\n\nvar utils_1 = require(\"./utils\");\n\nvar ec = new elliptic_1.ec('secp256k1');\nvar BASE_PATH = \"m/51073068'/0'\";\nvar ROOT_STORE_PATH = \"0'/0'/0'/0'/0'/0'/0'/0'\";\nvar BASE_PATH_LEGACY = \"m/7696500'/0'/0'\";\nvar AUTH_PATH_WALLET = BASE_PATH + '/' + ROOT_STORE_PATH + '/0';\nvar AUTH_PATH_ENCRYPTION = BASE_PATH + '/' + ROOT_STORE_PATH + '/3';\n\nvar ensure0x = function ensure0x(str) {\n  return (str.startsWith('0x') ? '' : '0x') + str;\n};\n\nvar Keyring = /*#__PURE__*/function () {\n  function Keyring(seed, migratedKeys) {\n    _classCallCheck(this, Keyring);\n\n    this._spaceKeys = {};\n    this._migratedKeys = false;\n\n    if (seed) {\n      this._seed = seed;\n      this._baseNode = hdnode_1.HDNode.fromSeed(this._seed).derivePath(BASE_PATH);\n\n      var rootNode = this._baseNode.derivePath(ROOT_STORE_PATH);\n\n      this._rootKeys = this._deriveRootKeySet(rootNode);\n    }\n\n    if (migratedKeys) {\n      this._migratedKeys = true;\n\n      this._importMigratedKeys(migratedKeys);\n    }\n\n    if (!(seed || migratedKeys)) throw new Error('One or both of seed or migratedKeys required');\n  }\n\n  _createClass(Keyring, [{\n    key: \"_importMigratedKeys\",\n    value: function _importMigratedKeys(migratedKeysString) {\n      var _this = this;\n\n      var migratedKeys = JSON.parse(migratedKeysString);\n\n      var getHDNode = function getHDNode(seed) {\n        var seedNode = hdnode_1.HDNode.fromSeed(seed);\n        return seedNode.derivePath(BASE_PATH_LEGACY);\n      };\n\n      var rootNode = getHDNode(migratedKeys.seed);\n      this._rootKeys = this._deriveRootKeySet(rootNode);\n      this._rootKeys.managementAddress = migratedKeys.managementAddress;\n      this._rootKeys.managementKey = {\n        address: migratedKeys.managementAddress\n      };\n      Object.keys(migratedKeys.spaceSeeds).map(function (name) {\n        var spaceNode = getHDNode(migratedKeys.spaceSeeds[name]);\n        _this._spaceKeys[name] = _this._deriveKeySet(spaceNode);\n      });\n    }\n  }, {\n    key: \"_deriveKeySet\",\n    value: function _deriveKeySet(hdNode) {\n      return {\n        signingKey: hdNode.derivePath('0'),\n        asymEncryptionKey: tweetnacl_1.default.box.keyPair.fromSecretKey(new Uint8Array(Buffer.from(hdNode.derivePath('2').privateKey.slice(2), 'hex'))),\n        symEncryptionKey: utils_1.hexToUint8Array(hdNode.derivePath('3').privateKey.slice(2))\n      };\n    }\n  }, {\n    key: \"_deriveRootKeySet\",\n    value: function _deriveRootKeySet(hdNode) {\n      return Object.assign(Object.assign({}, this._deriveKeySet(hdNode)), {\n        managementKey: hdNode.derivePath('1')\n      });\n    }\n  }, {\n    key: \"_deriveSpaceKeys\",\n    value: function _deriveSpaceKeys(space) {\n      var _a, _b;\n\n      var spaceHash = js_sha256_1.sha256(\"\".concat(space, \".3box\"));\n      var spacePath = (_b = (_a = spaceHash.match(/.{1,12}/g)) === null || _a === void 0 ? void 0 : _a.map(function (n) {\n        return parseInt(n, 16).toString(2);\n      }).map(function (n) {\n        return \"\".concat(n.length === 47 ? '0' : '').concat(n);\n      }).join('').match(/.{1,31}/g)) === null || _b === void 0 ? void 0 : _b.map(function (n) {\n        return parseInt(n, 2);\n      }).join(\"'/\");\n\n      var spaceNode = this._baseNode.derivePath(\"\".concat(spacePath, \"'\"));\n\n      this._spaceKeys[space] = this._deriveKeySet(spaceNode);\n    }\n  }, {\n    key: \"_getKeys\",\n    value: function _getKeys(space) {\n      if (!space) {\n        return this._rootKeys;\n      } else if (!this._spaceKeys[space]) {\n        if (this._migratedKeys) throw new Error('Can not derive space keys, not given in migrated keys');\n\n        this._deriveSpaceKeys(space);\n      }\n\n      return this._spaceKeys[space];\n    }\n  }, {\n    key: \"asymEncrypt\",\n    value: function asymEncrypt(msg, toPublic) {\n      var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n          nonce = _ref.nonce;\n\n      return crypto_1.asymEncrypt(msg, toPublic, nonce);\n    }\n  }, {\n    key: \"asymDecrypt\",\n    value: function asymDecrypt(ciphertext, fromPublic, nonce) {\n      var _ref2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n          space = _ref2.space,\n          toBuffer = _ref2.toBuffer;\n\n      var key = this._getKeys(space).asymEncryptionKey.secretKey;\n\n      return crypto_1.asymDecrypt(ciphertext, fromPublic, key, nonce, toBuffer);\n    }\n  }, {\n    key: \"symEncrypt\",\n    value: function symEncrypt(msg) {\n      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          space = _ref3.space,\n          nonce = _ref3.nonce;\n\n      return crypto_1.symEncryptBase(msg, this._getKeys(space).symEncryptionKey, nonce);\n    }\n  }, {\n    key: \"symDecrypt\",\n    value: function symDecrypt(ciphertext, nonce) {\n      var _ref4 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n          space = _ref4.space,\n          toBuffer = _ref4.toBuffer;\n\n      return crypto_1.symDecryptBase(ciphertext, this._getKeys(space).symEncryptionKey, nonce, toBuffer);\n    }\n  }, {\n    key: \"managementPersonalSign\",\n    value: function managementPersonalSign(message) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var wallet;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                wallet = this.managementWallet();\n                _context.next = 3;\n                return wallet.signMessage(message);\n\n              case 3:\n                return _context.abrupt(\"return\", _context.sent);\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n  }, {\n    key: \"managementWallet\",\n    value: function managementWallet() {\n      var node = this._rootKeys.managementKey;\n      return new wallet_1.Wallet(node.privateKey);\n    }\n  }, {\n    key: \"getJWTSigner\",\n    value: function getJWTSigner(space, useMgmt) {\n      var pubkeys = this._getKeys(space);\n\n      var key = useMgmt ? pubkeys.managementKey : pubkeys.signingKey;\n      return did_jwt_1.EllipticSigner(key.privateKey.slice(2));\n    }\n  }, {\n    key: \"getRootSigner\",\n    value: function getRootSigner(keyId) {\n      var _a, _b;\n\n      var key = keyId === 'managementKey' ? (_a = this._rootKeys) === null || _a === void 0 ? void 0 : _a.managementKey : (_b = this._rootKeys) === null || _b === void 0 ? void 0 : _b.signingKey;\n\n      if (key == null || !(key instanceof hdnode_1.HDNode)) {\n        throw new Error('Invalid key');\n      }\n\n      return did_jwt_1.EllipticSigner(key.privateKey.slice(2));\n    }\n  }, {\n    key: \"getDBSalt\",\n    value: function getDBSalt(space) {\n      return js_sha256_1.sha256(this._getKeys(space).signingKey.derivePath('0').privateKey.slice(2));\n    }\n  }, {\n    key: \"getPublicKeys\",\n    value: function getPublicKeys() {\n      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          space = _ref5.space,\n          uncompressed = _ref5.uncompressed,\n          mgmtPub = _ref5.mgmtPub;\n\n      var keys = this._getKeys(space);\n\n      var signingKey = keys.signingKey.publicKey.slice(2);\n      var managementKey = space ? null : mgmtPub && keys.managementKey.publicKey ? keys.managementKey.publicKey.slice(2) : keys.managementKey.address;\n\n      if (uncompressed) {\n        signingKey = ec.keyFromPublic(Buffer.from(signingKey, 'hex')).getPublic(false, 'hex');\n      }\n\n      return {\n        signingKey: signingKey,\n        managementKey: managementKey,\n        asymEncryptionKey: tweetnacl_util_1.default.encodeBase64(keys.asymEncryptionKey.publicKey)\n      };\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      return this._seed;\n    }\n  }], [{\n    key: \"encryptWithAuthSecret\",\n    value: function encryptWithAuthSecret(message, authSecret) {\n      var node = hdnode_1.HDNode.fromSeed(ensure0x(authSecret)).derivePath(AUTH_PATH_ENCRYPTION);\n      var key = utils_1.hexToUint8Array(node.privateKey.slice(2));\n      return crypto_1.symEncryptBase(message, key);\n    }\n  }, {\n    key: \"decryptWithAuthSecret\",\n    value: function decryptWithAuthSecret(ciphertext, nonce, authSecret) {\n      var node = hdnode_1.HDNode.fromSeed(ensure0x(authSecret)).derivePath(AUTH_PATH_ENCRYPTION);\n      var key = utils_1.hexToUint8Array(node.privateKey.slice(2));\n      return crypto_1.symDecryptBase(ciphertext, key, nonce);\n    }\n  }, {\n    key: \"walletForAuthSecret\",\n    value: function walletForAuthSecret(authSecret) {\n      var node = hdnode_1.HDNode.fromSeed(ensure0x(authSecret)).derivePath(AUTH_PATH_WALLET);\n      return new wallet_1.Wallet(node.privateKey);\n    }\n  }]);\n\n  return Keyring;\n}();\n\nexports.default = Keyring;","map":null,"metadata":{},"sourceType":"script"}