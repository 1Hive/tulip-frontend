{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _createForOfIteratorHelper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar PeerDistanceList = require('../peer-list/peer-distance-list');\n\nvar EventEmitter = require('events');\n\nvar Path = require('./path');\n\nvar WorkerQueue = require('./workerQueue');\n\nvar utils = require('../utils');\n/**\n * Manages a single run of the query.\n */\n\n\nvar Run = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Run, _EventEmitter);\n\n  var _super = _createSuper(Run);\n\n  /**\n   * Creates a Run.\n   *\n   * @param {Query} query\n   */\n  function Run(query) {\n    var _this;\n\n    _classCallCheck(this, Run);\n\n    _this = _super.call(this);\n    _this.query = query;\n    _this.running = false;\n    _this.workers = []; // The peers that have been queried (including error responses)\n\n    _this.peersSeen = new Set(); // The errors received when querying peers\n\n    _this.errors = []; // The closest K peers that have been queried successfully\n    // (this member is initialized when the worker queues start)\n\n    _this.peersQueried = null;\n    return _this;\n  }\n  /**\n   * Stop all the workers\n   */\n\n\n  _createClass(Run, [{\n    key: \"stop\",\n    value: function stop() {\n      if (!this.running) {\n        return;\n      }\n\n      this.running = false;\n\n      var _iterator = _createForOfIteratorHelper(this.workers),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var worker = _step.value;\n          worker.stop();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    /**\n     * Execute the run with the given initial set of peers.\n     *\n     * @param {Array<PeerId>} peers\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"execute\",\n    value: function () {\n      var _execute = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(peers) {\n        var paths, numPaths, i, res, _i, _paths, path;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                paths = []; // array of states per disjoint path\n                // Create disjoint paths\n\n                numPaths = Math.min(this.query.dht.disjointPaths, peers.length);\n\n                for (i = 0; i < numPaths; i++) {\n                  paths.push(new Path(this, this.query.makePath(i, numPaths)));\n                } // Assign peers to paths round-robin style\n\n\n                peers.forEach(function (peer, i) {\n                  paths[i % numPaths].addInitialPeer(peer);\n                }); // Execute the query along each disjoint path\n\n                _context.next = 6;\n                return this.executePaths(paths);\n\n              case 6:\n                res = {\n                  // The closest K peers we were able to query successfully\n                  finalSet: new Set(this.peersQueried.peers),\n                  paths: []\n                }; // Collect the results from each completed path\n\n                for (_i = 0, _paths = paths; _i < _paths.length; _i++) {\n                  path = _paths[_i];\n\n                  if (path.res && (path.res.pathComplete || path.res.queryComplete)) {\n                    path.res.success = true;\n                    res.paths.push(path.res);\n                  }\n                }\n\n                return _context.abrupt(\"return\", res);\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function execute(_x) {\n        return _execute.apply(this, arguments);\n      }\n\n      return execute;\n    }()\n    /**\n     * Execute all paths through the DHT.\n     *\n     * @param {Array<Path>} paths\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"executePaths\",\n    value: function () {\n      var _executePaths = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(paths) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                this.running = true;\n                this.emit('start');\n                _context2.prev = 2;\n                _context2.next = 5;\n                return Promise.all(paths.map(function (path) {\n                  return path.execute();\n                }));\n\n              case 5:\n                _context2.prev = 5;\n                // Ensure all workers are stopped\n                this.stop(); // Completed the Run\n\n                this.emit('complete');\n                return _context2.finish(5);\n\n              case 9:\n                if (!(this.errors.length === this.peersSeen.size)) {\n                  _context2.next = 11;\n                  break;\n                }\n\n                throw this.errors[0];\n\n              case 11:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[2,, 5, 9]]);\n      }));\n\n      function executePaths(_x2) {\n        return _executePaths.apply(this, arguments);\n      }\n\n      return executePaths;\n    }()\n    /**\n     * Initialize the list of queried peers, then start a worker queue for the\n     * given path.\n     *\n     * @param {Path} path\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"workerQueue\",\n    value: function () {\n      var _workerQueue = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(path) {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.init();\n\n              case 2:\n                _context3.next = 4;\n                return this.startWorker(path);\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function workerQueue(_x3) {\n        return _workerQueue.apply(this, arguments);\n      }\n\n      return workerQueue;\n    }()\n    /**\n     * Create and start a worker queue for a particular path.\n     *\n     * @param {Path} path\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"startWorker\",\n    value: function () {\n      var _startWorker = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(path) {\n        var worker;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                worker = new WorkerQueue(this.query.dht, this, path, this.query._log);\n                this.workers.push(worker);\n                _context4.next = 4;\n                return worker.execute();\n\n              case 4:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function startWorker(_x4) {\n        return _startWorker.apply(this, arguments);\n      }\n\n      return startWorker;\n    }()\n    /**\n     * Initialize the list of closest peers we've queried - this is shared by all\n     * paths in the run.\n     *\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"init\",\n    value: function () {\n      var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        var _this2 = this;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (!this.peersQueried) {\n                  _context6.next = 2;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\");\n\n              case 2:\n                if (!this.peersQueriedPromise) {\n                  _context6.next = 6;\n                  break;\n                }\n\n                _context6.next = 5;\n                return this.peersQueriedPromise;\n\n              case 5:\n                return _context6.abrupt(\"return\");\n\n              case 6:\n                // This promise is temporarily stored so that others may await its completion\n                this.peersQueriedPromise = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n                  var dhtKey;\n                  return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n                    while (1) {\n                      switch (_context5.prev = _context5.next) {\n                        case 0:\n                          _context5.next = 2;\n                          return utils.convertBuffer(_this2.query.key);\n\n                        case 2:\n                          dhtKey = _context5.sent;\n                          _this2.peersQueried = new PeerDistanceList(dhtKey, _this2.query.dht.kBucketSize);\n\n                        case 4:\n                        case \"end\":\n                          return _context5.stop();\n                      }\n                    }\n                  }, _callee5);\n                }))(); // After PeerDistanceList is initialized, clean up\n\n                _context6.next = 9;\n                return this.peersQueriedPromise;\n\n              case 9:\n                delete this.peersQueriedPromise;\n\n              case 10:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function init() {\n        return _init.apply(this, arguments);\n      }\n\n      return init;\n    }()\n    /**\n     * If we've queried K peers, and the remaining peers in the given `worker`'s queue\n     * are all further from the key than the peers we've already queried, then we should\n     * stop querying on that `worker`.\n     *\n     * @param {WorkerQueue} worker\n     * @returns {Promise<Boolean>}\n     */\n\n  }, {\n    key: \"continueQuerying\",\n    value: function () {\n      var _continueQuerying = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(worker) {\n        var running, someCloser;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (!(this.peersQueried.length < this.peersQueried.capacity)) {\n                  _context7.next = 2;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", true);\n\n              case 2:\n                // Get all the peers that are currently being queried.\n                // Note that this function gets called right after a peer has been popped\n                // off the head of the closest peers queue so it will include that peer.\n                running = worker.queue.workersList().map(function (i) {\n                  return i.data;\n                }); // Check if any of the peers that are currently being queried are closer\n                // to the key than the peers we've already queried\n\n                _context7.next = 5;\n                return this.peersQueried.anyCloser(running);\n\n              case 5:\n                someCloser = _context7.sent;\n\n                if (!someCloser) {\n                  _context7.next = 8;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", true);\n\n              case 8:\n                return _context7.abrupt(\"return\", false);\n\n              case 9:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function continueQuerying(_x5) {\n        return _continueQuerying.apply(this, arguments);\n      }\n\n      return continueQuerying;\n    }()\n  }]);\n\n  return Run;\n}(EventEmitter);\n\nmodule.exports = Run;","map":null,"metadata":{},"sourceType":"script"}