{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar mkdir = require('./mkdir');\n\nvar stat = require('./stat');\n\nvar log = require('debug')('ipfs:mfs:cp');\n\nvar errCode = require('err-code');\n\nvar updateTree = require('./utils/update-tree');\n\nvar updateMfsRoot = require('./utils/update-mfs-root');\n\nvar addLink = require('./utils/add-link');\n\nvar applyDefaultOptions = require('./utils/apply-default-options');\n\nvar toMfsPath = require('./utils/to-mfs-path');\n\nvar toSourcesAndDestination = require('./utils/to-sources-and-destination');\n\nvar toTrail = require('./utils/to-trail');\n\nvar _require = require('../../utils'),\n    withTimeoutOption = _require.withTimeoutOption;\n\nvar defaultOptions = {\n  parents: false,\n  flush: true,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  shardSplitThreshold: 1000\n};\n\nmodule.exports = function (context) {\n  return withTimeoutOption( /*#__PURE__*/function () {\n    var _mfsCp = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var _len,\n          args,\n          _key,\n          options,\n          _yield$toSourcesAndDe,\n          sources,\n          destination,\n          missing,\n          destinationIsDirectory,\n          parentFolder,\n          destinationPath,\n          trail,\n          source,\n          destinationName,\n          _args = arguments;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              for (_len = _args.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = _args[_key];\n              }\n\n              options = applyDefaultOptions(args, defaultOptions);\n              _context.next = 4;\n              return toSourcesAndDestination(context, args);\n\n            case 4:\n              _yield$toSourcesAndDe = _context.sent;\n              sources = _yield$toSourcesAndDe.sources;\n              destination = _yield$toSourcesAndDe.destination;\n\n              if (sources.length) {\n                _context.next = 9;\n                break;\n              }\n\n              throw errCode(new Error('Please supply at least one source'), 'ERR_INVALID_PARAMS');\n\n            case 9:\n              options.parents = options.p || options.parents; // make sure all sources exist\n\n              missing = sources.find(function (source) {\n                return !source.exists;\n              });\n\n              if (!missing) {\n                _context.next = 13;\n                break;\n              }\n\n              throw errCode(new Error(\"\".concat(missing.path, \" does not exist\")), 'ERR_INVALID_PARAMS');\n\n            case 13:\n              destinationIsDirectory = isDirectory(destination);\n\n              if (!destination.exists) {\n                _context.next = 20;\n                break;\n              }\n\n              log('Destination exists');\n\n              if (!(sources.length === 1 && !destinationIsDirectory)) {\n                _context.next = 18;\n                break;\n              }\n\n              throw errCode(new Error('directory already has entry by that name'), 'ERR_ALREADY_EXISTS');\n\n            case 18:\n              _context.next = 49;\n              break;\n\n            case 20:\n              log('Destination does not exist');\n\n              if (!(sources.length > 1)) {\n                _context.next = 31;\n                break;\n              }\n\n              if (options.parents) {\n                _context.next = 24;\n                break;\n              }\n\n              throw errCode(new Error('destination did not exist, pass -p to create intermediate directories'), 'ERR_INVALID_PARAMS');\n\n            case 24:\n              _context.next = 26;\n              return mkdir(context)(destination.path, options);\n\n            case 26:\n              _context.next = 28;\n              return toMfsPath(context, destination.path);\n\n            case 28:\n              destination = _context.sent;\n              _context.next = 49;\n              break;\n\n            case 31:\n              if (!(destination.parts.length > 1)) {\n                _context.next = 49;\n                break;\n              }\n\n              // copying to a folder, create it if necessary\n              parentFolder = \"/\".concat(destination.parts.slice(0, -1).join('/'));\n              _context.prev = 33;\n              _context.next = 36;\n              return stat(context)(parentFolder, options);\n\n            case 36:\n              _context.next = 49;\n              break;\n\n            case 38:\n              _context.prev = 38;\n              _context.t0 = _context[\"catch\"](33);\n\n              if (!(_context.t0.code !== 'ERR_NOT_FOUND')) {\n                _context.next = 42;\n                break;\n              }\n\n              throw _context.t0;\n\n            case 42:\n              if (options.parents) {\n                _context.next = 44;\n                break;\n              }\n\n              throw errCode(new Error('destination did not exist, pass -p to create intermediate directories'), 'ERR_INVALID_PARAMS');\n\n            case 44:\n              _context.next = 46;\n              return mkdir(context)(parentFolder, options);\n\n            case 46:\n              _context.next = 48;\n              return toMfsPath(context, destination.path);\n\n            case 48:\n              destination = _context.sent;\n\n            case 49:\n              destinationPath = isDirectory(destination) ? destination.mfsPath : destination.mfsDirectory;\n              _context.next = 52;\n              return toTrail(context, destinationPath, options);\n\n            case 52:\n              trail = _context.sent;\n\n              if (!(sources.length === 1)) {\n                _context.next = 58;\n                break;\n              }\n\n              source = sources.pop();\n              destinationName = destinationIsDirectory ? source.name : destination.name;\n              log(\"Only one source, copying to destination \".concat(destinationIsDirectory ? 'directory' : 'file', \" \").concat(destinationName));\n              return _context.abrupt(\"return\", copyToFile(context, source, destinationName, trail, options));\n\n            case 58:\n              log('Multiple sources, wrapping in a directory');\n              return _context.abrupt(\"return\", copyToDirectory(context, sources, destination, trail, options));\n\n            case 60:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[33, 38]]);\n    }));\n\n    function mfsCp() {\n      return _mfsCp.apply(this, arguments);\n    }\n\n    return mfsCp;\n  }());\n};\n\nvar isDirectory = function isDirectory(destination) {\n  return destination.unixfs && destination.unixfs.type && destination.unixfs.type.includes('directory');\n};\n\nvar copyToFile = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(context, source, destination, destinationTrail, options) {\n    var parent, newRootCid;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            parent = destinationTrail.pop();\n            _context2.next = 3;\n            return addSourceToParent(context, source, destination, parent, options);\n\n          case 3:\n            parent = _context2.sent;\n            // update the tree with the new containing directory\n            destinationTrail.push(parent);\n            _context2.next = 7;\n            return updateTree(context, destinationTrail, options);\n\n          case 7:\n            newRootCid = _context2.sent;\n            _context2.next = 10;\n            return updateMfsRoot(context, newRootCid);\n\n          case 10:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function copyToFile(_x, _x2, _x3, _x4, _x5) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar copyToDirectory = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(context, sources, destination, destinationTrail, options) {\n    var i, source, newRootCid;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            i = 0;\n\n          case 1:\n            if (!(i < sources.length)) {\n              _context3.next = 9;\n              break;\n            }\n\n            source = sources[i];\n            _context3.next = 5;\n            return addSourceToParent(context, source, source.name, destination, options);\n\n          case 5:\n            destination = _context3.sent;\n\n          case 6:\n            i++;\n            _context3.next = 1;\n            break;\n\n          case 9:\n            // update the tree with the new containing directory\n            destinationTrail[destinationTrail.length - 1] = destination;\n            _context3.next = 12;\n            return updateTree(context, destinationTrail, options);\n\n          case 12:\n            newRootCid = _context3.sent;\n            _context3.next = 15;\n            return updateMfsRoot(context, newRootCid);\n\n          case 15:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function copyToDirectory(_x6, _x7, _x8, _x9, _x10) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nvar addSourceToParent = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(context, source, childName, parent, options) {\n    var sourceBlock, _yield$addLink, node, cid;\n\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.next = 2;\n            return context.repo.blocks.get(source.cid);\n\n          case 2:\n            sourceBlock = _context4.sent;\n            _context4.next = 5;\n            return addLink(context, {\n              parentCid: parent.cid,\n              size: sourceBlock.data.length,\n              cid: source.cid,\n              name: childName,\n              hashAlg: options.hashAlg,\n              cidVersion: options.cidVersion,\n              flush: options.flush\n            });\n\n          case 5:\n            _yield$addLink = _context4.sent;\n            node = _yield$addLink.node;\n            cid = _yield$addLink.cid;\n            parent.node = node;\n            parent.cid = cid;\n            parent.size = node.size;\n            return _context4.abrupt(\"return\", parent);\n\n          case 12:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n\n  return function addSourceToParent(_x11, _x12, _x13, _x14, _x15) {\n    return _ref3.apply(this, arguments);\n  };\n}();","map":null,"metadata":{},"sourceType":"script"}