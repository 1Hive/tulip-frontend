{"ast":null,"code":"'use strict';\n\nconst ipns = require('ipns');\n\nconst crypto = require('libp2p-crypto');\n\nconst PeerId = require('peer-id');\n\nconst errcode = require('err-code');\n\nconst debug = require('debug');\n\nconst log = debug('ipfs:ipns:resolver');\nlog.error = debug('ipfs:ipns:resolver:error');\n\nconst {\n  Errors\n} = require('interface-datastore');\n\nconst ERR_NOT_FOUND = Errors.notFoundError().code;\nconst defaultMaximumRecursiveDepth = 32;\n\nclass IpnsResolver {\n  constructor(routing) {\n    this._routing = routing;\n  }\n\n  async resolve(name, options) {\n    options = options || {};\n\n    if (typeof name !== 'string') {\n      throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME');\n    }\n\n    options = options || {};\n    const recursive = options.recursive && options.recursive.toString() === 'true';\n    const nameSegments = name.split('/');\n\n    if (nameSegments.length !== 3 || nameSegments[0] !== '') {\n      throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME');\n    }\n\n    const key = nameSegments[2]; // Define a maximum depth if recursive option enabled\n\n    let depth;\n\n    if (recursive) {\n      depth = defaultMaximumRecursiveDepth;\n    }\n\n    const res = await this.resolver(key, depth);\n    log(`${name} was locally resolved correctly`);\n    return res;\n  } // Recursive resolver according to the specified depth\n\n\n  async resolver(name, depth) {\n    // Exceeded recursive maximum depth\n    if (depth === 0) {\n      const errMsg = `could not resolve name (recursion limit of ${defaultMaximumRecursiveDepth} exceeded)`;\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_RESOLVE_RECURSION_LIMIT');\n    }\n\n    const res = await this._resolveName(name);\n    const nameSegments = res.split('/'); // If obtained a ipfs cid or recursive option is disabled\n\n    if (nameSegments[1] === 'ipfs' || !depth) {\n      return res;\n    } // continue recursively until depth equals 0\n\n\n    return this.resolver(nameSegments[2], depth - 1);\n  } // resolve ipns entries from the provided routing\n\n\n  async _resolveName(name) {\n    const peerId = PeerId.createFromCID(name);\n    const {\n      routingKey\n    } = ipns.getIdKeys(peerId.toBytes());\n    let record;\n\n    try {\n      record = await this._routing.get(routingKey.toBuffer());\n    } catch (err) {\n      log.error(err);\n\n      if (err.code === ERR_NOT_FOUND) {\n        throw errcode(new Error(`record requested for ${name} was not found in the network`), 'ERR_NO_RECORD_FOUND');\n      }\n\n      throw errcode(new Error(`unexpected error getting the ipns record ${peerId.id}`), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD');\n    } // IPNS entry\n\n\n    let ipnsEntry;\n\n    try {\n      ipnsEntry = ipns.unmarshal(record);\n    } catch (err) {\n      log.error(err);\n      throw errcode(new Error('found ipns record that we couldn\\'t convert to a value'), 'ERR_INVALID_RECORD_RECEIVED');\n    } // if the record has a public key validate it\n\n\n    if (ipnsEntry.pubKey) {\n      return this._validateRecord(peerId, ipnsEntry);\n    } // Otherwise, try to get the public key from routing\n\n\n    let pubKey;\n\n    try {\n      pubKey = await this._routing.get(routingKey.toBuffer());\n    } catch (err) {\n      log.error(err);\n\n      if (err.code === ERR_NOT_FOUND) {\n        throw errcode(new Error(`public key requested for ${name} was not found in the network`), 'ERR_NO_RECORD_FOUND');\n      }\n\n      throw errcode(new Error(`unexpected error getting the public key for the ipns record ${peerId.id}`), 'ERR_UNEXPECTED_ERROR_GETTING_PUB_KEY');\n    }\n\n    try {\n      // Insert it into the peer id, in order to be validated by IPNS validator\n      peerId.pubKey = crypto.keys.unmarshalPublicKey(pubKey);\n    } catch (err) {\n      log.error(err);\n      throw errcode(new Error('found public key record that we couldn\\'t convert to a value'), 'ERR_INVALID_PUB_KEY_RECEIVED');\n    }\n\n    return this._validateRecord(peerId, ipnsEntry);\n  } // validate a resolved record\n\n\n  async _validateRecord(peerId, ipnsEntry) {\n    const pubKey = await ipns.extractPublicKey(peerId, ipnsEntry); // IPNS entry validation\n\n    await ipns.validate(pubKey, ipnsEntry);\n    return ipnsEntry.value.toString();\n  }\n\n}\n\nexports = module.exports = IpnsResolver;","map":null,"metadata":{},"sourceType":"script"}