{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst util = require(\"util\");\n\nconst toString = Object.prototype.toString;\n\nconst isOfType = type => value => typeof value === type; // tslint:disable-line:strict-type-predicates\n\n\nconst getObjectType = value => {\n  const objectName = toString.call(value).slice(8, -1);\n\n  if (objectName) {\n    return objectName;\n  }\n\n  return null;\n};\n\nconst isObjectOfType = typeName => value => {\n  return getObjectType(value) === typeName;\n};\n\nfunction is(value) {\n  if (value === null) {\n    return \"null\"\n    /* null */\n    ;\n  }\n\n  if (value === true || value === false) {\n    return \"boolean\"\n    /* boolean */\n    ;\n  }\n\n  const type = typeof value;\n\n  if (type === 'undefined') {\n    return \"undefined\"\n    /* undefined */\n    ;\n  }\n\n  if (type === 'string') {\n    return \"string\"\n    /* string */\n    ;\n  }\n\n  if (type === 'number') {\n    return \"number\"\n    /* number */\n    ;\n  }\n\n  if (type === 'symbol') {\n    return \"symbol\"\n    /* symbol */\n    ;\n  }\n\n  if (is.function_(value)) {\n    return \"Function\"\n    /* Function */\n    ;\n  }\n\n  if (Array.isArray(value)) {\n    return \"Array\"\n    /* Array */\n    ;\n  }\n\n  if (Buffer.isBuffer(value)) {\n    return \"Buffer\"\n    /* Buffer */\n    ;\n  }\n\n  const tagType = getObjectType(value);\n\n  if (tagType) {\n    return tagType;\n  }\n\n  if (value instanceof String || value instanceof Boolean || value instanceof Number) {\n    throw new TypeError('Please don\\'t use object wrappers for primitive types');\n  }\n\n  return \"Object\"\n  /* Object */\n  ;\n}\n\n(function (is) {\n  const isObject = value => typeof value === 'object'; // tslint:disable:variable-name\n\n\n  is.undefined = isOfType('undefined');\n  is.string = isOfType('string');\n  is.number = isOfType('number');\n  is.function_ = isOfType('function');\n\n  is.null_ = value => value === null;\n\n  is.class_ = value => is.function_(value) && value.toString().startsWith('class ');\n\n  is.boolean = value => value === true || value === false; // tslint:enable:variable-name\n\n\n  is.symbol = isOfType('symbol');\n  is.array = Array.isArray;\n  is.buffer = Buffer.isBuffer;\n\n  is.nullOrUndefined = value => is.null_(value) || is.undefined(value);\n\n  is.object = value => !is.nullOrUndefined(value) && (is.function_(value) || isObject(value));\n\n  is.iterable = value => !is.nullOrUndefined(value) && is.function_(value[Symbol.iterator]);\n\n  is.generator = value => is.iterable(value) && is.function_(value.next) && is.function_(value.throw);\n\n  is.nativePromise = isObjectOfType(\"Promise\"\n  /* Promise */\n  );\n\n  const hasPromiseAPI = value => !is.null_(value) && isObject(value) && is.function_(value.then) && is.function_(value.catch);\n\n  is.promise = value => is.nativePromise(value) || hasPromiseAPI(value); // TODO: Change to use `isObjectOfType` once Node.js 6 or higher is targeted\n\n\n  const isFunctionOfType = type => value => is.function_(value) && is.function_(value.constructor) && value.constructor.name === type;\n\n  is.generatorFunction = isFunctionOfType('GeneratorFunction');\n  is.asyncFunction = isFunctionOfType('AsyncFunction');\n\n  is.boundFunction = value => is.function_(value) && !value.hasOwnProperty('prototype');\n\n  is.regExp = isObjectOfType(\"RegExp\"\n  /* RegExp */\n  );\n  is.date = isObjectOfType(\"Date\"\n  /* Date */\n  );\n  is.error = isObjectOfType(\"Error\"\n  /* Error */\n  );\n  is.map = isObjectOfType(\"Map\"\n  /* Map */\n  );\n  is.set = isObjectOfType(\"Set\"\n  /* Set */\n  );\n  is.weakMap = isObjectOfType(\"WeakMap\"\n  /* WeakMap */\n  );\n  is.weakSet = isObjectOfType(\"WeakSet\"\n  /* WeakSet */\n  );\n  is.int8Array = isObjectOfType(\"Int8Array\"\n  /* Int8Array */\n  );\n  is.uint8Array = isObjectOfType(\"Uint8Array\"\n  /* Uint8Array */\n  );\n  is.uint8ClampedArray = isObjectOfType(\"Uint8ClampedArray\"\n  /* Uint8ClampedArray */\n  );\n  is.int16Array = isObjectOfType(\"Int16Array\"\n  /* Int16Array */\n  );\n  is.uint16Array = isObjectOfType(\"Uint16Array\"\n  /* Uint16Array */\n  );\n  is.int32Array = isObjectOfType(\"Int32Array\"\n  /* Int32Array */\n  );\n  is.uint32Array = isObjectOfType(\"Uint32Array\"\n  /* Uint32Array */\n  );\n  is.float32Array = isObjectOfType(\"Float32Array\"\n  /* Float32Array */\n  );\n  is.float64Array = isObjectOfType(\"Float64Array\"\n  /* Float64Array */\n  );\n  is.arrayBuffer = isObjectOfType(\"ArrayBuffer\"\n  /* ArrayBuffer */\n  );\n  is.sharedArrayBuffer = isObjectOfType(\"SharedArrayBuffer\"\n  /* SharedArrayBuffer */\n  );\n  is.dataView = isObjectOfType(\"DataView\"\n  /* DataView */\n  ); // TODO: Remove `object` checks when targeting ES2015 or higher\n  // See `Notes`: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf\n\n  is.directInstanceOf = (instance, klass) => is.object(instance) && is.object(klass) && Object.getPrototypeOf(instance) === klass.prototype;\n\n  is.truthy = value => Boolean(value);\n\n  is.falsy = value => !value;\n\n  is.nan = value => Number.isNaN(value);\n\n  const primitiveTypes = new Set(['undefined', 'string', 'number', 'boolean', 'symbol']);\n\n  is.primitive = value => is.null_(value) || primitiveTypes.has(typeof value);\n\n  is.integer = value => Number.isInteger(value);\n\n  is.safeInteger = value => Number.isSafeInteger(value);\n\n  is.plainObject = value => {\n    // From: https://github.com/sindresorhus/is-plain-obj/blob/master/index.js\n    let prototype;\n    return getObjectType(value) === \"Object\"\n    /* Object */\n    && (prototype = Object.getPrototypeOf(value), prototype === null || // tslint:disable-line:ban-comma-operator\n    prototype === Object.getPrototypeOf({}));\n  };\n\n  const typedArrayTypes = new Set([\"Int8Array\"\n  /* Int8Array */\n  , \"Uint8Array\"\n  /* Uint8Array */\n  , \"Uint8ClampedArray\"\n  /* Uint8ClampedArray */\n  , \"Int16Array\"\n  /* Int16Array */\n  , \"Uint16Array\"\n  /* Uint16Array */\n  , \"Int32Array\"\n  /* Int32Array */\n  , \"Uint32Array\"\n  /* Uint32Array */\n  , \"Float32Array\"\n  /* Float32Array */\n  , \"Float64Array\"\n  /* Float64Array */\n  ]);\n\n  is.typedArray = value => {\n    const objectType = getObjectType(value);\n\n    if (objectType === null) {\n      return false;\n    }\n\n    return typedArrayTypes.has(objectType);\n  };\n\n  const isValidLength = value => is.safeInteger(value) && value > -1;\n\n  is.arrayLike = value => !is.nullOrUndefined(value) && !is.function_(value) && isValidLength(value.length);\n\n  is.inRange = (value, range) => {\n    if (is.number(range)) {\n      return value >= Math.min(0, range) && value <= Math.max(range, 0);\n    }\n\n    if (is.array(range) && range.length === 2) {\n      // TODO: Use spread operator here when targeting Node.js 6 or higher\n      return value >= Math.min.apply(null, range) && value <= Math.max.apply(null, range);\n    }\n\n    throw new TypeError(`Invalid range: ${util.inspect(range)}`);\n  };\n\n  const NODE_TYPE_ELEMENT = 1;\n  const DOM_PROPERTIES_TO_CHECK = ['innerHTML', 'ownerDocument', 'style', 'attributes', 'nodeValue'];\n\n  is.domElement = value => is.object(value) && value.nodeType === NODE_TYPE_ELEMENT && is.string(value.nodeName) && !is.plainObject(value) && DOM_PROPERTIES_TO_CHECK.every(property => property in value);\n\n  is.nodeStream = value => !is.nullOrUndefined(value) && isObject(value) && is.function_(value.pipe);\n\n  is.infinite = value => value === Infinity || value === -Infinity;\n\n  const isAbsoluteMod2 = value => rem => is.integer(rem) && Math.abs(rem % 2) === value;\n\n  is.even = isAbsoluteMod2(0);\n  is.odd = isAbsoluteMod2(1);\n\n  const isWhiteSpaceString = value => is.string(value) && /\\S/.test(value) === false;\n\n  const isEmptyStringOrArray = value => (is.string(value) || is.array(value)) && value.length === 0;\n\n  const isEmptyObject = value => !is.map(value) && !is.set(value) && is.object(value) && Object.keys(value).length === 0;\n\n  const isEmptyMapOrSet = value => (is.map(value) || is.set(value)) && value.size === 0;\n\n  is.empty = value => is.falsy(value) || isEmptyStringOrArray(value) || isEmptyObject(value) || isEmptyMapOrSet(value);\n\n  is.emptyOrWhitespace = value => is.empty(value) || isWhiteSpaceString(value);\n\n  const predicateOnArray = (method, predicate, args) => {\n    // `args` is the calling function's \"arguments object\".\n    // We have to do it this way to keep node v4 support.\n    // So here we convert it to an array and slice off the first item.\n    const values = Array.prototype.slice.call(args, 1);\n\n    if (is.function_(predicate) === false) {\n      throw new TypeError(`Invalid predicate: ${util.inspect(predicate)}`);\n    }\n\n    if (values.length === 0) {\n      throw new TypeError('Invalid number of values');\n    }\n\n    return method.call(values, predicate);\n  };\n\n  function any(predicate) {\n    return predicateOnArray(Array.prototype.some, predicate, arguments);\n  }\n\n  is.any = any;\n\n  function all(predicate) {\n    return predicateOnArray(Array.prototype.every, predicate, arguments);\n  }\n\n  is.all = all; // tslint:enable:only-arrow-functions no-function-expression\n})(is || (is = {})); // Some few keywords are reserved, but we'll populate them for Node.js users\n// See https://github.com/Microsoft/TypeScript/issues/2536\n\n\nObject.defineProperties(is, {\n  class: {\n    value: is.class_\n  },\n  function: {\n    value: is.function_\n  },\n  null: {\n    value: is.null_\n  }\n});\nexports.default = is; // For CommonJS default export support\n\nmodule.exports = is;\nmodule.exports.default = is;","map":null,"metadata":{},"sourceType":"script"}