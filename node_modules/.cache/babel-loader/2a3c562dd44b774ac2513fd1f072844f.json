{"ast":null,"code":"/*!\n * elliptic.js - elliptic curves for bcrypto\n * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Parts of this software are based on indutny/elliptic:\n *   Copyright (c) 2014, Fedor Indutny (MIT License).\n *   https://github.com/indutny/elliptic\n *\n * Formulas from DJB and Tanja Lange [EFD].\n *\n * References:\n *\n *   [GECC] Guide to Elliptic Curve Cryptography\n *     D. Hankerson, A. Menezes, and S. Vanstone\n *     https://tinyurl.com/guide-to-ecc\n *\n *   [GLV] Faster Point Multiplication on Elliptic Curves\n *     R. Gallant, R. Lambert, and S. Vanstone\n *     https://link.springer.com/content/pdf/10.1007/3-540-44647-8_11.pdf\n *\n *   [MONT1] Montgomery curves and the Montgomery ladder\n *     Daniel J. Bernstein, Tanja Lange\n *     https://eprint.iacr.org/2017/293.pdf\n *\n *   [COZ] Scalar Multiplication on Elliptic Curves from Co-Z Arithmetic\n *     R. Goundar, M. Joye, A. Miyaji, M. Rivain, A. Venelli\n *     https://www.matthieurivain.com/files/jcen11b.pdf\n *\n *   [SQUARED] Elligator Squared\n *     Mehdi Tibouchi\n *     https://eprint.iacr.org/2014/043.pdf\n *\n *   [SEC1] SEC 1 - Standards for Efficient Cryptography Group\n *     Certicom Research\n *     https://www.secg.org/sec1-v2.pdf\n *\n *   [SEC2] SEC 2: Recommended Elliptic Curve Domain Parameters\n *     Certicom Research\n *     https://www.secg.org/sec2-v2.pdf\n *\n *   [SIDE1] Elliptic Curves and Side-Channel Attacks\n *     Marc Joye\n *     https://pdfs.semanticscholar.org/8d69/9645033e25d74fcfd4cbf07a770d2e943e14.pdf\n *\n *   [BLIND] Side-Channel Analysis on Blinding Regular Scalar Multiplications\n *     B. Feix, M. Roussellet, A. Venelli\n *     https://eprint.iacr.org/2014/191.pdf\n *\n *   [ALT] Alternative Elliptic Curve Representations\n *     R. Struik\n *     https://tools.ietf.org/id/draft-ietf-lwig-curve-representations-02.html\n *\n *   [ARITH1] Arithmetic of Elliptic Curves\n *     Christophe Doche, Tanja Lange\n *     Handbook of Elliptic and Hyperelliptic Curve Cryptography\n *     Page 267, Section 13 (978-1-58488-518-4)\n *     https://hyperelliptic.org/HEHCC/index.html\n *\n *   [ARITH2] The Arithmetic of Elliptic Curves, 2nd Edition\n *     Joseph H. Silverman\n *     http://www.pdmi.ras.ru/~lowdimma/BSD/Silverman-Arithmetic_of_EC.pdf\n *\n *   [EFD] Explicit-Formulas Database\n *     Daniel J. Bernstein, Tanja Lange\n *     https://hyperelliptic.org/EFD/index.html\n *\n *   [SAFE] SafeCurves: choosing safe curves for elliptic-curve cryptography\n *     Daniel J. Bernstein\n *     https://safecurves.cr.yp.to/\n *\n *   [4GLV] Refinement of the Four-Dimensional GLV Method on Elliptic Curves\n *     Hairong Yi, Yuqing Zhu, and Dongdai Lin\n *     http://www.site.uottawa.ca/~cadams/papers/prepro/paper_19_slides.pdf\n *\n *   [ICART] How to Hash into Elliptic Curves\n *     Thomas Icart\n *     https://eprint.iacr.org/2009/226.pdf\n *\n *   [SSWU1] Efficient Indifferentiable Hashing into Ordinary Elliptic Curves\n *     E. Brier, J. Coron, T. Icart, D. Madore, H. Randriam, M. Tibouchi\n *     https://eprint.iacr.org/2009/340.pdf\n *\n *   [SSWU2] Rational points on certain hyperelliptic curves over finite fields\n *     Maciej Ulas\n *     https://arxiv.org/abs/0706.1448\n *\n *   [H2EC] Hashing to Elliptic Curves\n *     A. Faz-Hernandez, S. Scott, N. Sullivan, R. S. Wahby, C. A. Wood\n *     https://git.io/JeWz6\n *     https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve\n *\n *   [SVDW1] Construction of Rational Points on Elliptic Curves\n *     A. Shallue, C. E. van de Woestijne\n *     https://works.bepress.com/andrew_shallue/1/download/\n *\n *   [SVDW2] Indifferentiable Hashing to Barreto-Naehrig Curves\n *     Pierre-Alain Fouque, Mehdi Tibouchi\n *     https://www.di.ens.fr/~fouque/pub/latincrypt12.pdf\n *\n *   [SVDW3] Covert ECDH over secp256k1\n *     Pieter Wuille\n *     https://gist.github.com/sipa/29118d3fcfac69f9930d57433316c039\n *\n *   [MONT2] Montgomery Curve (wikipedia)\n *     https://en.wikipedia.org/wiki/Montgomery_curve\n *\n *   [SIDE2] Weierstrass Elliptic Curves and Side-Channel Attacks\n *     Eric Brier, Marc Joye\n *     http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.2.273&rep=rep1&type=pdf\n *\n *   [SIDE3] Unified Point Addition Formulae and Side-Channel Attacks\n *     Douglas Stebila, Nicolas Theriault\n *     https://eprint.iacr.org/2005/419.pdf\n *\n *   [MONT3] Montgomery Curves and their arithmetic\n *     C. Costello, B. Smith\n *     https://eprint.iacr.org/2017/212.pdf\n *\n *   [ELL2] Elliptic-curve points indistinguishable from uniform random strings\n *     D. Bernstein, M. Hamburg, A. Krasnova, T. Lange\n *     https://elligator.cr.yp.to/elligator-20130828.pdf\n *\n *   [RFC7748] Elliptic Curves for Security\n *     A. Langley, M. Hamburg, S. Turner\n *     https://tools.ietf.org/html/rfc7748\n *\n *   [TWISTED] Twisted Edwards Curves\n *     D. Bernstein, P. Birkner, M. Joye, T. Lange, C. Peters\n *     https://eprint.iacr.org/2008/013.pdf\n *\n *   [ELL1] Injective Encodings to Elliptic Curves\n *     P. Fouque, A. Joux, M. Tibouchi\n *     https://eprint.iacr.org/2013/373.pdf\n *\n *   [ISOGENY] Twisting Edwards curves with isogenies\n *     Mike Hamburg\n *     https://www.shiftleft.org/papers/isogeny/isogeny.pdf\n *\n *   [RFC8032] Edwards-Curve Digital Signature Algorithm (EdDSA)\n *     S. Josefsson, SJD AB, I. Liusvaara\n *     https://tools.ietf.org/html/rfc8032\n *\n *   [TIMING] Remote Timing Attacks are Still Practical\n *     B. Brumley, N. Tuveri\n *     https://eprint.iacr.org/2011/232.pdf\n *\n *   [SCHNORR] Schnorr Signatures for secp256k1\n *     Pieter Wuille\n *     https://github.com/sipa/bips/blob/d194620/bip-schnorr.mediawiki\n *\n *   [BIP340] Schnorr Signatures for secp256k1\n *     Pieter Wuille, Jonas Nick, Tim Ruffing\n *     https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n *\n *   [JCEN12] Efficient Software Implementation of Public-Key Cryptography\n *            on Sensor Networks Using the MSP430X Microcontroller\n *     C. P. L. Gouvea, L. B. Oliveira, J. Lopez\n *     http://conradoplg.cryptoland.net/files/2010/12/jcen12.pdf\n *\n *   [FIPS186] Federal Information Processing Standards Publication\n *     National Institute of Standards and Technology\n *     https://tinyurl.com/fips-186-3\n *\n *   [RFC5639] Elliptic Curve Cryptography (ECC) Brainpool\n *             Standard Curves and Curve Generation\n *     M. Lochter, BSI, J. Merkle\n *     https://tools.ietf.org/html/rfc5639\n *\n *   [TWISTEQ] Twisted Edwards & Short Weierstrass Equivalence\n *     Christopher Jeffrey\n *     https://gist.github.com/chjj/16ba7fa08d64e8dda269a9fe5b2a8bbc\n *\n *   [ECPM] Elliptic Curve Point Multiplication (wikipedia)\n *     https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication\n */\n'use strict';\n\nconst {\n  custom\n} = require('../internal/custom');\n\nconst BN = require('../bn');\n/*\n * Constants\n */\n\n\nconst types = {\n  AFFINE: 0,\n  JACOBIAN: 1,\n  PROJECTIVE: 2,\n  EXTENDED: 3\n};\nconst jsfIndex = [-3, // -1 -1\n-1, // -1 0\n-5, // -1 1\n-7, // 0 -1\n0, // 0 0\n7, // 0 1\n5, // 1 -1\n1, // 1 0\n3 // 1 1\n];\nconst USE_FIXED = false;\n/**\n * Curve\n */\n\nclass Curve {\n  constructor(Point, type, conf) {\n    this.Point = null;\n    this.id = null;\n    this.ossl = null;\n    this.type = 'base';\n    this.endian = 'be';\n    this.hash = null;\n    this.prefix = null;\n    this.context = false;\n    this.prime = null;\n    this.p = null;\n    this.red = null;\n    this.fieldSize = 0;\n    this.fieldBits = 0;\n    this.adjustedSize = 0;\n    this.signBit = 0;\n    this.n = null;\n    this.h = null;\n    this.q = null;\n    this.z = null;\n    this.g = null;\n    this.nh = null;\n    this.scalarSize = 0;\n    this.scalarBits = 0;\n    this.mask = null;\n    this.zero = null;\n    this.one = null;\n    this.two = null;\n    this.three = null;\n    this.four = null;\n    this.i2 = null;\n    this.i3 = null;\n    this.i4 = null;\n    this.i6 = null;\n    this.torsion = null;\n    this.endo = null;\n    this.hi = null;\n\n    this._init(Point, type, conf);\n  }\n\n  _init(Point, type, conf) {\n    assert(typeof Point === 'function');\n    assert(typeof type === 'string');\n    assert(conf && typeof conf === 'object');\n    assert(conf.red == null || conf.red instanceof BN.Red);\n    assert(conf.p != null, 'Must pass a prime.');\n    assert(conf.id == null || typeof conf.id === 'string');\n    assert(conf.ossl == null || typeof conf.ossl === 'string');\n    assert(conf.endian == null || typeof conf.endian === 'string');\n    assert(conf.hash == null || typeof conf.hash === 'string');\n    assert(conf.prefix == null || typeof conf.prefix === 'string');\n    assert(conf.context == null || typeof conf.context === 'boolean');\n    assert(conf.prime == null || typeof conf.prime === 'string');\n    assert(conf.torsion == null || Array.isArray(conf.torsion)); // Point class.\n\n    this.Point = Point; // Meta.\n\n    this.id = conf.id || null;\n    this.ossl = conf.ossl || null;\n    this.type = type;\n    this.endian = conf.endian || (type === 'short' ? 'be' : 'le');\n    this.hash = conf.hash || null;\n    this.prefix = conf.prefix ? Buffer.from(conf.prefix, 'binary') : null;\n    this.context = conf.context || false;\n    this.prime = conf.prime || null; // Prime.\n\n    this.p = BN.fromJSON(conf.p); // Reduction.\n\n    if (conf.red) {\n      this.red = conf.red;\n    } else {\n      // Use Montgomery when there is no fast reduction for the prime.\n      this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);\n      this.red.precompute();\n    } // Precalculate encoding length.\n\n\n    this.fieldSize = this.p.byteLength();\n    this.fieldBits = this.p.bitLength();\n    this.adjustedSize = this.fieldSize + ((this.fieldBits & 7) === 0);\n    this.signBit = this.adjustedSize * 8 - 1; // Curve configuration, optional.\n\n    this.n = BN.fromJSON(conf.n || '0');\n    this.h = BN.fromJSON(conf.h || '1');\n    this.q = this.n.mul(this.h);\n    this.z = BN.fromJSON(conf.z || '0').toRed(this.red);\n    this.g = null;\n    this.nh = this.n.ushrn(1);\n    this.scalarSize = this.n.byteLength();\n    this.scalarBits = this.n.bitLength();\n    this.mask = null; // Useful for many curves.\n\n    this.zero = new BN(0).toRed(this.red);\n    this.one = new BN(1).toRed(this.red);\n    this.two = new BN(2).toRed(this.red);\n    this.three = new BN(3).toRed(this.red);\n    this.four = new BN(4).toRed(this.red); // Inverses.\n\n    this.i2 = this.two.redInvert();\n    this.i3 = this.three.redInvert();\n    this.i4 = this.i2.redSqr();\n    this.i6 = this.i2.redMul(this.i3); // Torsion.\n\n    this.torsion = new Array(this.h.word(0));\n\n    for (let i = 0; i < this.torsion.length; i++) this.torsion[i] = this.point(); // Endomorphism.\n\n\n    this.endo = null; // Cache.\n\n    this.hi = null; // Memoize.\n\n    this._scale = memoize(this._scale, this);\n    this.isIsomorphic = memoize(this.isIsomorphic, this);\n    this.isIsogenous = memoize(this.isIsogenous, this); // Sanity checks.\n\n    assert(this.p.sign() > 0 && this.p.isOdd());\n    assert(this.n.sign() >= 0);\n    assert(this.h.sign() > 0 && this.h.cmpn(255) <= 0);\n    assert(this.endian === 'be' || this.endian === 'le');\n    return this;\n  }\n\n  _finalize(conf) {\n    assert(conf && typeof conf === 'object'); // Create mask.\n\n    this.mask = new Mask(this); // Create base point.\n\n    this.g = conf.g ? this.pointFromJSON(conf.g) : this.point(); // Parse small order points.\n\n    if (conf.torsion) {\n      assert(conf.torsion.length === this.torsion.length);\n\n      for (let i = 0; i < this.torsion.length; i++) this.torsion[i] = this.pointFromJSON(conf.torsion[i]);\n    }\n\n    return this;\n  }\n\n  _simpleMul(p, k) {\n    // Left-to-right point multiplication.\n    //\n    // [GECC] Algorithm 3.27, Page 97, Section 3.3.\n    //        Algorithm 3.26, Page 96, Section 3.3.\n    assert(p instanceof Point);\n    assert(k instanceof BN);\n    assert(!k.red); // We prefer left-to-right since it\n    // allows us to repeatedly add an\n    // affine point to the accumulator.\n\n    const bits = k.bitLength(); // Flip sign if necessary.\n\n    if (k.isNeg()) p = p.neg(); // Multiply.\n\n    let acc = this.jpoint();\n\n    for (let i = bits - 1; i >= 0; i--) {\n      const bit = k.bit(i);\n      acc = acc.dbl();\n      if (bit === 1) acc = acc.add(p);\n    }\n\n    return acc;\n  }\n\n  _simpleMulAdd(points, coeffs) {\n    // Multiple point multiplication, also known\n    // as \"Shamir's trick\".\n    //\n    // [GECC] Algorithm 3.48, Page 109, Section 3.3.3.\n    assert(Array.isArray(points));\n    assert(Array.isArray(coeffs));\n    assert(points.length === coeffs.length);\n    const len = points.length;\n    const npoints = new Array(len);\n    const ncoeffs = coeffs; // Check arrays and calculate size.\n\n    let max = 0;\n\n    for (let i = 0; i < len; i++) {\n      const point = points[i];\n      const coeff = coeffs[i];\n      assert(point instanceof Point);\n      assert(coeff instanceof BN);\n      assert(!coeff.red);\n      if (i > 0 && point.type !== points[i - 1].type) throw new Error('Cannot mix points.'); // Flip signs if necessary.\n\n      npoints[i] = coeff.isNeg() ? point.neg() : point; // Compute max scalar size.\n\n      max = Math.max(max, coeff.bitLength());\n    } // Multiply and add.\n\n\n    let acc = this.jpoint();\n\n    for (let i = max - 1; i >= 0; i--) {\n      acc = acc.dbl();\n\n      for (let j = 0; j < len; j++) {\n        const point = npoints[j];\n        const coeff = ncoeffs[j];\n        const bit = coeff.bit(i);\n        if (bit === 1) acc = acc.add(point);\n      }\n    }\n\n    return acc;\n  }\n\n  _constMul(p, k, rng) {\n    assert(p instanceof Point); // Must have order.\n\n    if (this.n.isZero()) return this._simpleMul(p, k); // Use Co-Z arithmetic for Weierstrass (h=1).\n\n    if (this.type === 'short' && this.h.cmpn(1) === 0) return this._coZLadderMul(p, k); // Otherwise, a regular ladder.\n\n    return this._ladderMul(p, k);\n  }\n\n  _ladderMul(p, k) {\n    // Generalized Montgomery Ladder.\n    //\n    // [MONT1] Page 24, Section 4.6.2.\n    assert(p instanceof Point);\n    assert(k instanceof BN);\n    assert(!k.red); // Curve must expose some form of unified\n    // addition (this is easier said than done\n    // for Weierstrass curves). This ensures\n    // both branches of the ladder consume\n    // the same power and number of cycles.\n    //\n    // We implement the ladder as a branchless\n    // function with a constant time swap.\n    //\n    // Current cost:\n    //\n    //   N * (14M + 14S + 11A + 2*a + 1*8 + 3*4 + 2*3 + 4*2)\n    //\n    //   N=256 => 3584M + 3584S + 2816A + 512*a\n    //          + 256*8 + 768*4 + 512*3 + 1024*2\n\n    const [sign, bits, exp] = getLadderBits(k, this.q); // Clone points (for safe swapping).\n\n    let a = p.toJ().clone();\n    let b = this.jpoint().clone();\n    let swap = 0; // Climb the ladder.\n\n    for (let i = bits - 1; i >= 0; i--) {\n      const bit = exp[i >> 3] >> (i & 7) & 1; // Maybe swap.\n\n      a.swap(b, swap ^ bit); // Unified addition.\n\n      a = a.uadd(b);\n      b = b.udbl();\n      swap = bit;\n    } // Finalize loop.\n\n\n    a.swap(b, swap); // Flip sign retroactively.\n\n    b.swap(b.neg(), sign);\n    return b;\n  }\n\n  _coZLadderMul(p, k) {\n    // Co-Z Montgomery Ladder.\n    //\n    // [COZ] Algorithm 9, Page 6, Section 4.\n    assert(p instanceof Point);\n    assert(k instanceof BN);\n    assert(!k.red); // Multiply with Co-Z arithmetic. This method is\n    // 2x faster than our regular unified addition\n    // ladder. However, there are some problems with\n    // leakage of the scalar length.\n    //\n    // There are three issues with this algorithm:\n    //\n    //   1. The amount of steps in the ladder is not\n    //      constant, since we must assume k[n-1]=1\n    //      (it follows that k[n]=0). A side effect\n    //      of this is that we cannot handle a point\n    //      at infinity (k[n-1]=0).\n    //\n    //   2. On the off chance we pass in a \"low\"\n    //      scalar (lacking several hi bits), there\n    //      will be a noticeable difference in cycles.\n    //\n    //   3. The algorithm cannot handle k = -1 mod n.\n    //      It will overflow to infinity.\n    //\n    // To avoid two of these issues, we _negate_ the\n    // scalar in the event that bits(k) < bits(-k). If\n    // we do end up negating a scalar, we negate the\n    // resulting point in constant time at the end.\n    //\n    // Doing this not only solves the point at infinity\n    // issue (i.e. N-0=N=0), but it also ensures a scalar\n    // is within at least 1 bit of the order (usually).\n    //\n    // The final edge case can be solved with a\n    // comparison and subsequent constant-time swap at\n    // the end.\n    //\n    // Note that our scalar recoding here disallows\n    // the possibility of curves with a cofactor > 1.\n    //\n    // A possibility for a perf improvement involves\n    // using the ZACAU method. This is faster assuming\n    // a cost of 1S < 1M, but our squaring impl. is\n    // identical to our multiplication impl., so we\n    // wouldn't get any real benefit.\n    //\n    // Current cost:\n    //\n    //   1M + 5S + 8A + 4*2 + 1*8\n    //   N * (11M + 3S + 21A + 1*2)\n    //\n    //   N=256 => 2817M + 773S + 5384A + 256*2 + 4*2 + 1*8\n\n    const c = p.toJ().clone();\n    const [sign, bits, exp, m1] = getCOZBits(k, this.n); // Initial double (we assume k[n-1] == 1).\n\n    let [a, b] = c.zdblu();\n    let swap = 0; // Climb the ladder.\n\n    for (let i = bits - 2; i >= 0; i--) {\n      const bit = exp[i >> 3] >> (i & 7) & 1; // Maybe swap.\n\n      a.swap(b, swap ^ bit); // Co-Z addition.\n\n      [a, b] = b.zaddc(a);\n      [b, a] = a.zaddu(b);\n      swap = bit;\n    } // Finalize loop.\n\n\n    a.swap(b, swap); // Final edge case.\n\n    b.swap(c.neg(), m1); // Adjust sign.\n\n    b.swap(b.neg(), sign);\n    return b;\n  }\n\n  _fixedMul(p, k) {\n    // Fixed-base method for point multiplication.\n    //\n    // [ECPM] \"Windowed method\".\n    // [GECC] Page 95, Section 3.3.\n    //\n    // Windows are appropriately shifted to avoid any\n    // doublings. This reduces a 256 bit multiplication\n    // down to 64 additions with a window size of 4.\n    assert(p instanceof Point);\n    assert(k instanceof BN);\n    assert(p.pre && p.pre.windows); // Get precomputed windows.\n\n    const {\n      width,\n      bits,\n      points\n    } = p._getWindows(0, 0); // Recompute window size.\n\n\n    const size = 1 << width; // Recompute steps.\n\n    const steps = (bits + width - 1) / width >>> 0; // Multiply.\n\n    let acc = this.jpoint();\n\n    for (let i = 0; i < steps; i++) {\n      const bits = k.bits(i * width, width);\n      acc = acc.add(points[i * size + bits]);\n    } // Adjust sign.\n\n\n    if (k.isNeg()) acc = acc.neg();\n    return acc;\n  }\n\n  _fixedNafMul(p, k) {\n    // Fixed-base NAF windowing method for point multiplication.\n    //\n    // [GECC] Algorithm 3.42, Page 105, Section 3.3.\n    assert(p instanceof Point);\n    assert(k instanceof BN);\n    assert(p.pre && p.pre.doubles); // Get precomputed doubles.\n\n    const {\n      step,\n      points\n    } = p._getDoubles(0, 0); // Get fixed NAF (in a more windowed form).\n\n\n    const naf = getFixedNAF(k, 1, k.bitLength() + 1, step); // Compute steps.\n\n    const I = ((1 << step + 1) - (step % 2 === 0 ? 2 : 1)) / 3; // Multiply.\n\n    let a = this.jpoint();\n    let b = this.jpoint();\n\n    for (let i = I; i > 0; i--) {\n      for (let j = 0; j < naf.length; j++) {\n        const nafW = naf[j];\n        if (nafW === i) b = b.add(points[j]);else if (nafW === -i) b = b.sub(points[j]);\n      }\n\n      a = a.add(b);\n    }\n\n    return a;\n  }\n\n  _windowMul(width, p, k) {\n    // Windowed method for point multiplication.\n    //\n    // [ECPM] \"Windowed method\".\n    // [GECC] Page 95, Section 3.3.\n    assert(width >>> 0 === width);\n    assert(p instanceof Point);\n    assert(k instanceof BN);\n    const size = 1 << width;\n    const bits = Math.max(k.bitLength(), this.n.bitLength());\n    const steps = (bits + width - 1) / width >>> 0;\n    const wnd = new Array(size);\n    const point = p.toJ(); // Precompute.\n\n    wnd[0] = this.jpoint();\n    wnd[1] = point;\n\n    for (let i = 2; i < size; i += 2) {\n      wnd[i + 0] = wnd[i >> 1].dbl();\n      wnd[i + 1] = wnd[i].add(point);\n    } // Multiply.\n\n\n    let acc = this.jpoint();\n\n    for (let i = steps - 1; i >= 0; i--) {\n      const bits = k.bits(i * width, width);\n\n      if (i === steps - 1) {\n        acc = wnd[bits];\n      } else {\n        acc = acc.dblp(width);\n        acc = acc.add(wnd[bits]);\n      }\n    } // Adjust sign.\n\n\n    if (k.isNeg()) acc = acc.neg();\n    return acc;\n  }\n\n  _slideMul(width, p, k) {\n    // Sliding window method for point multiplication.\n    //\n    // [ECPM] \"Sliding-window method\".\n    // [GECC] Algorithm 3.38, Page 101, Section 3.3.\n    assert(width >>> 0 === width);\n    assert(p instanceof Point);\n    assert(k instanceof BN);\n    const size = 1 << width - 1;\n    const wnd = new Array(size);\n    const point = p.toJ(); // Precompute.\n\n    wnd[0] = point.dblp(width - 1);\n    wnd[1] = wnd[0].add(point);\n\n    for (let i = 2; i < size; i++) wnd[i] = wnd[i - 1].add(point); // Multiply.\n\n\n    let i = k.bitLength();\n    let r = this.jpoint();\n\n    while (i >= width) {\n      const pos = i - width;\n      const bits = k.bits(pos, width);\n\n      if (bits < size) {\n        r = r.dbl();\n        i -= 1;\n        continue;\n      }\n\n      r = r.dblp(width);\n      r = r.add(wnd[bits & ~size]);\n      i = pos;\n    } // Finish.\n\n\n    if (i > 0) {\n      const bits = k.bits(0, i);\n\n      while (i--) {\n        r = r.dbl();\n        if (bits >> i & 1) r = r.add(p);\n      }\n    } // Adjust sign.\n\n\n    if (k.isNeg()) r = r.neg();\n    return r;\n  }\n\n  _wnafMul(w, p, k) {\n    // Window NAF method for point multiplication.\n    //\n    // [GECC] Algorithm 3.36, Page 100, Section 3.3.\n    assert(p instanceof Point);\n    assert(k instanceof BN); // Precompute window.\n\n    const {\n      width,\n      points\n    } = p._safeNAF(w); // Get NAF form.\n\n\n    const naf = getNAF(k, width, k.bitLength() + 1); // Add `this`*(N+1) for every w-NAF index.\n\n    let acc = this.jpoint();\n\n    for (let i = naf.length - 1; i >= 0; i--) {\n      const z = naf[i];\n      if (i !== naf.length - 1) acc = acc.dbl();\n      if (z > 0) acc = acc.add(points[z - 1 >> 1]);else if (z < 0) acc = acc.sub(points[-z - 1 >> 1]);\n    }\n\n    return acc;\n  }\n\n  _wnafMulAdd(w, points, coeffs) {\n    // Multiple point multiplication, also known\n    // as \"Shamir's trick\" (with interleaved NAFs).\n    //\n    // [GECC] Algorithm 3.48, Page 109, Section 3.3.3.\n    //        Algorithm 3.51, Page 112, Section 3.3.\n    //\n    // This is particularly useful for signature\n    // verifications and mutiplications after an\n    // endomorphism split.\n    assert(w >>> 0 === w);\n    assert(Array.isArray(points));\n    assert(Array.isArray(coeffs));\n    assert(points.length === coeffs.length);\n    const length = points.length;\n    const wnd = new Array(length);\n    const naf = new Array(length); // Check arrays and calculate size.\n\n    let max = 0;\n\n    for (let i = 0; i < length; i++) {\n      const point = points[i];\n      const coeff = coeffs[i];\n      assert(point instanceof Point);\n      assert(coeff instanceof BN);\n      if (i > 0 && point.type !== points[i - 1].type) throw new Error('Cannot mix points.'); // Avoid sparse arrays.\n\n      wnd[i] = null;\n      naf[i] = null; // Compute max scalar size.\n\n      max = Math.max(max, coeff.bitLength() + 1);\n    } // Compute NAFs.\n\n\n    let ppoint = null;\n    let pcoeff = null;\n    let len = 0;\n\n    for (let i = 0; i < length; i++) {\n      const point = points[i];\n      const coeff = coeffs[i];\n\n      const pre = point._getNAF(0); // Use precomputation if available.\n\n\n      if (pre) {\n        wnd[len] = pre.points;\n        naf[len] = getNAF(coeff, pre.width, max);\n        len += 1;\n        continue;\n      } // Save last non-precomputed point.\n\n\n      if (!ppoint) {\n        ppoint = point;\n        pcoeff = coeff;\n        continue;\n      } // Compute JSF in NAF form.\n\n\n      wnd[len] = ppoint._getJNAF(point);\n      naf[len] = getJNAF(pcoeff, coeff, max);\n      ppoint = null;\n      pcoeff = null;\n      len += 1;\n    } // Regular NAF for odd points.\n\n\n    if (ppoint) {\n      const nafw = ppoint._safeNAF(w);\n\n      wnd[len] = nafw.points;\n      naf[len] = getNAF(pcoeff, nafw.width, max);\n      len += 1;\n    } // Multiply and add.\n\n\n    let acc = this.jpoint();\n\n    for (let i = max - 1; i >= 0; i--) {\n      if (i !== max - 1) acc = acc.dbl();\n\n      for (let j = 0; j < len; j++) {\n        const z = naf[j][i];\n        if (z > 0) acc = acc.add(wnd[j][z - 1 >> 1]);else if (z < 0) acc = acc.sub(wnd[j][-z - 1 >> 1]);\n      }\n    }\n\n    return acc;\n  }\n\n  _endoWnafMulAdd(points, coeffs) {\n    throw new Error('Not implemented.');\n  }\n\n  _scale(curve, invert) {\n    assert(curve instanceof Curve);\n    assert(curve.p.eq(this.p));\n\n    switch (curve.type) {\n      case 'short':\n        return this._scaleShort(curve, invert);\n\n      case 'mont':\n        return this._scaleMont(curve, invert);\n\n      case 'edwards':\n        return this._scaleEdwards(curve, invert);\n\n      default:\n        throw new Error('Not implemented.');\n    }\n  }\n\n  _scaleShort(curve, invert) {\n    throw new Error('Not implemented.');\n  }\n\n  _scaleMont(curve, invert) {\n    throw new Error('Not implemented.');\n  }\n\n  _scaleEdwards(curve, invert) {\n    throw new Error('Not implemented.');\n  }\n\n  isElliptic() {\n    throw new Error('Not implemented.');\n  }\n\n  jinv() {\n    throw new Error('Not implemented.');\n  }\n\n  isComplete() {\n    return false;\n  }\n\n  precompute(rng) {\n    assert(!this.g.isInfinity(), 'Must have base point.');\n    assert(!this.n.isZero(), 'Must have order.');\n    this.g.precompute(this.n.bitLength(), rng);\n    return this;\n  }\n\n  scalar(num, base, endian) {\n    const k = new BN(num, base, endian);\n    assert(!k.red);\n    if (this.n.isZero()) return k;\n    return k.imod(this.n);\n  }\n\n  field(num, base, endian) {\n    const x = BN.cast(num, base, endian);\n    if (x.red) return x.forceRed(this.red);\n    return x.toRed(this.red);\n  }\n\n  point(x, y) {\n    throw new Error('Not implemented.');\n  }\n\n  jpoint(x, y, z) {\n    throw new Error('Not implemented.');\n  }\n\n  xpoint(x, z) {\n    throw new Error('Not implemented.');\n  }\n\n  cpoint(xx, xz, yy, yz) {\n    assert(xx instanceof BN);\n    assert(xz instanceof BN);\n    assert(yy instanceof BN);\n    assert(yz instanceof BN);\n    if (xz.isZero() || yz.isZero()) return this.point();\n    const z = xz.redMul(yz).redInvert();\n    const x = xx.redMul(yz).redMul(z);\n    const y = yy.redMul(xz).redMul(z);\n    return this.point(x, y);\n  }\n\n  solveX2(y) {\n    throw new Error('Not implemented.');\n  }\n\n  solveX(y) {\n    return this.solveX2(y).redSqrt();\n  }\n\n  solveY2(x) {\n    throw new Error('Not implemented.');\n  }\n\n  solveY(x) {\n    return this.solveY2(x).redSqrt();\n  }\n\n  validate(point) {\n    throw new Error('Not implemented.');\n  }\n\n  pointFromX(x, sign) {\n    throw new Error('Not implemented.');\n  }\n\n  pointFromY(y, sign) {\n    throw new Error('Not implemented.');\n  }\n\n  isIsomorphic(curve) {\n    throw new Error('Not implemented.');\n  }\n\n  isIsogenous(curve) {\n    throw new Error('Not implemented.');\n  }\n\n  pointFromShort(point) {\n    throw new Error('Not implemented.');\n  }\n\n  pointFromMont(point, sign) {\n    throw new Error('Not implemented.');\n  }\n\n  pointFromEdwards(point) {\n    throw new Error('Not implemented.');\n  }\n\n  pointFromUniform(u) {\n    throw new Error('Not implemented.');\n  }\n\n  pointToUniform(p) {\n    throw new Error('Not implemented.');\n  }\n\n  pointFromHash(bytes, pake = false) {\n    // [H2EC] \"Roadmap\".\n    assert(Buffer.isBuffer(bytes));\n    assert(typeof pake === 'boolean');\n    if (bytes.length !== this.fieldSize * 2) throw new Error('Invalid hash size.'); // Random oracle encoding.\n    // Ensure a proper distribution.\n\n    const s1 = bytes.slice(0, this.fieldSize);\n    const s2 = bytes.slice(this.fieldSize);\n    const u1 = this.decodeUniform(s1);\n    const u2 = this.decodeUniform(s2);\n    const p1 = this.pointFromUniform(u1);\n    const p2 = this.pointFromUniform(u2);\n    const p3 = p1.uadd(p2);\n    return pake ? p3.mulH() : p3;\n  }\n\n  pointToHash(p, subgroup, rng) {\n    // [SQUARED] Algorithm 1, Page 8, Section 3.3.\n    assert(p instanceof this.Point);\n    assert(subgroup >>> 0 === subgroup); // Add a random torsion component.\n\n    const i = subgroup % this.torsion.length;\n    const p0 = p.add(this.torsion[i]); // Average Cost (R = sqrt):\n    //\n    //   SSWU (~4 iterations) => 8I + 16R\n    //   SVDW (~4 iterations) => 12I + 28R\n    //   Elligator 1 (~2 iterations) => 6I + 10R\n    //   Elligator 2 (~2 iterations) => 4I + 6R\n    //   Ristretto (~1 iteration) => 1I + 2R + h*1R\n\n    for (;;) {\n      const u1 = this.randomField(rng);\n      const p1 = this.pointFromUniform(u1); // Avoid 2-torsion points:\n      //   Short Weierstrass: ((A / 3) / B, 0)\n      //   Montgomery: (0, 0)\n      //   Twisted Edwards: (0, -1)\n\n      if (p1.neg().eq(p1)) continue;\n      const p2 = p0.usub(p1);\n      const hint = randomInt(rng);\n      let u2;\n\n      try {\n        u2 = this.pointToUniform(p2, hint & 15);\n      } catch (e) {\n        if (e.message === 'Invalid point.') continue;\n        throw e;\n      }\n\n      const s1 = this.encodeUniform(u1, hint >>> 8);\n      const s2 = this.encodeUniform(u2, hint >>> 16);\n      return Buffer.concat([s1, s2]);\n    }\n  }\n\n  randomScalar(rng) {\n    const max = this.n.isZero() ? this.p : this.n;\n    return BN.random(rng, 1, max);\n  }\n\n  randomField(rng) {\n    return BN.random(rng, 1, this.p).toRed(this.red);\n  }\n\n  randomPoint(rng) {\n    let p;\n\n    for (;;) {\n      const x = this.randomField(rng);\n      const sign = (randomInt(rng) & 1) !== 0;\n\n      try {\n        p = this.pointFromX(x, sign);\n      } catch (e) {\n        continue;\n      }\n\n      assert(p.validate());\n      return p.mulH();\n    }\n  }\n\n  mulAll(points, coeffs) {\n    return this.jmulAll(points, coeffs);\n  }\n\n  mulAllSimple(points, coeffs) {\n    return this.jmulAllSimple(points, coeffs);\n  }\n\n  jmulAll(points, coeffs) {\n    assert(Array.isArray(points));\n    assert(points.length === 0 || points[0] instanceof Point); // Multiply with endomorphism if we're using affine points.\n\n    if (this.endo && points.length > 0 && points[0].type === types.AFFINE) return this._endoWnafMulAdd(points, coeffs); // Otherwise, a regular Shamir's trick.\n\n    return this._wnafMulAdd(4, points, coeffs);\n  }\n\n  jmulAllSimple(points, coeffs) {\n    return this._simpleMulAdd(points, coeffs);\n  }\n\n  mulH(k) {\n    assert(k instanceof BN);\n    return this.imulH(k.clone());\n  }\n\n  imulH(k) {\n    assert(k instanceof BN);\n    assert(!k.red);\n    const word = this.h.word(0); // Optimize for powers of two.\n\n    if ((word & word - 1) === 0) {\n      const bits = this.h.bitLength();\n      return k.iushln(bits - 1).imod(this.n);\n    }\n\n    return k.imuln(word).imod(this.n);\n  }\n\n  reduce(k) {\n    return this.mask.reduce(k);\n  }\n\n  splitHash(bytes) {\n    return this.mask.splitHash(bytes);\n  }\n\n  clamp(bytes) {\n    return this.mask.clamp(bytes);\n  }\n\n  encodeField(x) {\n    // [SEC1] Page 12, Section 2.3.5.\n    assert(x instanceof BN);\n    assert(!x.red);\n    return x.encode(this.endian, this.fieldSize);\n  }\n\n  decodeField(bytes) {\n    // [SEC1] Page 13, Section 2.3.6.\n    assert(Buffer.isBuffer(bytes));\n    if (bytes.length !== this.fieldSize) throw new Error('Invalid field element size.');\n    return BN.decode(bytes, this.endian);\n  }\n\n  encodeAdjusted(x) {\n    assert(x instanceof BN);\n    assert(!x.red);\n    return x.encode(this.endian, this.adjustedSize);\n  }\n\n  decodeAdjusted(bytes) {\n    assert(Buffer.isBuffer(bytes));\n    if (bytes.length !== this.adjustedSize) throw new Error('Invalid field element size.');\n    return BN.decode(bytes, this.endian);\n  }\n\n  encodeScalar(k) {\n    // [SEC1] Page 13, Section 2.3.7.\n    assert(k instanceof BN);\n    assert(!k.red);\n    return k.encode(this.endian, this.scalarSize);\n  }\n\n  decodeScalar(bytes) {\n    // [SEC1] Page 14, Section 2.3.8.\n    assert(Buffer.isBuffer(bytes));\n    if (bytes.length !== this.scalarSize) throw new Error('Invalid scalar size.');\n    return BN.decode(bytes, this.endian);\n  }\n\n  encodeUniform(r, bits) {\n    assert(r instanceof BN);\n    assert(bits >>> 0 === bits);\n    let mask = 0xff;\n    if ((this.fieldBits & 7) !== 0) mask = (1 << (this.fieldBits & 7)) - 1;\n    const x = r.fromRed();\n    const i = this.endian === 'le' ? this.fieldSize - 1 : 0;\n    const out = x.encode(this.endian, this.fieldSize);\n    out[i] |= bits & ~mask & 0xff;\n    return out;\n  }\n\n  decodeUniform(bytes) {\n    assert(Buffer.isBuffer(bytes));\n    if (bytes.length !== this.fieldSize) throw new Error('Invalid field size.');\n    const x = BN.decode(bytes, this.endian);\n    x.iumaskn(this.fieldBits);\n    return x.toRed(this.red);\n  }\n\n  encodePoint(point, compact) {\n    assert(point instanceof Point);\n    return point.encode(compact);\n  }\n\n  decodePoint(bytes) {\n    throw new Error('Not implemented.');\n  }\n\n  encodeX(point) {\n    throw new Error('Not implemented.');\n  }\n\n  decodeX(bytes) {\n    throw new Error('Not implemented.');\n  }\n\n  decodeEven(bytes) {\n    throw new Error('Not implemented.');\n  }\n\n  decodeSquare(bytes) {\n    throw new Error('Not implemented.');\n  }\n\n  toShort() {\n    throw new Error('Not implemented.');\n  }\n\n  toMont(b0) {\n    throw new Error('Not implemented.');\n  }\n\n  toEdwards(a0) {\n    throw new Error('Not implemented.');\n  }\n\n  pointToJSON(point, pre) {\n    assert(point instanceof Point);\n    return point.toJSON(pre);\n  }\n\n  pointFromJSON(json) {\n    throw new Error('Not implemented.');\n  }\n\n  toJSON(pre) {\n    let prefix, context;\n    let n, z, endo;\n\n    if (this.type === 'edwards') {\n      prefix = this.prefix ? this.prefix.toString() : null;\n      context = this.context;\n    }\n\n    if (!this.n.isZero()) n = this.n.toJSON();\n\n    if (!this.z.isZero()) {\n      z = this.z.fromRed();\n      if (this.z.redIsHigh()) z.isub(this.p);\n      z = z.toString(16);\n    }\n\n    if (this.endo) endo = this.endo.toJSON();\n    return {\n      id: this.id,\n      ossl: this.ossl,\n      type: this.type,\n      endian: this.endian,\n      hash: this.hash,\n      prefix,\n      context,\n      prime: this.prime,\n      p: this.p.toJSON(),\n      a: undefined,\n      b: undefined,\n      d: undefined,\n      n,\n      h: this.h.toString(16),\n      s: undefined,\n      z,\n      c: undefined,\n      g: this.g.toJSON(pre),\n      endo\n    };\n  }\n\n  static fromJSON(json) {\n    return new this(json);\n  }\n\n}\n/**\n * Point\n */\n\n\nclass Point {\n  constructor(curve, type) {\n    assert(curve instanceof Curve);\n    assert(type >>> 0 === type);\n    this.curve = curve;\n    this.type = type;\n    this.pre = null;\n  }\n\n  _init() {\n    throw new Error('Not implemented.');\n  }\n\n  _getNAF(width) {\n    assert(width >>> 0 === width);\n    if (this.pre && this.pre.naf) return this.pre.naf;\n    if (width === 0) return null;\n    const size = 1 << width - 1;\n    const points = new Array(size);\n    const dbl = size === 1 ? null : this.dbl();\n    points[0] = this;\n\n    for (let i = 1; i < size; i++) points[i] = points[i - 1].add(dbl);\n\n    return new NAF(width, points);\n  }\n\n  _safeNAF(width) {\n    return this._getNAF(width);\n  }\n\n  _getWindows(width, bits) {\n    assert(width >>> 0 === width);\n    assert(bits >>> 0 === bits);\n    if (this.pre && this.pre.windows) return this.pre.windows;\n    if (width === 0) return null;\n    const size = 1 << width;\n    const steps = (bits + width - 1) / width >>> 0;\n    const points = new Array(steps * size);\n    let g = this.toP();\n\n    for (let i = 0; i < steps; i++) {\n      points[i * size] = this.curve.point();\n\n      for (let j = 1; j < size; j++) points[i * size + j] = points[i * size + j - 1].add(g);\n\n      g = g.dblp(width);\n    }\n\n    return new Windows(width, bits, points);\n  }\n\n  _getDoubles(step, power) {\n    assert(step >>> 0 === step);\n    assert(power >>> 0 === power);\n    if (this.pre && this.pre.doubles) return this.pre.doubles;\n    if (step === 0) return null;\n    const len = Math.ceil(power / step) + 1;\n    const points = new Array(len);\n    let acc = this;\n    let k = 0;\n    points[k++] = acc;\n\n    for (let i = 0; i < power; i += step) {\n      for (let j = 0; j < step; j++) acc = acc.dbl();\n\n      points[k++] = acc;\n    }\n\n    assert(k === len);\n    return new Doubles(step, points);\n  }\n\n  _getBeta() {\n    return null;\n  }\n\n  _getBlinding(rng) {\n    if (this.pre && this.pre.blinding) return this.pre.blinding;\n    if (!rng) return null;\n    if (this.curve.n.isZero()) return null; // Pregenerate a random blinding value:\n    //\n    //   blind = random integer in [1,n-1]\n    //   unblind = G * blind\n    //\n    // We intend to subtract the blinding value\n    // from scalars before multiplication. We\n    // can add the unblinding point once the\n    // multiplication is complete.\n\n    const blind = this.curve.randomScalar(rng);\n    const unblind = this.mul(blind);\n    return new Blinding(blind, unblind);\n  }\n\n  _hasWindows(k) {\n    assert(k instanceof BN);\n    if (!this.pre || !this.pre.windows) return false;\n    const {\n      bits\n    } = this.pre.windows;\n    return bits >= k.bitLength();\n  }\n\n  _hasDoubles(k) {\n    assert(k instanceof BN);\n    if (!this.pre || !this.pre.doubles) return false;\n    const {\n      step,\n      points\n    } = this.pre.doubles;\n    const power = k.bitLength() + 1;\n    return points.length >= Math.ceil(power / step) + 1;\n  }\n\n  _getJNAF(point) {\n    assert(point instanceof Point);\n    assert(point.type === this.type); // Create comb for JSF.\n\n    return [this, // 1\n    this.add(point), // 3\n    this.sub(point), // 5\n    point // 7\n    ];\n  }\n\n  _blind(k, rng) {\n    // [SIDE1] Page 5, Section 4.\n    // [BLIND] Page 20, Section 7.\n    assert(k instanceof BN);\n    assert(!k.red); // Scalar splitting (requires precomputation).\n    //\n    // Blind a multiplication by first subtracting\n    // a blinding value from the scalar. Example:\n    //\n    //   b = random integer in [1,n-1]\n    //   B = P * b (precomputed)\n    //   Q = P * (k - b) + B\n    //\n    // Note that Joye describes a different method\n    // (multiplier randomization) which computes:\n    //\n    //   B = random point in E\n    //   Q = (P + B) * k - B * k\n    //\n    // Our method is more similar to the \"scalar\n    // splitting\" technique described in the\n    // second source above.\n    //\n    // The blinding value and its corresponding\n    // point are randomly generated and computed\n    // on boot. As long as an attacker is not\n    // able to observe the boot, this should give\n    // a decent bit of protection against various\n    // channel attacks.\n\n    if (this.pre && this.pre.blinding) {\n      const {\n        blind,\n        unblind\n      } = this.pre.blinding;\n      const t = k.sub(blind);\n      return [this, t, unblind];\n    } // Randomization is not possible without\n    // an RNG. Do a normal multiplication.\n\n\n    if (!rng) return [this, k, null]; // If we have no precomputed blinding\n    // factor, there are two possibilities\n    // for randomization:\n    //\n    // 1. Randomize the multiplier by adding\n    //    a random multiple of `n`.\n    //\n    // 2. Re-scale the point itself by a\n    //    random factor.\n    //\n    // The first option can be accomplished\n    // with some like:\n    //\n    //   a = random integer in [1,n-1]\n    //   r = a * n\n    //   Q = P * (k + r)\n    //\n    // The second is accomplished with:\n    //\n    //   a = random element in F(p)\n    //   R = (x * a^2, y * a^3, z * a)\n    //   Q = R * k\n    //\n    // If we have precomputed doubles / naf\n    // points, we opt for the first method\n    // to avoid randomizing everything.\n\n    if (this.pre) {\n      if (this.curve.n.isZero()) return [this, k, null];\n      const a = this.curve.randomScalar(rng);\n      const r = a.mul(this.curve.n);\n      const t = r.iadd(k);\n      return [this, t, null];\n    } // If there is no precomputation _at all_,\n    // we opt for the second method.\n\n\n    const p = this.randomize(rng);\n    return [p, k, null];\n  }\n\n  clone() {\n    throw new Error('Not implemented.');\n  }\n\n  swap(point, flag) {\n    throw new Error('Not implemented.');\n  }\n\n  precompute(bits, rng) {\n    assert(bits >>> 0 === bits);\n    if (!this.pre) this.pre = new Precomp();\n    if (!this.pre.naf) this.pre.naf = this._getNAF(8);\n    if (USE_FIXED && !this.pre.windows) this.pre.windows = this._getWindows(4, bits);\n    if (!this.pre.doubles) this.pre.doubles = this._getDoubles(4, bits + 1);\n    if (!this.pre.beta) this.pre.beta = this._getBeta();\n    if (!this.pre.blinding) this.pre.blinding = this._getBlinding(rng);\n    return this;\n  }\n\n  validate() {\n    return this.curve.validate(this);\n  }\n\n  normalize() {\n    return this;\n  }\n\n  scale(a) {\n    throw new Error('Not implemented.');\n  }\n\n  randomize(rng) {\n    const z = this.curve.randomField(rng);\n    return this.scale(z);\n  }\n\n  neg() {\n    throw new Error('Not implemented.');\n  }\n\n  add(point) {\n    throw new Error('Not implemented.');\n  }\n\n  sub(point) {\n    assert(point instanceof Point);\n    return this.add(point.neg());\n  }\n\n  dbl() {\n    throw new Error('Not implemented.');\n  }\n\n  dblp(pow) {\n    // Repeated doubling. This can\n    // be optimized by child classes.\n    assert(pow >>> 0 === pow);\n    let r = this;\n\n    for (let i = 0; i < pow; i++) r = r.dbl();\n\n    return r;\n  }\n\n  uadd(point) {\n    throw new Error('Not implemented.');\n  }\n\n  usub(point) {\n    assert(point instanceof Point);\n    return this.uadd(point.neg());\n  }\n\n  udbl() {\n    throw new Error('Not implemented.');\n  }\n\n  zaddu(point) {\n    throw new Error('Not implemented.');\n  }\n\n  zaddc(point) {\n    throw new Error('Not implemented.');\n  }\n\n  zdblu() {\n    throw new Error('Not implemented.');\n  }\n\n  diffAdd(p, q) {\n    throw new Error('Not implemented.');\n  }\n\n  diffAddDbl(p, q) {\n    throw new Error('Not implemented.');\n  }\n\n  recover() {\n    throw new Error('Not implemented.');\n  }\n\n  getX() {\n    throw new Error('Not implemented.');\n  }\n\n  getY() {\n    throw new Error('Not implemented.');\n  }\n\n  eq(point) {\n    throw new Error('Not implemented.');\n  }\n\n  isInfinity() {\n    throw new Error('Not implemented.');\n  }\n\n  isOdd() {\n    throw new Error('Not implemented.');\n  }\n\n  isEven() {\n    throw new Error('Not implemented.');\n  }\n\n  isSquare() {\n    throw new Error('Not implemented.');\n  }\n\n  eqX(x) {\n    throw new Error('Not implemented.');\n  }\n\n  eqXToP(x) {\n    throw new Error('Not implemented.');\n  }\n\n  isSmall() {\n    // Test whether the point is of small order.\n    if (this.isInfinity()) return false; // P * h = O\n\n    return this.jmulH().isInfinity();\n  }\n\n  hasTorsion() {\n    // Test whether the point is in another subgroup.\n    if (this.isInfinity()) return false; // P * n != O\n\n    return !this.jmul(this.curve.n).isInfinity();\n  }\n\n  mul(k) {\n    return this.jmul(k);\n  }\n\n  muln(k) {\n    return this.jmuln(k);\n  }\n\n  mulSimple(k) {\n    return this.jmulSimple(k);\n  }\n\n  mulBlind(k, rng) {\n    return this.jmulBlind(k, rng);\n  }\n\n  mulConst(k, rng) {\n    return this.jmulConst(k, rng);\n  }\n\n  mulAdd(k1, p2, k2) {\n    return this.jmulAdd(k1, p2, k2);\n  }\n\n  mulAddSimple(k1, p2, k2) {\n    return this.jmulAddSimple(k1, p2, k2);\n  }\n\n  mulH() {\n    return this.jmulH();\n  }\n\n  div(k) {\n    return this.jdiv(k);\n  }\n\n  divn(k) {\n    return this.jdivn(k);\n  }\n\n  divH() {\n    return this.jdivH();\n  }\n\n  jmul(k) {\n    if (USE_FIXED && this._hasWindows(k)) return this.curve._fixedMul(this, k);\n    if (this._hasDoubles(k)) return this.curve._fixedNafMul(this, k);\n    if (this.curve.endo && this.type === types.AFFINE) return this.curve._endoWnafMulAdd([this], [k]);\n    return this.curve._wnafMul(4, this, k);\n  }\n\n  jmuln(k) {\n    assert((k | 0) === k);\n    return this.jmulSimple(new BN(k));\n  }\n\n  jmulSimple(k) {\n    return this.curve._simpleMul(this, k);\n  }\n\n  jmulBlind(k, rng = null) {\n    const [p, t, unblind] = this._blind(k, rng);\n\n    const q = p.jmul(t);\n    if (unblind) return q.add(unblind);\n    return q;\n  }\n\n  jmulConst(k, rng = null) {\n    const [p, t, unblind] = this._blind(k, rng);\n\n    const q = this.curve._constMul(p, t, rng);\n\n    if (unblind) return q.uadd(unblind);\n    return q;\n  }\n\n  jmulAdd(k1, p2, k2) {\n    if (this.curve.endo && this.type === types.AFFINE) return this.curve._endoWnafMulAdd([this, p2], [k1, k2]);\n    return this.curve._wnafMulAdd(4, [this, p2], [k1, k2]);\n  }\n\n  jmulAddSimple(k1, p2, k2) {\n    return this.curve._simpleMulAdd([this, p2], [k1, k2]);\n  }\n\n  jmulH() {\n    const word = this.curve.h.word(0); // Optimize for powers of two.\n\n    if ((word & word - 1) === 0) {\n      const bits = this.curve.h.bitLength();\n      return this.toJ().dblp(bits - 1);\n    }\n\n    return this.jmulSimple(this.curve.h);\n  }\n\n  jdiv(k) {\n    assert(k instanceof BN);\n    assert(!k.red);\n    return this.jmul(k.invert(this.curve.n));\n  }\n\n  jdivn(k) {\n    assert(!this.curve.n.isZero());\n    if (this.curve.h.cmpn(k) === 0) return this.jdivH();\n    return this.jdiv(new BN(k));\n  }\n\n  jdivH() {\n    if (this.curve.n.isZero()) return this.toJ();\n    if (this.curve.h.cmpn(1) === 0) return this.toJ();\n    if (this.curve.hi === null) this.curve.hi = this.curve.h.invert(this.curve.n);\n    return this.jmul(this.curve.hi);\n  }\n\n  ladder(k) {\n    throw new Error('Not implemented.');\n  }\n\n  ladderSimple(k) {\n    throw new Error('Not implemented.');\n  }\n\n  ladderBlind(k, rng) {\n    throw new Error('Not implemented.');\n  }\n\n  ladderConst(k, rng) {\n    throw new Error('Not implemented.');\n  }\n\n  toP() {\n    return this.normalize();\n  }\n\n  toJ() {\n    return this;\n  }\n\n  toX() {\n    return this;\n  }\n\n  encode(compact) {\n    throw new Error('Not implemented.');\n  }\n\n  static decode(curve, bytes) {\n    throw new Error('Not implemented.');\n  }\n\n  encodeX() {\n    throw new Error('Not implemented.');\n  }\n\n  static decodeX(curve, bytes) {\n    throw new Error('Not implemented.');\n  }\n\n  static decodeEven(curve, bytes) {\n    throw new Error('Not implemented.');\n  }\n\n  static decodeSquare(curve, bytes) {\n    throw new Error('Not implemented.');\n  }\n\n  toJSON(pre) {\n    throw new Error('Not implemented.');\n  }\n\n  static fromJSON(curve, json) {\n    throw new Error('Not implemented.');\n  }\n\n  [custom]() {\n    return '<Point>';\n  }\n\n}\n/**\n * ShortCurve\n */\n\n\nclass ShortCurve extends Curve {\n  constructor(conf) {\n    super(ShortPoint, 'short', conf);\n    this.a = BN.fromJSON(conf.a).toRed(this.red);\n    this.b = BN.fromJSON(conf.b).toRed(this.red);\n    this.c = BN.fromJSON(conf.c || '0').toRed(this.red);\n    this.ai = this.a.isZero() ? this.zero : this.a.redInvert();\n    this.zi = this.z.isZero() ? this.zero : this.z.redInvert();\n    this.zeroA = this.a.isZero();\n    this.threeA = this.a.eq(this.three.redNeg());\n    this.redN = this.n.toRed(this.red);\n    this.pmodn = this.p.clone();\n    this.highOrder = this.n.cmp(this.p) >= 0;\n    this.smallGap = false;\n\n    this._finalize(conf);\n  }\n\n  _finalize(conf) {\n    super._finalize(conf); // Precalculate endomorphism.\n\n\n    if (conf.endo != null) this.endo = Endo.fromJSON(this, conf.endo);else this.endo = this._getEndomorphism();\n\n    if (!this.n.isZero()) {\n      this.pmodn = this.p.mod(this.n); // Check for Maxwell's trick (see eqXToP).\n\n      this.smallGap = this.p.div(this.n).cmpn(1) <= 0;\n    }\n\n    return this;\n  }\n\n  static _isomorphism(curveA, curveB, customA, odd) {\n    // Short Weierstrass Isomorphism.\n    //\n    // [GECC] Page 84, Section 3.1.5.\n    // [ARITH1] Page 274, Section 13.1.5.\n    // [ALT] Appendix F.3 (Isomorphic Mapping between Weierstrass Curves).\n    //\n    // Find `u` such that `a * u^4 = a'` and `b * u^6 = b'`.\n    //\n    // Transformation:\n    //\n    //   u4 = a' / a\n    //   u2 = +-sqrt(u4)\n    //   u6 = u4 * u2\n    //   a' = a * u4\n    //   b' = b * u6\n    //\n    // Where `u2` is any root that is square.\n    assert(curveA instanceof BN);\n    assert(curveB instanceof BN);\n    assert(customA instanceof BN);\n    assert(odd == null || typeof odd === 'boolean');\n    assert(!curveA.isZero() && !curveB.isZero());\n    const u4 = customA.redDiv(curveA);\n    const u2 = u4.redSqrt();\n\n    if (odd != null) {\n      if (u2.redIsOdd() !== odd) u2.redINeg();\n    } else {\n      if (u2.redJacobi() !== 1) u2.redINeg();\n    }\n\n    if (u2.redJacobi() !== 1) throw new Error('Invalid `a` coefficient.');\n    const u6 = u4.redMul(u2);\n    const a = curveA.redMul(u4);\n    const b = curveB.redMul(u6);\n    assert(a.eq(customA));\n    return [a, b];\n  }\n\n  _short(a0, odd) {\n    return ShortCurve._isomorphism(this.a, this.b, a0, odd);\n  }\n\n  _mont(b0, odd) {\n    // Short Weierstrass->Montgomery Equivalence.\n    //\n    // [ARITH1] Page 286, Section 13.2.3.c.\n    // [SAFE] \"Ladders\".\n    //\n    // Transformation:\n    //\n    //   r = A / (3 * B)\n    //   s = +-sqrt(3 * r^2 + a)\n    //   A = 3 * r / s\n    //   B = 1 / s\n    const [r, s] = this._findRS(odd);\n\n    const b = s.redInvert();\n    const a = r.redMuln(3).redMul(b);\n    if (b0 != null) return MontCurve._isomorphism(a, b, b0);\n    return [a, b];\n  }\n\n  _edwards(a0, odd) {\n    // Short Weierstrass->Twisted Edwards Equivalence.\n    //\n    // [TWISTEQ] Section 1.\n    //\n    // Transformation:\n    //\n    //   r = (a' + d') / 6\n    //   s = +-sqrt(3 * r^2 + a)\n    //   a' = 3 * r + 2 * s\n    //   d' = 3 * r - 2 * s\n    const [r, s] = this._findRS(odd);\n\n    const r3 = r.redMuln(3);\n    const s2 = s.redMuln(2);\n    const a = r3.redAdd(s2);\n    const d = r3.redSub(s2);\n    if (a0 != null) return EdwardsCurve._isomorphism(a, d, a0);\n    return [a, d];\n  }\n\n  _findRS(sign) {\n    // Find `r` and `s` for equivalence.\n    //\n    // [ARITH1] Page 286, Section 13.2.3.c.\n    // [SAFE] \"Ladders\".\n    //\n    // Computation:\n    //\n    //   r = solve(r^3 + a * r + b == 0, r)\n    //   s = +-sqrt(3 * r^2 + a)\n    //\n    // Computing `r` is non-trivial. We need\n    // to solve `r^3 + a * r + b = 0`, but we\n    // don't have a polynomial solver, so we\n    // loop over random points until we find\n    // one with 2-torsion. Multiplying by the\n    // subgroup order should yield a point of\n    // ((A / 3) / B, 0) which is a solution.\n    assert(sign == null || typeof sign === 'boolean');\n    assert(this.h.word(0) >= 4);\n    assert(!this.n.isZero());\n    const x = this.one.redNeg();\n    let p;\n\n    for (;;) {\n      x.redIAdd(this.one);\n\n      try {\n        p = this.pointFromX(x);\n      } catch (e) {\n        continue;\n      }\n\n      p = p.mul(this.n);\n      if (p.isInfinity()) continue;\n      if (!p.y.isZero()) continue;\n      break;\n    }\n\n    const r = p.x;\n    const r2 = r.redSqr();\n    const s = r2.redMuln(3).redIAdd(this.a).redSqrt();\n\n    if (sign != null) {\n      if (s.redIsOdd() !== sign) s.redINeg();\n    }\n\n    return [r, s];\n  }\n\n  _scale0(a, b) {\n    // We can extract the isomorphism factors with:\n    //\n    //   u4 = a' / a\n    //   u6 = b' / b\n    //   u2 = +-sqrt(u4)\n    //   u = +-sqrt(u2)\n    //   u3 = u2 * u\n    //\n    // `u2` should be picked such that `u4 * u2 = u6`.\n    const u4 = this.a.redDiv(this.field(a));\n    const u6 = this.b.redDiv(this.field(b));\n    const u2 = u4.redSqrt();\n    if (!u4.redMul(u2).eq(u6)) u2.redINeg();\n    assert(u4.redMul(u2).eq(u6));\n    const u = u2.redSqrt();\n    const u3 = u2.redMul(u);\n    assert(!u.isZero());\n    return [u2, u3];\n  }\n\n  _scale1(x, y) {\n    // If base points are available, it is much\n    // easier, with:\n    //\n    //   u2 = x' / x\n    //   u3 = y' / y\n    //   u = +-sqrt(u2)\n    //\n    // `u` should be picked such that `u2 * u = u3`.\n    const u2 = this.g.x.redDiv(this.field(x));\n    const u3 = this.g.y.redDiv(this.field(y));\n    const u = u2.redSqrt();\n    if (!u2.redMul(u).eq(u3)) u.redINeg();\n    assert(u2.redMul(u).eq(u3));\n    assert(!u.isZero());\n    return [u2, u3];\n  }\n\n  _scaleShort(curve) {\n    assert(curve instanceof ShortCurve);\n    if (this.g.isInfinity() || curve.g.isInfinity()) return this._scale0(curve.a, curve.b);\n    return this._scale1(curve.g.x, curve.g.y);\n  }\n\n  _scaleMont(curve) {\n    assert(curve instanceof MontCurve);\n\n    if (this.g.isInfinity() || curve.g.isInfinity()) {\n      const [a, b] = curve._short();\n\n      return this._scale0(a, b);\n    }\n\n    const {\n      x,\n      y\n    } = curve.g;\n    const nx = x.redAdd(curve.a3).redMul(curve.bi);\n    const ny = y.redMul(curve.bi);\n    return this._scale1(nx, ny);\n  }\n\n  _scaleEdwards(curve) {\n    assert(curve instanceof EdwardsCurve);\n\n    if (this.g.isInfinity() || curve.g.isInfinity()) {\n      const [a, b] = curve._short();\n\n      return this._scale0(a, b);\n    }\n\n    const {\n      x,\n      y,\n      z\n    } = curve.g;\n    const a5 = curve.a.redMuln(5);\n    const d5 = curve.d.redMuln(5);\n    const dma = curve.d.redSub(curve.a);\n    const d5a = d5.redSub(curve.a);\n    const da5 = curve.d.redSub(a5);\n    const ypz = y.redAdd(z);\n    const ymz = y.redSub(z);\n    const xx = d5a.redMul(y).redIAdd(da5.redMul(z));\n    const xz = ymz.redMuln(12);\n    const yy = dma.redMul(ypz).redMul(z);\n    const yz = ymz.redMul(x).redIMuln(4);\n    const zi = xz.redMul(yz).redInvert();\n    const nx = xx.redMul(yz).redMul(zi);\n    const ny = yy.redMul(xz).redMul(zi);\n    return this._scale1(nx, ny);\n  }\n\n  _getEndomorphism(index = 0) {\n    // Compute endomorphism.\n    //\n    // [GECC] Example 3.76, Page 128, Section 3.5.\n    // No curve params.\n    if (this.n.isZero() || this.g.isInfinity()) return null; // No efficient endomorphism.\n\n    if (!this.zeroA || this.p.modrn(3) !== 1 || this.n.modrn(3) !== 1) return null; // Solve beta^3 mod p = 1.\n\n    const [b1, b2] = this._getEndoRoots(this.p); // Choose the smallest beta by default.\n\n\n    const beta = [b1, b2][index & 1].toRed(this.red); // Solve lambda^3 mod n = 1.\n\n    const [l1, l2] = this._getEndoRoots(this.n); // Choose the lambda matching selected beta.\n    // Note that P * lambda = (x * beta, y).\n\n\n    const p = this.point(this.g.x.redMul(beta), this.g.y);\n    let lambda;\n\n    if (this.g.mul(l1).eq(p)) {\n      lambda = l1;\n    } else {\n      assert(this.g.mul(l2).eq(p));\n      lambda = l2;\n    } // Get basis vectors.\n\n\n    const basis = this._getEndoBasis(lambda); // Precompute `g1` and `g2`.\n\n\n    const pre = this._getEndoPrecomp(basis);\n\n    return new Endo(beta, lambda, basis, pre);\n  }\n\n  _getEndoRoots(num) {\n    // Find roots for x^2 + x + 1 in F.\n    //\n    // [GECC] Example 3.76, Page 128, Section 3.5.\n    // [GLV] Page 192, Section 2 (Endomorphisms).\n    //\n    // The above document doesn't fully explain how\n    // to derive these and only \"hints\" at it, as\n    // mentioned by Hal Finney[1], but we're basically\n    // computing two possible cube roots of 1 here.\n    //\n    // Note that we could also compute[2]:\n    //\n    //   beta = 2^((p - 1) / 3) mod p\n    //   lambda = 3^((n - 1) / 3) mod n\n    //\n    // As an extension of Fermat's little theorem:\n    //\n    //   g^(p - 1) mod p == 1\n    //\n    // It is suspected[3] this is how Hal Finney[4]\n    // computed his original endomorphism roots.\n    //\n    // @indutny's method for computing cube roots\n    // of unity[5] appears to be the method described\n    // on wikipedia[6][7].\n    //\n    // Sage produces the same solution:\n    //\n    //   sage: solve(x^2 + x + 1 == 0, x)\n    //   [x == -1/2*I*sqrt(3) - 1/2, x == 1/2*I*sqrt(3) - 1/2]\n    //\n    // This can be reduced to:\n    //\n    //   x = (+-sqrt(-3) - 1) / 2\n    //\n    // [1] https://bitcointalk.org/index.php?topic=3238.msg45565#msg45565\n    // [2] https://crypto.stackexchange.com/a/22739\n    // [3] https://bitcoin.stackexchange.com/a/35872\n    // [4] https://github.com/halfinney/bitcoin/commit/dc411b5\n    // [5] https://en.wikipedia.org/wiki/Cube_root_of_unity\n    // [6] https://en.wikipedia.org/wiki/Splitting_field#Cubic_example\n    // [7] http://mathworld.wolfram.com/SplittingField.html\n    const red = num === this.p ? this.red : BN.mont(num);\n    const two = new BN(2).toRed(red);\n    const three = new BN(3).toRed(red);\n    const i2 = two.redInvert(); // S1 = sqrt(-3) / 2\n\n    const s1 = three.redNeg().redSqrt().redMul(i2); // S2 = -S1\n\n    const s2 = s1.redNeg(); // R1 = S1 - 1 / 2\n\n    const r1 = s1.redSub(i2).fromRed(); // R2 = S2 - 1 / 2\n\n    const r2 = s2.redSub(i2).fromRed();\n    return [r1, r2].sort(BN.cmp);\n  }\n\n  _getEndoBasis(lambda) {\n    // Compute endomorphic basis.\n    //\n    // This essentially computes Cornacchia's algorithm\n    // for solving x^2 + d * y^2 = m (d = lambda, m = order).\n    //\n    // https://en.wikipedia.org/wiki/Cornacchia%27s_algorithm\n    //\n    // [GECC] Algorithm 3.74, Page 127, Section 3.5.\n    // [GLV] Page 196, Section 4 (Decomposing K).\n    //\n    // Balanced length-two representation of a multiplier.\n    //\n    // 1. Run the extended euclidean algorithm with inputs n\n    //    and lambda. The algorithm produces a sequence of\n    //    equations si*n + ti*lam = ri where s0=1, t0=0,\n    //    r0=n, s1=0, t1=1, r1=lam, and the remainders ri\n    //    and are non-negative and strictly decreasing. Let\n    //    l be the greatest index for which rl >= sqrt(n).\n    const [rl, tl, rl1, tl1, rl2, tl2] = this._egcdSqrt(lambda); // 2. Set (a1, b1) <- (rl+1, -tl+1).\n\n\n    const a1 = rl1;\n    const b1 = tl1.neg(); // 3. If (rl^2 + tl^2) <= (rl+2^2 + tl+2^2)\n    //    then set (a2, b2) <- (rl, -tl).\n    //    else set (a2, b2) <- (rl+2, -tl+2).\n\n    const lhs = rl.sqr().iadd(tl.sqr());\n    const rhs = rl2.sqr().iadd(tl2.sqr());\n    let a2, b2;\n\n    if (lhs.cmp(rhs) <= 0) {\n      a2 = rl;\n      b2 = tl.neg();\n    } else {\n      a2 = rl2;\n      b2 = tl2.neg();\n    }\n\n    return [new Vector(a1, b1), new Vector(a2, b2)];\n  }\n\n  _egcdSqrt(lambda) {\n    // Extended Euclidean algorithm for integers.\n    //\n    // [GECC] Algorithm 2.19, Page 40, Section 2.2.\n    // [GLV] Page 196, Section 4 (Decomposing K).\n    assert(lambda instanceof BN);\n    assert(!lambda.red);\n    assert(lambda.sign() > 0);\n    assert(this.n.sign() > 0); // Note that we insert the approximate square\n    // root checks as described in algorithm 3.74.\n    //\n    // Algorithm 2.19 is defined as:\n    //\n    // 1. u <- a\n    //    v <- b\n    //\n    // 2. x1 <- 1\n    //    y1 <- 0\n    //    x2 <- 0\n    //    y2 <- 1\n    //\n    // 3. while u != 0 do\n    //\n    // 3.1. q <- floor(v / u)\n    //      r <- v - q * u\n    //      x <- x2 - q * x1\n    //      y <- y2 - q * y1\n    //\n    // 3.2. v <- u\n    //      u <- r\n    //      x2 <- x1\n    //      x1 <- x\n    //      y2 <- y1\n    //      y1 <- y\n    //\n    // 4. d <- v\n    //    x <- x2\n    //    y <- y2\n    //\n    // 5. Return (d, x, y).\n    // Start with an approximate square root of n.\n\n    const sqrtn = this.n.ushrn(this.n.bitLength() >>> 1);\n    let u = lambda; // r1\n\n    let v = this.n.clone(); // r0\n\n    let x1 = new BN(1); // t1\n\n    let y1 = new BN(0); // t0\n\n    let x2 = new BN(0); // s1\n\n    let y2 = new BN(1); // s0\n    // All vectors are roots of: a + b * lambda = 0 (mod n).\n\n    let rl, tl; // First vector.\n\n    let rl1, tl1; // Inner.\n\n    let i = 0;\n    let j = 0;\n    let p; // Compute EGCD.\n\n    while (!u.isZero() && i < 2) {\n      const q = v.quo(u);\n      const r = v.sub(q.mul(u));\n      const x = x2.sub(q.mul(x1));\n      const y = y2.sub(q.mul(y1)); // Check for r < sqrt(n).\n\n      if (j === 0 && r.cmp(sqrtn) < 0) {\n        rl = p;\n        tl = x1;\n        rl1 = r;\n        tl1 = x;\n        j = 1; // 1 more round.\n      }\n\n      p = r;\n      v = u;\n      u = r;\n      x2 = x1;\n      x1 = x;\n      y2 = y1;\n      y1 = y;\n      i += j;\n    } // Should never happen.\n\n\n    assert(j !== 0, 'Could not find r < sqrt(n).'); // Second vector.\n\n    const rl2 = x2;\n    const tl2 = x1;\n    return [rl, tl, rl1, tl1, rl2, tl2];\n  }\n\n  _getEndoPrecomp(basis) {\n    // Precompute `g1` and `g2` to avoid round division.\n    //\n    // [JCEN12] Page 5, Section 4.3.\n    //\n    // Computation:\n    //\n    //   d = a1 * b2 - b1 * a2\n    //   t = ceil(log2(d+1)) + 16\n    //   g1 = round((2^t * b2) / d)\n    //   g2 = round((2^t * b1) / d)\n    //\n    // Where `d` is equal to `n`.\n    //\n    // As far as `t` goes, the paper above adds 2,\n    // whereas libsecp256k1 adds 16 (a total of 272).\n    assert(Array.isArray(basis));\n    assert(basis.length === 2);\n    assert(basis[0] instanceof Vector);\n    assert(basis[1] instanceof Vector);\n    const [v1, v2] = basis;\n    const d = v1.a.mul(v2.b).isub(v1.b.mul(v2.a));\n    const shift = d.bitLength() + 16;\n    const pow = BN.shift(1, shift);\n    const g1 = pow.mul(v2.b).divRound(d);\n    const g2 = pow.mul(v1.b).divRound(d);\n    assert(d.eq(this.n));\n    return [g1, g2];\n  }\n\n  _endoSplit(k) {\n    // Balanced length-two representation of a multiplier.\n    //\n    // [GECC] Algorithm 3.74, Page 127, Section 3.5.\n    //\n    // Also note that it is possible to precompute[1]\n    // values in order to avoid the division[2][3][4].\n    //\n    // This involves precomputing `g1` and `g2 (see\n    // above). `c1` and `c2` can then be computed as\n    // follows:\n    //\n    //   t = ceil(log2(n+1)) + 16\n    //   c1 = (k * g1) >> t\n    //   c2 = -((k * g2) >> t)\n    //\n    // Where `>>` is an _unsigned_ right shift. Also\n    // note that the last bit discarded in the shift\n    // must be stored. If it is 1, then add 1 to the\n    // scalar (absolute addition).\n    //\n    // It's worth noting that libsecp256k1 uses a\n    // different calculation along the lines of:\n    //\n    //   t = ceil(log2(n+1)) + 16\n    //   c1 = ((k * g1) >> t) * -b1\n    //   c2 = ((k * -g2) >> t) * -b2\n    //   k2 = c1 + c2\n    //   k1 = k2 * -lambda + k\n    //\n    // So, in the future, we can consider changing\n    // step 4 to:\n    //\n    //   4. Compute c1 = (k * g1) >> t\n    //          and c2 = -((k * g2) >> t).\n    //\n    //   const shift = this.scalarBits + 16;\n    //   const [g1, g2] = this.endo.pre;\n    //   const c1 = k.mulShift(g1, shift);\n    //   const c2 = k.mulShift(g2, shift).ineg();\n    //\n    // Once we're brave enough, that is.\n    //\n    // [1] [JCEN12] Page 5, Section 4.3.\n    // [2] https://github.com/bitcoin-core/secp256k1/blob/0b70241/src/scalar_impl.h#L259\n    // [3] https://github.com/bitcoin-core/secp256k1/pull/21\n    // [4] https://github.com/bitcoin-core/secp256k1/pull/127\n    assert(k instanceof BN);\n    assert(!k.red);\n    assert(!this.n.isZero());\n    const [v1, v2] = this.endo.basis; // 4. Compute c1 = round(b2 * k / n)\n    //        and c2 = round(-b1 * k / n).\n\n    const c1 = v2.b.mul(k).divRound(this.n);\n    const c2 = v1.b.neg().mul(k).divRound(this.n); // 5. Compute k1 = k - c1 * a1 - c2 * a2\n    //        and k2 = -c1 * b1 - c2 * b2.\n\n    const p1 = c1.mul(v1.a);\n    const p2 = c2.mul(v2.a);\n    const q1 = c1.ineg().mul(v1.b);\n    const q2 = c2.mul(v2.b); // Calculate answer.\n\n    const k1 = k.sub(p1).isub(p2);\n    const k2 = q1.isub(q2); // 6. Return (k1, k2).\n\n    return [k1, k2];\n  }\n\n  _endoBeta(point) {\n    assert(point instanceof ShortPoint);\n    return [point, point._getBeta()];\n  }\n\n  _endoWnafMulAdd(points, coeffs) {\n    // Point multiplication with efficiently computable endomorphisms.\n    //\n    // [GECC] Algorithm 3.77, Page 129, Section 3.5.\n    // [GLV] Page 193, Section 3 (Using Efficient Endomorphisms).\n    //\n    // Note it may be possible to do this 4-dimensionally [4GLV].\n    assert(Array.isArray(points));\n    assert(Array.isArray(coeffs));\n    assert(points.length === coeffs.length);\n    assert(this.endo != null);\n    const len = points.length;\n    const npoints = new Array(len * 2);\n    const ncoeffs = new Array(len * 2);\n\n    for (let i = 0; i < len; i++) {\n      const [p1, p2] = this._endoBeta(points[i]);\n\n      const [k1, k2] = this._endoSplit(coeffs[i]);\n\n      npoints[i * 2 + 0] = p1;\n      ncoeffs[i * 2 + 0] = k1;\n      npoints[i * 2 + 1] = p2;\n      ncoeffs[i * 2 + 1] = k2;\n    }\n\n    return this._wnafMulAdd(4, npoints, ncoeffs);\n  }\n\n  _icart(u0) {\n    // Icart's Method.\n    //\n    // Distribution: 5/8.\n    //\n    // [ICART] Page 4, Section 2.\n    // [H2EC] \"Icart Method\".\n    //\n    // Assumptions:\n    //\n    //   - p = 2 (mod 3).\n    //   - u != 0.\n    //\n    // Map:\n    //\n    //   u = 1, if u = 0\n    //   v = (3 * a - u^4) / (6 * u)\n    //   w = (2 * p - 1) / 3\n    //   x = (v^2 - b - u^6 / 27)^w + u^2 / 3\n    //   y = u * x + v\n    const {\n      a,\n      b,\n      i3,\n      one\n    } = this;\n    const i27 = i3.redSqr().redMul(i3);\n    const w = this.p.ushln(1).isubn(1).idivn(3);\n    const u = u0.clone();\n    u.cinject(one, u.czero());\n    const u2 = u.redSqr();\n    const u4 = u2.redSqr();\n    const u6 = u4.redMul(u2);\n    const u6i = u.redMuln(6).redFermat();\n    const v = a.redMuln(3).redISub(u4).redMul(u6i);\n    const v2 = v.redSqr();\n    const u6d27 = u6.redMul(i27);\n    const u2d3 = u2.redMul(i3);\n    const x = v2.redISub(b).redISub(u6d27).redPow(w).redIAdd(u2d3);\n    const y = u.redMul(x).redIAdd(v);\n    return this.point(x, y);\n  }\n\n  _sswu(u) {\n    // Simplified Shallue-Woestijne-Ulas Method.\n    //\n    // Distribution: 3/8.\n    //\n    // [SSWU1] Page 15-16, Section 7. Appendix G.\n    // [SSWU2] Page 5, Theorem 2.3.\n    // [H2EC] \"Simplified Shallue-van de Woestijne-Ulas Method\".\n    //\n    // Assumptions:\n    //\n    //   - a != 0, b != 0.\n    //   - Let z be a non-square in F(p).\n    //   - z != -1.\n    //   - The polynomial g(x) - z is irreducible over F(p).\n    //   - g(b / (z * a)) is square in F(p).\n    //   - u != 0, u != +-sqrt(-1 / z).\n    //\n    // Map:\n    //\n    //   g(x) = x^3 + a * x + b\n    //   t1 = 1 / (z^2 * u^4 + z * u^2)\n    //   x1 = (-b / a) * (1 + t1)\n    //   x1 = b / (z * a), if t1 = 0\n    //   x2 = z * u^2 * x1\n    //   x = x1, if g(x1) is square\n    //     = x2, otherwise\n    //   y = sign(u) * abs(sqrt(g(x)))\n    const {\n      b,\n      z,\n      ai,\n      zi,\n      one\n    } = this;\n    const e = this.p.subn(2);\n    const z2 = z.redSqr();\n    const ba = b.redNeg().redMul(ai);\n    const bza = b.redMul(zi).redMul(ai);\n    const u2 = u.redSqr();\n    const u4 = u2.redSqr();\n    const t1 = z2.redMul(u4).redIAdd(z.redMul(u2)).redPow(e);\n    const x1 = ba.redMul(one.redAdd(t1));\n    x1.cinject(bza, t1.czero());\n    const x2 = z.redMul(u2).redMul(x1);\n    const y1 = this.solveY2(x1);\n    const y2 = this.solveY2(x2);\n    const alpha = y1.redIsSquare() | 0;\n    const x = x1.cinject(x2, alpha ^ 1);\n    const y = y1.cinject(y2, alpha ^ 1).redSqrt();\n    y.cinject(y.redNeg(), y.redIsOdd() ^ u.redIsOdd());\n    return this.point(x, y);\n  }\n\n  _sswui(p, hint) {\n    // Inverting the Map (Simplified Shallue-Woestijne-Ulas).\n    //\n    // Assumptions:\n    //\n    //   - a^2 * x^2 - 2 * a * b * x - 3 * b^2 is square in F(p).\n    //   - If r < 3 then x != -b / a.\n    //\n    // Unlike SVDW, the preimages here are evenly\n    // distributed (more or less). SSWU covers ~3/8\n    // of the curve points. Each preimage has a 1/2\n    // chance of mapping to either x1 or x2.\n    //\n    // Assuming the point is within that set, each\n    // point has a 1/4 chance of inverting to any\n    // of the preimages. This means we can simply\n    // randomly select a preimage if one exists.\n    //\n    // However, the [SVDW2] sampling method seems\n    // slighly faster in practice for [SQUARED].\n    //\n    // Map:\n    //\n    //   c = sqrt(a^2 * x^2 - 2 * a * b * x - 3 * b^2)\n    //   u1 = -(a * x + b - c) / (2 * (a * x + b) * z)\n    //   u2 = -(a * x + b + c) / (2 * (a * x + b) * z)\n    //   u3 = -(a * x + b - c) / (2 * b * z)\n    //   u4 = -(a * x + b + c) / (2 * b * z)\n    //   r = random integer in [1,4]\n    //   u = sign(y) * abs(sqrt(ur))\n    const {\n      a,\n      b,\n      z\n    } = this;\n    const {\n      x,\n      y\n    } = p;\n    const r = hint & 3;\n    const a2x2 = a.redSqr().redMul(x.redSqr());\n    const abx2 = a.redMul(b).redMul(x).redIMuln(2);\n    const b23 = b.redSqr().redMuln(3);\n    const axb = a.redMul(x).redIAdd(b);\n    const [s0, c] = sqrt(a2x2.redISub(abx2).redISub(b23));\n    const n0 = axb.redSub(c).redINeg();\n    const n1 = axb.redAdd(c).redINeg();\n    const d0 = axb.redMul(z).redIMuln(2);\n    const d1 = b.redMul(z).redIMuln(2);\n    n0.cinject(n1, r & 1); // r = 1 or 3\n\n    d0.cinject(d1, r >>> 1); // r = 2 or 3\n\n    const [s1, u] = divSqrt(n0, d0);\n    u.cinject(u.redNeg(), u.redIsOdd() ^ y.redIsOdd());\n    if (!(s0 & s1)) throw new Error('Invalid point.');\n    return u;\n  }\n\n  _svdwf(u) {\n    // Shallue-van de Woestijne Method.\n    //\n    // Distribution: 9/16.\n    //\n    // [SVDW1] Section 5.\n    // [SVDW2] Page 8, Section 3.\n    //         Page 15, Section 6, Algorithm 1.\n    // [H2EC] \"Shallue-van de Woestijne Method\".\n    //\n    // Assumptions:\n    //\n    //   - p = 1 (mod 3).\n    //   - a = 0, b != 0.\n    //   - Let z be a unique element in F(p).\n    //   - g((sqrt(-3 * z^2) - z) / 2) is square in F(p).\n    //   - u != 0, u != +-sqrt(-g(z)).\n    //\n    // Map:\n    //\n    //   g(x) = x^3 + b\n    //   c = sqrt(-3 * z^2)\n    //   t1 = u^2 + g(z)\n    //   t2 = 1 / (u^2 * t1)\n    //   t3 = u^4 * t2 * c\n    //   x1 = (c - z) / 2 - t3\n    //   x2 = t3 - (c + z) / 2\n    //   x3 = z - t1^3 * t2 / (3 * z^2)\n    //   x = x1, if g(x1) is square\n    //     = x2, if g(x2) is square\n    //     = x3, otherwise\n    //   y = sign(u) * abs(sqrt(g(x)))\n    const {\n      c,\n      z,\n      zi,\n      i2,\n      i3\n    } = this;\n    const e = this.p.subn(2);\n    const gz = this.solveY2(z);\n    const z3 = i3.redMul(zi.redSqr());\n    const u2 = u.redSqr();\n    const u4 = u2.redSqr();\n    const t1 = u2.redAdd(gz);\n    const t2 = u2.redMul(t1).redPow(e);\n    const t3 = u4.redMul(t2).redMul(c);\n    const t4 = t1.redSqr().redMul(t1);\n    const x1 = c.redSub(z).redMul(i2).redISub(t3);\n    const x2 = t3.redSub(c.redAdd(z).redMul(i2));\n    const x3 = z.redSub(t4.redMul(t2).redMul(z3));\n    const y1 = this.solveY2(x1);\n    const y2 = this.solveY2(x2);\n    const y3 = this.solveY2(x3);\n    const alpha = y1.redIsSquare() | 0;\n    const beta = y2.redIsSquare() | 0;\n    x1.cinject(x2, (alpha ^ 1) & beta);\n    y1.cinject(y2, (alpha ^ 1) & beta);\n    x1.cinject(x3, (alpha ^ 1) & (beta ^ 1));\n    y1.cinject(y3, (alpha ^ 1) & (beta ^ 1));\n    return [x1, y1];\n  }\n\n  _svdw(u) {\n    const [x, yy] = this._svdwf(u);\n\n    const y = yy.redSqrt();\n    y.cinject(y.redNeg(), y.redIsOdd() ^ u.redIsOdd());\n    return this.point(x, y);\n  }\n\n  _svdwi(p, hint) {\n    // Inverting the Map (Shallue-van de Woestijne).\n    //\n    // [SQUARED] Algorithm 1, Page 8, Section 3.3.\n    // [SVDW2] Page 12, Section 5.\n    // [SVDW3] \"Inverting the map\".\n    //\n    // Assumptions:\n    //\n    //   - If r = 1 then x != -(c + z) / 2.\n    //   - If r = 2 then x != (c - z) / 2.\n    //   - If r > 2 then (t0 - t1 + t2) is square in F(p).\n    //   - f(f^-1(x)) = x where f is the map function.\n    //\n    // We use the sampling method from [SVDW2],\n    // _not_ [SQUARED]. This seems to have a\n    // better distribution in practice.\n    //\n    // Note that [SVDW3] also appears to be\n    // incorrect in terms of distribution.\n    //\n    // The distribution of f(u), assuming u is\n    // random, is (1/2, 1/4, 1/4).\n    //\n    // To mirror this, f^-1(x) should simply\n    // pick (1/2, 1/4, 1/8, 1/8).\n    //\n    // To anyone running the forward map, our\n    // strings will appear to be random.\n    //\n    // Map:\n    //\n    //   g(x) = x^3 + b\n    //   c = sqrt(-3 * z^2)\n    //   t0 = 9 * (x^2 * z^2 + z^4)\n    //   t1 = 18 * x * z^3\n    //   t2 = 12 * g(z) * (x - z)\n    //   t3 = sqrt(t0 - t1 + t2)\n    //   t4 = t3 * z\n    //   u1 = g(z) * (c - 2 * x - z) / (c + 2 * x + z)\n    //   u2 = g(z) * (c + 2 * x + z) / (c - 2 * x - z)\n    //   u3 = (3 * (z^3 - x * z^2) - 2 * g(z) + t4) / 2\n    //   u4 = (3 * (z^3 - x * z^2) - 2 * g(z) - t4) / 2\n    //   r = random integer in [1,4]\n    //   u = sign(y) * abs(sqrt(ur))\n    const {\n      b,\n      c,\n      z,\n      two\n    } = this;\n    const {\n      x,\n      y\n    } = p;\n    const r = hint & 3;\n    const z2 = z.redSqr();\n    const z3 = z2.redMul(z);\n    const z4 = z2.redSqr();\n    const gz = z3.redAdd(b);\n    const gz2 = gz.redMuln(2);\n    const xx = x.redSqr();\n    const x2z = x.redMuln(2).redIAdd(z);\n    const xz2 = x.redMul(z2);\n    const c0 = c.redSub(x2z);\n    const c1 = c.redAdd(x2z);\n    const t0 = xx.redMul(z2).redIAdd(z4).redIMuln(9);\n    const t1 = x.redMul(z3).redIMuln(18);\n    const t2 = gz.redMul(x.redSub(z)).redIMuln(12);\n    const [s0, t3] = sqrt(t0.redISub(t1).redIAdd(t2));\n    const s1 = r - 2 >>> 31 | s0;\n    const t4 = t3.redMul(z);\n    const t5 = z3.redISub(xz2).redIMuln(3).redISub(gz2);\n    const n0 = gz.redMul(c0);\n    const n1 = gz.redMul(c1);\n    const n2 = t5.redAdd(t4);\n    const n3 = t5.redSub(t4);\n    const d0 = two.clone();\n    n0.cinject(n1, (r ^ 1) - 1 >>> 31); // r = 1\n\n    n0.cinject(n2, (r ^ 2) - 1 >>> 31); // r = 2\n\n    n0.cinject(n3, (r ^ 3) - 1 >>> 31); // r = 3\n\n    d0.cinject(c1, (r ^ 0) - 1 >>> 31); // r = 0\n\n    d0.cinject(c0, (r ^ 1) - 1 >>> 31); // r = 1\n\n    const [s2, u] = divSqrt(n0, d0);\n\n    const [x0] = this._svdwf(u);\n\n    const s3 = x0.ceq(x);\n    u.cinject(u.redNeg(), u.redIsOdd() ^ y.redIsOdd());\n    if (!(s1 & s2 & s3)) throw new Error('Invalid point.');\n    return u;\n  }\n\n  isElliptic() {\n    const {\n      a,\n      b\n    } = this;\n    const a2 = a.redSqr();\n    const a3 = a2.redMul(a);\n    const b2 = b.redSqr();\n    const d = b2.redMuln(27).redIAdd(a3.redMuln(4)); // 4 * a^3 + 27 * b^2 != 0\n\n    return !d.isZero();\n  }\n\n  jinv() {\n    // [ARITH1] Page 71, Section 4.4.\n    // http://mathworld.wolfram.com/j-Invariant.html\n    const {\n      a,\n      b\n    } = this;\n    const a2 = a.redSqr();\n    const a3 = a2.redMul(a);\n    const b2 = b.redSqr();\n    const t0 = a3.redMuln(4);\n    const lhs = t0.redMuln(1728);\n    const rhs = b2.redMuln(27).redIAdd(t0);\n    if (rhs.isZero()) throw new Error('Curve is not elliptic.'); // (1728 * 4 * a^3) / (4 * a^3 + 27 * b^2)\n\n    return lhs.redDiv(rhs).fromRed();\n  }\n\n  point(x, y, inf = 0) {\n    return new ShortPoint(this, x, y, inf);\n  }\n\n  jpoint(x, y, z) {\n    return new JPoint(this, x, y, z);\n  }\n\n  solveY2(x) {\n    // [GECC] Page 89, Section 3.2.2.\n    // https://hyperelliptic.org/EFD/g1p/auto-shortw.html\n    assert(x instanceof BN); // y^2 = x^3 + a * x + b\n\n    const x3 = x.redSqr().redMul(x);\n    const y2 = x3.redIAdd(this.b);\n\n    if (!this.zeroA) {\n      // Save some cycles for a = -3.\n      if (this.threeA) y2.redIAdd(x.redMuln(-3));else y2.redIAdd(this.a.redMul(x));\n    }\n\n    return y2;\n  }\n\n  validate(point) {\n    assert(point instanceof ShortPoint);\n    if (point.inf) return true;\n    const {\n      x,\n      y\n    } = point;\n    const y2 = this.solveY2(x);\n    return y.redSqr().eq(y2);\n  }\n\n  pointFromX(x, sign = null) {\n    assert(x instanceof BN);\n    assert(sign == null || typeof sign === 'boolean');\n    if (!x.red) x = x.toRed(this.red);\n    const y = this.solveY(x);\n\n    if (sign != null) {\n      if (y.redIsOdd() !== sign) y.redINeg();\n    }\n\n    return this.point(x, y);\n  }\n\n  isIsomorphic(curve) {\n    // [GECC] Page 84, Section 3.1.5.\n    // [ARITH1] Page 286, Section 13.2.3.c.\n    assert(curve instanceof Curve);\n    if (!curve.p.eq(this.p)) return false;\n    let u2, u3;\n\n    try {\n      [u2, u3] = this._scale(curve);\n    } catch (e) {\n      return false;\n    } // E(a,b) <-> E(au^4,bu^6)\n\n\n    if (curve.type === 'short') {\n      // a' = a * u^4, b' = b * u^6\n      const a = this.field(curve.a).redMul(u2.redSqr());\n      const b = this.field(curve.b).redMul(u3.redSqr());\n      return this.a.eq(a) && this.b.eq(b);\n    } // E(a,b) <-> M(A,B)\n\n\n    if (curve.type === 'mont') {\n      // (A / (3 * B))^3 + a * (A / (3 * B)) + b = 0\n      const {\n        a3,\n        bi\n      } = curve;\n      const x = this.field(a3.redMul(bi)).redMul(u2);\n      const y2 = this.solveY2(x);\n      return y2.isZero();\n    } // E(a,b) <-> E(a,d)\n\n\n    if (curve.type === 'edwards') {\n      // ((a' + d') / 6)^3 + a * ((a' + d') / 6) + b = 0\n      const x = this.field(curve.ad6).redMul(u2);\n      const y2 = this.solveY2(x);\n      return y2.isZero();\n    }\n\n    return false;\n  }\n\n  isIsogenous(curve) {\n    assert(curve instanceof Curve);\n    return false;\n  }\n\n  pointFromShort(point) {\n    // [GECC] Page 84, Section 3.1.5.\n    // [ALT] Appendix F.3 (Isomorphic Mapping between Weierstrass Curves).\n    assert(point instanceof ShortPoint);\n\n    if (this.isIsomorphic(point.curve)) {\n      // Isomorphic maps for E(a,b)<->E(au^4,bu^6):\n      //\n      //   x' = x * u^2\n      //   y' = y * u^3\n      //\n      // Where a * u^4 = a' and b * u^6 = b'.\n      if (point.isInfinity()) return this.point();\n\n      const [u2, u3] = this._scale(point.curve);\n\n      const x = this.field(point.x);\n      const y = this.field(point.y);\n      const nx = x.redMul(u2);\n      const ny = y.redMul(u3);\n      return this.point(nx, ny);\n    }\n\n    throw new Error('Not implemented.');\n  }\n\n  pointFromMont(point) {\n    // [ALT] Appendix E.2 (Switching between Alternative Representations).\n    // [MONT2] \"Equivalence with Weierstrass curves\"\n    assert(point instanceof MontPoint);\n\n    if (this.isIsomorphic(point.curve)) {\n      // Equivalence for M(A,B)->E(a,b):\n      //\n      //   x = (u + A / 3) / B\n      //   y = v / B\n      //\n      // Undefined if ((u^3 + A * u^2 + u) / B) is not square.\n      if (point.isInfinity()) return this.point();\n      const {\n        a3,\n        bi\n      } = point.curve;\n\n      const [u2, u3] = this._scale(point.curve);\n\n      const nx = point.x.redAdd(a3).redMul(bi);\n      const ny = point.y.redMul(bi);\n      return this.point(this.field(nx).redMul(u2), this.field(ny).redMul(u3));\n    }\n\n    throw new Error('Not implemented.');\n  }\n\n  pointFromEdwards(point) {\n    // [TWISTEQ] Section 2.\n    assert(point instanceof EdwardsPoint);\n\n    if (this.isIsomorphic(point.curve)) {\n      // Equivalence for E(a,d)->E(a',b'):\n      //\n      //   x' = ((5 * d - a) * y + d - 5 * a) / (12 * (y - 1))\n      //   y' = (d - a) * (y + 1) / (4 * x * (y - 1))\n      //\n      // Undefined for x = 0 or y = 1.\n      //\n      // Exceptional Cases:\n      //   - (0, 1) -> O\n      //   - (0, -1) -> ((a + d) / 6, 0)\n      //\n      // Unexceptional Cases:\n      //   - (sqrt(1 / a), 0) -> ((5 * a - d) / 12, (a - d) / 4 * sqrt(a))\n      const {\n        a,\n        d,\n        ad6\n      } = point.curve;\n\n      const [u2, u3] = this._scale(point.curve);\n\n      if (point.isInfinity()) return this.point();\n\n      if (point.x.isZero()) {\n        const x = this.field(ad6).redMul(u2);\n        return this.point(x, this.zero);\n      }\n\n      const {\n        x,\n        y,\n        z\n      } = point;\n      const a5 = a.redMuln(5);\n      const d5 = d.redMuln(5);\n      const dma = d.redSub(a);\n      const d5a = d5.redSub(a);\n      const da5 = d.redSub(a5);\n      const ypz = y.redAdd(z);\n      const ymz = y.redSub(z);\n      const xx = d5a.redMul(y).redIAdd(da5.redMul(z));\n      const xz = ymz.redMuln(12);\n      const yy = dma.redMul(ypz).redMul(z);\n      const yz = ymz.redMul(x).redIMuln(4);\n      return this.cpoint(this.field(xx).redMul(u2), this.field(xz), this.field(yy).redMul(u3), this.field(yz));\n    }\n\n    throw new Error('Not implemented.');\n  }\n\n  pointFromUniform(u) {\n    assert(u instanceof BN); // z = 0 or b = 0\n\n    if (this.z.isZero() || this.b.isZero()) throw new Error('Not implemented.'); // a != 0, b != 0\n\n    if (!this.a.isZero()) return this._sswu(u); // p = 1 mod 3, a = 0, b != 0\n\n    if (!this.c.isZero()) return this._svdw(u);\n    throw new Error('Not implemented.');\n  }\n\n  pointToUniform(p, hint) {\n    assert(p instanceof ShortPoint);\n    assert(hint >>> 0 === hint); // z = 0 or b = 0\n\n    if (this.z.isZero() || this.b.isZero()) throw new Error('Not implemented.'); // P = O\n\n    if (p.isInfinity()) throw new Error('Invalid point.'); // Add a random torsion component.\n\n    const i = (hint >>> 4 & 15) % this.torsion.length;\n    const q = p.add(this.torsion[i]); // a != 0, b != 0\n\n    if (!this.a.isZero()) return this._sswui(q, hint); // p = 1 mod 3, a = 0, b != 0\n\n    if (!this.c.isZero()) return this._svdwi(q, hint);\n    throw new Error('Not implemented.');\n  }\n\n  mulAll(points, coeffs) {\n    return super.mulAll(points, coeffs).toP();\n  }\n\n  mulAllSimple(points, coeffs) {\n    return super.mulAllSimple(points, coeffs).toP();\n  }\n\n  decodePoint(bytes) {\n    return ShortPoint.decode(this, bytes);\n  }\n\n  encodeX(point) {\n    assert(point instanceof Point);\n    return point.encodeX();\n  }\n\n  decodeEven(bytes) {\n    return ShortPoint.decodeEven(this, bytes);\n  }\n\n  decodeSquare(bytes) {\n    return ShortPoint.decodeSquare(this, bytes);\n  }\n\n  toShort(a0, odd, sign = null) {\n    const [a, b] = this._short(a0, odd);\n\n    const curve = new ShortCurve({\n      red: this.red,\n      prime: this.prime,\n      p: this.p,\n      a: a,\n      b: b,\n      n: this.n,\n      h: this.h\n    });\n\n    if (sign != null) {\n      const [, u3] = curve._scale(this);\n\n      if (u3.redIsOdd() !== sign) u3.redINeg();\n    }\n\n    if (!this.g.isInfinity()) curve.g = curve.pointFromShort(this.g);\n\n    for (let i = 0; i < this.h; i++) curve.torsion[i] = curve.pointFromShort(this.torsion[i]);\n\n    return curve;\n  }\n\n  toMont(b0, odd, sign = null) {\n    const [a, b] = this._mont(b0, odd);\n\n    const curve = new MontCurve({\n      red: this.red,\n      prime: this.prime,\n      p: this.p,\n      a: a,\n      b: b,\n      n: this.n,\n      h: this.h\n    });\n\n    if (sign != null) {\n      const [, u3] = this._scale(curve);\n\n      if (u3.redIsOdd() !== sign) u3.redINeg();\n    }\n\n    if (!this.g.isInfinity()) curve.g = curve.pointFromShort(this.g);\n\n    for (let i = 0; i < this.h; i++) curve.torsion[i] = curve.pointFromShort(this.torsion[i]);\n\n    return curve;\n  }\n\n  toEdwards(a0, odd, sign = null) {\n    const [a, d] = this._edwards(a0, odd);\n\n    const curve = new EdwardsCurve({\n      red: this.red,\n      prime: this.prime,\n      p: this.p,\n      a: a,\n      d: d,\n      n: this.n,\n      h: this.h\n    });\n\n    if (sign != null) {\n      const [, u3] = this._scale(curve);\n\n      if (u3.redIsOdd() !== sign) u3.redINeg();\n    }\n\n    if (!this.g.isInfinity()) {\n      curve.g = curve.pointFromShort(this.g);\n      curve.g.normalize();\n    }\n\n    if (curve.isComplete()) {\n      for (let i = 0; i < this.h; i++) {\n        curve.torsion[i] = curve.pointFromShort(this.torsion[i]);\n        curve.torsion[i].normalize();\n      }\n    }\n\n    return curve;\n  }\n\n  pointFromJSON(json) {\n    return ShortPoint.fromJSON(this, json);\n  }\n\n  toJSON(pre) {\n    const json = super.toJSON(pre);\n    json.a = this.a.fromRed().toJSON();\n    json.b = this.b.fromRed().toJSON();\n    if (!this.c.isZero()) json.c = this.c.fromRed().toJSON();\n    return json;\n  }\n\n}\n/**\n * ShortPoint\n */\n\n\nclass ShortPoint extends Point {\n  constructor(curve, x, y, inf) {\n    assert(curve instanceof ShortCurve);\n    super(curve, types.AFFINE);\n    this.x = this.curve.zero;\n    this.y = this.curve.zero;\n    this.inf = 1;\n    if (x != null) this._init(x, y, inf);\n  }\n\n  _init(x, y, inf) {\n    assert(x instanceof BN);\n    assert(y instanceof BN);\n    this.x = x;\n    this.y = y;\n    if (!this.x.red) this.x = this.x.toRed(this.curve.red);\n    if (!this.y.red) this.y = this.y.toRed(this.curve.red);\n    this.inf = inf | 0;\n  }\n\n  _safeNAF(width) {\n    assert(width >>> 0 === width);\n    if (this.pre && this.pre.naf) return this.pre.naf; // Avoid inversions.\n\n    if (width > 1) return this.toJ()._getNAF(width);\n    return this._getNAF(width);\n  }\n\n  _getBeta() {\n    if (!this.curve.endo) return null;\n    if (this.pre && this.pre.beta) return this.pre.beta; // Augment the point with our beta value.\n    // This is the counterpart to `k2` after\n    // the endomorphism split of `k`.\n    //\n    // Note that if we have precomputation,\n    // we have to clone and update all of the\n    // precomputed points below.\n\n    const xb = this.x.redMul(this.curve.endo.beta);\n    const beta = this.curve.point(xb, this.y);\n\n    if (this.pre) {\n      beta.pre = this.pre.map(point => {\n        const xb = point.x.redMul(this.curve.endo.beta);\n        return this.curve.point(xb, point.y);\n      });\n      this.pre.beta = beta;\n    }\n\n    return beta;\n  }\n\n  _getJNAF(point) {\n    assert(point instanceof ShortPoint);\n    if (this.inf | point.inf) return super._getJNAF(point); // Create comb for JSF.\n\n    const comb = [this, // 1\n    null, // 3\n    null, // 5\n    point // 7\n    ]; // Try to avoid Jacobian points, if possible.\n\n    if (this.y.eq(point.y)) {\n      comb[1] = this.add(point);\n      comb[2] = this.toJ().sub(point);\n    } else if (this.y.eq(point.y.redNeg())) {\n      comb[1] = this.toJ().add(point);\n      comb[2] = this.sub(point);\n    } else {\n      comb[1] = this.toJ().add(point);\n      comb[2] = this.toJ().sub(point);\n    }\n\n    return comb;\n  }\n\n  clone() {\n    return this.curve.point(this.x.clone(), this.y.clone(), this.inf);\n  }\n\n  swap(point, flag) {\n    assert(point instanceof ShortPoint);\n    const cond = (flag >> 31 | -flag >> 31) & 1;\n    const inf1 = this.inf;\n    const inf2 = point.inf;\n    this.x.cswap(point.x, flag);\n    this.y.cswap(point.y, flag);\n    this.inf = inf1 & (cond ^ 1) | inf2 & cond;\n    point.inf = inf2 & (cond ^ 1) | inf1 & cond;\n    return this;\n  }\n\n  scale(a) {\n    return this.toJ().scale(a);\n  }\n\n  neg() {\n    // P = O\n    if (this.inf) return this; // -(X1, Y1) = (X1, -Y1)\n\n    return this.curve.point(this.x, this.y.redNeg());\n  }\n\n  add(p) {\n    // [GECC] Page 80, Section 3.1.2.\n    //\n    // Addition Law:\n    //\n    //   l = (y1 - y2) / (x1 - x2)\n    //   x3 = l^2 - x1 - x2\n    //   y3 = l * (x1 - x3) - y1\n    //\n    // 1I + 2M + 1S + 6A\n    assert(p instanceof ShortPoint); // O + P = P\n\n    if (this.inf) return p; // P + O = P\n\n    if (p.inf) return this; // P + P, P + -P\n\n    if (this.x.eq(p.x)) {\n      // P + -P = O\n      if (!this.y.eq(p.y)) return this.curve.point(); // P + P = 2P\n\n      return this.dbl();\n    } // X1 != X2, Y1 = Y2\n\n\n    if (this.y.eq(p.y)) {\n      // X3 = -X1 - X2\n      const nx = this.x.redNeg().redISub(p.x); // Y3 = -Y1\n\n      const ny = this.y.redNeg(); // Skip the inverse.\n\n      return this.curve.point(nx, ny);\n    } // H = X1 - X2\n\n\n    const h = this.x.redSub(p.x); // R = Y1 - Y2\n\n    const r = this.y.redSub(p.y); // L = R / H\n\n    const l = r.redDiv(h); // X3 = L^2 - X1 - X2\n\n    const nx = l.redSqr().redISub(this.x).redISub(p.x); // Y3 = L * (X1 - X3) - Y1\n\n    const ny = l.redMul(this.x.redSub(nx)).redISub(this.y);\n    return this.curve.point(nx, ny);\n  }\n\n  dbl() {\n    // [GECC] Page 80, Section 3.1.2.\n    //\n    // Addition Law (doubling):\n    //\n    //   l = (3 * x1^2 + a) / (2 * y1)\n    //   x3 = l^2 - 2 * x1\n    //   y3 = l * (x1 - x3) - y1\n    //\n    // 1I + 2M + 2S + 3A + 2*2 + 1*3\n    // P = O\n    if (this.inf) return this; // Y1 = 0\n\n    if (this.y.isZero()) return this.curve.point(); // XX = X1^2\n\n    const xx = this.x.redSqr(); // M = 3 * XX + a\n\n    const m = xx.redIMuln(3).redIAdd(this.curve.a); // Z = 2 * Y1\n\n    const z = this.y.redMuln(2); // L = M / Z\n\n    const l = m.redDiv(z); // X3 = L^2 - 2 * X1\n\n    const nx = l.redSqr().redISub(this.x).redISub(this.x); // Y3 = L * (X1 - X3) - Y1\n\n    const ny = l.redMul(this.x.redSub(nx)).redISub(this.y);\n    return this.curve.point(nx, ny);\n  }\n\n  dblp(pow) {\n    return this.toJ().dblp(pow).toP();\n  }\n\n  uadd(p) {\n    // [SIDE2] Page 5, Section 3.\n    // [SIDE3] Page 4, Section 3.\n    //\n    // Addition Law (unified):\n    //\n    //   l = ((x1 + x2)^2 - (x1 * x2) + a) / (y1 + y2)\n    //   x3 = l^2 - x1 - x2\n    //   y3 = l * (x1 - x3) - y1\n    //\n    // If x1 != x2 and y1 = -y2, we switch\n    // back to the regular addition lambda:\n    //\n    //   l = (y1 - y2) / (x1 - x2)\n    //\n    // 1I + 3M + 2S + 10A\n    assert(p instanceof ShortPoint); // M = Y1 + Y2\n\n    const m = this.y.redAdd(p.y); // A = (X1 + X2)^2\n\n    const a = this.x.redAdd(p.x).redSqr(); // B = X1 * X2\n\n    const b = this.x.redMul(p.x); // R = A - B + a\n\n    const r = a.redISub(b).redIAdd(this.curve.a); // Check for degenerate case (X1 != X2, Y1 = -Y2).\n\n    const degenerate = m.czero() & r.czero(); // M = X1 - X2 (if degenerate)\n\n    m.cinject(this.x.redSub(p.x), degenerate); // R = Y1 - Y2 (if degenerate)\n\n    r.cinject(this.y.redSub(p.y), degenerate); // Check for negation (X1 = X2, Y1 = -Y2).\n\n    const negated = m.czero() & ((this.inf | p.inf) ^ 1); // M = 1 (if M = 0)\n\n    m.cinject(this.curve.one, m.czero()); // L = R / M\n\n    const l = r.redMul(m.redFermat()); // X3 = L^2 - X1 - X2\n\n    const nx = l.redSqr().redISub(this.x).redISub(p.x); // Y3 = L * (X1 - X3) - Y1\n\n    const ny = l.redMul(this.x.redSub(nx)).redISub(this.y); // Check for infinity.\n\n    const inf = negated | this.inf & p.inf; // Case 1: O + P = P\n\n    nx.cinject(p.x, this.inf);\n    ny.cinject(p.y, this.inf); // Case 2: P + O = P\n\n    nx.cinject(this.x, p.inf);\n    ny.cinject(this.y, p.inf); // Case 3 & 4: P + -P = O, O + O = O\n\n    nx.cinject(this.curve.zero, inf);\n    ny.cinject(this.curve.zero, inf);\n    return this.curve.point(nx, ny, inf);\n  }\n\n  udbl() {\n    return this.uadd(this);\n  }\n\n  recover(x1, z1, x2, z2) {\n    // Brier-Joye Y-coordinate Recovery.\n    //\n    // [SIDE2] Proposition 3, Page 7, Section 4.\n    //\n    // 14M + 3S + 5A + 2*2 + 1*a + 1*b\n    assert(x1 instanceof BN);\n    assert(z1 instanceof BN);\n    assert(x2 instanceof BN);\n    assert(z2 instanceof BN); // P = O\n\n    if (this.inf) return this.curve.jpoint(); // Z = Z1 * Z2\n\n    const z = z1.redMul(z2); // ZZ = Z^2\n\n    const zz = z.redSqr(); // ZZZ = ZZ * Z\n\n    const zzz = zz.redMul(z); // U0 = X0 * Z\n\n    const u0 = this.x.redMul(z); // U1 = X1 * Z2\n\n    const u1 = x1.redMul(z2); // U2 = X2 * Z1\n\n    const u2 = x2.redMul(z1); // A = 2 * b * ZZZ\n\n    const a = this.curve.b.redMul(zzz).redIMuln(2); // B = a * ZZ + U0 * U1\n\n    const b = u0.redMul(u1).redIAdd(this.curve.a.redMul(zz)); // C = U0 + U1\n\n    const c = u0.redAdd(u1); // D = U0 - U1\n\n    const d = u0.redISub(u1); // E = A + B * C\n\n    const e = a.redIAdd(b.redMul(c)); // F = U2 * D^2\n\n    const f = u2.redMul(d.redSqr()); // G = E - F\n\n    const g = e.redISub(f); // H = 2 * Y0 * ZZZ\n\n    const h = this.y.redMul(zzz).redIMuln(2); // I = X1 * H\n\n    const i = x1.redMul(h); // J = G * Z1\n\n    const j = g.redMul(z1); // K = Z1 * H\n\n    const k = z1.redMul(h); // X3 = I * K\n\n    const nx = i.redMul(k); // Y3 = J * K^2\n\n    const ny = j.redMul(k.redSqr()); // Z3 = K\n\n    const nz = k;\n    return this.curve.jpoint(nx, ny, nz);\n  }\n\n  getX() {\n    if (this.inf) throw new Error('Invalid point.');\n    return this.x.fromRed();\n  }\n\n  getY() {\n    if (this.inf) throw new Error('Invalid point.');\n    return this.y.fromRed();\n  }\n\n  eq(p) {\n    assert(p instanceof ShortPoint); // P = Q\n\n    if (this === p) return true; // P = O\n\n    if (this.inf) return p.inf !== 0; // Q = O\n\n    if (p.inf) return false; // X1 = X2, Y1 = Y2\n\n    return this.x.eq(p.x) && this.y.eq(p.y);\n  }\n\n  isInfinity() {\n    // Infinity cannot be represented in\n    // the affine space, except by a flag.\n    return this.inf !== 0;\n  }\n\n  isOdd() {\n    if (this.inf) return false;\n    return this.y.redIsOdd();\n  }\n\n  isEven() {\n    if (this.inf) return false;\n    return this.y.redIsEven();\n  }\n\n  isSquare() {\n    if (this.inf) return false;\n    return this.y.redJacobi() !== -1;\n  }\n\n  eqX(x) {\n    assert(x instanceof BN);\n    assert(!x.red);\n    if (this.inf) return false;\n    return this.getX().eq(x);\n  }\n\n  eqXToP(x) {\n    assert(x instanceof BN);\n    assert(!x.red);\n    assert(!this.curve.n.isZero());\n    if (this.inf) return false;\n    return this.getX().imod(this.curve.n).eq(x);\n  }\n\n  mul(k) {\n    return super.mul(k).toP();\n  }\n\n  muln(k) {\n    return super.muln(k).toP();\n  }\n\n  mulSimple(k) {\n    return super.mulSimple(k).toP();\n  }\n\n  mulBlind(k, rng) {\n    return super.mulBlind(k, rng).toP();\n  }\n\n  mulConst(k, rng) {\n    return super.mulConst(k, rng).toP();\n  }\n\n  mulAdd(k1, p2, k2) {\n    return super.mulAdd(k1, p2, k2).toP();\n  }\n\n  mulAddSimple(k1, p2, k2) {\n    return super.mulAddSimple(k1, p2, k2).toP();\n  }\n\n  mulH() {\n    return super.mulH().toP();\n  }\n\n  div(k) {\n    return super.div(k).toP();\n  }\n\n  divn(k) {\n    return super.divn(k).toP();\n  }\n\n  divH() {\n    return super.divH().toP();\n  }\n\n  toP() {\n    return this;\n  }\n\n  toJ() {\n    // (X3, Y3, Z3) = (1, 1, 0)\n    if (this.inf) return this.curve.jpoint(); // (X3, Y3, Z3) = (X1, Y1, 1)\n\n    return this.curve.jpoint(this.x, this.y, this.curve.one);\n  }\n\n  encode(compact) {\n    // [SEC1] Page 10, Section 2.3.3.\n    if (compact == null) compact = true;\n    assert(typeof compact === 'boolean');\n    const {\n      fieldSize\n    } = this.curve; // We do not serialize points at infinity.\n\n    if (this.inf) throw new Error('Invalid point.'); // Compressed form (0x02 = even, 0x03 = odd).\n\n    if (compact) {\n      const p = Buffer.allocUnsafe(1 + fieldSize);\n      const x = this.curve.encodeField(this.getX());\n      p[0] = 0x02 | this.y.redIsOdd();\n      x.copy(p, 1);\n      return p;\n    } // Uncompressed form (0x04).\n\n\n    const p = Buffer.allocUnsafe(1 + fieldSize * 2);\n    const x = this.curve.encodeField(this.getX());\n    const y = this.curve.encodeField(this.getY());\n    p[0] = 0x04;\n    x.copy(p, 1);\n    y.copy(p, 1 + fieldSize);\n    return p;\n  }\n\n  static decode(curve, bytes) {\n    // [SEC1] Page 11, Section 2.3.4.\n    assert(curve instanceof ShortCurve);\n    assert(Buffer.isBuffer(bytes));\n    const len = curve.fieldSize;\n    if (bytes.length < 1 + len) throw new Error('Not a point.'); // Point forms:\n    //\n    //   0x00 -> Infinity (openssl, unsupported)\n    //   0x02 -> Compressed Even\n    //   0x03 -> Compressed Odd\n    //   0x04 -> Uncompressed\n    //   0x06 -> Hybrid Even (openssl)\n    //   0x07 -> Hybrid Odd (openssl)\n    //\n    // Note that openssl supports serializing points\n    // at infinity as {0}. We choose not to support it\n    // because it's strange and not terribly useful.\n\n    const form = bytes[0];\n\n    switch (form) {\n      case 0x02:\n      case 0x03:\n        {\n          if (bytes.length !== 1 + len) throw new Error('Invalid point size for compressed.');\n          const x = curve.decodeField(bytes.slice(1, 1 + len));\n          if (x.cmp(curve.p) >= 0) throw new Error('Invalid point.');\n          const p = curve.pointFromX(x, form === 0x03);\n          assert(!p.isInfinity());\n          return p;\n        }\n\n      case 0x04:\n      case 0x06:\n      case 0x07:\n        {\n          if (bytes.length !== 1 + len * 2) throw new Error('Invalid point size for uncompressed.');\n          const x = curve.decodeField(bytes.slice(1, 1 + len));\n          const y = curve.decodeField(bytes.slice(1 + len, 1 + 2 * len)); // [GECC] Algorithm 4.3, Page 180, Section 4.\n\n          if (x.cmp(curve.p) >= 0 || y.cmp(curve.p) >= 0) throw new Error('Invalid point.'); // OpenSSL hybrid encoding.\n\n          if (form !== 0x04 && form !== (0x06 | y.isOdd())) throw new Error('Invalid hybrid encoding.');\n          const p = curve.point(x, y);\n          if (!p.validate()) throw new Error('Invalid point.');\n          assert(!p.isInfinity());\n          return p;\n        }\n\n      default:\n        {\n          throw new Error('Unknown point format.');\n        }\n    }\n  }\n\n  encodeX() {\n    // [SCHNORR] \"Specification\".\n    // [BIP340] \"Specification\".\n    return this.curve.encodeField(this.getX());\n  }\n\n  static decodeEven(curve, bytes) {\n    // [BIP340] \"Specification\".\n    assert(curve instanceof ShortCurve);\n    const x = curve.decodeField(bytes);\n    if (x.cmp(curve.p) >= 0) throw new Error('Invalid point.');\n    return curve.pointFromX(x, false);\n  }\n\n  static decodeSquare(curve, bytes) {\n    // [SCHNORR] \"Specification\".\n    // [BIP340] \"Specification\".\n    assert(curve instanceof ShortCurve);\n    const x = curve.decodeField(bytes);\n    if (x.cmp(curve.p) >= 0) throw new Error('Invalid point.');\n    return curve.pointFromX(x);\n  }\n\n  toJSON(pre) {\n    if (this.inf) return [];\n    const x = this.getX().toJSON();\n    const y = this.getY().toJSON();\n    if (pre === true && this.pre) return [x, y, this.pre.toJSON()];\n    return [x, y];\n  }\n\n  static fromJSON(curve, json) {\n    assert(curve instanceof ShortCurve);\n    assert(Array.isArray(json));\n    assert(json.length === 0 || json.length === 2 || json.length === 3);\n    if (json.length === 0) return curve.point();\n    const x = BN.fromJSON(json[0]);\n    const y = BN.fromJSON(json[1]);\n    const point = curve.point(x, y);\n    if (json.length > 2 && json[2] != null) point.pre = Precomp.fromJSON(point, json[2]);\n    return point;\n  }\n\n  [custom]() {\n    if (this.inf) return '<ShortPoint: Infinity>';\n    return '<ShortPoint:' + ' x=' + this.x.fromRed().toString(16, 2) + ' y=' + this.y.fromRed().toString(16, 2) + '>';\n  }\n\n}\n/**\n * JPoint\n */\n\n\nclass JPoint extends Point {\n  constructor(curve, x, y, z) {\n    assert(curve instanceof ShortCurve);\n    super(curve, types.JACOBIAN);\n    this.x = this.curve.one;\n    this.y = this.curve.one;\n    this.z = this.curve.zero;\n    this.zOne = 0;\n    if (x != null) this._init(x, y, z);\n  }\n\n  _init(x, y, z) {\n    assert(x instanceof BN);\n    assert(y instanceof BN);\n    assert(z == null || z instanceof BN);\n    this.x = x;\n    this.y = y;\n    this.z = z || this.curve.one;\n    if (!this.x.red) this.x = this.x.toRed(this.curve.red);\n    if (!this.y.red) this.y = this.y.toRed(this.curve.red);\n    if (!this.z.red) this.z = this.z.toRed(this.curve.red);\n    this.zOne = this.z.eq(this.curve.one) | 0;\n  }\n\n  clone() {\n    return this.curve.jpoint(this.x.clone(), this.y.clone(), this.z.clone());\n  }\n\n  swap(point, flag) {\n    assert(point instanceof JPoint);\n    const cond = (flag >> 31 | -flag >> 31) & 1;\n    const zOne1 = this.zOne;\n    const zOne2 = point.zOne;\n    this.x.cswap(point.x, flag);\n    this.y.cswap(point.y, flag);\n    this.z.cswap(point.z, flag);\n    this.zOne = zOne1 & (cond ^ 1) | zOne2 & cond;\n    point.zOne = zOne2 & (cond ^ 1) | zOne1 & cond;\n    return this;\n  }\n\n  validate() {\n    // [GECC] Example 3.20, Page 88, Section 3.\n    const {\n      a,\n      b\n    } = this.curve; // P = O\n\n    if (this.isInfinity()) return true; // Z1 = 1\n\n    if (this.zOne) return this.curve.validate(this.toP()); // y^2 = x^3 + a * x * z^4 + b * z^6\n\n    const lhs = this.y.redSqr();\n    const x3 = this.x.redSqr().redMul(this.x);\n    const z2 = this.z.redSqr();\n    const z4 = z2.redSqr();\n    const z6 = z4.redMul(z2);\n    const rhs = x3.redIAdd(b.redMul(z6));\n\n    if (!this.curve.zeroA) {\n      // Save some cycles for a = -3.\n      if (this.curve.threeA) rhs.redIAdd(z4.redIMuln(-3).redMul(this.x));else rhs.redIAdd(a.redMul(z4).redMul(this.x));\n    }\n\n    return lhs.eq(rhs);\n  }\n\n  normalize() {\n    // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#scaling-z\n    // 1I + 3M + 1S\n    // Z = 1\n    if (this.zOne) return this; // P = O\n\n    if (this.isInfinity()) return this; // A = 1 / Z1\n\n    const a = this.z.redInvert(); // AA = A^2\n\n    const aa = a.redSqr(); // X3 = X1 * AA\n\n    this.x = this.x.redMul(aa); // Y3 = Y1 * AA * A\n\n    this.y = this.y.redMul(aa).redMul(a); // Z3 = 1\n\n    this.z = this.curve.one;\n    this.zOne = 1;\n    return this;\n  }\n\n  scale(a) {\n    assert(a instanceof BN); // P = O\n\n    if (this.isInfinity()) return this.curve.jpoint(); // AA = A^2\n\n    const aa = a.redSqr(); // X3 = X1 * AA\n\n    const nx = this.x.redMul(aa); // Y3 = Y1 * AA * A\n\n    const ny = this.y.redMul(aa).redMul(a); // Z3 = Z1 * A\n\n    const nz = this.z.redMul(a);\n    return this.curve.jpoint(nx, ny, nz);\n  }\n\n  neg() {\n    // -(X1, Y1, Z1) = (X1, -Y1, Z1)\n    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);\n  }\n\n  add(p) {\n    assert(p instanceof Point);\n    if (p.type === types.AFFINE) return this._mixedAdd(p);\n    return this._add(p);\n  }\n\n  _add(p) {\n    assert(p instanceof JPoint); // O + P = P\n\n    if (this.isInfinity()) return p; // P + O = P\n\n    if (p.isInfinity()) return this; // Z1 = 1, Z2 = 1\n\n    if (this.zOne && p.zOne) return this._addAA(p); // Z1 = 1\n\n    if (this.zOne) return p._addJA(this); // Z2 = 1\n\n    if (p.zOne) return this._addJA(p);\n    return this._addJJ(p);\n  }\n\n  _mixedAdd(p) {\n    assert(p instanceof ShortPoint); // O + P = P\n\n    if (this.isInfinity()) return p.toJ(); // P + O = P\n\n    if (p.isInfinity()) return this; // Z1 = 1, Z2 = 1\n\n    if (this.zOne) return this._addAA(p);\n    return this._addJA(p);\n  }\n\n  _addJJ(p) {\n    // No assumptions.\n    // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#addition-add-1998-cmo-2\n    // 12M + 4S + 6A + 1*2 (implemented as: 12M + 4S + 7A)\n    // Z1Z1 = Z1^2\n    const z1z1 = this.z.redSqr(); // Z2Z2 = Z2^2\n\n    const z2z2 = p.z.redSqr(); // U1 = X1 * Z2Z2\n\n    const u1 = this.x.redMul(z2z2); // U2 = X2 * Z1Z1\n\n    const u2 = p.x.redMul(z1z1); // S1 = Y1 * Z2 * Z2Z2\n\n    const s1 = this.y.redMul(p.z).redMul(z2z2); // S2 = Y2 * Z1 * Z1Z1\n\n    const s2 = p.y.redMul(this.z).redMul(z1z1); // H = U2 - U1\n\n    const h = u2.redISub(u1); // r = S2 - S1\n\n    const r = s2.redISub(s1); // H = 0\n\n    if (h.isZero()) {\n      if (!r.isZero()) return this.curve.jpoint();\n      return this.dbl();\n    } // HH = H^2\n\n\n    const hh = h.redSqr(); // HHH = H * HH\n\n    const hhh = h.redMul(hh); // V = U1 * HH\n\n    const v = u1.redMul(hh); // X3 = r^2 - HHH - 2 * V\n\n    const nx = r.redSqr().redISub(hhh).redISub(v).redISub(v); // Y3 = r * (V - X3) - S1 * HHH\n\n    const ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(hhh)); // Z3 = Z1 * Z2 * H\n\n    const nz = this.z.redMul(p.z).redMul(h);\n    return this.curve.jpoint(nx, ny, nz);\n  }\n\n  _addJA(p) {\n    // Assumes Z2 = 1.\n    // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#addition-madd\n    // 8M + 3S + 6A + 5*2 (implemented as: 8M + 3S + 7A + 4*2)\n    // Z1Z1 = Z1^2\n    const z1z1 = this.z.redSqr(); // U2 = X2 * Z1Z1\n\n    const u2 = p.x.redMul(z1z1); // S2 = Y2 * Z1 * Z1Z1\n\n    const s2 = p.y.redMul(this.z).redMul(z1z1); // H = U2 - X1\n\n    const h = u2.redISub(this.x); // r = 2 * (S2 - Y1)\n\n    const r = s2.redISub(this.y).redIMuln(2); // H = 0\n\n    if (h.isZero()) {\n      if (!r.isZero()) return this.curve.jpoint();\n      return this.dbl();\n    } // I = (2 * H)^2\n\n\n    const i = h.redMuln(2).redSqr(); // J = H * I\n\n    const j = h.redMul(i); // V = X1 * I\n\n    const v = this.x.redMul(i); // X3 = r^2 - J - 2 * V\n\n    const nx = r.redSqr().redISub(j).redISub(v).redISub(v); // Y3 = r * (V - X3) - 2 * Y1 * J\n\n    const ny = r.redMul(v.redISub(nx)).redISub(this.y.redMul(j).redIMuln(2)); // Z3 = 2 * Z1 * H\n\n    const nz = this.z.redMul(h).redIMuln(2);\n    return this.curve.jpoint(nx, ny, nz);\n  }\n\n  _addAA(p) {\n    // Assumes Z1 = 1, Z2 = 1.\n    // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#addition-mmadd-2007-bl\n    // 4M + 2S + 6A + 4*2 + 1*4 (implemented as: 4M + 2S + 7A + 3*2 + 1*4)\n    // H = X2 - X1\n    const h = p.x.redSub(this.x); // r = 2 * (Y2 - Y1)\n\n    const r = p.y.redSub(this.y).redIMuln(2); // H = 0\n\n    if (h.isZero()) {\n      if (!r.isZero()) return this.curve.jpoint();\n      return this.dbl();\n    } // HH = H^2\n\n\n    const hh = h.redSqr(); // I = 4 * HH\n\n    const i = hh.redIMuln(4); // J = H * I\n\n    const j = h.redMul(i); // V = X1 * I\n\n    const v = this.x.redMul(i); // X3 = r^2 - J - 2 * V\n\n    const nx = r.redSqr().redISub(j).redISub(v).redISub(v); // Y3 = r * (V - X3) - 2 * Y1 * J\n\n    const ny = r.redMul(v.redISub(nx)).redISub(this.y.redMul(j).redIMuln(2)); // Z3 = 2 * H\n\n    const nz = h.redIMuln(2);\n    return this.curve.jpoint(nx, ny, nz);\n  }\n\n  dbl() {\n    // P = O\n    if (this.isInfinity()) return this; // Y1 = 0\n\n    if (this.y.isZero()) return this.curve.jpoint(); // Z1 = 1\n\n    if (this.zOne) return this._dblA(); // a = 0\n\n    if (this.curve.zeroA) return this._dbl0(); // a = -3\n\n    if (this.curve.threeA) return this._dbl3();\n    return this._dblJ();\n  }\n\n  _dblJ() {\n    // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#doubling-dbl-1998-cmo-2\n    // 3M + 6S + 4A + 1*a + 2*2 + 1*3 + 1*4 + 1*8\n    // (implemented as: 3M + 6S + 5A + 1*a + 1*2 + 1*3 + 1*4 + 1*8)\n    // XX = X1^2\n    const xx = this.x.redSqr(); // YY = Y1^2\n\n    const yy = this.y.redSqr(); // ZZ = Z1^2\n\n    const zz = this.z.redSqr(); // S = 4 * X1 * YY\n\n    const s = this.x.redMul(yy).redIMuln(4); // M = 3 * XX + a * ZZ^2\n\n    const m = xx.redIMuln(3).redIAdd(this.curve.a.redMul(zz.redSqr())); // T = M^2 - 2 * S\n\n    const t = m.redSqr().redISub(s).redISub(s); // X3 = T\n\n    const nx = t; // Y3 = M * (S - T) - 8 * YY^2\n\n    const ny = m.redMul(s.redISub(t)).redISub(yy.redSqr().redIMuln(8)); // Z3 = 2 * Y1 * Z1\n\n    const nz = this.y.redMul(this.z).redIMuln(2);\n    return this.curve.jpoint(nx, ny, nz);\n  }\n\n  _dblA() {\n    // Assumes Z = 1.\n    // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#doubling-mdbl-2007-bl\n    // 1M + 5S + 7A + 3*2 + 1*3 + 1*8\n    // (implemented as: 1M + 5S + 8A + 2*2 + 1*3 + 1*8)\n    // XX = X1^2\n    const xx = this.x.redSqr(); // YY = Y1^2\n\n    const yy = this.y.redSqr(); // YYYY = YY^2\n\n    const yyyy = yy.redSqr(); // + XYY2 = (X1 + YY)^2\n\n    const xyy2 = yy.redIAdd(this.x).redSqr(); // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n\n    const s = xyy2.redISub(xx).redISub(yyyy).redIMuln(2); // M = 3 * XX + a\n\n    const m = xx.redIMuln(3).redIAdd(this.curve.a); // T = M^2 - 2 * S\n\n    const t = m.redSqr().redISub(s).redISub(s); // X3 = T\n\n    const nx = t; // Y3 = M * (S - T) - 8 * YYYY\n\n    const ny = m.redMul(s.redISub(t)).redISub(yyyy.redIMuln(8)); // Z3 = 2 * Y1\n\n    const nz = this.y.redMuln(2);\n    return this.curve.jpoint(nx, ny, nz);\n  }\n\n  _dbl0() {\n    // Assumes a = 0.\n    // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#doubling-dbl-2009-l\n    // 2M + 5S + 6A + 3*2 + 1*3 + 1*8\n    // (implemented as: 2M + 5S + 7A + 2*2 + 1*3 + 1*8)\n    // A = X1^2\n    const a = this.x.redSqr(); // B = Y1^2\n\n    const b = this.y.redSqr(); // C = B^2\n\n    const c = b.redSqr(); // + XB2 = (X1 + B)^2\n\n    const xb2 = b.redIAdd(this.x).redSqr(); // D = 2 * ((X1 + B)^2 - A - C)\n\n    const d = xb2.redISub(a).redISub(c).redIMuln(2); // E = 3 * A\n\n    const e = a.redIMuln(3); // F = E^2\n\n    const f = e.redSqr(); // X3 = F - 2 * D\n\n    const nx = f.redISub(d).redISub(d); // Y3 = E * (D - X3) - 8 * C\n\n    const ny = e.redMul(d.redISub(nx)).redISub(c.redIMuln(8)); // Z3 = 2 * Y1 * Z1\n\n    const nz = this.y.redMul(this.z).redIMuln(2);\n    return this.curve.jpoint(nx, ny, nz);\n  }\n\n  _dbl3() {\n    // Assumes a = -3.\n    // https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b\n    // 3M + 5S + 8A + 1*3 + 1*4 + 2*8\n    // (implemented as: 3M + 5S + 8A + 1*2 + 1*3 + 1*4 + 1*8)\n    // delta = Z1^2\n    const delta = this.z.redSqr(); // gamma = Y1^2\n\n    const gamma = this.y.redSqr(); // beta = X1 * gamma\n\n    const beta = this.x.redMul(gamma); // + xmdelta = X1 - delta\n\n    const xmdelta = this.x.redSub(delta); // + xpdelta = X1 + delta\n\n    const xpdelta = this.x.redAdd(delta); // alpha = 3 * (X1 - delta) * (X1 + delta)\n\n    const alpha = xmdelta.redMul(xpdelta).redIMuln(3); // + beta4 = 4 * beta\n\n    const beta4 = beta.redIMuln(4); // + beta8 = 2 * beta4\n\n    const beta8 = beta4.redMuln(2); // + gamma28 = 8 * gamma^2\n\n    const gamma28 = gamma.redSqr().redIMuln(8); // X3 = alpha^2 - 8 * beta\n\n    const nx = alpha.redSqr().redISub(beta8); // Z3 = (Y1 + Z1)^2 - gamma - delta\n\n    const nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta); // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2\n\n    const ny = alpha.redMul(beta4.redISub(nx)).redISub(gamma28);\n    return this.curve.jpoint(nx, ny, nz);\n  }\n\n  dblp(pow) {\n    assert(pow >>> 0 === pow); // a = 0 or a = -3\n\n    if (this.curve.zeroA || this.curve.threeA) return super.dblp(pow); // m = 0\n\n    if (pow === 0) return this; // P = O\n\n    if (this.isInfinity()) return this;\n    return this._dblp(pow);\n  }\n\n  _dblp(pow) {\n    // Repeated point doubling (Jacobian coordinates).\n    //\n    // [GECC] Algorithm 3.23, Page 93, Section 3.2.\n    //\n    // Modified version of:\n    //   https://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian.html#doubling-dbl-1998-cmo-2\n    //\n    // Divergences from the above formula are marked with diff notation.\n    //\n    // Implemented as:\n    //   1M + 2S + 1*2 + N * (4M + 4S + 4A + 1*a + 1*3 + 2*2)\n    //   e.g. N = 1 => 5M + 6S + 4A + 1*a + 1*3 + 3*2\n    //\n    // Repeated doubling also explained here:\n    //   https://en.wikibooks.org/wiki/Cryptography/Prime_Curve/Jacobian_Coordinates\n    //\n    // Note that the above sources change:\n    //   M = 3 * XX + a * ZZZZ\n    // To:\n    //   M = 3 * (XX - ZZZZ)\n    //\n    // In order to assume a = -3.\n    const {\n      a,\n      i2\n    } = this.curve; // Reuse results (y is always y*2).\n\n    let x = this.x;\n    let z = this.z; // + Y1 = Y1 * 2\n\n    let y = this.y.redMuln(2); // + ZZZZ = Z1^4\n\n    let zzzz = z.redPown(4);\n\n    for (let i = 0; i < pow; i++) {\n      // Y1 = 0\n      if (y.isZero()) return this.curve.jpoint(); // XX = X1^2\n\n      const xx = x.redSqr(); // YY = Y1^2\n\n      const yy = y.redSqr(); // + YYYY = YY^2\n\n      const yyyy = yy.redSqr(); // - M = 3 * XX + a * ZZ^2\n      // + M = 3 * XX + a * ZZZZ\n\n      const m = xx.redIMuln(3).redIAdd(a.redMul(zzzz)); // - S = 4 * X1 * YY\n      // + S = X1 * YY\n\n      const s = x.redMul(yy); // T = M^2 - 2 * S\n\n      const t = m.redSqr().redISub(s).redISub(s); // X3 = T\n\n      const nx = t; // - Y3 = M * (S - T) - 8 * YY^2\n      // + Y3 = M * (S - T) * 2 - YYYY\n\n      const ny = m.redMul(s.redISub(t)).redIMuln(2).redISub(yyyy); // Z3 = 2 * Y1 * Z1\n\n      const nz = y.redMul(z); // + ZZZZ = ZZZZ * YYYY\n\n      if (i + 1 < pow) zzzz = zzzz.redMul(yyyy); // + X1 = X3\n\n      x = nx; // + Y1 = Y3\n\n      y = ny; // + Z1 = Z3\n\n      z = nz;\n    }\n\n    return this.curve.jpoint(x, y.redMul(i2), z);\n  }\n\n  uadd(p) {\n    assert(p instanceof Point);\n    if (p.type === types.AFFINE) return this._uadd(p.toJ());\n    return this._uadd(p);\n  }\n\n  _uadd(p) {\n    // Strongly unified Jacobian addition (Brier and Joye).\n    //\n    // [SIDE2] Page 6, Section 3.\n    // [SIDE3] Page 4, Section 3.\n    //\n    // The above documents use projective coordinates[1]\n    // and have been modified for jacobian coordinates. A\n    // further modification, taken from libsecp256k1[2],\n    // handles the degenerate case of: x1 != x2, y1 = -y2.\n    //\n    // [1] https://hyperelliptic.org/EFD/g1p/auto-shortw-projective.html#addition-add-2002-bj\n    // [2] https://github.com/bitcoin-core/secp256k1/blob/ee9e68c/src/group_impl.h#L525\n    //\n    // 11M + 8S + 7A + 1*a + 2*4 + 1*3 + 2*2 (a != 0)\n    // 11M + 6S + 6A + 2*4 + 1*3 + 2*2 (a = 0)\n    assert(p instanceof JPoint);\n    const {\n      zero,\n      one\n    } = this.curve; // Z1Z1 = Z1^2\n\n    const z1z1 = this.z.redSqr(); // Z2Z2 = Z2^2\n\n    const z2z2 = p.z.redSqr(); // U1 = X1 * Z2Z2\n\n    const u1 = this.x.redMul(z2z2); // U2 = X2 * Z1Z1\n\n    const u2 = p.x.redMul(z1z1); // S1 = Y1 * Z2Z2 * Z2\n\n    const s1 = this.y.redMul(z2z2).redMul(p.z); // S2 = Y2 * Z1Z1 * Z1\n\n    const s2 = p.y.redMul(z1z1).redMul(this.z); // Z = Z1 * Z2\n\n    const z = this.z.redMul(p.z); // T = U1 + U2\n\n    const t = u1.redAdd(u2); // M = S1 + S2\n\n    const m = s1.redAdd(s2); // R = T^2 - U1 * U2\n\n    const r = t.redSqr().redISub(u1.redMul(u2)); // R = R + a * Z^4 (if a != 0)\n\n    if (!this.curve.zeroA) {\n      const zzzz = z.redPown(4); // Save some cycles for a = -3.\n\n      if (this.curve.threeA) r.redIAdd(zzzz.redIMuln(-3));else r.redIAdd(this.curve.a.redMul(zzzz));\n    } // Check for degenerate case (X1 != X2, Y1 = -Y2).\n\n\n    const degenerate = m.czero() & r.czero(); // M = U1 - U2 (if degenerate)\n\n    m.cinject(u1.redSub(u2), degenerate); // R = S1 - S2 (if degenerate)\n\n    r.cinject(s1.redSub(s2), degenerate); // L = M^2\n\n    const l = m.redSqr(); // G = T * L\n\n    const g = t.redMul(l); // LL = L^2\n\n    const ll = l.redSqr(); // LL = 0 (if degenerate)\n\n    ll.cinject(zero, degenerate); // W = R^2\n\n    const w = r.redSqr(); // F = Z * M\n\n    const f = z.redMul(m); // H = 3 * G - 2 * W\n\n    const h = g.redMuln(3).redISub(w).redISub(w); // X3 = 4 * (W - G)\n\n    const nx = w.redISub(g).redIMuln(4); // Y3 = 4 * (R * H - LL)\n\n    const ny = r.redMul(h).redISub(ll).redIMuln(4); // Z3 = 2 * F\n\n    const nz = f.redIMuln(2); // Check for infinity.\n\n    const inf1 = this.z.czero();\n    const inf2 = p.z.czero();\n    const inf3 = nz.czero() & ((inf1 | inf2) ^ 1); // Case 1: O + P = P\n\n    nx.cinject(p.x, inf1);\n    ny.cinject(p.y, inf1);\n    nz.cinject(p.z, inf1); // Case 2: P + O = P\n\n    nx.cinject(this.x, inf2);\n    ny.cinject(this.y, inf2);\n    nz.cinject(this.z, inf2); // Case 3: P + -P = O\n\n    nx.cinject(one, inf3);\n    ny.cinject(one, inf3);\n    nz.cinject(zero, inf3);\n    return this.curve.jpoint(nx, ny, nz);\n  }\n\n  udbl() {\n    const p = this._udbl();\n\n    const inf = this.z.czero() | this.y.czero(); // Case 1 & 2: 2 * O = O, 2 * (X, 0) = O\n\n    p.x.cinject(this.curve.one, inf);\n    p.y.cinject(this.curve.one, inf);\n    p.z.cinject(this.curve.zero, inf);\n    return p;\n  }\n\n  _udbl() {\n    // a = 0\n    if (this.curve.zeroA) return this._dbl0(); // a = -3\n\n    if (this.curve.threeA) return this._dbl3();\n    return this._dblJ();\n  }\n\n  zaddu(p) {\n    // Co-Z addition with update (ZADDU).\n    // [COZ] Algorithm 19, Page 15, Appendix C.\n    // 5M + 2S + 7A\n    assert(p instanceof JPoint); // H = X1 - X2\n\n    const h = this.x.redSub(p.x); // R = Y1 - Y2\n\n    const r = this.y.redSub(p.y); // HH = H^2\n\n    const hh = h.redSqr(); // V1 = X1 * HH\n\n    const v1 = this.x.redMul(hh); // V2 = X2 * HH\n\n    const v2 = p.x.redMul(hh); // X4 = V1\n\n    const x4 = v1; // X3 = R^2 - V1 - V2\n\n    const x3 = r.redSqr().redISub(v1).redISub(v2); // Y4 = Y1 * (V1 - V2)\n\n    const y4 = this.y.redMul(v1.redSub(v2)); // Y3 = R * (X4 - X3) - Y4\n\n    const y3 = r.redMul(x4.redSub(x3)).redISub(y4); // Z4 = Z1 * H\n\n    const z4 = this.z.redMul(h); // Z3 = Z4\n\n    const z3 = z4; // R = (X3, Y3, Z3)\n    // P = (X4, Y4, Z4)\n\n    return [this.curve.jpoint(x3, y3, z3), this.curve.jpoint(x4, y4, z4)];\n  }\n\n  zaddc(p) {\n    // Co-Z addition with conjugate (ZADDC).\n    // [COZ] Algorithm 20, Page 15, Appendix C.\n    // 6M + 3S + 14A + 1*2\n    assert(p instanceof JPoint); // H = X1 - X2\n\n    const h = this.x.redSub(p.x); // R = Y1 - Y2\n\n    const r = this.y.redSub(p.y); // M = Y1 + Y2\n\n    const m = this.y.redAdd(p.y); // HH = H^2\n\n    const hh = h.redSqr(); // V1 = X1 * HH\n\n    const v1 = this.x.redMul(hh); // V2 = X2 * HH\n\n    const v2 = p.x.redMul(hh); // X4 = (Y1 + Y2)^2 - V1 - V2\n\n    const x4 = m.redSqr().redISub(v1).redISub(v2); // X3 = R^2 - V1 - V2\n\n    const x3 = r.redSqr().redISub(v1).redISub(v2); // Y = Y1 * (V2 - V1)\n\n    const y = this.y.redMul(v2.redISub(v1)); // Z = R + 2 * Y2\n\n    const z = p.y.redMuln(2).redIAdd(r); // I = V1 - X4\n\n    const i = v1.redISub(x4); // J = X4 + I - X3\n\n    const j = x4.redAdd(i).redISub(x3); // Y4 = Z * I + Y\n\n    const y4 = z.redMul(i).redIAdd(y); // Y3 = R * J + Y\n\n    const y3 = r.redMul(j).redIAdd(y); // Z4 = Z1 * H\n\n    const z4 = this.z.redMul(h); // Z3 = Z4\n\n    const z3 = z4; // R = (X3, Y3, Z3)\n    // S = (X4, Y4, Z4)\n\n    return [this.curve.jpoint(x3, y3, z3), this.curve.jpoint(x4, y4, z4)];\n  }\n\n  zdblu() {\n    // Co-Z doubling with update (DBLU).\n    // [COZ] Algorithm 21, Page 15, Appendix C.\n    //\n    // 1M + 5S + 8A + 4*2 + 1*8\n    //\n    // Note that the original formula assumed Z1=1.\n    // We have modified it to allow for scaled points.\n    //\n    // New Cost: 2M + 5S + 8A + 1*a + 1*3 + 2*2 + 1*8\n    // XX = X1^2\n    const xx = this.x.redSqr(); // YY = Y1^2\n\n    const yy = this.y.redSqr(); // YYYY = YY^2\n\n    const yyyy = yy.redSqr(); // S = (X1 + YY)^2\n\n    const s = this.x.redAdd(yy).redSqr(); // M = 3 * XX\n\n    const m = xx.redMuln(3); // M = M + a * Z1^4 (if a != 0)\n\n    if (!this.curve.zeroA) {\n      const zzzz = this.z.redPown(4); // Save some cycles for a = -3.\n\n      if (this.curve.threeA) m.redIAdd(zzzz.redIMuln(-3));else m.redIAdd(this.curve.a.redMul(zzzz));\n    } // X4 = 2 * (S - XX - YYYY)\n\n\n    const x4 = s.redISub(xx).redISub(yyyy).redIMuln(2); // X3 = M^2 - X4 - X4\n\n    const x3 = m.redSqr().redISub(x4).redISub(x4); // Y4 = 8 * YYYY\n\n    const y4 = yyyy.redIMuln(8); // Y3 = (X4 - X3) * M - Y4\n\n    const y3 = x4.redSub(x3).redMul(m).redISub(y4); // Z4 = 2 * (Y1 * Z1)\n\n    const z4 = this.y.redMul(this.z).redIMuln(2); // Z3 = Z4\n\n    const z3 = z4; // R = (X3, Y3, Z3)\n    // P = (X4, Y4, Z4)\n\n    return [this.curve.jpoint(x3, y3, z3), this.curve.jpoint(x4, y4, z4)];\n  }\n\n  recover(x1, z1, x2, z2) {\n    return this.toP().recover(x1, z1, x2, z2);\n  }\n\n  getX() {\n    if (this.isInfinity()) throw new Error('Invalid point.');\n    this.normalize();\n    return this.x.fromRed();\n  }\n\n  getY() {\n    if (this.isInfinity()) throw new Error('Invalid point.');\n    this.normalize();\n    return this.y.fromRed();\n  }\n\n  eq(p) {\n    assert(p instanceof JPoint); // P = Q\n\n    if (this === p) return true; // P = O\n\n    if (this.isInfinity()) return p.isInfinity(); // Q = O\n\n    if (p.isInfinity()) return false; // Z1 = Z2\n\n    if (this.z.eq(p.z)) {\n      return this.x.eq(p.x) && this.y.eq(p.y);\n    } // X1 * Z2^2 == X2 * Z1^2\n\n\n    const zz1 = this.z.redSqr();\n    const zz2 = p.z.redSqr();\n    const x1 = this.x.redMul(zz2);\n    const x2 = p.x.redMul(zz1);\n    if (!x1.eq(x2)) return false; // Y1 * Z2^3 == Y2 * Z1^3\n\n    const zzz1 = zz1.redMul(this.z);\n    const zzz2 = zz2.redMul(p.z);\n    const y1 = this.y.redMul(zzz2);\n    const y2 = p.y.redMul(zzz1);\n    return y1.eq(y2);\n  }\n\n  isInfinity() {\n    // Z1 = 0\n    return this.z.isZero();\n  }\n\n  isOdd() {\n    if (this.isInfinity()) return false;\n    this.normalize();\n    return this.y.redIsOdd();\n  }\n\n  isEven() {\n    if (this.isInfinity()) return false;\n    this.normalize();\n    return this.y.redIsEven();\n  }\n\n  isSquare() {\n    if (this.isInfinity()) return false;\n    return this.y.redMul(this.z).redJacobi() !== -1;\n  }\n\n  eqX(x) {\n    // Verify that integer `x` is equal to field\n    // element `x` by scaling it by our z coordinate.\n    // This optimization is mentioned in and used for\n    // bip-schnorr[1]. This avoids having to affinize\n    // the resulting point during verification.\n    //\n    // [1] [SCHNORR] \"Optimizations\".\n    assert(x instanceof BN);\n    assert(!x.red);\n    if (this.isInfinity()) return false;\n    const zz = this.z.redSqr();\n    const rx = x.toRed(this.curve.red).redMul(zz);\n    return this.x.eq(rx);\n  }\n\n  eqXToP(x) {\n    // Similar to the optimization above, this\n    // optimization, suggested by Maxwell[1],\n    // compares an integer to an X coordinate\n    // by scaling it.\n    //\n    // Since a signature's R value is modulo N\n    // in ECDSA, we may be dealing with an R\n    // value greater than N in actuality.\n    //\n    // If the equality check fails, we can\n    // scale N itself by Z and add it to the\n    // X field element (up until a certain\n    // limit) and repeat the check.\n    //\n    // If P is more than 100 times larger than\n    // N, we don't gain much here, so we just\n    // affinize and do the comparison.\n    //\n    // [1] https://github.com/bitcoin-core/secp256k1/commit/ce7eb6f\n    assert(x instanceof BN);\n    assert(!x.red);\n    if (!this.curve.smallGap) return this.toP().eqXToP(x);\n    if (this.isInfinity()) return false;\n    if (x.cmp(this.curve.p) >= 0) return false;\n    const zz = this.z.redSqr();\n    const rx = x.toRed(this.curve.red).redMul(zz);\n    if (this.x.eq(rx)) return true;\n    if (this.curve.highOrder) return false;\n    if (x.cmp(this.curve.pmodn) >= 0) return false;\n    const rn = this.curve.redN.redMul(zz);\n    rx.redIAdd(rn);\n    return this.x.eq(rx);\n  }\n\n  toP() {\n    // P = O\n    if (this.isInfinity()) return this.curve.point();\n    this.normalize(); // (X3, Y3) = (X1 / Z1^2, Y1 / Z1^3)\n\n    return this.curve.point(this.x, this.y);\n  }\n\n  toJ() {\n    return this;\n  }\n\n  encode(compact) {\n    return this.toP().encode(compact);\n  }\n\n  static decode(curve, bytes) {\n    return ShortPoint.decode(curve, bytes).toJ();\n  }\n\n  encodeX() {\n    return this.toP().encodeX();\n  }\n\n  static decodeEven(curve, bytes) {\n    return ShortPoint.decodeEven(curve, bytes).toJ();\n  }\n\n  static decodeSquare(curve, bytes) {\n    return ShortPoint.decodeSquare(curve, bytes).toJ();\n  }\n\n  toJSON(pre) {\n    return this.toP().toJSON(pre);\n  }\n\n  static fromJSON(curve, json) {\n    return ShortPoint.fromJSON(curve, json).toJ();\n  }\n\n  [custom]() {\n    if (this.isInfinity()) return '<JPoint: Infinity>';\n    return '<JPoint:' + ' x=' + this.x.fromRed().toString(16, 2) + ' y=' + this.y.fromRed().toString(16, 2) + ' z=' + this.z.fromRed().toString(16, 2) + '>';\n  }\n\n}\n/**\n * MontCurve\n */\n\n\nclass MontCurve extends Curve {\n  constructor(conf) {\n    super(MontPoint, 'mont', conf);\n    this.a = BN.fromJSON(conf.a).toRed(this.red);\n    this.b = BN.fromJSON(conf.b).toRed(this.red);\n    this.bi = this.b.redInvert();\n    this.a2 = this.a.redAdd(this.two);\n    this.a24 = this.a2.redMul(this.i4);\n    this.a3 = this.a.redMul(this.i3);\n    this.a0 = this.a.redMul(this.bi);\n    this.b0 = this.bi.redSqr();\n\n    this._finalize(conf);\n  }\n\n  static _isomorphism(curveA, curveB, customB) {\n    // Montgomery Isomorphism.\n    //\n    // [MONT3] Page 3, Section 2.1.\n    //\n    // Transformation:\n    //\n    //   A' = A\n    //   B' = B'\n    //\n    // Where (B / B') is square.\n    assert(curveA instanceof BN);\n    assert(curveB instanceof BN);\n    assert(customB instanceof BN);\n    const a = curveA.clone();\n    const b = customB.clone();\n    const c = curveB.redDiv(customB);\n    if (c.redJacobi() !== 1) throw new Error('Invalid `b` coefficient.');\n    return [a, b];\n  }\n\n  _short(a0, odd) {\n    // Montgomery->Short Weierstrass Equivalence.\n    //\n    // [MONT2] \"Equivalence with Weierstrass curves\".\n    //\n    // Transformation:\n    //\n    //   a = (3 - A^2) / (3 * B^2)\n    //   b = (2 * A^3 - 9 * A) / (27 * B^3)\n    const {\n      a,\n      b,\n      three\n    } = this;\n    const a2 = a.redSqr();\n    const a3 = a2.redMul(a);\n    const b2 = b.redSqr();\n    const b3 = b2.redMul(b);\n    const n0 = three.redSub(a2);\n    const d0 = b2.redMuln(3);\n    const n1 = a3.redMuln(2).redISub(a.redMuln(9));\n    const d1 = b3.redMuln(27);\n    const wa = n0.redDiv(d0);\n    const wb = n1.redDiv(d1);\n    if (a0 != null) return ShortCurve._isomorphism(wa, wb, a0, odd);\n    return [wa, wb];\n  }\n\n  _mont(b0) {\n    return MontCurve._isomorphism(this.a, this.b, b0);\n  }\n\n  _edwards(a0, invert = false) {\n    // Montgomery->Twisted Edwards Transformation.\n    //\n    // [MONT1] Page 11, Section 4.3.5.\n    // [TWISTED] Theorem 3.2, Page 4, Section 3.\n    //\n    // Equivalence:\n    //\n    //   a = (A + 2) / B\n    //   d = (A - 2) / B\n    //\n    // Isomorphism:\n    //\n    //   a = a'\n    //   d = a' * (A - 2) / (A + 2)\n    //\n    // Where ((A + 2) / (B * a')) is square.\n    //\n    // If `d` is square, we can usually find\n    // a complete curve by using the `invert`\n    // option. This will create an isomorphism\n    // chain of: M(A,B)->E(a,d)->E(d,a).\n    //\n    // The equivalence between E(a,d) and\n    // E(d,a) is:\n    //\n    //   (x, y) = (x, 1 / y)\n    //\n    // Meaning our map to E(d,a) is:\n    //\n    //   x = u / v\n    //   y = 1 / ((u - 1) / (u + 1))\n    //     = (u + 1) / (u - 1)\n    assert(typeof invert === 'boolean');\n    const {\n      two,\n      bi\n    } = this;\n    const a = this.a.redAdd(two).redMul(bi);\n    const d = this.a.redSub(two).redMul(bi);\n    if (invert) a.swap(d);\n    if (a0 != null) return EdwardsCurve._isomorphism(a, d, a0);\n    return [a, d];\n  }\n\n  _scaleShort(curve) {\n    assert(curve instanceof ShortCurve);\n\n    const [u2, u3] = curve._scale(this);\n\n    return [this.field(u2.redInvert()), this.field(u3.redInvert())];\n  }\n\n  _scaleMont(curve) {\n    // We can extract the isomorphism factor with:\n    //\n    //   c = +-sqrt(B / B')\n    //\n    // If base points are available, we can do:\n    //\n    //   c = v' / v\n    assert(curve instanceof MontCurve);\n    if (this.g.isInfinity() || curve.g.isInfinity()) return this.field(curve.b).redDivSqrt(this.b);\n    return this.g.y.redDiv(this.field(curve.g.y));\n  }\n\n  _scaleEdwards(curve, invert) {\n    // We _could_ do something like:\n    //\n    //   B = 4 / (a - d)\n    //   c = +-sqrt(B / B')\n    //\n    // Which can be reduced to:\n    //\n    //   c = +-sqrt(4 / ((a - d) * B'))\n    //\n    // If base points are available:\n    //\n    //   v = u' / x\n    //   c = v' / v\n    //\n    // Which can be reduced to:\n    //\n    //   c = v' * x / u'\n    //\n    // However, the way our maps are\n    // written, we can re-use the Edwards\n    // isomorphism factor when going the\n    // other direction.\n    assert(curve instanceof EdwardsCurve);\n\n    const c = curve._scale(this, invert);\n\n    return this.field(c);\n  }\n\n  _solveY0(x) {\n    assert(x instanceof BN); // y^2 = x^3 + A * x^2 + B * x\n\n    const a = this.a0;\n    const b = this.b0;\n    const x2 = x.redSqr();\n    const x3 = x2.redMul(x);\n    const y2 = x3.redIAdd(a.redMul(x2)).redIAdd(b.redMul(x));\n    return y2;\n  }\n\n  _elligator2(u) {\n    // Elligator 2.\n    //\n    // Distribution: 1/2.\n    //\n    // [ELL2] Page 11, Section 5.2.\n    // [H2EC] \"Elligator 2 Method\".\n    //        \"Mappings for Montgomery curves\".\n    // [SAFE] \"Indistinguishability from uniform random strings\".\n    //\n    // Assumptions:\n    //\n    //   - y^2 = x^3 + A * x^2 + B * x.\n    //   - A != 0, B != 0.\n    //   - A^2 - 4 * B is non-zero and non-square in F(p).\n    //   - Let z be a non-square in F(p).\n    //   - u != +-sqrt(-1 / z).\n    //\n    // Note that Elligator 2 is defined over the form:\n    //\n    //   y'^2 = x'^3 + A' * x'^2 + B' * x'\n    //\n    // Instead of:\n    //\n    //   B * y^2 = x^3 + A * x^2 + x\n    //\n    // Where:\n    //\n    //   A' = A / B\n    //   B' = 1 / B^2\n    //   x' = x / B\n    //   y' = y / B\n    //\n    // And:\n    //\n    //   x = B * x'\n    //   y = B * y'\n    //\n    // This is presumably the result of Elligator 2\n    // being designed in long Weierstrass form. If\n    // we want to support B != 1, we need to do the\n    // conversion.\n    //\n    // Map:\n    //\n    //   g(x) = x^3 + A * x^2 + B * x\n    //   x1 = -A / (1 + z * u^2)\n    //   x1 = -A, if x1 = 0\n    //   x2 = -x1 - A\n    //   x = x1, if g(x1) is square\n    //     = x2, otherwise\n    //   y = sign(u) * abs(sqrt(g(x)))\n    const lhs = this.a0.redNeg();\n    const rhs = this.one.redAdd(this.z.redMul(u.redSqr()));\n    rhs.cinject(this.one, rhs.czero());\n    const x1 = lhs.redMul(rhs.redFermat());\n    const x2 = x1.redNeg().redISub(this.a0);\n\n    const y1 = this._solveY0(x1);\n\n    const y2 = this._solveY0(x2);\n\n    const alpha = y1.redIsSquare() | 0;\n    const x0 = x1.cinject(x2, alpha ^ 1);\n    const y0 = y1.cinject(y2, alpha ^ 1).redSqrt();\n    y0.cinject(y0.redNeg(), y0.redIsOdd() ^ u.redIsOdd());\n    const x = this.b.redMul(x0);\n    const y = this.b.redMul(y0);\n    return this.point(x, y);\n  }\n\n  _invert2(p, hint) {\n    // Inverting the Map (Elligator 2).\n    //\n    // [ELL2] Page 12, Section 5.3.\n    //\n    // Assumptions:\n    //\n    //   - -z * x * (x + A) is square in F(p).\n    //   - If r = 1 then x != 0.\n    //   - If r = 2 then x != -A.\n    //\n    // Map:\n    //\n    //   u1 = -(x + A) / (x * z)\n    //   u2 = -x / ((x + A) * z)\n    //   r = random integer in [1,2]\n    //   u = sign(y) * abs(sqrt(ur))\n    //\n    // Note that `0 / 0` can only occur if `A == 0`\n    // (this violates the assumptions of Elligator 2).\n    const {\n      x,\n      y\n    } = p;\n    const r = hint & 1;\n    const x0 = x.redMul(this.bi);\n    const y0 = y.redMul(this.bi);\n    const n = x0.redAdd(this.a0);\n    const d = x0;\n    n.cswap(d, r);\n    const lhs = n.redINeg();\n    const rhs = d.redMul(this.z);\n    const [sqr, u] = divSqrt(lhs, rhs);\n    u.cinject(u.redNeg(), u.redIsOdd() ^ y0.redIsOdd());\n    if (!sqr) throw new Error('Invalid point.');\n    return u;\n  }\n\n  _constMul(p, k, rng) {\n    // Use the single-coordinate ladder in\n    // combination with y-coordinate recovery\n    // to compute an affine point.\n    //\n    // There are a few edge cases here, some\n    // of them documented by Mike Hamburg[1].\n    //\n    // There are two primary edge cases here:\n    //\n    //   1. P * k = O where k = n - 1.\n    //   2. P * k = O where P is small order.\n    //\n    // The first occurs due to the fact that\n    // the Okeya-Sakurai formula requires\n    // one to compute both Q and Q+P. In the\n    // case of k=n-1, Q+P becomes infinity.\n    //\n    // In other words:\n    //\n    //   Q2 = P * (n - 1) + P = O\n    //\n    // The second edge case is a side effect\n    // of the differential addition used in\n    // the ladder. This covers the first two\n    // cases mentioned by Hamburg.\n    //\n    // [1] https://tinyurl.com/y4q2dey9\n    assert(p instanceof MontPoint);\n    const x = p.toX();\n    const [a, b] = x.ladderConst(k, rng);\n    const q = p.recover(b, a);\n    return k.isNeg() ? q.neg() : q;\n  }\n\n  isElliptic() {\n    const a2 = this.a.redSqr();\n    const d = this.b.redMul(a2.redSub(this.four)); // B * (A^2 - 4) != 0\n\n    return !d.isZero();\n  }\n\n  jinv() {\n    // [MONT3] Page 3, Section 2.\n    const {\n      a,\n      three,\n      four\n    } = this;\n    const a2 = a.redSqr();\n    const t0 = a2.redSub(three);\n    const lhs = t0.redPown(3).redIMuln(256);\n    const rhs = a2.redSub(four);\n    if (rhs.isZero()) throw new Error('Curve is not elliptic.'); // (256 * (A^2 - 3)^3) / (A^2 - 4)\n\n    return lhs.redDiv(rhs).fromRed();\n  }\n\n  point(x, y, inf = 0) {\n    return new MontPoint(this, x, y, inf);\n  }\n\n  jpoint(x, y, z) {\n    assert(x == null && y == null && z == null);\n    return this.point();\n  }\n\n  xpoint(x, z) {\n    return new XPoint(this, x, z);\n  }\n\n  solveY2(x) {\n    // [MONT3] Page 3, Section 2.\n    // https://hyperelliptic.org/EFD/g1p/auto-montgom.html\n    assert(x instanceof BN); // B * y^2 = x^3 + A * x^2 + x\n\n    const x2 = x.redSqr();\n    const x3 = x2.redMul(x);\n    const by2 = x3.redIAdd(this.a.redMul(x2)).redIAdd(x);\n    const y2 = by2.redMul(this.bi);\n    return y2;\n  }\n\n  validate(point) {\n    assert(point instanceof MontPoint);\n    if (point.isInfinity()) return true;\n    const {\n      x,\n      y\n    } = point;\n    const y2 = this.solveY2(x);\n    return y.redSqr().eq(y2);\n  }\n\n  pointFromX(x, sign = null) {\n    assert(x instanceof BN);\n    assert(sign == null || typeof sign === 'boolean');\n    if (!x.red) x = x.toRed(this.red);\n    const y = this.solveY(x);\n\n    if (sign != null) {\n      if (y.redIsOdd() !== sign) y.redINeg();\n    }\n\n    return this.point(x, y);\n  }\n\n  isIsomorphic(curve, invert) {\n    // [MONT3] Page 3, Section 2.1.\n    assert(curve instanceof Curve);\n    if (!curve.p.eq(this.p)) return false; // M(A,B) <-> M(A,B')\n\n    if (curve.type === 'mont') {\n      const a = this.field(curve.a);\n      const b = this.field(curve.b); // A' = A\n\n      if (!this.a.eq(a)) return false; // B' != 0\n\n      if (this.b.isZero()) return false; // jacobi(B / B') = 1\n\n      const c = b.redDiv(this.b);\n      return c.redJacobi() === 1;\n    }\n\n    return curve.isIsomorphic(this, invert);\n  }\n\n  isIsogenous(curve) {\n    assert(curve instanceof Curve);\n    if (curve.type === 'mont') return false;\n    return curve.isIsogenous(this);\n  }\n\n  pointFromShort(point) {\n    // [ALT] Appendix E.2 (Switching between Alternative Representations).\n    // [MONT2] \"Equivalence with Weierstrass curves\"\n    assert(point instanceof ShortPoint);\n\n    if (this.isIsomorphic(point.curve)) {\n      // Equivalence for E(a,b)->M(A,B):\n      //\n      //   u = B * x - A / 3\n      //   v = B * y\n      //\n      // Undefined if ((u^3 + A * u^2 + u) / B) is not square.\n      if (point.isInfinity()) return this.point();\n      const {\n        a3,\n        b\n      } = this;\n\n      const [u2, u3] = this._scale(point.curve);\n\n      const x = this.field(point.x).redMul(u2);\n      const y = this.field(point.y).redMul(u3);\n      const u = b.redMul(x).redISub(a3);\n      const v = b.redMul(y);\n      return this.point(u, v);\n    }\n\n    throw new Error('Not implemented.');\n  }\n\n  pointFromMont(point) {\n    // [MONT3] Page 3, Section 2.1.\n    assert(point instanceof MontPoint);\n\n    if (this.isIsomorphic(point.curve)) {\n      // Isomorphic maps for M(A,B)<->M(A,B'):\n      //\n      //   u' = u\n      //   v' = +-sqrt(B / B') * v\n      //\n      // Undefined if (B / B') is not square.\n      if (point.isInfinity()) return this.point();\n\n      const c = this._scale(point.curve);\n\n      const u = this.field(point.x);\n      const v = this.field(point.y);\n      const nu = u;\n      const nv = c.redMul(v);\n      return this.point(nu, nv);\n    }\n\n    throw new Error('Not implemented.');\n  }\n\n  pointFromEdwards(point) {\n    // [RFC7748] Section 4.1 & 4.2.\n    // [MONT3] Page 6, Section 2.5.\n    // [TWISTED] Theorem 3.2, Page 4, Section 3.\n    assert(point instanceof EdwardsPoint);\n    assert(point.curve.p.eq(this.p)); // Edwards `x`, `y`, `z`.\n\n    const x = this.field(point.x);\n    const y = this.field(point.y);\n    const z = this.field(point.z);\n\n    if (this.isIsogenous(point.curve)) {\n      // 4-isogeny maps for E(1,d)->M(2-4d,1):\n      //\n      //   u = y^2 / x^2\n      //   v = (2 - x^2 - y^2) * y / x^3\n      //\n      // Undefined for x = 0.\n      //\n      // Exceptional Cases:\n      //   - (0, 1) -> O\n      //   - (0, -1) -> (0, 0)\n      //\n      // Unexceptional Cases:\n      //   - (+-1, 0) -> (0, 0)\n      if (point.isInfinity()) return this.point();\n      if (point.x.isZero()) return this.point(this.zero, this.zero);\n      const c = z.redSqr().redIMuln(2);\n      const uu = y.redSqr();\n      const uz = x.redSqr();\n      const vv = c.redISub(uz).redISub(uu).redMul(y);\n      const vz = uz.redMul(x);\n      return this.cpoint(uu, uz, vv, vz);\n    }\n\n    if (this.isIsomorphic(point.curve, true)) {\n      // Isomorphic maps for E(d,a)->M(A,B):\n      //\n      //   u = (y + 1) / (y - 1)\n      //   v = +-sqrt((A - 2) / (B * a)) * u / x\n      //\n      // Undefined for x = 0 or y = 1.\n      //\n      // Exceptional Cases:\n      //   - (0, 1) -> O\n      //   - (0, -1) -> (0, 0)\n      //\n      // Unexceptional Cases:\n      //   - (+-sqrt(1 / a), 0) -> (-1, +-sqrt((A - 2) / B))\n      if (point.isInfinity()) return this.point();\n      if (point.x.isZero()) return this.point(this.zero, this.zero);\n\n      const c = this._scale(point.curve, true);\n\n      const uu = y.redAdd(z);\n      const uz = y.redSub(z);\n      const vv = c.redMul(z).redMul(uu);\n      const vz = x.redMul(uz);\n      return this.cpoint(uu, uz, vv, vz);\n    }\n\n    if (this.isIsomorphic(point.curve, false)) {\n      // Isomorphic maps for E(a,d)->M(A,B):\n      //\n      //   u = (1 + y) / (1 - y)\n      //   v = +-sqrt((A + 2) / (B * a)) * u / x\n      //\n      // Undefined for x = 0 or y = 1.\n      //\n      // Exceptional Cases:\n      //   - (0, 1) -> O\n      //   - (0, -1) -> (0, 0)\n      //\n      // Unexceptional Cases:\n      //   - (+-sqrt(1 / a), 0) -> (1, +-sqrt((A + 2) / B))\n      if (point.isInfinity()) return this.point();\n      if (point.x.isZero()) return this.point(this.zero, this.zero);\n\n      const c = this._scale(point.curve, false);\n\n      const uu = z.redAdd(y);\n      const uz = z.redSub(y);\n      const vv = c.redMul(z).redMul(uu);\n      const vz = x.redMul(uz);\n      return this.cpoint(uu, uz, vv, vz);\n    }\n\n    throw new Error('Not implemented.');\n  }\n\n  pointFromUniform(u) {\n    assert(u instanceof BN); // z = 0 or A = 0\n\n    if (this.z.isZero() || this.a.isZero()) throw new Error('Not implemented.');\n    return this._elligator2(u);\n  }\n\n  pointToUniform(p, hint) {\n    assert(p instanceof MontPoint);\n    assert(hint >>> 0 === hint); // z = 0 or A = 0\n\n    if (this.z.isZero() || this.a.isZero()) throw new Error('Not implemented.'); // P = O\n\n    if (p.isInfinity()) throw new Error('Invalid point.'); // Add a random torsion component.\n\n    const i = (hint >>> 4 & 15) % this.torsion.length;\n    const q = p.add(this.torsion[i]);\n    return this._invert2(q, hint);\n  }\n\n  decodePoint(bytes, sign) {\n    return MontPoint.decode(this, bytes, sign);\n  }\n\n  encodeX(point) {\n    assert(point instanceof XPoint);\n    return point.encode();\n  }\n\n  decodeX(bytes) {\n    return XPoint.decode(this, bytes);\n  }\n\n  toShort(a0, odd, sign = null) {\n    const [a, b] = this._short(a0, odd);\n\n    const curve = new ShortCurve({\n      red: this.red,\n      prime: this.prime,\n      p: this.p,\n      a: a,\n      b: b,\n      n: this.n,\n      h: this.h\n    });\n\n    if (sign != null) {\n      const [, u3] = curve._scale(this);\n\n      if (u3.redIsOdd() !== sign) u3.redINeg();\n    }\n\n    if (!this.g.isInfinity()) curve.g = curve.pointFromMont(this.g);\n\n    for (let i = 0; i < this.h; i++) curve.torsion[i] = curve.pointFromMont(this.torsion[i]);\n\n    return curve;\n  }\n\n  toMont(b0, sign = null) {\n    const [a, b] = this._mont(b0);\n\n    const curve = new MontCurve({\n      red: this.red,\n      prime: this.prime,\n      p: this.p,\n      a: a,\n      b: b,\n      n: this.n,\n      h: this.h,\n      z: this.z\n    });\n\n    if (sign != null) {\n      const c = curve._scale(this);\n\n      if (c.redIsOdd() !== sign) c.redINeg();\n    }\n\n    if (!this.g.isInfinity()) curve.g = curve.pointFromMont(this.g);\n\n    for (let i = 0; i < this.h; i++) curve.torsion[i] = curve.pointFromMont(this.torsion[i]);\n\n    return curve;\n  }\n\n  toEdwards(a0, invert, sign = null) {\n    const [a, d] = this._edwards(a0, invert);\n\n    const curve = new EdwardsCurve({\n      red: this.red,\n      prime: this.prime,\n      p: this.p,\n      a: a,\n      d: d,\n      n: this.n,\n      h: this.h,\n      z: this.z\n    });\n\n    if (sign != null) {\n      const c = curve._scale(this, invert);\n\n      if (c.redIsOdd() !== sign) c.redINeg();\n    }\n\n    if (!this.g.isInfinity()) {\n      curve.g = curve.pointFromMont(this.g);\n      curve.g.normalize();\n    }\n\n    if (curve.isComplete()) {\n      for (let i = 0; i < this.h; i++) {\n        curve.torsion[i] = curve.pointFromMont(this.torsion[i]);\n        curve.torsion[i].normalize();\n      }\n    }\n\n    return curve;\n  }\n\n  pointFromJSON(json) {\n    return MontPoint.fromJSON(this, json);\n  }\n\n  toJSON(pre) {\n    const json = super.toJSON(pre);\n    json.a = this.a.fromRed().toJSON();\n    json.b = this.b.fromRed().toJSON();\n    return json;\n  }\n\n}\n/**\n * MontPoint\n */\n\n\nclass MontPoint extends Point {\n  constructor(curve, x, y, inf) {\n    assert(curve instanceof MontCurve);\n    super(curve, types.AFFINE);\n    this.x = this.curve.zero;\n    this.y = this.curve.zero;\n    this.inf = 1;\n    if (x != null) this._init(x, y, inf);\n  }\n\n  _init(x, y, inf) {\n    assert(x instanceof BN);\n    assert(y instanceof BN);\n    this.x = x;\n    this.y = y;\n    if (!this.x.red) this.x = this.x.toRed(this.curve.red);\n    if (!this.y.red) this.y = this.y.toRed(this.curve.red);\n    this.inf = inf | 0;\n  }\n\n  clone() {\n    return this.curve.point(this.x.clone(), this.y.clone(), this.inf);\n  }\n\n  swap(point, flag) {\n    assert(point instanceof MontPoint);\n    const cond = (flag >> 31 | -flag >> 31) & 1;\n    const inf1 = this.inf;\n    const inf2 = point.inf;\n    this.x.cswap(point.x, flag);\n    this.y.cswap(point.y, flag);\n    this.inf = inf1 & (cond ^ 1) | inf2 & cond;\n    point.inf = inf2 & (cond ^ 1) | inf1 & cond;\n    return this;\n  }\n\n  scale(a) {\n    return this.clone();\n  }\n\n  randomize(rng) {\n    return this.clone();\n  }\n\n  neg() {\n    // P = O\n    if (this.inf) return this; // -(X1, Y1) = (X1, -Y1)\n\n    return this.curve.point(this.x, this.y.redNeg());\n  }\n\n  add(p) {\n    // [MONT1] Page 8, Section 4.3.2.\n    //\n    // Addition Law:\n    //\n    //   l = (y2 - y1) / (x2 - x1)\n    //   x3 = b * l^2 - a - x1 - x2\n    //   y3 = l * (x1 - x3) - y1\n    //\n    // 1I + 2M + 1S + 7A + 1*b\n    assert(p instanceof MontPoint); // O + P = P\n\n    if (this.inf) return p; // P + O = P\n\n    if (p.inf) return this; // P + P, P + -P\n\n    if (this.x.eq(p.x)) {\n      // P + -P = O\n      if (!this.y.eq(p.y)) return this.curve.point(); // P + P = 2P\n\n      return this.dbl();\n    } // H = X2 - X1\n\n\n    const h = p.x.redSub(this.x); // R = Y2 - Y1\n\n    const r = p.y.redSub(this.y); // L = R / H\n\n    const l = r.redDiv(h); // K = b * L^2\n\n    const k = this.curve.b.redMul(l.redSqr()); // X3 = K - a - X1 - X2\n\n    const nx = k.redISub(this.curve.a).redISub(this.x).redISub(p.x); // Y3 = L * (X1 - X3) - Y1\n\n    const ny = l.redMul(this.x.redSub(nx)).redISub(this.y);\n    return this.curve.point(nx, ny);\n  }\n\n  dbl() {\n    // [MONT1] Page 8, Section 4.3.2.\n    //\n    // Addition Law (doubling):\n    //\n    //   l = (3 * x1^2 + 2 * a * x1 + 1) / (2 * b * y1)\n    //   x3 = b * l^2 - a - 2 * x1\n    //   y3 = l * (x1 - x3) - y1\n    //\n    // 1I + 3M + 2S + 7A + 1*a + 1*b + 1*b + 2*2 + 1*3\n    // P = O\n    if (this.inf) return this; // Y1 = 0\n\n    if (this.y.isZero()) return this.curve.point(); // M1 = 3 * X1^2\n\n    const m1 = this.x.redSqr().redIMuln(3); // M2 = 2 * a * X1\n\n    const m2 = this.curve.a.redMul(this.x).redIMuln(2); // M = M1 + M2 + 1\n\n    const m = m1.redIAdd(m2).redIAdd(this.curve.one); // Z = 2 * b * Y1\n\n    const z = this.curve.b.redMul(this.y).redIMuln(2); // L = M / Z\n\n    const l = m.redDiv(z); // K = b * L^2\n\n    const k = this.curve.b.redMul(l.redSqr()); // X3 = K - a - 2 * X1\n\n    const nx = k.redISub(this.curve.a).redISub(this.x).redISub(this.x); // Y3 = L * (X1 - X3) - Y1\n\n    const ny = l.redMul(this.x.redSub(nx)).redISub(this.y);\n    return this.curve.point(nx, ny);\n  }\n\n  uadd(p) {\n    // [MONT1] Page 8, Section 4.3.2.\n    // 1I + 3M + 2S + 9A + 1*a + 2*b + 2*2 + 1*3\n    assert(p instanceof MontPoint); // H = X2 - X1\n\n    const h = p.x.redSub(this.x); // R = Y2 - Y1\n\n    const r = p.y.redSub(this.y); // M1 = 3 * X1^2\n\n    const m1 = this.x.redSqr().redIMuln(3); // M2 = 2 * a * X1\n\n    const m2 = this.curve.a.redMul(this.x).redIMuln(2); // M = M1 + M2 + 1\n\n    const m = m1.redIAdd(m2).redIAdd(this.curve.one); // Z = 2 * b * Y1\n\n    const z = this.curve.b.redMul(this.y).redIMuln(2); // Check for doubling (X1 = X2, Y1 = Y2).\n\n    const double = h.czero() & r.czero(); // R = M (if double)\n\n    r.cinject(m, double); // H = Z (if double)\n\n    h.cinject(z, double); // Check for negation (X1 = X2, Y1 = -Y2).\n\n    const negated = h.czero() & ((this.inf | p.inf) ^ 1); // H = 1 (if H = 0)\n\n    h.cinject(this.curve.one, h.czero()); // L = R / H\n\n    const l = r.redMul(h.redFermat()); // K = b * L^2\n\n    const k = this.curve.b.redMul(l.redSqr()); // X3 = K - a - X1 - X2\n\n    const nx = k.redISub(this.curve.a).redISub(this.x).redISub(p.x); // Y3 = L * (X1 - X3) - Y1\n\n    const ny = l.redMul(this.x.redSub(nx)).redISub(this.y); // Check for infinity.\n\n    const inf = negated | this.inf & p.inf; // Case 1: O + P = P\n\n    nx.cinject(p.x, this.inf);\n    ny.cinject(p.y, this.inf); // Case 2: P + O = P\n\n    nx.cinject(this.x, p.inf);\n    ny.cinject(this.y, p.inf); // Case 3 & 4: P + -P = O, O + O = O\n\n    nx.cinject(this.curve.zero, inf);\n    ny.cinject(this.curve.zero, inf);\n    return this.curve.point(nx, ny, inf);\n  }\n\n  udbl() {\n    return this.uadd(this);\n  }\n\n  recover(p1, p2) {\n    // Okeya-Sakurai Y-coordinate Recovery.\n    //\n    // [MONT3] Algorithm 5, Page 13, Section 4.3.\n    //         Algorithm 6, Page 14, Section 4.3.\n    //\n    // 1I + 12M + 1S + 6A + 1*a + 1*b + 2*2\n    assert(p1 instanceof XPoint);\n    assert(p2 instanceof XPoint); // P = O\n\n    if (this.inf) return this.curve.point(); // A = X0 * Z1\n\n    const a = this.x.redMul(p1.z); // B = X1 + A\n\n    const b = p1.x.redAdd(a); // C = (X1 - A)^2 * X2\n\n    const c = p1.x.redSub(a).redSqr().redMul(p2.x); // D = 2 * a * Z1\n\n    const d = this.curve.a.redMul(p1.z).redIMuln(2); // E = B + D\n\n    const e = b.redIAdd(d); // F = X0 * X1 + Z1\n\n    const f = this.x.redMul(p1.x).redIAdd(p1.z); // G = E * F\n\n    const g = e.redMul(f); // H = D * Z1\n\n    const h = d.redMul(p1.z); // I = (G - H) * Z2\n\n    const i = g.redISub(h).redMul(p2.z); // J = 2 * b * Y0\n\n    const j = this.curve.b.redMul(this.y).redIMuln(2); // K = J * Z1 * Z2\n\n    const k = j.redMul(p1.z).redMul(p2.z); // X = K * X1\n\n    const x = k.redMul(p1.x); // Y = I - C\n\n    const y = i.redISub(c); // Z = K * Z1\n\n    const z = k.redMul(p1.z); // Z = 0\n\n    if (z.isZero()) return this.curve.point(); // L = 1 / Z\n\n    const l = z.redInvert(); // X3 = X * L\n\n    const nx = x.redMul(l); // Y3 = Y * L\n\n    const ny = y.redMul(l);\n    return this.curve.point(nx, ny);\n  }\n\n  getX() {\n    if (this.inf) throw new Error('Invalid point.');\n    return this.x.fromRed();\n  }\n\n  getY() {\n    if (this.inf) throw new Error('Invalid point.');\n    return this.y.fromRed();\n  }\n\n  eq(p) {\n    assert(p instanceof MontPoint); // P = Q\n\n    if (this === p) return true; // P = O\n\n    if (this.inf) return p.inf !== 0; // Q = O\n\n    if (p.inf) return false; // X1 = X2, Y1 = Y2\n\n    return this.x.eq(p.x) && this.y.eq(p.y);\n  }\n\n  isInfinity() {\n    // Infinity cannot be represented in\n    // the affine space, except by a flag.\n    return this.inf !== 0;\n  }\n\n  isOdd() {\n    if (this.inf) return false;\n    return this.y.redIsOdd();\n  }\n\n  isEven() {\n    if (this.inf) return false;\n    return this.y.redIsEven();\n  }\n\n  toP() {\n    return this;\n  }\n\n  toJ() {\n    return this;\n  }\n\n  toX() {\n    // (X3, Z3) = (1, 0)\n    if (this.inf) return this.curve.xpoint(); // (X3, Z3) = (X1, 1)\n\n    return this.curve.xpoint(this.x, this.curve.one);\n  }\n\n  encode() {\n    return this.toX().encode();\n  }\n\n  static decode(curve, bytes, sign) {\n    assert(curve instanceof MontCurve);\n    return curve.decodeX(bytes).toP(sign);\n  }\n\n  toJSON(pre) {\n    if (this.inf) return [];\n    const x = this.getX().toJSON();\n    const y = this.getY().toJSON();\n    return [x, y];\n  }\n\n  static fromJSON(curve, json) {\n    assert(curve instanceof MontCurve);\n    assert(Array.isArray(json));\n    assert(json.length === 0 || json.length === 2 || json.length === 3);\n    if (json.length === 0) return curve.point();\n    const x = BN.fromJSON(json[0]);\n    const y = BN.fromJSON(json[1]);\n    return curve.point(x, y);\n  }\n\n  [custom]() {\n    if (this.inf) return '<MontPoint: Infinity>';\n    return '<MontPoint:' + ' x=' + this.x.fromRed().toString(16, 2) + ' y=' + this.y.fromRed().toString(16, 2) + '>';\n  }\n\n}\n/**\n * XPoint\n */\n\n\nclass XPoint extends Point {\n  constructor(curve, x, z) {\n    assert(curve instanceof MontCurve);\n    super(curve, types.PROJECTIVE);\n    this.x = this.curve.one;\n    this.z = this.curve.zero;\n    if (x != null) this._init(x, z);\n  }\n\n  _init(x, z) {\n    assert(x instanceof BN);\n    assert(z == null || z instanceof BN);\n    this.x = x;\n    this.z = z || this.curve.one;\n    if (!this.x.red) this.x = this.x.toRed(this.curve.red);\n    if (!this.z.red) this.z = this.z.toRed(this.curve.red);\n  }\n\n  clone() {\n    return this.curve.xpoint(this.x.clone(), this.z.clone());\n  }\n\n  swap(point, flag) {\n    assert(point instanceof XPoint);\n    this.x.cswap(point.x, flag);\n    this.z.cswap(point.z, flag);\n    return this;\n  }\n\n  precompute(power, rng) {\n    // No-op.\n    return this;\n  }\n\n  validate() {\n    if (this.isInfinity()) return true; // B * y^2 * z = x^3 + A * x^2 * z + x * z^2\n\n    const {\n      x,\n      z\n    } = this;\n    const x2 = x.redSqr();\n    const x3 = x2.redMul(x);\n    const z2 = z.redSqr();\n    const ax2 = this.curve.a.redMul(x2).redMul(z);\n    const by2 = x3.redIAdd(ax2).redIAdd(x.redMul(z2));\n    const y2 = by2.redMul(this.curve.bi); // sqrt(y^2 * z^4) = y * z^2\n\n    return y2.redMul(z).redJacobi() !== -1;\n  }\n\n  normalize() {\n    // https://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#scaling-scale\n    // 1I + 1M\n    // P = O\n    if (this.isInfinity()) return this; // Z1 = 1\n\n    if (this.z.eq(this.curve.one)) return this; // X3 = X1 / Z1\n\n    this.x = this.x.redDiv(this.z); // Z3 = 1\n\n    this.z = this.curve.one;\n    return this;\n  }\n\n  scale(a) {\n    assert(a instanceof BN); // P = O\n\n    if (this.isInfinity()) return this.curve.xpoint(); // X3 = X1 * A\n\n    const nx = this.x.redMul(a); // Y3 = Y1 * A\n\n    const nz = this.z.redMul(a);\n    return this.curve.xpoint(nx, nz);\n  }\n\n  neg() {\n    // -(X1, Z1) = (X1, Z1)\n    return this;\n  }\n\n  dbl() {\n    // https://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3\n    // 2M + 2S + 4A + 1*a24\n    // A = X1 + Z1\n    const a = this.x.redAdd(this.z); // AA = A^2\n\n    const aa = a.redSqr(); // B = X1 - Z1\n\n    const b = this.x.redSub(this.z); // BB = B^2\n\n    const bb = b.redSqr(); // C = AA - BB\n\n    const c = aa.redSub(bb); // X3 = AA * BB\n\n    const nx = aa.redMul(bb); // Z3 = C * (BB + a24 * C)\n\n    const nz = c.redMul(bb.redIAdd(this.curve.a24.redMul(c)));\n    return this.curve.xpoint(nx, nz);\n  }\n\n  diffAdd(p, q) {\n    // https://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3\n    // 4M + 2S + 6A\n    assert(p instanceof XPoint);\n    assert(q instanceof XPoint); // A = X2 + Z2\n\n    const a = p.x.redAdd(p.z); // B = X2 - Z2\n\n    const b = p.x.redSub(p.z); // C = X3 + Z3\n\n    const c = q.x.redAdd(q.z); // D = X3 - Z3\n\n    const d = q.x.redSub(q.z); // DA = D * A\n\n    const da = d.redMul(a); // CB = C * B\n\n    const cb = c.redMul(b); // X5 = Z1 * (DA + CB)^2\n\n    const nx = this.z.redMul(da.redAdd(cb).redSqr()); // Z5 = X1 * (DA - CB)^2\n\n    const nz = this.x.redMul(da.redISub(cb).redSqr());\n    return this.curve.xpoint(nx, nz);\n  }\n\n  diffAddDbl(p, q) {\n    // https://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#ladder-ladd-1987-m-3\n    // Note that we swap P2 and P3 here (for consistency).\n    // 6M + 4S + 8A + 1*a24\n    assert(p instanceof XPoint);\n    assert(q instanceof XPoint); // A = X2 + Z2\n\n    const a = q.x.redAdd(q.z); // AA = A^2\n\n    const aa = a.redSqr(); // B = X2 - Z2\n\n    const b = q.x.redSub(q.z); // BB = B^2\n\n    const bb = b.redSqr(); // E = AA - BB\n\n    const e = aa.redSub(bb); // C = X3 + Z3\n\n    const c = p.x.redAdd(p.z); // D = X3 - Z3\n\n    const d = p.x.redSub(p.z); // DA = D * A\n\n    const da = d.redMul(a); // CB = C * B\n\n    const cb = c.redMul(b); // X5 = Z1 * (DA + CB)^2\n\n    const nx = this.z.redMul(da.redAdd(cb).redSqr()); // Z5 = X1 * (DA - CB)^2\n\n    const nz = this.x.redMul(da.redISub(cb).redSqr()); // X4 = AA * BB\n\n    const dx = aa.redMul(bb); // Z4 = E * (BB + a24 * E)\n\n    const dz = e.redMul(bb.redIAdd(this.curve.a24.redMul(e)));\n    return [this.curve.xpoint(nx, nz), this.curve.xpoint(dx, dz)];\n  }\n\n  getX() {\n    if (this.isInfinity()) throw new Error('Invalid point.');\n    this.normalize();\n    return this.x.fromRed();\n  }\n\n  getY(sign) {\n    return this.toP(sign).getY();\n  }\n\n  eq(p) {\n    assert(p instanceof XPoint); // P = Q\n\n    if (this === p) return true; // P = O\n\n    if (this.isInfinity()) return p.isInfinity(); // Q = O\n\n    if (p.isInfinity()) return false; // Z1 = Z2\n\n    if (this.z.eq(p.z)) return this.x.eq(p.x); // X1 * Z2 == X2 * Z1\n\n    const x1 = this.x.redMul(p.z);\n    const x2 = p.x.redMul(this.z);\n    return x1.eq(x2);\n  }\n\n  isInfinity() {\n    // Z1 = 0\n    return this.z.isZero();\n  }\n\n  isOdd() {\n    return false;\n  }\n\n  isEven() {\n    return false;\n  }\n\n  hasTorsion() {\n    if (this.isInfinity()) return false; // X1 = 0, Z1 != 0 (edge case)\n\n    if (this.x.isZero()) return true;\n    return super.hasTorsion();\n  }\n\n  jmul(k) {\n    return this.ladder(k)[1];\n  }\n\n  jmulSimple(k) {\n    return this.ladderSimple(k)[1];\n  }\n\n  jmulBlind(k, rng) {\n    return this.ladderBlind(k, rng)[1];\n  }\n\n  jmulConst(k, rng) {\n    return this.ladderConst(k, rng)[1];\n  }\n\n  jmulAdd(k1, p2, k2) {\n    throw new Error('Not implemented.');\n  }\n\n  jmulAddSimple(k1, p2, k2) {\n    throw new Error('Not implemented.');\n  }\n\n  ladder(k) {\n    // Multiply with the Montgomery Ladder.\n    //\n    // [MONT3] Algorithm 4, Page 12, Section 4.2.\n    //\n    // Note that any clamping is meant to\n    // be done _outside_ of this function.\n    assert(k instanceof BN);\n    assert(!k.red);\n    const bits = k.bitLength();\n    let a = this;\n    let b = this.curve.xpoint();\n\n    for (let i = bits - 1; i >= 0; i--) {\n      const bit = k.bit(i);\n      if (bit === 0) [a, b] = this.diffAddDbl(a, b);else [b, a] = this.diffAddDbl(b, a);\n    }\n\n    return [a, b];\n  }\n\n  ladderSimple(k) {\n    // Montgomery Ladder with explicit\n    // additions and doubling (testing).\n    assert(k instanceof BN);\n    assert(!k.red);\n    const bits = k.bitLength();\n    let a = this;\n    let b = this.curve.xpoint(); // Climb the ladder.\n\n    for (let i = bits - 1; i >= 0; i--) {\n      const bit = k.bit(i);\n\n      if (bit === 0) {\n        a = this.diffAdd(a, b);\n        b = b.dbl();\n      } else {\n        b = this.diffAdd(b, a);\n        a = a.dbl();\n      }\n    }\n\n    return [a, b];\n  }\n\n  ladderBlind(k, rng) {\n    if (!rng) return this.ladder(k); // Randomize if available.\n\n    return this.randomize(rng).ladder(k);\n  }\n\n  ladderConst(k, rng) {\n    // Multiply with the Montgomery Ladder.\n    //\n    // [MONT3] Algorithm 7, Page 16, Section 5.3.\n    //         Algorithm 8, Page 16, Section 5.3.\n    //\n    // [RFC7748] Page 7, Section 5.\n    //\n    // Note that any clamping is meant to\n    // be done _outside_ of this function.\n    assert(k instanceof BN);\n    assert(!k.red);\n    const bits = Math.max(k.bitLength(), this.curve.fieldBits);\n    const bytes = bits + 7 >>> 3; // Recode scalar to base256.\n\n    const exp = k.toArray('le', bytes); // Randomize if available.\n\n    const point = rng ? this.randomize(rng) : this; // Clone points (for safe swapping).\n\n    let a = point.clone();\n    let b = this.curve.xpoint().clone();\n    let swap = 0; // Climb the ladder.\n\n    for (let i = bits - 1; i >= 0; i--) {\n      const bit = exp[i >> 3] >> (i & 7) & 1; // Maybe swap.\n\n      a.swap(b, swap ^ bit); // Single coordinate add+double.\n\n      [a, b] = point.diffAddDbl(a, b);\n      swap = bit;\n    } // Finalize loop.\n\n\n    a.swap(b, swap);\n    return [a, b];\n  }\n\n  toP(sign = null) {\n    assert(sign == null || typeof sign === 'boolean');\n    if (this.isInfinity()) return this.curve.point();\n    this.normalize();\n    return this.curve.pointFromX(this.x, sign);\n  }\n\n  toJ() {\n    return this;\n  }\n\n  toX() {\n    return this;\n  }\n\n  encode() {\n    // [RFC7748] Section 5.\n    return this.curve.encodeField(this.getX());\n  }\n\n  static decode(curve, bytes) {\n    assert(curve instanceof MontCurve); // [RFC7748] Section 5.\n\n    const x = curve.decodeField(bytes); // We're supposed to ignore the hi bit\n    // on montgomery points... I think. If\n    // we don't, the X25519 test vectors\n    // break, which is pretty convincing\n    // evidence. This is a no-op for X448.\n\n    x.iumaskn(curve.fieldBits); // Note: montgomery points are meant to be\n    // reduced by the prime and do not have to\n    // be explicitly validated in order to do\n    // the montgomery ladder.\n\n    const p = curve.xpoint(x, curve.one);\n    assert(!p.isInfinity());\n    return p;\n  }\n\n  toJSON(pre) {\n    return this.toP().toJSON(pre);\n  }\n\n  static fromJSON(curve, json) {\n    return MontPoint.fromJSON(curve, json).toX();\n  }\n\n  [custom]() {\n    if (this.isInfinity()) return '<XPoint: Infinity>';\n    return '<XPoint:' + ' x=' + this.x.fromRed().toString(16, 2) + ' z=' + this.z.fromRed().toString(16, 2) + '>';\n  }\n\n}\n/**\n * EdwardsCurve\n */\n\n\nclass EdwardsCurve extends Curve {\n  constructor(conf) {\n    super(EdwardsPoint, 'edwards', conf);\n    this.a = BN.fromJSON(conf.a).toRed(this.red);\n    this.d = BN.fromJSON(conf.d).toRed(this.red);\n    this.s = BN.fromJSON(conf.s || '0').toRed(this.red);\n    this.si = this.s.isZero() ? this.zero : this.s.redInvert();\n    this.k = this.d.redMuln(2);\n    this.smi = -this.d.redNeg().word(0);\n    this.ad6 = this.a.redAdd(this.d).redMul(this.i6);\n    this.twisted = !this.a.eq(this.one);\n    this.oneA = this.a.eq(this.one);\n    this.mOneA = this.a.eq(this.one.redNeg());\n    this.smallD = this.prime != null && this.d.redNeg().length === 1;\n    this.alt = null;\n\n    this._finalize(conf);\n  }\n\n  static _isomorphism(curveA, curveD, customA) {\n    // Twisted Edwards Isomorphism.\n    //\n    // [TWISTED] Definition 2.1, Page 3, Section 2.\n    //\n    // Transformation:\n    //\n    //   a' = a'\n    //   d' = a' * d / a\n    //\n    // Where (a / a') is square.\n    assert(curveA instanceof BN);\n    assert(curveD instanceof BN);\n    assert(customA instanceof BN);\n    const a = customA.clone();\n    const d = customA.redMul(curveD).redDiv(curveA);\n    const c = curveA.redDiv(customA);\n    if (c.redJacobi() !== 1) throw new Error('Invalid `a` coefficient.');\n    return [a, d];\n  }\n\n  _short(a0, odd) {\n    // Twisted Edwards->Short Weierstrass Equivalence.\n    //\n    // [TWISTEQ] Section 2.\n    //\n    // Transformation:\n    //\n    //   a' = -(a^2 + 14 * a * d + d^2) / 48\n    //   b' = (33 * (a^2 * d + a * d^2) - a^3 - d^3) / 864\n    const {\n      a,\n      d\n    } = this;\n    const a2 = a.redSqr();\n    const a3 = a2.redMul(a);\n    const d2 = d.redSqr();\n    const d3 = d2.redMul(d);\n    const ad14 = a.redMul(d).redIMuln(14);\n    const a2d = a2.redMul(d);\n    const ad2 = a.redMul(d2);\n    const t0 = a2d.redIAdd(ad2).redIMuln(33);\n    const wa = a2.redAdd(ad14).redIAdd(d2).redDivn(-48);\n    const wb = t0.redISub(a3).redISub(d3).redDivn(864);\n    if (a0 != null) return ShortCurve._isomorphism(wa, wb, a0, odd);\n    return [wa, wb];\n  }\n\n  _mont(b0, invert = false) {\n    // Twisted Edwards->Montgomery Transformation.\n    //\n    // [TWISTED] Theorem 3.2, Page 4, Section 3.\n    //\n    // Equivalence:\n    //\n    //   A = 2 * (a + d) / (a - d)\n    //   B = 4 / (a - d)\n    //\n    // Isomorphism:\n    //\n    //   A = 2 * (a + d) / (a - d)\n    //   B = B'\n    //\n    // Where ((4 / (a - d)) / B') is square.\n    //\n    // If `4 / (a - d)` is non-square, we can\n    // usually force B=1 by using the `invert`\n    // option. This will create an isomorphism\n    // chain of: E(a,d)->E(d,a)->M(-A,-B).\n    //\n    // The equivalence between E(a,d) and E(d,a)\n    // is:\n    //\n    //   (x, y) = (x, 1 / y)\n    //\n    // Meaning our map to M(-A,-B) is:\n    //\n    //   u = (1 + 1 / y) / (1 - 1 / y)\n    //     = (y + 1) / (y - 1)\n    //   v = u / x\n    assert(typeof invert === 'boolean');\n    let apd, amd;\n\n    if (invert) {\n      apd = this.d.redAdd(this.a);\n      amd = this.d.redSub(this.a);\n    } else {\n      apd = this.a.redAdd(this.d);\n      amd = this.a.redSub(this.d);\n    }\n\n    const z = amd.redInvert();\n    const a = apd.redMuln(2).redMul(z);\n    const b = z.redMuln(4);\n    if (b0 != null) return MontCurve._isomorphism(a, b, b0);\n    return [a, b];\n  }\n\n  _edwards(a0) {\n    return EdwardsCurve._isomorphism(this.a, this.d, a0);\n  }\n\n  _scaleShort(curve) {\n    assert(curve instanceof ShortCurve);\n\n    const [u2, u3] = curve._scale(this);\n\n    return [this.field(u2.redInvert()), this.field(u3.redInvert())];\n  }\n\n  _scaleMont(curve, invert = false) {\n    // Calculate isomorphism factor between\n    // Twisted Edwards and Montgomery with:\n    //\n    //   a = (A + 2) / B\n    //   c = +-sqrt(a / a')\n    //\n    // Which can be reduced to:\n    //\n    //   c = +-sqrt((A + 2) / (B * a'))\n    //\n    // If base points are available, we can do:\n    //\n    //   x = u / v\n    //   c = x' / x\n    //\n    // Which can be reduced to:\n    //\n    //   c = v * x' / u\n    //\n    // We can now calculate the Edwards `x` with:\n    //\n    //   x' = c * u / v\n    //\n    // And likewise, the Montgomery `v`:\n    //\n    //   v = c * u / x'\n    assert(curve instanceof MontCurve);\n    assert(typeof invert === 'boolean');\n\n    if (this.g.isInfinity() || curve.g.isInfinity()) {\n      const [a] = curve._edwards(null, invert);\n\n      return this.field(a).redDivSqrt(this.a);\n    }\n\n    const x = curve.g.x.redDiv(curve.g.y);\n    return this.g.x.redDiv(this.field(x));\n  }\n\n  _scaleEdwards(curve) {\n    // We can extract the isomorphism factor with:\n    //\n    //   c = +-sqrt(a / a')\n    //\n    // If base points are available, we can do:\n    //\n    //   c = x' / x\n    assert(curve instanceof EdwardsCurve);\n    if (this.g.isInfinity() || curve.g.isInfinity()) return this.field(curve.a).redDivSqrt(this.a);\n    return this.g.x.redDiv(this.field(curve.g.x));\n  }\n\n  _mulA(num) {\n    assert(num instanceof BN); // n * a = n\n\n    if (this.oneA) return num.clone(); // n * a = -n\n\n    if (this.mOneA) return num.redNeg();\n    return this.a.redMul(num);\n  }\n\n  _mulD(num) {\n    assert(num instanceof BN); // -d < 0x4000000\n\n    if (this.smallD) return num.redMuln(this.smi);\n    return this.d.redMul(num);\n  }\n\n  _elligator1(t) {\n    // Elligator 1.\n    //\n    // Distribution: 1/2.\n    //\n    // [ELL1] Page 6, Section 3.\n    //        Page 15, Appendix A.\n    // [ELL2] Page 7, Section 3.2.\n    //\n    // Assumptions:\n    //\n    //   - Let p be a prime power congruent to 3 mod 4.\n    //   - Let s be a nonzero element of F(p).\n    //   - Let c = 2 / s^2.\n    //   - Let r = c + 1 / c.\n    //   - Let d = -(c + 1)^2 / (c - 1)^2.\n    //   - (s^2 - 2) * (s^2 + 2) != 0.\n    //   - c * (c - 1) * (c + 1) != 0.\n    //   - r != 0.\n    //   - d is not square.\n    //   - x^2 + y^2 = 1 + d * x^2 * y^2.\n    //   - u * v * X * Y * x * (Y + 1) != 0.\n    //   - Y^2 = X^5 + (r^2 - 2) * X^3 + X.\n    //\n    // Elligator 1, as devised by Fouque et al,\n    // takes place on the hyperelliptic curve of:\n    //\n    //   y^2 = x^5 + (r^2 - 2) * x^3 + x\n    //\n    // Not only must our Edwards curve be complete,\n    // with a prime congruent to 3 mod 4, and a = 1,\n    // our curve must be isomorphic to a hyperelliptic\n    // curve of the above form. Roughly one half of\n    // all Edwards curves are isomorphic to a curve\n    // of said form.\n    //\n    // We can derive the isomorphism with:\n    //\n    //   c = (d +- 2 * sqrt(-d) - 1) / (d + 1)\n    //   s = +-sqrt(2 / c)\n    //   r = c + 1 / c\n    //\n    // Note that even if your curve is an Elligator 1\n    // curve, Elligator 2 is probably still preferable,\n    // as it has nearly the same properties (i.e. the\n    // same distribution), and is much less complex.\n    //\n    // Map:\n    //\n    //   f(a) = a^((p - 1) / 2)\n    //   u = (1 - t) / (1 + t)\n    //   v = u^5 + (r^2 - 2) * u^3 + u\n    //   X = f(v) * u\n    //   Y = (f(v) * v)^((p + 1) / 4) * f(v) * f(u^2 + 1 / c^2)\n    //   Y = 1, if u = 0\n    //   x = (c - 1) * s * X * (1 + X) / Y\n    //   y = (r * X - (1 + X)^2) / (r * X + (1 + X)^2)\n    //\n    // When t = +-1, we create the hyperelliptic\n    // 2-torsion point of (0, 0). This needs to be\n    // mapped to (0, -1) in Edwards form, but the x\n    // denominator becomes zero. As far as I can\n    // tell, this is the only exceptional case.\n    //\n    // The only other exceptional case initially\n    // appears to be when the y denominator sums to\n    // zero (when t = sqrt(4 / r + 1)), however, the\n    // hyperelliptic `X` is negated by the sign of\n    // `v`, making this impossible.\n    const {\n      s,\n      si,\n      i2,\n      one,\n      two\n    } = this;\n    const c = si.redSqr().redIMuln(2);\n    const ci = s.redSqr().redMul(i2);\n    const ci2 = ci.redSqr();\n    const r = c.redAdd(ci);\n    const r2 = r.redSqr().redISub(two);\n    const cm1 = c.redSub(one);\n    const e0 = this.p.subn(2);\n    const e1 = this.p.subn(1).iushrn(1);\n    const e2 = this.p.addn(1).iushrn(2);\n    const uu = one.redSub(t);\n    const uz = one.redAdd(t);\n    const u = uu.redMul(uz.redPow(e0));\n    const u2 = u.redSqr();\n    const u3 = u2.redMul(u);\n    const u5 = u3.redMul(u2);\n    const v = u5.redAdd(r2.redMul(u3)).redIAdd(u);\n    const f0 = v.redPow(e1);\n    const f1 = u2.redAdd(ci2).redPow(e1);\n    const f2 = f0.redMul(f1);\n    const X = f0.redMul(u);\n    const Y = f0.redMul(v).redPow(e2).redMul(f2);\n    const X1 = one.redAdd(X);\n    const rX = r.redMul(X);\n    const X12 = X1.redSqr();\n    const xx = cm1.redMul(s).redMul(X).redMul(X1);\n    const xz = Y.cinject(this.one, u.czero());\n    const yy = rX.redSub(X12);\n    const yz = rX.redAdd(X12);\n    return this.cpoint(xx, xz, yy, yz);\n  }\n\n  _invert1(p, hint) {\n    // Inverting the Map (Elligator 1).\n    //\n    // [ELL1] Page 6, Section 3.\n    //        Page 15, Appendix A.\n    // [ELL2] Page 7, Section 3.3.\n    //\n    // Assumptions:\n    //\n    //   - y + 1 != 0.\n    //   - (1 + n * r)^2 - 1 is square in F(p).\n    //   - If n * r = -2 then x = 2 * s * (c - 1) * f(c) / r.\n    //   - Y = (c - 1) * s * X * (1 + X) / x.\n    //\n    // Map:\n    //\n    //   f(a) = a^((p - 1) / 2)\n    //   n = (y - 1) / (2 * (y + 1))\n    //   X = -(1 + n * r) + ((1 + n * r)^2 - 1)^((p + 1) / 4)\n    //   z = f((c - 1) * s * X * (1 + X) * x * (X^2 + 1 / c^2))\n    //   u = z * X\n    //   t = (1 - u) / (1 + u)\n    const {\n      s,\n      si,\n      i2,\n      one\n    } = this;\n    const {\n      x,\n      y,\n      z\n    } = p;\n    const sign = hint & 1;\n    const c = si.redSqr().redIMuln(2);\n    const ci = s.redSqr().redMul(i2);\n    const ci2 = ci.redSqr();\n    const r = c.redAdd(ci);\n    const cm1 = c.redSub(one);\n    const e0 = this.p.subn(2);\n    const e1 = this.p.subn(1).iushrn(1);\n    const e2 = this.p.addn(1).iushrn(2);\n    const nn = y.redSub(z);\n    const nz = y.redAdd(z).redIMuln(2);\n    const n = nn.redMul(nz.redPow(e0));\n    const nr1 = one.redAdd(n.redMul(r));\n    const w2 = nr1.redSqr().redISub(one);\n    const w = w2.redPow(e2);\n    const sqr = w.redSqr().ceq(w2);\n    const X = w.redSub(nr1);\n    const X1 = one.redAdd(X);\n    const YY = cm1.redMul(s).redMul(X).redMul(X1);\n    const Y = YY.redMul(x.redMul(z));\n    const X2 = X.redSqr().redIAdd(ci2);\n    const Z = Y.redMul(X2).redPow(e1);\n    const u = Z.redMul(X);\n    const tt = one.redSub(u);\n    const tz = one.redAdd(u);\n    const t = tt.redMul(tz.redPow(e0));\n    t.cinject(t.redNeg(), t.redIsOdd() ^ sign);\n    if (!sqr) throw new Error('Invalid point.');\n    return t;\n  }\n\n  _alt() {\n    if (!this.alt) this.alt = this.toMont();\n    return this.alt;\n  }\n\n  isElliptic() {\n    const ad = this.a.redMul(this.d);\n    const amd = this.a.redSub(this.d); // a * d * (a - d) != 0\n\n    return !ad.redMul(amd).isZero();\n  }\n\n  jinv() {\n    // [TWISTED] Definition 2.1, Page 3, Section 2.\n    const {\n      a,\n      d\n    } = this;\n    const ad = a.redMul(d);\n    const amd4 = a.redSub(d).redPown(4);\n    const a2 = a.redSqr();\n    const d2 = d.redSqr();\n    const t0 = a2.redAdd(ad.redMuln(14)).redIAdd(d2);\n    const lhs = t0.redPown(3).redIMuln(16);\n    const rhs = ad.redMul(amd4);\n    if (rhs.isZero()) throw new Error('Curve is not elliptic.'); // 16 * (a^2 + 14 * a * d + d^2)^3 / (a * d * (a - d)^4)\n\n    return lhs.redDiv(rhs).fromRed();\n  }\n\n  isComplete() {\n    return this.a.redJacobi() === 1 && this.d.redJacobi() === -1;\n  }\n\n  point(x, y, z, t) {\n    return new EdwardsPoint(this, x, y, z, t);\n  }\n\n  jpoint(x, y, z) {\n    assert(x == null && y == null && z == null);\n    return this.point();\n  }\n\n  cpoint(xx, xz, yy, yz) {\n    assert(xx instanceof BN);\n    assert(xz instanceof BN);\n    assert(yy instanceof BN);\n    assert(yz instanceof BN);\n    const x = xx.redMul(yz);\n    const y = yy.redMul(xz);\n    const z = xz.redMul(yz);\n    const t = xx.redMul(yy);\n    return this.point(x, y, z, t);\n  }\n\n  solveX2(y) {\n    // [RFC8032] Section 5.1.3 & 5.2.3.\n    assert(y instanceof BN); // x^2 = (y^2 - 1) / (d * y^2 - a)\n\n    const y2 = y.redSqr();\n\n    const rhs = this._mulD(y2).redISub(this.a);\n\n    const lhs = y2.redISub(this.one);\n    const x2 = lhs.redDiv(rhs);\n    return x2;\n  }\n\n  solveX(y) {\n    // Optimize with inverse square root trick.\n    //\n    // Note that `0 / 0` can only occur if\n    // `a == d` (i.e. the curve is singular).\n    const y2 = y.redSqr();\n\n    const rhs = this._mulD(y2).redISub(this.a);\n\n    const lhs = y2.redISub(this.one);\n    return lhs.redDivSqrt(rhs);\n  }\n\n  solveY2(x) {\n    assert(x instanceof BN); // y^2 = (a * x^2 - 1) / (d * x^2 - 1)\n\n    const x2 = x.redSqr();\n\n    const lhs = this._mulA(x2).redISub(this.one);\n\n    const rhs = this._mulD(x2).redISub(this.one);\n\n    const y2 = lhs.redDiv(rhs);\n    return y2;\n  }\n\n  solveY(x) {\n    // Optimize with inverse square root trick.\n    //\n    // Note that `0 / 0` can only occur if\n    // `a == d` (i.e. the curve is singular).\n    const x2 = x.redSqr();\n\n    const lhs = this._mulA(x2).redISub(this.one);\n\n    const rhs = this._mulD(x2).redISub(this.one);\n\n    return lhs.redDivSqrt(rhs);\n  }\n\n  validate(point) {\n    // [TWISTED] Definition 2.1, Page 3, Section 2.\n    //           Page 11, Section 6.\n    assert(point instanceof EdwardsPoint); // Z1 = 1\n\n    if (point.zOne) {\n      // a * x^2 + y^2 = 1 + d * x^2 * y^2\n      const x2 = point.x.redSqr();\n      const y2 = point.y.redSqr();\n\n      const dxy = this._mulD(x2).redMul(y2);\n\n      const lhs = this._mulA(x2).redIAdd(y2);\n\n      const rhs = this.one.redAdd(dxy);\n      const tz = point.t;\n      const xy = point.x.redMul(point.y);\n      return lhs.eq(rhs) && tz.eq(xy);\n    } // (a * x^2 + y^2) * z^2 = z^4 + d * x^2 * y^2\n\n\n    const x2 = point.x.redSqr();\n    const y2 = point.y.redSqr();\n    const z2 = point.z.redSqr();\n    const z4 = z2.redSqr();\n\n    const dxy = this._mulD(x2).redMul(y2);\n\n    const lhs = this._mulA(x2).redIAdd(y2).redMul(z2);\n\n    const rhs = z4.redIAdd(dxy);\n    const tz = point.t.redMul(point.z);\n    const xy = point.x.redMul(point.y);\n    return lhs.eq(rhs) && tz.eq(xy);\n  }\n\n  pointFromX(x, sign = null) {\n    assert(x instanceof BN);\n    assert(sign == null || typeof sign === 'boolean');\n    if (!x.red) x = x.toRed(this.red);\n    const y = this.solveY(x);\n\n    if (sign != null) {\n      if (y.isZero() && sign) throw new Error('Invalid point.');\n      if (y.redIsOdd() !== sign) y.redINeg();\n    }\n\n    return this.point(x, y);\n  }\n\n  pointFromY(y, sign = null) {\n    assert(y instanceof BN);\n    assert(sign == null || typeof sign === 'boolean');\n    if (!y.red) y = y.toRed(this.red);\n    const x = this.solveX(y);\n\n    if (sign != null) {\n      if (x.isZero() && sign) throw new Error('Invalid point.');\n      if (x.redIsOdd() !== sign) x.redINeg();\n    }\n\n    return this.point(x, y);\n  }\n\n  isIsomorphic(curve, invert = false) {\n    // [TWISTED] Theorem 3.2, Page 4, Section 3.\n    //           Definition 2.1, Page 3, Section 2.\n    assert(curve instanceof Curve);\n    assert(typeof invert === 'boolean');\n    if (!curve.p.eq(this.p)) return false; // E(a,d) <-> E(a,b)\n\n    if (curve.type === 'short') return curve.isIsomorphic(this); // E(a,d) <-> M(A,B)\n    // E(a,d) <-> M(-A,-B)\n\n    if (curve.type === 'mont') {\n      // A * (a - d) = 2 * (a + d)\n      const a = this.field(curve.a);\n      let apd, amd;\n\n      if (invert) {\n        apd = this.d.redAdd(this.a);\n        amd = this.d.redSub(this.a);\n      } else {\n        apd = this.a.redAdd(this.d);\n        amd = this.a.redSub(this.d);\n      }\n\n      return a.redMul(amd).eq(apd.redIMuln(2));\n    } // E(a,d) <-> E(a',a'd/a)\n\n\n    if (curve.type === 'edwards') {\n      // a' * d = a * d'\n      const a = this.field(curve.a);\n      const d = this.field(curve.d);\n      return this.a.redMul(d).eq(a.redMul(this.d));\n    }\n\n    return false;\n  }\n\n  isIsogenous(curve) {\n    // Check for the 4-isogenies described by Hamburg:\n    // https://moderncrypto.org/mail-archive/curves/2016/000806.html\n    assert(curve instanceof Curve);\n    if (!curve.p.eq(this.p)) return false; // E(1,d) <-> M(2-4d,1)\n\n    if (curve.type === 'mont') {\n      if (!this.a.eq(this.one)) return false;\n      const a = this.field(curve.a);\n      const b = this.field(curve.b);\n      const d24 = this.two.redSub(this.d.redMuln(4));\n      return a.eq(d24) && b.eq(this.one);\n    } // E(a,d) <-> E(-a,d-a)\n\n\n    if (curve.type === 'edwards') {\n      const a = this.field(curve.a);\n      const d = this.field(curve.d);\n      return a.eq(this.a.redNeg()) && d.eq(this.d.redSub(this.a));\n    }\n\n    return false;\n  }\n\n  pointFromShort(point) {\n    // [TWISTEQ] Section 1.\n    assert(point instanceof ShortPoint);\n\n    if (this.isIsomorphic(point.curve)) {\n      // Equivalence for E(a,b)->E(a',d'):\n      //\n      //   x' = (6 * x - a' - d') / (6 * y)\n      //   y' = (12 * x - 5 * a' + d') / (12 * x + a' - 5 * d')\n      //\n      // Undefined for x = (5 * d' - a') / 12 or y = 0.\n      //\n      // Exceptional Cases:\n      //   - O -> (0, 1)\n      //   - ((a' + d') / 6, 0) -> (0, -1)\n      //   - ((5 * d' - a') / 12, (d' - a') / 4 * sqrt(d')) -> (sqrt(1/d'), oo)\n      //\n      // Unexceptional Cases:\n      //   - ((5 * a' - d') / 12, (a' - d') / 4 * sqrt(a')) -> (sqrt(1/a'), 0)\n      if (point.isInfinity()) return this.point();\n      if (point.y.isZero()) return this.point(this.zero, this.one.redNeg());\n      const {\n        a,\n        d\n      } = this;\n\n      const [u2, u3] = this._scale(point.curve);\n\n      const a5 = a.redMuln(5);\n      const d5 = d.redMuln(5);\n      const x = this.field(point.x).redMul(u2);\n      const y = this.field(point.y).redMul(u3);\n      const x6 = x.redMuln(6);\n      const x12 = x.redMuln(12);\n      const xx = x6.redSub(a).redISub(d);\n      const xz = y.redMuln(6);\n      const yy = x12.redSub(a5).redIAdd(d);\n      const yz = x12.redAdd(a).redISub(d5);\n      return this.cpoint(xx, xz, yy, yz);\n    }\n\n    throw new Error('Not implemented.');\n  }\n\n  pointFromMont(point) {\n    // [RFC7748] Section 4.1 & 4.2.\n    // [MONT3] Page 6, Section 2.5.\n    // [TWISTED] Theorem 3.2, Page 4, Section 3.\n    assert(point instanceof MontPoint);\n    assert(point.curve.p.eq(this.p)); // Montgomery `u`, `v`.\n\n    const u = this.field(point.x);\n    const v = this.field(point.y);\n\n    if (this.isIsogenous(point.curve)) {\n      // 4-isogeny maps for M(2-4d,1)->E(1,d):\n      //\n      //   x = 4 * v * (u^2 - 1) / (u^4 - 2 * u^2 + 4 * v^2 + 1)\n      //   y = -(u^5 - 2 * u^3 - 4 * u * v^2 + u) /\n      //        (u^5 - 2 * u^2 * v^2 - 2 * u^3 - 2 * v^2 + u)\n      //\n      // Undefined for u = 0 and v = 0.\n      //\n      // Exceptional Cases:\n      //   - O -> (0, 1)\n      //   - (0, 0) -> (0, 1)\n      //\n      // Unexceptional Cases:\n      //   - (-1, +-sqrt(A - 2)) -> (0, 1)\n      //   - (1, +-sqrt(A + 2)) -> (0, -1)\n      //\n      // The point (1, v) is invalid on Curve448.\n      if (point.isInfinity()) return this.point();\n      if (point.x.isZero()) return this.point();\n      const u2 = u.redSqr();\n      const u3 = u2.redMul(u);\n      const u4 = u3.redMul(u);\n      const u5 = u4.redMul(u);\n      const v2 = v.redSqr();\n      const a = v.redMuln(4);\n      const b = u2.redSub(this.one);\n      const c = u2.redMuln(2);\n      const d = v2.redMuln(4);\n      const e = u3.redIMuln(2);\n      const f = u.redMul(v2).redIMuln(4);\n      const g = u2.redMul(v2).redIMuln(2);\n      const h = v2.redIMuln(2);\n      const xx = a.redMul(b);\n      const xz = u4.redISub(c).redIAdd(d).redIAdd(this.one);\n      const yy = u5.redSub(e).redISub(f).redIAdd(u).redINeg();\n      const yz = u5.redISub(g).redISub(e).redISub(h).redIAdd(u);\n      return this.cpoint(xx, xz, yy, yz).divn(4);\n    }\n\n    if (this.isIsomorphic(point.curve, true)) {\n      // Isomorphic maps for M(-A,-B)->E(a,d):\n      //\n      //   x = +-sqrt((A - 2) / (B * a)) * u / v\n      //   y = (u + 1) / (u - 1)\n      //\n      // Undefined for u = 1 or v = 0.\n      //\n      // Exceptional Cases:\n      //   - O -> (0, 1)\n      //   - (0, 0) -> (0, -1)\n      //   - (1, +-sqrt((A + 2) / B)) -> (+-sqrt(1 / d), oo)\n      //\n      // Unexceptional Cases:\n      //   - (-1, +-sqrt((A - 2) / B)) -> (+-sqrt(1 / a), 0)\n      //\n      // The point (1, v) is invalid on Curve448.\n      if (point.isInfinity()) return this.point();\n      if (point.x.isZero()) return this.point(this.zero, this.one.redNeg());\n\n      const c = this._scale(point.curve, true);\n\n      const xx = c.redMul(u);\n      const xz = v;\n      const yy = u.redAdd(this.one);\n      const yz = u.redSub(this.one);\n      return this.cpoint(xx, xz, yy, yz);\n    }\n\n    if (this.isIsomorphic(point.curve, false)) {\n      // Isomorphic maps for M(A,B)->E(a,d):\n      //\n      //   x = +-sqrt((A + 2) / (B * a)) * u / v\n      //   y = (u - 1) / (u + 1)\n      //\n      // Undefined for u = -1 or v = 0.\n      //\n      // Exceptional Cases:\n      //   - O -> (0, 1)\n      //   - (0, 0) -> (0, -1)\n      //   - (-1, +-sqrt((A - 2) / B)) -> (+-sqrt(1 / d), oo)\n      //\n      // Unexceptional Cases:\n      //   - (1, +-sqrt((A + 2) / B)) -> (+-sqrt(1 / a), 0)\n      //\n      // The point (-1, v) is invalid on Curve25519.\n      if (point.isInfinity()) return this.point();\n      if (point.x.isZero()) return this.point(this.zero, this.one.redNeg());\n\n      const c = this._scale(point.curve, false);\n\n      const xx = c.redMul(u);\n      const xz = v;\n      const yy = u.redSub(this.one);\n      const yz = u.redAdd(this.one);\n      return this.cpoint(xx, xz, yy, yz);\n    }\n\n    throw new Error('Not implemented.');\n  }\n\n  pointFromEdwards(point) {\n    // [TWISTED] Definition 2.1, Page 3, Section 2.\n    // [ISOGENY] Page 2, Section 2.\n    assert(point instanceof EdwardsPoint);\n    assert(point.curve.p.eq(this.p)); // Edwards `x`, `y`, `z`, `t`.\n\n    const a = this.field(point.curve.a);\n    const x = this.field(point.x);\n    const y = this.field(point.y);\n    const z = this.field(point.z);\n    const t = this.field(point.t);\n\n    if (this.isIsogenous(point.curve)) {\n      // 4-isogeny maps for E(a,d)<->E(-a,d-a):\n      //\n      //   x' = (2 * x * y) / (y^2 - a * x^2)\n      //   y' = (y^2 + a * x^2) / (2 - y^2 - a * x^2)\n      //\n      // Undefined for y^2 - a * x^2 = 0\n      //            or y^2 + a * x^2 = 2.\n      const xy = x.redMul(y);\n      const x2 = x.redSqr();\n      const y2 = y.redSqr();\n      const z2 = z.redSqr();\n      const ax2 = a.redMul(x2);\n      const xx = xy.redIMuln(2);\n      const xz = y2.redSub(ax2);\n      const yy = y2.redAdd(ax2);\n      const yz = z2.redIMuln(2).redISub(yy);\n      const p = this.cpoint(xx, xz, yy, yz);\n      return !this.twisted ? p.divn(4) : p;\n    }\n\n    if (this.isIsomorphic(point.curve)) {\n      // Isomorphic maps for E(a,d)<->E(a',a'd/a):\n      //\n      //   x' = +-sqrt(a / a') * x\n      //   y' = y\n      //\n      // Undefined when (a / a') is not square.\n      const c = this._scale(point.curve);\n\n      const nx = c.redMul(x);\n      const ny = y;\n      const nz = z;\n      const nt = c.redMul(t);\n      return this.point(nx, ny, nz, nt);\n    }\n\n    throw new Error('Not implemented.');\n  }\n\n  pointFromUniform(u, curve = null) {\n    assert(u instanceof BN);\n    assert(u.red === this.red);\n    assert(curve == null || curve instanceof MontCurve);\n    if (!curve) curve = this._alt();\n    const u0 = curve.field(u);\n    const p0 = curve.pointFromUniform(u0);\n    return this.pointFromMont(p0);\n  }\n\n  pointToUniform(p, hint, curve = null) {\n    assert(p instanceof EdwardsPoint);\n    assert(hint >>> 0 === hint);\n    assert(curve == null || curve instanceof MontCurve);\n    if (!curve) curve = this._alt(); // Add a random torsion component.\n\n    const i = (hint >> 4 & 15) % this.torsion.length;\n    const q = p.add(this.torsion[i]); // Convert and invert.\n\n    const p0 = curve.pointFromEdwards(q);\n    const u0 = curve.pointToUniform(p0, hint & 15);\n    return this.field(u0);\n  }\n\n  pointFromHash(bytes, pake, curve = null) {\n    assert(curve == null || curve instanceof MontCurve);\n    if (!curve) curve = this._alt();\n    const p0 = curve.pointFromHash(bytes, pake);\n    return this.pointFromMont(p0);\n  }\n\n  pointToHash(p, subgroup, rng, curve = null) {\n    assert(p instanceof EdwardsPoint);\n    assert(subgroup >>> 0 === subgroup);\n    assert(curve == null || curve instanceof MontCurve);\n    if (!curve) curve = this._alt(); // Add a random torsion component.\n\n    const i = subgroup % this.torsion.length;\n    const q = p.add(this.torsion[i]); // Convert and invert.\n\n    const p0 = curve.pointFromEdwards(q);\n    return curve.pointToHash(p0, 0, rng);\n  }\n\n  decodePoint(bytes) {\n    return EdwardsPoint.decode(this, bytes);\n  }\n\n  toShort(a0, odd, sign = null) {\n    const [a, b] = this._short(a0, odd);\n\n    const curve = new ShortCurve({\n      red: this.red,\n      prime: this.prime,\n      p: this.p,\n      a: a,\n      b: b,\n      n: this.n,\n      h: this.h\n    });\n\n    if (sign != null) {\n      const [, u3] = curve._scale(this);\n\n      if (u3.redIsOdd() !== sign) u3.redINeg();\n    }\n\n    if (!this.g.isInfinity()) curve.g = curve.pointFromEdwards(this.g);\n\n    for (let i = 0; i < this.h; i++) curve.torsion[i] = curve.pointFromEdwards(this.torsion[i]);\n\n    return curve;\n  }\n\n  toMont(b0, invert, sign = null) {\n    const [a, b] = this._mont(b0, invert);\n\n    const curve = new MontCurve({\n      red: this.red,\n      prime: this.prime,\n      p: this.p,\n      a: a,\n      b: b,\n      n: this.n,\n      h: this.h,\n      z: this.z\n    });\n\n    if (sign != null) {\n      const c = this._scale(curve, invert);\n\n      if (c.redIsOdd() !== sign) c.redINeg();\n    }\n\n    if (!this.g.isInfinity()) curve.g = curve.pointFromEdwards(this.g);\n\n    for (let i = 0; i < this.h; i++) curve.torsion[i] = curve.pointFromEdwards(this.torsion[i]);\n\n    return curve;\n  }\n\n  toEdwards(a0, sign = null) {\n    const [a, d] = this._edwards(a0);\n\n    const curve = new EdwardsCurve({\n      red: this.red,\n      prime: this.prime,\n      p: this.p,\n      a: a,\n      d: d,\n      n: this.n,\n      h: this.h,\n      z: this.z\n    });\n\n    if (sign != null) {\n      const c = curve._scale(this);\n\n      if (c.redIsOdd() !== sign) c.redINeg();\n    }\n\n    if (!this.g.isInfinity()) {\n      curve.g = curve.pointFromEdwards(this.g);\n      curve.g.normalize();\n    }\n\n    if (curve.isComplete()) {\n      for (let i = 0; i < this.h; i++) {\n        curve.torsion[i] = curve.pointFromEdwards(this.torsion[i]);\n        curve.torsion[i].normalize();\n      }\n    }\n\n    return curve;\n  }\n\n  pointFromJSON(json) {\n    return EdwardsPoint.fromJSON(this, json);\n  }\n\n  toJSON(pre) {\n    const json = super.toJSON(pre);\n    json.a = this.a.fromRed().toJSON();\n    json.d = this.d.fromRed().toJSON();\n    if (!this.s.isZero()) json.s = this.s.fromRed().toJSON();\n    return json;\n  }\n\n}\n/**\n * EdwardsPoint\n */\n\n\nclass EdwardsPoint extends Point {\n  constructor(curve, x, y, z, t) {\n    assert(curve instanceof EdwardsCurve);\n    super(curve, types.EXTENDED);\n    this.x = this.curve.zero;\n    this.y = this.curve.one;\n    this.z = this.curve.one;\n    this.t = this.curve.zero;\n    this.zOne = 1;\n    if (x != null) this._init(x, y, z, t);\n  }\n\n  _init(x, y, z, t) {\n    assert(x instanceof BN);\n    assert(y instanceof BN);\n    assert(z == null || z instanceof BN);\n    assert(t == null || t instanceof BN);\n    this.x = x;\n    this.y = y;\n    this.z = z || this.curve.one;\n    this.t = t || null;\n    if (!this.x.red) this.x = this.x.toRed(this.curve.red);\n    if (!this.y.red) this.y = this.y.toRed(this.curve.red);\n    if (!this.z.red) this.z = this.z.toRed(this.curve.red);\n    if (this.t && !this.t.red) this.t = this.t.toRed(this.curve.red);\n    this.zOne = this.z.eq(this.curve.one) | 0;\n\n    this._check();\n\n    if (!this.t) {\n      this.t = this.x.redMul(this.y);\n      if (!this.zOne) this.t = this.t.redDiv(this.z);\n    }\n  }\n\n  _check() {\n    // In order to achieve complete\n    // addition formulas, `a` must\n    // be a square (always the case\n    // for a=1), and `d` must be a\n    // non-square.\n    //\n    // If this is not the case, the\n    // addition formulas may have\n    // exceptional cases where Z3=0.\n    //\n    // In particular, this can occur\n    // when: Q*h = -P*h and Q != -P.\n    //\n    // This is assuming 4-torsion is\n    // involved (the 4-torsion point\n    // is _not_ representable when\n    // `d` is square).\n    if (this.z.isZero()) throw new Error('Invalid point.');\n  }\n\n  clone() {\n    return this.curve.point(this.x.clone(), this.y.clone(), this.z.clone(), this.t.clone());\n  }\n\n  swap(point, flag) {\n    assert(point instanceof EdwardsPoint);\n    const cond = (flag >> 31 | -flag >> 31) & 1;\n    const zOne1 = this.zOne;\n    const zOne2 = point.zOne;\n    this.x.cswap(point.x, flag);\n    this.y.cswap(point.y, flag);\n    this.z.cswap(point.z, flag);\n    this.t.cswap(point.t, flag);\n    this.zOne = zOne1 & (cond ^ 1) | zOne2 & cond;\n    point.zOne = zOne2 & (cond ^ 1) | zOne1 & cond;\n    return this;\n  }\n\n  normalize() {\n    // https://hyperelliptic.org/EFD/g1p/auto-edwards-projective.html#scaling-z\n    // 1I + 2M (+ 1M if extended)\n    // Z1 = 1\n    if (this.zOne) return this; // A = 1 / Z1\n\n    const a = this.z.redInvert(); // X3 = X1 * A\n\n    this.x = this.x.redMul(a); // Y3 = Y1 * A\n\n    this.y = this.y.redMul(a); // T3 = T1 * A\n\n    this.t = this.t.redMul(a); // Z3 = 1\n\n    this.z = this.curve.one;\n    this.zOne = 1;\n    return this;\n  }\n\n  scale(a) {\n    assert(a instanceof BN); // X3 = X1 * A\n\n    const nx = this.x.redMul(a); // Y3 = Y1 * A\n\n    const ny = this.y.redMul(a); // Z3 = Z1 * A\n\n    const nz = this.z.redMul(a); // T3 = T1 * A\n\n    const nt = this.t.redMul(a);\n    return this.curve.point(nx, ny, nz, nt);\n  }\n\n  neg() {\n    // -(X1, Y1, Z1, T1) = (-X1, Y1, Z1, -T1)\n    const nx = this.x.redNeg();\n    const ny = this.y;\n    const nz = this.z;\n    const nt = this.t.redNeg();\n    return this.curve.point(nx, ny, nz, nt);\n  }\n\n  add(p) {\n    assert(p instanceof EdwardsPoint); // P = O\n\n    if (this.isInfinity()) return p; // Q = O\n\n    if (p.isInfinity()) return this; // Z1 = 1\n\n    if (this.zOne) return p._add(this, 0);\n    return this._add(p, 0);\n  }\n\n  _add(p, flag) {\n    // a = -1\n    if (this.curve.mOneA) return this._addM1(p, flag);\n    return this._addA(p, flag);\n  }\n\n  _addM1(p, flag) {\n    // Assumes a = -1.\n    //\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-3\n    // 8M + 8A + 1*k + 1*2\n    //\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-madd-2008-hwcd-3\n    // 7M + 8A + 1*k + 1*2\n    const zOne = p.zOne & (flag ^ 1); // A = (Y1 - X1) * (Y2 - X2)\n\n    const a = this.y.redSub(this.x).redMul(p.y.redSub(p.x)); // B = (Y1 + X1) * (Y2 + X2)\n\n    const b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x)); // C = T1 * k * T2\n\n    const c = this.t.redMul(this.curve.k).redMul(p.t); // D = Z1 * 2 * Z2\n\n    const d = zOne ? this.z.redAdd(this.z) : this.z.redMul(p.z).redIMuln(2); // E = B - A\n\n    const e = b.redSub(a); // F = D - C\n\n    const f = d.redSub(c); // G = D + C\n\n    const g = d.redIAdd(c); // H = B + A\n\n    const h = b.redIAdd(a); // X3 = E * F\n\n    const nx = e.redMul(f); // Y3 = G * H\n\n    const ny = g.redMul(h); // T3 = E * H\n\n    const nt = e.redMul(h); // Z3 = F * G\n\n    const nz = f.redMul(g);\n    return this.curve.point(nx, ny, nz, nt);\n  }\n\n  _addA(p, flag) {\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n    // 9M + 7A + 1*a + 1*d\n    //\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-madd-2008-hwcd\n    // 8M + 7A + 1*a + 1*d\n    const zOne = p.zOne & (flag ^ 1); // A = X1 * X2\n\n    const a = this.x.redMul(p.x); // B = Y1 * Y2\n\n    const b = this.y.redMul(p.y); // C = T1 * d * T2\n\n    const c = this.curve._mulD(this.t).redMul(p.t); // D = Z1 * Z2\n\n\n    const d = zOne ? this.z.clone() : this.z.redMul(p.z); // + XYXY = (X1 + Y1) * (X2 + Y2)\n\n    const xyxy = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)); // E = (X1 + Y1) * (X2 + Y2) - A - B\n\n    const e = xyxy.redISub(a).redISub(b); // F = D - C\n\n    const f = d.redSub(c); // G = D + C\n\n    const g = d.redIAdd(c); // H = B - a * A\n\n    const h = b.redISub(this.curve._mulA(a)); // X3 = E * F\n\n    const nx = e.redMul(f); // Y3 = G * H\n\n    const ny = g.redMul(h); // T3 = E * H\n\n    const nt = e.redMul(h); // Z3 = F * G\n\n    const nz = f.redMul(g);\n    return this.curve.point(nx, ny, nz, nt);\n  }\n\n  dbl() {\n    // P = O\n    if (this.isInfinity()) return this;\n    return this._dbl(0);\n  }\n\n  _dbl(flag) {\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n    // 4M + 4S + 6A + 1*a + 1*2\n    //\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-mdbl-2008-hwcd\n    // 3M + 4S + 7A + 1*a + 1*2\n    const zOne = this.zOne & (flag ^ 1); // A = X1^2\n\n    const a = this.x.redSqr(); // B = Y1^2\n\n    const b = this.y.redSqr(); // C = 2 * Z1^2\n\n    const c = zOne ? this.curve.two : this.z.redSqr().redIMuln(2); // D = a * A\n\n    const d = this.curve._mulA(a); // E = (X1 + Y1)^2 - A - B\n\n\n    const e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b); // G = D + B\n\n    const g = d.redAdd(b); // F = G - C\n\n    const f = g.redSub(c); // H = D - B\n\n    const h = d.redISub(b); // X3 = E * F\n\n    const nx = e.redMul(f); // Y3 = G * H\n\n    const ny = g.redMul(h); // T3 = E * H\n\n    const nt = e.redMul(h); // Z3 = F * G\n\n    const nz = f.redMul(g);\n    return this.curve.point(nx, ny, nz, nt);\n  }\n\n  uadd(p) {\n    assert(p instanceof EdwardsPoint);\n    return this._add(p, 1);\n  }\n\n  udbl() {\n    return this._dbl(1);\n  }\n\n  getX() {\n    this.normalize();\n    return this.x.fromRed();\n  }\n\n  getY() {\n    this.normalize();\n    return this.y.fromRed();\n  }\n\n  eq(p) {\n    assert(p instanceof EdwardsPoint);\n    assert(!this.z.isZero());\n    assert(!p.z.isZero()); // P = Q\n\n    if (this === p) return true; // Z1 = Z2\n\n    if (this.z.eq(p.z)) {\n      return this.x.eq(p.x) && this.y.eq(p.y);\n    } // X1 * Z2 == X2 * Z1\n\n\n    const x1 = this.x.redMul(p.z);\n    const x2 = p.x.redMul(this.z);\n    if (!x1.eq(x2)) return false;\n    const y1 = this.y.redMul(p.z);\n    const y2 = p.y.redMul(this.z);\n    return y1.eq(y2);\n  }\n\n  isInfinity() {\n    assert(!this.z.isZero()); // X1 = 0\n\n    if (!this.x.isZero()) return false; // Y1 = Z1\n\n    return this.y.eq(this.z);\n  }\n\n  isOdd() {\n    this.normalize();\n    return this.x.redIsOdd();\n  }\n\n  isEven() {\n    this.normalize();\n    return this.x.redIsEven();\n  }\n\n  toP() {\n    return this.normalize();\n  }\n\n  toJ() {\n    return this;\n  }\n\n  encode() {\n    // [RFC8032] Section 5.1.2.\n    const y = this.getY(); // Note: `x` normalized from `getY()` call.\n\n    y.setn(this.curve.signBit, this.x.redIsOdd());\n    return this.curve.encodeAdjusted(y);\n  }\n\n  static decode(curve, bytes) {\n    // [RFC8032] Section 5.1.3.\n    assert(curve instanceof EdwardsCurve);\n    const y = curve.decodeAdjusted(bytes);\n    const sign = y.testn(curve.signBit) !== 0;\n    y.setn(curve.signBit, 0);\n    if (y.cmp(curve.p) >= 0) throw new Error('Invalid point.');\n    return curve.pointFromY(y, sign);\n  }\n\n  toJSON(pre) {\n    if (this.isInfinity()) return [];\n    const x = this.getX().toJSON();\n    const y = this.getY().toJSON();\n    if (pre === true && this.pre) return [x, y, this.pre.toJSON()];\n    return [x, y];\n  }\n\n  static fromJSON(curve, json) {\n    assert(curve instanceof EdwardsCurve);\n    assert(Array.isArray(json));\n    assert(json.length === 0 || json.length === 2 || json.length === 3);\n    if (json.length === 0) return curve.point();\n    const x = BN.fromJSON(json[0]);\n    const y = BN.fromJSON(json[1]);\n    const point = curve.point(x, y);\n    if (json.length > 2 && json[2] != null) point.pre = Precomp.fromJSON(point, json[2]);\n    return point;\n  }\n\n  [custom]() {\n    if (this.isInfinity()) return '<EdwardsPoint: Infinity>';\n    return '<EdwardsPoint:' + ' x=' + this.x.fromRed().toString(16, 2) + ' y=' + this.y.fromRed().toString(16, 2) + ' z=' + this.z.fromRed().toString(16, 2) + '>';\n  }\n\n}\n/**\n * Mask\n */\n\n\nclass Mask {\n  constructor(curve) {\n    assert(curve instanceof Curve); // Get prime bit length.\n\n    let bits = curve.fieldBits;\n    let top = bits & 7;\n    if (top === 0) top = 8; // Adjust for low order.\n\n    if (curve.scalarSize < curve.fieldSize) {\n      bits = curve.scalarSize * 8;\n      top = 8;\n    } // Our curve.\n\n\n    this.curve = curve; // Cofactor mask (p25519=-8, p448=-4).\n\n    this.h = -curve.h.word(0) & 0xff; // Prime top byte (p25519=0x7f, p448=0xff).\n\n    this.n = (1 << top) - 1; // High bit (p25519=0x40, p448=0x80).\n\n    this.b = 1 << top - 1; // AND mask (p25519=0x7fff...f8, p448=0xffff...fc).\n\n    this.and = BN.mask(bits).iuxorn(this.h ^ 0xff); // OR mask (p25519=0x4000..., p448=0x8000...).\n\n    this.or = BN.shift(1, bits - 1);\n  }\n\n  reduce(k) {\n    assert(k instanceof BN);\n    assert(!k.red);\n    k.iuand(this.and);\n    k.iuor(this.or);\n    return k;\n  }\n\n  clamp(bytes) {\n    assert(Buffer.isBuffer(bytes));\n    assert(bytes.length === this.curve.scalarSize);\n    let i = 0;\n    let j = this.curve.scalarSize - 1;\n    if (this.curve.endian === 'be') [i, j] = [j, i]; // Adjust for high order.\n\n    if (this.curve.scalarSize > this.curve.fieldSize) {\n      if (this.curve.endian === 'be') bytes[j++] = 0;else bytes[j--] = 0;\n    } // Ensure a multiple of the cofactor.\n\n\n    bytes[i] &= this.h; // Clamp to the prime.\n\n    bytes[j] &= this.n; // Set the high bit.\n\n    bytes[j] |= this.b;\n    return bytes;\n  }\n\n  splitHash(bytes) {\n    assert(Buffer.isBuffer(bytes));\n    assert(bytes.length === this.curve.adjustedSize * 2);\n    let off = 0;\n    if (this.curve.endian === 'be') off = this.curve.adjustedSize - this.curve.scalarSize;\n    const scalar = bytes.slice(off, off + this.curve.scalarSize);\n    const prefix = bytes.slice(this.curve.adjustedSize);\n    this.clamp(scalar);\n    return [scalar, prefix];\n  }\n\n}\n/**\n * Precomp\n */\n\n\nclass Precomp {\n  constructor() {\n    this.naf = null;\n    this.windows = null;\n    this.doubles = null;\n    this.blinding = null;\n    this.beta = null;\n  }\n\n  map(func) {\n    assert(typeof func === 'function');\n    const out = new this.constructor();\n    if (this.naf) out.naf = this.naf.map(func);\n    if (this.doubles) out.doubles = this.doubles.map(func);\n    return out;\n  }\n\n  toJSON() {\n    return {\n      naf: this.naf ? this.naf.toJSON() : null,\n      windows: this.windows ? this.windows.toJSON() : null,\n      doubles: this.doubles ? this.doubles.toJSON() : null,\n      blinding: this.blinding ? this.blinding.toJSON() : undefined\n    };\n  }\n\n  fromJSON(point, json) {\n    assert(point instanceof Point);\n    assert(json && typeof json === 'object');\n    if (json.naf != null) this.naf = NAF.fromJSON(point, json.naf);\n    if (json.windows != null) this.windows = Windows.fromJSON(point, json.windows);\n    if (json.doubles != null) this.doubles = Doubles.fromJSON(point, json.doubles);\n    if (json.blinding != null) this.blinding = Blinding.fromJSON(point, json.blinding);\n    return this;\n  }\n\n  static fromJSON(point, json) {\n    return new this().fromJSON(point, json);\n  }\n\n}\n/**\n * NAF\n */\n\n\nclass NAF {\n  constructor(width, points) {\n    this.width = width;\n    this.points = points;\n  }\n\n  map(func) {\n    assert(typeof func === 'function');\n    const {\n      width\n    } = this;\n    const points = [];\n\n    for (const point of this.points) points.push(func(point));\n\n    return new this.constructor(width, points);\n  }\n\n  toJSON() {\n    return {\n      width: this.width,\n      points: this.points.slice(1).map(point => {\n        return point.toJSON();\n      })\n    };\n  }\n\n  static fromJSON(point, json) {\n    assert(point instanceof Point);\n    assert(json && typeof json === 'object');\n    assert(json.width >>> 0 === json.width);\n    assert(Array.isArray(json.points));\n    const {\n      curve\n    } = point;\n    const {\n      width\n    } = json;\n    const points = [point];\n\n    for (const item of json.points) points.push(curve.pointFromJSON(item));\n\n    return new this(width, points);\n  }\n\n}\n/**\n * Windows\n */\n\n\nclass Windows {\n  constructor(width, bits, points) {\n    this.width = width;\n    this.bits = bits;\n    this.points = points;\n  }\n\n  toJSON() {\n    return {\n      width: this.width,\n      bits: this.bits,\n      points: this.points.slice(1).map(point => {\n        return point.toJSON();\n      })\n    };\n  }\n\n  static fromJSON(point, json) {\n    assert(point instanceof Point);\n    assert(json && typeof json === 'object');\n    assert(json.width >>> 0 === json.width);\n    assert(json.bits >>> 0 === json.bits);\n    assert(Array.isArray(json.points));\n    const {\n      curve\n    } = point;\n    const {\n      width,\n      bits\n    } = json;\n    const points = [point];\n\n    for (const item of json.points) points.push(curve.pointFromJSON(item));\n\n    return new this(width, bits, points);\n  }\n\n}\n/**\n * Doubles\n */\n\n\nclass Doubles {\n  constructor(step, points) {\n    this.step = step;\n    this.points = points;\n  }\n\n  map(func) {\n    assert(typeof func === 'function');\n    const {\n      step\n    } = this;\n    const points = [];\n\n    for (const point of this.points) points.push(func(point));\n\n    return new this.constructor(step, points);\n  }\n\n  toJSON() {\n    return {\n      step: this.step,\n      points: this.points.slice(1).map(point => {\n        return point.toJSON();\n      })\n    };\n  }\n\n  static fromJSON(point, json) {\n    assert(point instanceof Point);\n    assert(json && typeof json === 'object');\n    assert(json.step >>> 0 === json.step);\n    assert(Array.isArray(json.points));\n    const {\n      curve\n    } = point;\n    const {\n      step\n    } = json;\n    const points = [point];\n\n    for (const item of json.points) points.push(curve.pointFromJSON(item));\n\n    return new this(step, points);\n  }\n\n}\n/**\n * Blinding\n */\n\n\nclass Blinding {\n  constructor(blind, unblind) {\n    this.blind = blind;\n    this.unblind = unblind;\n  }\n\n  toJSON() {\n    return {\n      blind: this.blind.toJSON(),\n      unblind: this.unblind.toJSON()\n    };\n  }\n\n  static fromJSON(point, json) {\n    assert(point instanceof Point);\n    assert(json && typeof json === 'object');\n    const {\n      curve\n    } = point;\n    const blind = BN.fromJSON(json.blind);\n    const unblind = curve.pointFromJSON(json.unblind);\n    return new this(blind, unblind);\n  }\n\n}\n/**\n * Endo\n */\n\n\nclass Endo {\n  constructor(beta, lambda, basis, pre) {\n    this.beta = beta;\n    this.lambda = lambda;\n    this.basis = basis;\n    this.pre = pre;\n  }\n\n  toJSON() {\n    return {\n      beta: this.beta.fromRed().toJSON(),\n      lambda: this.lambda.toJSON(),\n      basis: [this.basis[0].toJSON(), this.basis[1].toJSON()],\n      pre: [this.pre[0].toJSON(), this.pre[1].toJSON()]\n    };\n  }\n\n  static fromJSON(curve, json) {\n    assert(curve instanceof Curve);\n    assert(json && typeof json === 'object');\n    assert(Array.isArray(json.basis));\n    assert(Array.isArray(json.pre));\n    assert(json.basis.length === 2);\n    assert(json.pre.length === 2);\n    const beta = BN.fromJSON(json.beta).toRed(curve.red);\n    const lambda = BN.fromJSON(json.lambda);\n    const basis = [Vector.fromJSON(json.basis[0]), Vector.fromJSON(json.basis[1])];\n    const pre = [BN.fromJSON(json.pre[0]), BN.fromJSON(json.pre[1])];\n    return new this(beta, lambda, basis, pre);\n  }\n\n}\n/**\n * Vector\n */\n\n\nclass Vector {\n  constructor(a, b) {\n    this.a = a;\n    this.b = b;\n  }\n\n  toJSON() {\n    return {\n      a: this.a.toJSON(),\n      b: this.b.toJSON()\n    };\n  }\n\n  static fromJSON(json) {\n    assert(json && typeof json === 'object');\n    const a = BN.fromJSON(json.a);\n    const b = BN.fromJSON(json.b);\n    return new this(a, b);\n  }\n\n}\n/**\n * P192\n * https://tinyurl.com/fips-186-2 (page 29)\n * https://tinyurl.com/fips-186-3 (page 88)\n */\n\n\nclass P192 extends ShortCurve {\n  constructor(pre) {\n    super({\n      id: 'P192',\n      ossl: 'prime192v1',\n      type: 'short',\n      endian: 'be',\n      hash: 'SHA256',\n      prime: 'p192',\n      // 2^192 - 2^64 - 1 (= 3 mod 4)\n      p: ['ffffffff ffffffff ffffffff fffffffe', 'ffffffff ffffffff'],\n      // -3 mod p\n      a: ['ffffffff ffffffff ffffffff fffffffe', 'ffffffff fffffffc'],\n      b: ['64210519 e59c80e7 0fa7e9ab 72243049', 'feb8deec c146b9b1'],\n      n: ['ffffffff ffffffff ffffffff 99def836', '146bc9b1 b4d22831'],\n      h: '1',\n      // Icart\n      z: '-5',\n      g: [['188da80e b03090f6 7cbf20eb 43a18800', 'f4ff0afd 82ff1012'], ['07192b95 ffc8da78 631011ed 6b24cdd5', '73f977a1 1e794811'], pre]\n    });\n  }\n\n}\n/**\n * P224\n * https://tinyurl.com/fips-186-2 (page 30)\n * https://tinyurl.com/fips-186-3 (page 88)\n */\n\n\nclass P224 extends ShortCurve {\n  constructor(pre) {\n    super({\n      id: 'P224',\n      ossl: 'secp224r1',\n      type: 'short',\n      endian: 'be',\n      hash: 'SHA256',\n      prime: 'p224',\n      // 2^224 - 2^96 + 1 (no congruence)\n      p: ['ffffffff ffffffff ffffffff ffffffff', '00000000 00000000 00000001'],\n      // -3 mod p\n      a: ['ffffffff ffffffff ffffffff fffffffe', 'ffffffff ffffffff fffffffe'],\n      b: ['b4050a85 0c04b3ab f5413256 5044b0b7', 'd7bfd8ba 270b3943 2355ffb4'],\n      n: ['ffffffff ffffffff ffffffff ffff16a2', 'e0b8f03e 13dd2945 5c5c2a3d'],\n      h: '1',\n      // SSWU\n      z: '1f',\n      g: [['b70e0cbd 6bb4bf7f 321390b9 4a03c1d3', '56c21122 343280d6 115c1d21'], ['bd376388 b5f723fb 4c22dfe6 cd4375a0', '5a074764 44d58199 85007e34'], pre]\n    });\n  }\n\n}\n/**\n * P256\n * https://tinyurl.com/fips-186-2 (page 31)\n * https://tinyurl.com/fips-186-3 (page 89)\n */\n\n\nclass P256 extends ShortCurve {\n  constructor(pre) {\n    super({\n      id: 'P256',\n      ossl: 'prime256v1',\n      type: 'short',\n      endian: 'be',\n      hash: 'SHA256',\n      prime: null,\n      // 2^256 - 2^224 + 2^192 + 2^96 - 1 (= 3 mod 4)\n      p: ['ffffffff 00000001 00000000 00000000', '00000000 ffffffff ffffffff ffffffff'],\n      // -3 mod p\n      a: ['ffffffff 00000001 00000000 00000000', '00000000 ffffffff ffffffff fffffffc'],\n      b: ['5ac635d8 aa3a93e7 b3ebbd55 769886bc', '651d06b0 cc53b0f6 3bce3c3e 27d2604b'],\n      n: ['ffffffff 00000000 ffffffff ffffffff', 'bce6faad a7179e84 f3b9cac2 fc632551'],\n      h: '1',\n      // SSWU\n      z: '-a',\n      g: [['6b17d1f2 e12c4247 f8bce6e5 63a440f2', '77037d81 2deb33a0 f4a13945 d898c296'], ['4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16', '2bce3357 6b315ece cbb64068 37bf51f5'], pre]\n    });\n  }\n\n}\n/**\n * P384\n * https://tinyurl.com/fips-186-2 (page 32)\n * https://tinyurl.com/fips-186-3 (page 89)\n */\n\n\nclass P384 extends ShortCurve {\n  constructor(pre) {\n    super({\n      id: 'P384',\n      ossl: 'secp384r1',\n      type: 'short',\n      endian: 'be',\n      hash: 'SHA384',\n      prime: null,\n      // 2^384 - 2^128 - 2^96 + 2^32 - 1 (= 3 mod 4)\n      p: ['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff fffffffe', 'ffffffff 00000000 00000000 ffffffff'],\n      // -3 mod p\n      a: ['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff fffffffe', 'ffffffff 00000000 00000000 fffffffc'],\n      b: ['b3312fa7 e23ee7e4 988e056b e3f82d19', '181d9c6e fe814112 0314088f 5013875a', 'c656398d 8a2ed19d 2a85c8ed d3ec2aef'],\n      n: ['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff c7634d81 f4372ddf', '581a0db2 48b0a77a ecec196a ccc52973'],\n      h: '1',\n      // Icart\n      z: '-c',\n      g: [['aa87ca22 be8b0537 8eb1c71e f320ad74', '6e1d3b62 8ba79b98 59f741e0 82542a38', '5502f25d bf55296c 3a545e38 72760ab7'], ['3617de4a 96262c6f 5d9e98bf 9292dc29', 'f8f41dbd 289a147c e9da3113 b5f0b8c0', '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f'], pre]\n    });\n  }\n\n}\n/**\n * P521\n * https://tinyurl.com/fips-186-2 (page 33)\n * https://tinyurl.com/fips-186-3 (page 90)\n */\n\n\nclass P521 extends ShortCurve {\n  constructor(pre) {\n    super({\n      id: 'P521',\n      ossl: 'secp521r1',\n      type: 'short',\n      endian: 'be',\n      hash: 'SHA512',\n      prime: 'p521',\n      // 2^521 - 1 (= 3 mod 4)\n      p: ['000001ff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff'],\n      // -3 mod p\n      a: ['000001ff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'fffffffc'],\n      b: ['00000051 953eb961 8e1c9a1f 929a21a0', 'b68540ee a2da725b 99b315f3 b8b48991', '8ef109e1 56193951 ec7e937b 1652c0bd', '3bb1bf07 3573df88 3d2c34f1 ef451fd4', '6b503f00'],\n      n: ['000001ff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'fffffffa 51868783 bf2f966b 7fcc0148', 'f709a5d0 3bb5c9b8 899c47ae bb6fb71e', '91386409'],\n      h: '1',\n      // SSWU\n      z: '-4',\n      g: [['000000c6 858e06b7 0404e9cd 9e3ecb66', '2395b442 9c648139 053fb521 f828af60', '6b4d3dba a14b5e77 efe75928 fe1dc127', 'a2ffa8de 3348b3c1 856a429b f97e7e31', 'c2e5bd66'], ['00000118 39296a78 9a3bc004 5c8a5fb4', '2c7d1bd9 98f54449 579b4468 17afbd17', '273e662c 97ee7299 5ef42640 c550b901', '3fad0761 353c7086 a272c240 88be9476', '9fd16650'], pre]\n    });\n  }\n\n}\n/**\n * SECP256K1\n * https://www.secg.org/SEC2-Ver-1.0.pdf (page 15, section 2.7.1)\n * https://www.secg.org/sec2-v2.pdf (page 9, section 2.4.1)\n */\n\n\nclass SECP256K1 extends ShortCurve {\n  constructor(pre) {\n    super({\n      id: 'SECP256K1',\n      ossl: 'secp256k1',\n      type: 'short',\n      endian: 'be',\n      hash: 'SHA256',\n      prime: 'k256',\n      // 2^256 - 2^32 - 977 (= 3 mod 4)\n      p: ['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff fffffffe fffffc2f'],\n      a: '0',\n      b: '7',\n      n: ['ffffffff ffffffff ffffffff fffffffe', 'baaedce6 af48a03b bfd25e8c d0364141'],\n      h: '1',\n      // SVDW\n      z: '1',\n      // sqrt(-3)\n      c: ['0a2d2ba9 3507f1df 233770c2 a797962c', 'c61f6d15 da14ecd4 7d8d27ae 1cd5f852'],\n      g: [['79be667e f9dcbbac 55a06295 ce870b07', '029bfcdb 2dce28d9 59f2815b 16f81798'], ['483ada77 26a3c465 5da4fbfc 0e1108a8', 'fd17b448 a6855419 9c47d08f fb10d4b8'], pre],\n      // Precomputed endomorphism.\n      endo: {\n        beta: ['7ae96a2b 657c0710 6e64479e ac3434e9', '9cf04975 12f58995 c1396c28 719501ee'],\n        lambda: ['5363ad4c c05c30e0 a5261c02 8812645a', '122e22ea 20816678 df02967c 1b23bd72'],\n        basis: [{\n          a: '3086d221a7d46bcde86c90e49284eb15',\n          b: '-e4437ed6010e88286f547fa90abfe4c3'\n        }, {\n          a: '114ca50f7a8e2f3f657c1108d9d44cfd8',\n          b: '3086d221a7d46bcde86c90e49284eb15'\n        }],\n        pre: ['3086d221a7d46bcde86c90e49284eb153dab', '-e4437ed6010e88286f547fa90abfe4c42212']\n      }\n    });\n  }\n\n}\n/**\n * BRAINPOOLP256\n * https://tools.ietf.org/html/rfc5639#section-3.4\n */\n\n\nclass BRAINPOOLP256 extends ShortCurve {\n  constructor(pre) {\n    super({\n      id: 'BRAINPOOLP256',\n      ossl: 'brainpoolP256r1',\n      type: 'short',\n      endian: 'be',\n      hash: 'SHA256',\n      prime: null,\n      // (= 3 mod 4)\n      p: ['a9fb57db a1eea9bc 3e660a90 9d838d72', '6e3bf623 d5262028 2013481d 1f6e5377'],\n      a: ['7d5a0975 fc2c3057 eef67530 417affe7', 'fb8055c1 26dc5c6c e94a4b44 f330b5d9'],\n      b: ['26dc5c6c e94a4b44 f330b5d9 bbd77cbf', '95841629 5cf7e1ce 6bccdc18 ff8c07b6'],\n      n: ['a9fb57db a1eea9bc 3e660a90 9d838d71', '8c397aa3 b561a6f7 901e0e82 974856a7'],\n      h: '1',\n      // Icart\n      z: '-2',\n      g: [['8bd2aeb9 cb7e57cb 2c4b482f fc81b7af', 'b9de27e1 e3bd23c2 3a4453bd 9ace3262'], ['547ef835 c3dac4fd 97f8461a 14611dc9', 'c2774513 2ded8e54 5c1d54c7 2f046997'], pre]\n    });\n  }\n\n}\n/**\n * BRAINPOOLP384\n * https://tools.ietf.org/html/rfc5639#section-3.6\n */\n\n\nclass BRAINPOOLP384 extends ShortCurve {\n  constructor(pre) {\n    super({\n      id: 'BRAINPOOLP384',\n      ossl: 'brainpoolP384r1',\n      type: 'short',\n      endian: 'be',\n      hash: 'SHA384',\n      prime: null,\n      // (= 3 mod 4)\n      p: ['8cb91e82 a3386d28 0f5d6f7e 50e641df', '152f7109 ed5456b4 12b1da19 7fb71123', 'acd3a729 901d1a71 87470013 3107ec53'],\n      a: ['7bc382c6 3d8c150c 3c72080a ce05afa0', 'c2bea28e 4fb22787 139165ef ba91f90f', '8aa5814a 503ad4eb 04a8c7dd 22ce2826'],\n      b: ['04a8c7dd 22ce2826 8b39b554 16f0447c', '2fb77de1 07dcd2a6 2e880ea5 3eeb62d5', '7cb43902 95dbc994 3ab78696 fa504c11'],\n      n: ['8cb91e82 a3386d28 0f5d6f7e 50e641df', '152f7109 ed5456b3 1f166e6c ac0425a7', 'cf3ab6af 6b7fc310 3b883202 e9046565'],\n      h: '1',\n      // SSWU\n      z: '-5',\n      g: [['1d1c64f0 68cf45ff a2a63a81 b7c13f6b', '8847a3e7 7ef14fe3 db7fcafe 0cbd10e8', 'e826e034 36d646aa ef87b2e2 47d4af1e'], ['8abe1d75 20f9c2a4 5cb1eb8e 95cfd552', '62b70b29 feec5864 e19c054f f9912928', '0e464621 77918111 42820341 263c5315'], pre]\n    });\n  }\n\n}\n/**\n * BRAINPOOLP512\n * https://tools.ietf.org/html/rfc5639#section-3.7\n */\n\n\nclass BRAINPOOLP512 extends ShortCurve {\n  constructor(pre) {\n    super({\n      id: 'BRAINPOOLP512',\n      ossl: 'brainpoolP512r1',\n      type: 'short',\n      endian: 'be',\n      hash: 'SHA512',\n      prime: null,\n      // (= 3 mod 4)\n      p: ['aadd9db8 dbe9c48b 3fd4e6ae 33c9fc07', 'cb308db3 b3c9d20e d6639cca 70330871', '7d4d9b00 9bc66842 aecda12a e6a380e6', '2881ff2f 2d82c685 28aa6056 583a48f3'],\n      a: ['7830a331 8b603b89 e2327145 ac234cc5', '94cbdd8d 3df91610 a83441ca ea9863bc', '2ded5d5a a8253aa1 0a2ef1c9 8b9ac8b5', '7f1117a7 2bf2c7b9 e7c1ac4d 77fc94ca'],\n      b: ['3df91610 a83441ca ea9863bc 2ded5d5a', 'a8253aa1 0a2ef1c9 8b9ac8b5 7f1117a7', '2bf2c7b9 e7c1ac4d 77fc94ca dc083e67', '984050b7 5ebae5dd 2809bd63 8016f723'],\n      n: ['aadd9db8 dbe9c48b 3fd4e6ae 33c9fc07', 'cb308db3 b3c9d20e d6639cca 70330870', '553e5c41 4ca92619 41866119 7fac1047', '1db1d381 085ddadd b5879682 9ca90069'],\n      h: '1',\n      // Icart\n      z: '7',\n      g: [['81aee4bd d82ed964 5a21322e 9c4c6a93', '85ed9f70 b5d916c1 b43b62ee f4d0098e', 'ff3b1f78 e2d0d48d 50d1687b 93b97d5f', '7c6d5047 406a5e68 8b352209 bcb9f822'], ['7dde385d 566332ec c0eabfa9 cf7822fd', 'f209f700 24a57b1a a000c55b 881f8111', 'b2dcde49 4a5f485e 5bca4bd8 8a2763ae', 'd1ca2b2f a8f05406 78cd1e0f 3ad80892'], pre]\n    });\n  }\n\n}\n/**\n * X25519\n * https://tools.ietf.org/html/rfc7748#section-4.1\n */\n\n\nclass X25519 extends MontCurve {\n  constructor() {\n    super({\n      id: 'X25519',\n      ossl: 'X25519',\n      type: 'mont',\n      endian: 'le',\n      hash: 'SHA512',\n      prime: 'p25519',\n      // 2^255 - 19 (= 5 mod 8)\n      p: ['7fffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff ffffffed'],\n      // 486662\n      a: '76d06',\n      b: '1',\n      n: ['10000000 00000000 00000000 00000000', '14def9de a2f79cd6 5812631a 5cf5d3ed'],\n      h: '8',\n      // Elligator 2\n      z: '2',\n      g: [['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000009'], // See: https://www.rfc-editor.org/errata/eid4730\n      ['5f51e65e 475f794b 1fe122d3 88b72eb3', '6dc2b281 92839e4d d6163a5d 81312c14']],\n      torsion: [// (1)\n      [], // (2)\n      ['0000000000000000000000000000000000000000000000000000000000000000', '0000000000000000000000000000000000000000000000000000000000000000'], // (4)\n      ['0000000000000000000000000000000000000000000000000000000000000001', '141b0b6806563d503de05885280b59109ca5ee38d7b56c9c165db7106377bbd8'], // (4)\n      ['0000000000000000000000000000000000000000000000000000000000000001', '6be4f497f9a9c2afc21fa77ad7f4a6ef635a11c7284a9363e9a248ef9c884415'], // (8)\n      ['00b8495f16056286fdb1329ceb8d09da6ac49ff1fae35616aeb8413b7c7aebe0', '46ce3ed6a9617c5ad6b7d3eb19d74ba86cc403d6127fe4b29778eb7c6daf84d3'], // (8)\n      ['00b8495f16056286fdb1329ceb8d09da6ac49ff1fae35616aeb8413b7c7aebe0', '3931c129569e83a529482c14e628b457933bfc29ed801b4d6887148392507b1a'], // (8)\n      ['57119fd0dd4e22d8868e1c58c45c44045bef839c55b1d0b1248c50a3bc959c5f', '173a6c76c2ba719bce3935ffba04afeadf5bbcb971559722f0efc7bdfb7f9a36'], // (8)\n      ['57119fd0dd4e22d8868e1c58c45c44045bef839c55b1d0b1248c50a3bc959c5f', '68c593893d458e6431c6ca0045fb501520a443468eaa68dd0f103842048065b7']]\n    });\n  }\n\n}\n/**\n * X448\n * https://tools.ietf.org/html/rfc7748#section-4.2\n */\n\n\nclass X448 extends MontCurve {\n  constructor() {\n    super({\n      id: 'X448',\n      ossl: 'X448',\n      type: 'mont',\n      endian: 'le',\n      hash: 'SHAKE256',\n      prime: 'p448',\n      // 2^448 - 2^224 - 1 (= 3 mod 4)\n      p: ['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff fffffffe ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff'],\n      // 156326\n      a: '262a6',\n      b: '1',\n      n: ['3fffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff 7cca23e9', 'c44edb49 aed63690 216cc272 8dc58f55', '2378c292 ab5844f3'],\n      h: '4',\n      // Elligator 2\n      z: '-1',\n      g: [['00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000000 00000000 00000000', '00000000 00000005'], ['7d235d12 95f5b1f6 6c98ab6e 58326fce', 'cbae5d34 f55545d0 60f75dc2 8df3f6ed', 'b8027e23 46430d21 1312c4b1 50677af7', '6fd7223d 457b5b1a']],\n      torsion: [// (1)\n      [], // (2)\n      [['00000000000000000000000000000000000000000000000000000000', '00000000000000000000000000000000000000000000000000000000'], ['00000000000000000000000000000000000000000000000000000000', '00000000000000000000000000000000000000000000000000000000']], // (4)\n      [['fffffffffffffffffffffffffffffffffffffffffffffffffffffffe', 'fffffffffffffffffffffffffffffffffffffffffffffffffffffffe'], ['ba4d3a0829b6112f8812e51ba0bb2abebc1cb08eb48e556936ba50fd', 'd2e7d68af8cb32160522425b3f990812abbe635ad37a21e17551b193']], // (4)\n      [['fffffffffffffffffffffffffffffffffffffffffffffffffffffffe', 'fffffffffffffffffffffffffffffffffffffffffffffffffffffffe'], ['45b2c5f7d649eed077ed1ae45f44d54143e34f714b71aa96c945af01', '2d1829750734cde9faddbda4c066f7ed54419ca52c85de1e8aae4e6c']]]\n    });\n  }\n\n}\n/**\n * MONT448\n * Isomorphic to Ed448-Goldilocks.\n */\n\n\nclass MONT448 extends MontCurve {\n  constructor() {\n    super({\n      id: 'MONT448',\n      ossl: null,\n      type: 'mont',\n      endian: 'le',\n      hash: 'SHAKE256',\n      prime: 'p448',\n      // 2^448 - 2^224 - 1 (= 3 mod 4)\n      p: ['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff fffffffe ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff'],\n      // -78160 / -39082 mod p\n      a: ['b2cf97d2 d43459a9 31ed36b1 fc4e3cb5', '5d93f8d2 22746997 60ccffc6 49961ed6', 'c5b05fca c24864ed 6fb59697 931b78da', '84ddecd8 ca2b5cfb'],\n      b: '1',\n      n: ['3fffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff 7cca23e9', 'c44edb49 aed63690 216cc272 8dc58f55', '2378c292 ab5844f3'],\n      h: '4',\n      // Elligator 2\n      z: '-1',\n      g: [['ac0d24cc c6c75cb0 eb71f81e 7a6edf51', '48e88aee 009a2a24 e795687e c28e125a', '3e6730a6 0d46367b aa7fe99d 152128dc', '41321bc7 7817f059'], ['5a4437f6 80c0d0db 9b061276 d5d0ffcc', 'e786ff33 b6a53d30 98746425 82e66f09', '4433dae7 7244a6e2 6b11e905 7228f483', '556c41a5 913f55fe']],\n      torsion: [// (1)\n      [], // (2)\n      [['00000000000000000000000000000000000000000000000000000000', '00000000000000000000000000000000000000000000000000000000'], ['00000000000000000000000000000000000000000000000000000000', '00000000000000000000000000000000000000000000000000000000']], // (4)\n      [['fffffffffffffffffffffffffffffffffffffffffffffffffffffffe', 'fffffffffffffffffffffffffffffffffffffffffffffffffffffffe'], ['bec92fd06da2acf2b4e261e87cef0d3422e75c183c589857b71924e5', '73c2f9cee18da5f2466e2f393c2eedf0f105a60ab40c717d4f1e1fd7']], // (4)\n      [['fffffffffffffffffffffffffffffffffffffffffffffffffffffffe', 'fffffffffffffffffffffffffffffffffffffffffffffffffffffffe'], ['4136d02f925d530d4b1d9e178310f2cbdd18a3e7c3a767a848e6db19', '8c3d06311e725a0db991d0c6c3d1120f0efa59f54bf38e82b0e1e028']]]\n    });\n  }\n\n}\n/**\n * ED25519\n * https://tools.ietf.org/html/rfc8032#section-5.1\n */\n\n\nclass ED25519 extends EdwardsCurve {\n  constructor(pre) {\n    super({\n      id: 'ED25519',\n      ossl: 'ED25519',\n      type: 'edwards',\n      endian: 'le',\n      hash: 'SHA512',\n      prefix: 'SigEd25519 no Ed25519 collisions',\n      context: false,\n      prime: 'p25519',\n      // 2^255 - 19 (= 5 mod 8)\n      p: ['7fffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff ffffffed'],\n      a: '-1',\n      // -121665 / 121666 mod p\n      d: ['52036cee 2b6ffe73 8cc74079 7779e898', '00700a4d 4141d8ab 75eb4dca 135978a3'],\n      n: ['10000000 00000000 00000000 00000000', '14def9de a2f79cd6 5812631a 5cf5d3ed'],\n      h: '8',\n      // Elligator 2\n      z: '2',\n      g: [['216936d3 cd6e53fe c0a4e231 fdd6dc5c', '692cc760 9525a7b2 c9562d60 8f25d51a'], // 4/5\n      ['66666666 66666666 66666666 66666666', '66666666 66666666 66666666 66666658'], pre],\n      torsion: [// (0, 1) (1)\n      ['0000000000000000000000000000000000000000000000000000000000000000', '0000000000000000000000000000000000000000000000000000000000000001'], // (0, -1) (2)\n      ['0000000000000000000000000000000000000000000000000000000000000000', '7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec'], // (-sqrt(1 / a), 0) (4)\n      ['547cdb7fb03e20f4d4b2ff66c2042858d0bce7f952d01b873b11e4d8b5f15f3d', '0000000000000000000000000000000000000000000000000000000000000000'], // (sqrt(1 / a), 0) (4)\n      ['2b8324804fc1df0b2b4d00993dfbd7a72f431806ad2fe478c4ee1b274a0ea0b0', '0000000000000000000000000000000000000000000000000000000000000000'], // (-sqrt((1 / d) - sqrt(a^2 - a * d) / (a * d)), sqrt(a) * x) (8)\n      ['602a465ff9c6b5d716cc66cdc721b544a3e6c38fec1a1dc7215eb9b93aba2ea3', '7a03ac9277fdc74ec6cc392cfa53202a0f67100d760b3cba4fd84d3d706a17c7'], // (sqrt((1 / d) - sqrt(a^2 - a * d) / (a * d)), sqrt(a) * x) (8)\n      ['1fd5b9a006394a28e933993238de4abb5c193c7013e5e238dea14646c545d14a', '7a03ac9277fdc74ec6cc392cfa53202a0f67100d760b3cba4fd84d3d706a17c7'], // (-sqrt((1 / d) - sqrt(a^2 - a * d) / (a * d)), -sqrt(a) * x) (8)\n      ['602a465ff9c6b5d716cc66cdc721b544a3e6c38fec1a1dc7215eb9b93aba2ea3', '05fc536d880238b13933c6d305acdfd5f098eff289f4c345b027b2c28f95e826'], // (sqrt((1 / d) - sqrt(a^2 - a * d) / (a * d)), -sqrt(a) * x) (8)\n      ['1fd5b9a006394a28e933993238de4abb5c193c7013e5e238dea14646c545d14a', '05fc536d880238b13933c6d305acdfd5f098eff289f4c345b027b2c28f95e826']]\n    });\n  }\n\n}\n/**\n * ISO448\n * https://tools.ietf.org/html/rfc7748#section-4.2\n * https://git.zx2c4.com/goldilocks/tree/_aux/ristretto/ristretto.sage#n658\n */\n\n\nclass ISO448 extends EdwardsCurve {\n  constructor(pre) {\n    super({\n      id: 'ISO448',\n      ossl: null,\n      type: 'edwards',\n      endian: 'le',\n      hash: 'SHAKE256',\n      prefix: 'SigEd448',\n      context: true,\n      prime: 'p448',\n      // 2^448 - 2^224 - 1 (= 3 mod 4)\n      p: ['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff fffffffe ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff'],\n      a: '1',\n      // 39082 / 39081 mod p\n      d: ['d78b4bdc 7f0daf19 f24f38c2 9373a2cc', 'ad461572 42a50f37 809b1da3 412a12e7', '9ccc9c81 264cfe9a d0809970 58fb61c4', '243cc32d baa156b9'],\n      n: ['3fffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff 7cca23e9', 'c44edb49 aed63690 216cc272 8dc58f55', '2378c292 ab5844f3'],\n      h: '4',\n      // Elligator 2\n      z: '-1',\n      g: [['79a70b2b 70400553 ae7c9df4 16c792c6', '1128751a c9296924 0c25a07d 728bdc93', 'e21f7787 ed697224 9de732f3 8496cd11', '69871309 3e9c04fc'], // Note: the RFC has this wrong.\n      ['7fffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff 80000000', '00000000 00000000 00000000 00000000', '00000000 00000001'], pre],\n      torsion: [// (0, c) (1)\n      [['00000000000000000000000000000000000000000000000000000000', '00000000000000000000000000000000000000000000000000000000'], ['00000000000000000000000000000000000000000000000000000000', '00000000000000000000000000000000000000000000000000000001']], // (0, -c) (2)\n      [['00000000000000000000000000000000000000000000000000000000', '00000000000000000000000000000000000000000000000000000000'], ['fffffffffffffffffffffffffffffffffffffffffffffffffffffffe', 'fffffffffffffffffffffffffffffffffffffffffffffffffffffffe']], // (c, 0) (4)\n      [['00000000000000000000000000000000000000000000000000000000', '00000000000000000000000000000000000000000000000000000001'], ['00000000000000000000000000000000000000000000000000000000', '00000000000000000000000000000000000000000000000000000000']], // (-c, 0) (4)\n      [['fffffffffffffffffffffffffffffffffffffffffffffffffffffffe', 'fffffffffffffffffffffffffffffffffffffffffffffffffffffffe'], ['00000000000000000000000000000000000000000000000000000000', '00000000000000000000000000000000000000000000000000000000']]]\n    });\n  }\n\n}\n/**\n * ED448\n * https://tools.ietf.org/html/rfc8032#section-5.2\n */\n\n\nclass ED448 extends EdwardsCurve {\n  constructor(pre) {\n    super({\n      id: 'ED448',\n      ossl: 'ED448',\n      type: 'edwards',\n      endian: 'le',\n      hash: 'SHAKE256',\n      prefix: 'SigEd448',\n      context: true,\n      prime: 'p448',\n      // 2^448 - 2^224 - 1 (= 3 mod 4)\n      p: ['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff fffffffe ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff'],\n      a: '1',\n      // -39081 mod p\n      d: ['ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff fffffffe ffffffff', 'ffffffff ffffffff ffffffff ffffffff', 'ffffffff ffff6756'],\n      n: ['3fffffff ffffffff ffffffff ffffffff', 'ffffffff ffffffff ffffffff 7cca23e9', 'c44edb49 aed63690 216cc272 8dc58f55', '2378c292 ab5844f3'],\n      h: '4',\n      // Elligator 2\n      z: '-1',\n      g: [['4f1970c6 6bed0ded 221d15a6 22bf36da', '9e146570 470f1767 ea6de324 a3d3a464', '12ae1af7 2ab66511 433b80e1 8b00938e', '2626a82b c70cc05e'], ['693f4671 6eb6bc24 88762037 56c9c762', '4bea7373 6ca39840 87789c1e 05a0c2d7', '3ad3ff1c e67c39c4 fdbd132c 4ed7c8ad', '9808795b f230fa14'], pre],\n      torsion: [// (0, c) (1)\n      [['00000000000000000000000000000000000000000000000000000000', '00000000000000000000000000000000000000000000000000000000'], ['00000000000000000000000000000000000000000000000000000000', '00000000000000000000000000000000000000000000000000000001']], // (0, -c) (2)\n      [['00000000000000000000000000000000000000000000000000000000', '00000000000000000000000000000000000000000000000000000000'], ['fffffffffffffffffffffffffffffffffffffffffffffffffffffffe', 'fffffffffffffffffffffffffffffffffffffffffffffffffffffffe']], // (c, 0) (4)\n      [['00000000000000000000000000000000000000000000000000000000', '00000000000000000000000000000000000000000000000000000001'], ['00000000000000000000000000000000000000000000000000000000', '00000000000000000000000000000000000000000000000000000000']], // (-c, 0) (4)\n      [['fffffffffffffffffffffffffffffffffffffffffffffffffffffffe', 'fffffffffffffffffffffffffffffffffffffffffffffffffffffffe'], ['00000000000000000000000000000000000000000000000000000000', '00000000000000000000000000000000000000000000000000000000']]]\n    });\n  }\n\n}\n/*\n * Curve Registry\n */\n\n\nconst curves = {\n  __proto__: null,\n  P192,\n  P224,\n  P256,\n  P384,\n  P521,\n  SECP256K1,\n  BRAINPOOLP256,\n  BRAINPOOLP384,\n  BRAINPOOLP512,\n  X25519,\n  X448,\n  MONT448,\n  ED25519,\n  ISO448,\n  ED448\n};\nconst cache = {\n  __proto__: null,\n  P192: null,\n  P224: null,\n  P256: null,\n  P384: null,\n  P521: null,\n  SECP256K1: null,\n  BRAINPOOLP256: null,\n  BRAINPOOLP384: null,\n  BRAINPOOLP512: null,\n  X25519: null,\n  X448: null,\n  MONT448: null,\n  ED25519: null,\n  ISO448: null,\n  ED448: null\n};\n\nfunction curve(name, ...args) {\n  assert(typeof name === 'string');\n  const key = name.toUpperCase();\n  let curve = cache[key];\n\n  if (!curve) {\n    const Curve = curves[key];\n    if (!Curve) throw new Error(`Curve not found: \"${name}\".`);\n    curve = new Curve(...args);\n    cache[key] = curve;\n  }\n\n  return curve;\n}\n\nfunction register(name, Curve) {\n  assert(typeof name === 'string');\n  assert(typeof Curve === 'function');\n  const key = name.toUpperCase();\n  if (curves[key]) throw new Error(`Curve already registered: \"${name}\".`);\n  curves[key] = Curve;\n  cache[key] = null;\n}\n/*\n * Scalar Recoding\n */\n\n\nfunction getNAF(c, width, max) {\n  // Computing the width-w NAF of a positive integer.\n  //\n  // [GECC] Algorithm 3.35, Page 100, Section 3.3.\n  assert(c instanceof BN);\n  assert(!c.red);\n  assert(width >>> 0 === width);\n  assert(max >>> 0 === max);\n  const naf = new Array(max);\n  const pow = 1 << width + 1;\n  const k = c.abs();\n  const s = c.sign() | 1;\n  let i = 0;\n\n  while (!k.isZero()) {\n    let z = 0;\n\n    if (k.isOdd()) {\n      z = k.andln(pow - 1);\n      if (z & pow >>> 1) z -= pow;\n      k.isubn(z);\n    }\n\n    naf[i++] = z * s; // Optimization: shift by word if possible.\n\n    let shift = 1;\n    if (!k.isZero() && k.andln(pow - 1) === 0) shift = width + 1;\n\n    for (let j = 1; j < shift; j++) naf[i++] = 0;\n\n    k.iushrn(shift);\n  }\n\n  assert(i <= max);\n\n  for (; i < max; i++) naf[i] = 0;\n\n  return naf;\n}\n\nfunction getFixedNAF(k, width, max, step) {\n  assert(step >>> 0 === step); // Recode to NAF.\n\n  const naf = getNAF(k, width, max); // Translate into more windowed form.\n\n  const len = Math.ceil(naf.length / step);\n  const repr = new Array(len);\n  let i = 0;\n\n  for (let j = 0; j < naf.length; j += step) {\n    let nafW = 0;\n\n    for (let k = j + step - 1; k >= j; k--) nafW = (nafW << 1) + naf[k];\n\n    repr[i++] = nafW;\n  }\n\n  assert(i === len);\n  return repr;\n}\n\nfunction getJSF(c1, c2, max) {\n  // Joint sparse form.\n  //\n  // [GECC] Algorithm 3.50, Page 111, Section 3.3.\n  assert(c1 instanceof BN);\n  assert(c2 instanceof BN);\n  assert(!c1.red);\n  assert(!c2.red);\n  assert(max >>> 0 === max);\n  const jsf = [new Array(max), new Array(max)];\n  const k1 = c1.abs();\n  const k2 = c2.abs();\n  const s1 = c1.sign() | 1;\n  const s2 = c2.sign() | 1;\n  let i = 0;\n  let d1 = 0;\n  let d2 = 0;\n\n  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {\n    // First phase.\n    let m14 = k1.andln(3) + d1 & 3;\n    let m24 = k2.andln(3) + d2 & 3;\n    let u1 = 0;\n    let u2 = 0;\n    if (m14 === 3) m14 = -1;\n    if (m24 === 3) m24 = -1;\n\n    if (m14 & 1) {\n      const m8 = k1.andln(7) + d1 & 7;\n      if ((m8 === 3 || m8 === 5) && m24 === 2) u1 = -m14;else u1 = m14;\n    }\n\n    if (m24 & 1) {\n      const m8 = k2.andln(7) + d2 & 7;\n      if ((m8 === 3 || m8 === 5) && m14 === 2) u2 = -m24;else u2 = m24;\n    }\n\n    jsf[0][i] = u1 * s1;\n    jsf[1][i] = u2 * s2; // Second phase.\n\n    if (2 * d1 === u1 + 1) d1 = 1 - d1;\n    if (2 * d2 === u2 + 1) d2 = 1 - d2;\n    k1.iushrn(1);\n    k2.iushrn(1);\n    i += 1;\n  }\n\n  assert(i <= max);\n\n  for (; i < max; i++) {\n    jsf[0][i] = 0;\n    jsf[1][i] = 0;\n  }\n\n  return jsf;\n}\n\nfunction getJNAF(c1, c2, max) {\n  const jsf = getJSF(c1, c2, max);\n  const naf = new Array(max); // JSF -> NAF conversion.\n\n  for (let i = 0; i < max; i++) {\n    const ja = jsf[0][i];\n    const jb = jsf[1][i];\n    naf[i] = jsfIndex[(ja + 1) * 3 + (jb + 1)];\n  }\n\n  return naf;\n}\n\nfunction getLadderBits(k, n) {\n  // [TIMING] Page 16, Section 6.\n  assert(k instanceof BN);\n  assert(n instanceof BN); // Ensure positive.\n\n  const k0 = k.abs(); // Inflate scalar.\n\n  const k1 = k0.add(n);\n  const k2 = k1.add(n); // Get bit lengths.\n\n  const kb = k1.bitLength();\n  const nb = n.bitLength(); // k' = k + 2 * n, if ceil(log2(k + n)) <= ceil(log2(n)),\n  //    = k + n, otherwise\n\n  k1.cinject(k2, kb - nb - 1 >>> 31); // Track sign.\n\n  const sign = k.isNeg() & 1; // Calculate the new scalar's length.\n\n  const bits = k1.bitLength(); // Recode scalar to base256.\n\n  const exp = k1.toArray('le');\n  return [sign, bits, exp];\n}\n\nfunction getCOZBits(k, n) {\n  assert(k instanceof BN);\n  assert(n instanceof BN); // Reduce.\n\n  const u = k.mod(n); // Negate scalar.\n\n  const v = n.sub(u); // Get bit lengths.\n\n  const ub = u.bitLength();\n  const vb = v.bitLength(); // Negate if ceil(log2(k)) < ceil(log2(-k)).\n\n  const sign = ub - vb >>> 31; // Possibly negate.\n\n  u.cinject(v, sign); // Calculate the new scalar's length.\n\n  const bits = u.bitLength(); // Recode scalar to base256.\n\n  const exp = u.toArray('le'); // Final edge case.\n\n  const m1 = u.ceq(n.subn(1));\n  return [sign, bits, exp, m1];\n}\n/*\n * Helpers\n */\n\n\nfunction assert(val, msg) {\n  if (!val) {\n    const err = new Error(msg || 'Assertion failed');\n    if (Error.captureStackTrace) Error.captureStackTrace(err, assert);\n    throw err;\n  }\n}\n\nfunction sqrt(a) {\n  assert(a instanceof BN);\n\n  try {\n    return [1, a.redSqrt()];\n  } catch (e) {\n    if (e.message === 'X is not a square mod P.') return [0, a.clone()];\n    throw e;\n  }\n}\n\nfunction divSqrt(u, v) {\n  assert(u instanceof BN);\n  assert(v instanceof BN);\n\n  try {\n    return [1, u.redDivSqrt(v)];\n  } catch (e) {\n    if (e.message === 'Not invertible.' || e.message === 'X is not a square mod P.') {\n      return [0, u.clone()];\n    }\n\n    throw e;\n  }\n}\n\nfunction randomInt(rng) {\n  return BN.randomBits(rng, 32).toNumber();\n}\n\nfunction memoize(method, self) {\n  const cache = new WeakMap();\n  return function memoized(curve, invert) {\n    const i = invert & 1;\n    const item = cache.get(curve);\n    if (item && item[i] !== null) return item[i];\n    const result = method.call(self, curve, invert);\n    if (!cache.has(curve)) cache.set(curve, [null, null]);\n    cache.get(curve)[i] = result;\n    return result;\n  };\n}\n/*\n * Expose\n */\n\n\nexports.Curve = Curve;\nexports.Point = Point;\nexports.ShortCurve = ShortCurve;\nexports.ShortPoint = ShortPoint;\nexports.JPoint = JPoint;\nexports.MontCurve = MontCurve;\nexports.MontPoint = MontPoint;\nexports.XPoint = XPoint;\nexports.EdwardsCurve = EdwardsCurve;\nexports.EdwardsPoint = EdwardsPoint;\nexports.curves = curves;\nexports.curve = curve;\nexports.register = register;","map":null,"metadata":{},"sourceType":"script"}