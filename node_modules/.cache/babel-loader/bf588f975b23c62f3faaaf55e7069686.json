{"ast":null,"code":"'use strict';\n\nconst _get = require('just-safe-get');\n\nconst debug = require('debug');\n\nconst Big = require('bignumber.js');\n\nconst errcode = require('err-code');\n\nconst migrator = require('ipfs-repo-migrations');\n\nconst bytes = require('bytes');\n\nconst pathJoin = require('ipfs-utils/src/path-join');\n\nconst constants = require('./constants');\n\nconst backends = require('./backends');\n\nconst version = require('./version');\n\nconst config = require('./config');\n\nconst spec = require('./spec');\n\nconst apiAddr = require('./api-addr');\n\nconst blockstore = require('./blockstore');\n\nconst defaultOptions = require('./default-options');\n\nconst defaultDatastore = require('./default-datastore');\n\nconst ERRORS = require('./errors');\n\nconst log = debug('repo');\nconst noLimit = Number.MAX_SAFE_INTEGER;\nconst AUTO_MIGRATE_CONFIG_KEY = 'repoAutoMigrate';\nconst lockers = {\n  memory: require('./lock-memory'),\n  fs: require('./lock')\n};\n/**\n * IpfsRepo implements all required functionality to read and write to an ipfs repo.\n *\n */\n\nclass IpfsRepo {\n  /**\n   * @param {string} repoPath - path where the repo is stored\n   * @param {object} options - Configuration\n   */\n  constructor(repoPath, options) {\n    if (typeof repoPath !== 'string') {\n      throw new Error('missing repoPath');\n    }\n\n    this.options = buildOptions(options);\n    this.closed = true;\n    this.path = repoPath;\n    this._locker = this._getLocker();\n    this.root = backends.create('root', this.path, this.options);\n    this.version = version(this.root);\n    this.config = config(this.root);\n    this.spec = spec(this.root);\n    this.apiAddr = apiAddr(this.root);\n  }\n  /**\n   * Initialize a new repo.\n   *\n   * @param {Object} config - config to write into `config`.\n   * @returns {Promise<void>}\n   */\n\n\n  async init(config) {\n    log('initializing at: %s', this.path);\n    await this._openRoot();\n    await this.config.set(buildConfig(config));\n    await this.spec.set(buildDatastoreSpec(config));\n    await this.version.set(constants.repoVersion);\n  }\n  /**\n   * Check if the repo is already initialized.\n   * @returns {Promise<Boolean>}\n   */\n\n\n  async isInitialized() {\n    if (!this.closed) {\n      // repo is open, must be initialized\n      return true;\n    }\n\n    try {\n      // have to open the root datastore in the browser before\n      // we can check whether it's been initialized\n      await this._openRoot();\n      await this._checkInitialized();\n      await this.root.close();\n      return true;\n    } catch (err) {\n      // FIXME: do not use exceptions for flow control\n      return false;\n    }\n  }\n  /**\n   * Open the repo. If the repo is already open an error will be thrown.\n   * If the repo is not initialized it will throw an error.\n   *\n   * @returns {Promise<void>}\n   */\n\n\n  async open() {\n    if (!this.closed) {\n      throw errcode(new Error('repo is already open'), ERRORS.ERR_REPO_ALREADY_OPEN);\n    }\n\n    log('opening at: %s', this.path); // check if the repo is already initialized\n\n    try {\n      await this._openRoot();\n      await this._checkInitialized();\n      this.lockfile = await this._openLock(this.path);\n      log('acquired repo.lock');\n      log('creating datastore');\n      this.datastore = backends.create('datastore', pathJoin(this.path, 'datastore'), this.options);\n      await this.datastore.open();\n      log('creating blocks');\n      const blocksBaseStore = backends.create('blocks', pathJoin(this.path, 'blocks'), this.options);\n      await blocksBaseStore.open();\n      this.blocks = await blockstore(blocksBaseStore, this.options.storageBackendOptions.blocks);\n      log('creating keystore');\n      this.keys = backends.create('keys', pathJoin(this.path, 'keys'), this.options);\n      await this.keys.open();\n      const isCompatible = await this.version.check(constants.repoVersion);\n\n      if (!isCompatible) {\n        if (await this._isAutoMigrationEnabled()) {\n          await this._migrate(constants.repoVersion);\n        } else {\n          throw new ERRORS.InvalidRepoVersionError('Incompatible repo versions. Automatic migrations disabled. Please migrate the repo manually.');\n        }\n      }\n\n      this.closed = false;\n      log('all opened');\n    } catch (err) {\n      if (this.lockfile) {\n        try {\n          await this._closeLock();\n          this.lockfile = null;\n        } catch (err2) {\n          log('error removing lock', err2);\n        }\n      }\n\n      throw err;\n    }\n  }\n  /**\n   * Returns the repo locker to be used. Null will be returned if no locker is requested\n   *\n   * @private\n   * @returns {Locker}\n   */\n\n\n  _getLocker() {\n    if (typeof this.options.lock === 'string') {\n      if (!lockers[this.options.lock]) {\n        throw new Error('Unknown lock type: ' + this.options.lock);\n      }\n\n      return lockers[this.options.lock];\n    }\n\n    if (!this.options.lock) {\n      throw new Error('No lock provided');\n    }\n\n    return this.options.lock;\n  }\n  /**\n   * Opens the root backend, catching and ignoring an 'Already open' error\n   * @returns {Promise}\n   */\n\n\n  async _openRoot() {\n    try {\n      await this.root.open();\n    } catch (err) {\n      if (err.message !== 'Already open') {\n        throw err;\n      }\n    }\n  }\n  /**\n   * Creates a lock on the repo if a locker is specified. The lockfile object will\n   * be returned in the callback if one has been created.\n   *\n   * @param {string} path\n   * @returns {Promise<lockfile>}\n   */\n\n\n  async _openLock(path) {\n    const lockfile = await this._locker.lock(path);\n\n    if (typeof lockfile.close !== 'function') {\n      throw errcode(new Error('Locks must have a close method'), 'ERR_NO_CLOSE_FUNCTION');\n    }\n\n    return lockfile;\n  }\n  /**\n   * Closes the lock on the repo\n   *\n   * @returns {Promise<void>}\n   */\n\n\n  _closeLock() {\n    return this.lockfile.close();\n  }\n  /**\n   * Check if the repo is already initialized.\n   * @private\n   * @returns {Promise}\n   */\n\n\n  async _checkInitialized() {\n    log('init check');\n    let config;\n\n    try {\n      [config] = await Promise.all([this.config.exists(), this.spec.exists(), this.version.exists()]);\n    } catch (err) {\n      if (err.code === 'ERR_NOT_FOUND') {\n        throw errcode(new Error('repo is not initialized yet'), ERRORS.ERR_REPO_NOT_INITIALIZED, {\n          path: this.path\n        });\n      }\n\n      throw err;\n    }\n\n    if (!config) {\n      throw errcode(new Error('repo is not initialized yet'), ERRORS.ERR_REPO_NOT_INITIALIZED, {\n        path: this.path\n      });\n    }\n  }\n  /**\n   * Close the repo and cleanup.\n   *\n   * @returns {Promise<void>}\n   */\n\n\n  async close() {\n    if (this.closed) {\n      throw errcode(new Error('repo is already closed'), ERRORS.ERR_REPO_ALREADY_CLOSED);\n    }\n\n    log('closing at: %s', this.path);\n\n    try {\n      // Delete api, ignoring irrelevant errors\n      await this.apiAddr.delete();\n    } catch (err) {\n      if (err.code !== ERRORS.ERR_REPO_NOT_INITIALIZED && !err.message.startsWith('ENOENT')) {\n        throw err;\n      }\n    }\n\n    await Promise.all([this.root, this.blocks, this.keys, this.datastore].map(store => store.close()));\n    log('unlocking');\n    this.closed = true;\n    await this._closeLock();\n    this.lockfile = null;\n  }\n  /**\n   * Check if a repo exists.\n   *\n   * @returns {Promise<bool>}\n   */\n\n\n  async exists() {\n    // eslint-disable-line require-await\n    return this.version.exists();\n  }\n  /**\n   * Get repo status.\n   *\n   * @returns {Object}\n   */\n\n\n  async stat() {\n    const [storageMax, blocks, version, datastore, keys] = await Promise.all([this._storageMaxStat(), this._blockStat(), this.version.get(), getSize(this.datastore), getSize(this.keys)]);\n    const size = blocks.size.plus(datastore).plus(keys);\n    return {\n      repoPath: this.path,\n      storageMax,\n      version: version,\n      numObjects: blocks.count,\n      repoSize: size\n    };\n  }\n\n  async _isAutoMigrationEnabled() {\n    if (this.options.autoMigrate !== undefined) {\n      return this.options.autoMigrate;\n    }\n\n    let autoMigrateConfig;\n\n    try {\n      autoMigrateConfig = await this.config.get(AUTO_MIGRATE_CONFIG_KEY);\n    } catch (e) {\n      if (e.code === ERRORS.NotFoundError.code) {\n        autoMigrateConfig = true; // Config's default value is True\n      } else {\n        throw e;\n      }\n    }\n\n    return autoMigrateConfig;\n  }\n\n  async _migrate(toVersion) {\n    const currentRepoVersion = await this.version.get();\n\n    if (currentRepoVersion > toVersion) {\n      log('reverting to version ' + toVersion);\n      return migrator.revert(this.path, toVersion, {\n        ignoreLock: true,\n        repoOptions: this.options\n      });\n    } else {\n      log('migrating to version ' + toVersion);\n      return migrator.migrate(this.path, toVersion, {\n        ignoreLock: true,\n        repoOptions: this.options\n      });\n    }\n  }\n\n  async _storageMaxStat() {\n    try {\n      const max = await this.config.get('Datastore.StorageMax');\n      return new Big(bytes(max));\n    } catch (err) {\n      return new Big(noLimit);\n    }\n  }\n\n  async _blockStat() {\n    let count = new Big(0);\n    let size = new Big(0);\n\n    for await (const block of this.blocks.query({})) {\n      count = count.plus(1);\n      size = size.plus(block.value.byteLength).plus(block.key._buf.byteLength);\n    }\n\n    return {\n      count,\n      size\n    };\n  }\n\n}\n\nasync function getSize(queryFn) {\n  const sum = new Big(0);\n\n  for await (const block of queryFn.query({})) {\n    sum.plus(block.value.byteLength).plus(block.key._buf.byteLength);\n  }\n\n  return sum;\n}\n\nmodule.exports = IpfsRepo;\nmodule.exports.utils = {\n  blockstore: require('./blockstore-utils')\n};\nmodule.exports.repoVersion = constants.repoVersion;\nmodule.exports.errors = ERRORS;\n\nfunction buildOptions(_options) {\n  const options = Object.assign({}, defaultOptions, _options);\n  options.storageBackends = Object.assign({}, defaultOptions.storageBackends, options.storageBackends);\n  options.storageBackendOptions = Object.assign({}, defaultOptions.storageBackendOptions, options.storageBackendOptions);\n  return options;\n} // TODO this should come from js-ipfs instead\n\n\nfunction buildConfig(_config) {\n  _config.datastore = Object.assign({}, defaultDatastore, _get(_config, 'datastore', {}));\n  return _config;\n}\n\nfunction buildDatastoreSpec(_config) {\n  const spec = Object.assign({}, defaultDatastore.Spec, _get(_config, 'datastore.Spec', {}));\n  return {\n    type: spec.type,\n    mounts: spec.mounts.map(mounting => ({\n      mountpoint: mounting.mountpoint,\n      type: mounting.child.type,\n      path: mounting.child.path,\n      shardFunc: mounting.child.shardFunc\n    }))\n  };\n}","map":null,"metadata":{},"sourceType":"script"}