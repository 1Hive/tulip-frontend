{"ast":null,"code":"/* eslint max-nested-callbacks: [\"error\", 5] */\n'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _asyncIterator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar sanitize = require('sanitize-filename');\n\nvar mergeOptions = require('merge-options');\n\nvar crypto = require('libp2p-crypto');\n\nvar DS = require('interface-datastore');\n\nvar CMS = require('./cms');\n\nvar errcode = require('err-code');\n\nvar keyPrefix = '/pkcs8/';\nvar infoPrefix = '/info/'; // NIST SP 800-132\n\nvar NIST = {\n  minKeyLength: 112 / 8,\n  minSaltLength: 128 / 8,\n  minIterationCount: 1000\n};\nvar defaultOptions = {\n  // See https://cryptosense.com/parametesr-choice-for-pbkdf2/\n  dek: {\n    keyLength: 512 / 8,\n    iterationCount: 10000,\n    salt: 'you should override this value with a crypto secure random number',\n    hash: 'sha2-512'\n  }\n};\n\nfunction validateKeyName(name) {\n  if (!name) return false;\n  if (typeof name !== 'string') return false;\n  return name === sanitize(name.trim());\n}\n/**\n * Throws an error after a delay\n *\n * This assumes than an error indicates that the keychain is under attack. Delay returning an\n * error to make brute force attacks harder.\n *\n * @param {string | Error} err - The error\n * @private\n */\n\n\nfunction throwDelayed(_x) {\n  return _throwDelayed.apply(this, arguments);\n}\n/**\n * Converts a key name into a datastore name.\n *\n * @param {string} name\n * @returns {DS.Key}\n * @private\n */\n\n\nfunction _throwDelayed() {\n  _throwDelayed = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(err) {\n    var min, max, delay;\n    return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n      while (1) {\n        switch (_context11.prev = _context11.next) {\n          case 0:\n            min = 200;\n            max = 1000;\n            delay = Math.random() * (max - min) + min;\n            _context11.next = 5;\n            return new Promise(function (resolve) {\n              return setTimeout(resolve, delay);\n            });\n\n          case 5:\n            throw err;\n\n          case 6:\n          case \"end\":\n            return _context11.stop();\n        }\n      }\n    }, _callee11);\n  }));\n  return _throwDelayed.apply(this, arguments);\n}\n\nfunction DsName(name) {\n  return new DS.Key(keyPrefix + name);\n}\n/**\n * Converts a key name into a datastore info name.\n *\n * @param {string} name\n * @returns {DS.Key}\n * @private\n */\n\n\nfunction DsInfoName(name) {\n  return new DS.Key(infoPrefix + name);\n}\n/**\n * Information about a key.\n *\n * @typedef {Object} KeyInfo\n *\n * @property {string} id - The universally unique key id.\n * @property {string} name - The local key name.\n */\n\n/**\n * Manages the lifecycle of a key. Keys are encrypted at rest using PKCS #8.\n *\n * A key in the store has two entries\n * - '/info/*key-name*', contains the KeyInfo for the key\n * - '/pkcs8/*key-name*', contains the PKCS #8 for the key\n *\n */\n\n\nvar Keychain = /*#__PURE__*/function () {\n  /**\n   * Creates a new instance of a key chain.\n   *\n   * @param {DS} store - where the key are.\n   * @param {object} options - ???\n   */\n  function Keychain(store, options) {\n    _classCallCheck(this, Keychain);\n\n    if (!store) {\n      throw new Error('store is required');\n    }\n\n    this.store = store;\n    var opts = mergeOptions(defaultOptions, options); // Enforce NIST SP 800-132\n\n    if (!opts.passPhrase || opts.passPhrase.length < 20) {\n      throw new Error('passPhrase must be least 20 characters');\n    }\n\n    if (opts.dek.keyLength < NIST.minKeyLength) {\n      throw new Error(\"dek.keyLength must be least \".concat(NIST.minKeyLength, \" bytes\"));\n    }\n\n    if (opts.dek.salt.length < NIST.minSaltLength) {\n      throw new Error(\"dek.saltLength must be least \".concat(NIST.minSaltLength, \" bytes\"));\n    }\n\n    if (opts.dek.iterationCount < NIST.minIterationCount) {\n      throw new Error(\"dek.iterationCount must be least \".concat(NIST.minIterationCount));\n    } // Create the derived encrypting key\n\n\n    var dek = crypto.pbkdf2(opts.passPhrase, opts.dek.salt, opts.dek.iterationCount, opts.dek.keyLength, opts.dek.hash);\n    Object.defineProperty(this, '_', {\n      value: function value() {\n        return dek;\n      }\n    });\n  }\n  /**\n   * Gets an object that can encrypt/decrypt protected data\n   * using the Cryptographic Message Syntax (CMS).\n   *\n   * CMS describes an encapsulation syntax for data protection. It\n   * is used to digitally sign, digest, authenticate, or encrypt\n   * arbitrary message content.\n   *\n   * @returns {CMS}\n   */\n\n\n  _createClass(Keychain, [{\n    key: \"cms\",\n    get: function get() {\n      return new CMS(this);\n    }\n    /**\n     * Generates the options for a keychain.  A random salt is produced.\n     *\n     * @returns {object}\n     */\n\n  }, {\n    key: \"createKey\",\n    value:\n    /**\n     * Create a new key.\n     *\n     * @param {string} name - The local key name; cannot already exist.\n     * @param {string} type - One of the key types; 'rsa'.\n     * @param {int} size - The key size in bits.\n      * @returns {KeyInfo}\n     */\n    function () {\n      var _createKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(name, type, size) {\n        var self, dsname, exists, keyInfo, keypair, kid, pem, batch;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                self = this;\n\n                if (!(!validateKeyName(name) || name === 'self')) {\n                  _context.next = 3;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", throwDelayed(errcode(new Error(\"Invalid key name '\".concat(name, \"'\")), 'ERR_INVALID_KEY_NAME')));\n\n              case 3:\n                if (!(typeof type !== 'string')) {\n                  _context.next = 5;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", throwDelayed(errcode(new Error(\"Invalid key type '\".concat(type, \"'\")), 'ERR_INVALID_KEY_TYPE')));\n\n              case 5:\n                if (Number.isSafeInteger(size)) {\n                  _context.next = 7;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", throwDelayed(errcode(new Error(\"Invalid key size '\".concat(size, \"'\")), 'ERR_INVALID_KEY_SIZE')));\n\n              case 7:\n                dsname = DsName(name);\n                _context.next = 10;\n                return self.store.has(dsname);\n\n              case 10:\n                exists = _context.sent;\n\n                if (!exists) {\n                  _context.next = 13;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", throwDelayed(errcode(new Error(\"Key '\".concat(name, \"' already exists\")), 'ERR_KEY_ALREADY_EXISTS')));\n\n              case 13:\n                _context.t0 = type.toLowerCase();\n                _context.next = _context.t0 === 'rsa' ? 16 : 19;\n                break;\n\n              case 16:\n                if (!(size < 2048)) {\n                  _context.next = 18;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", throwDelayed(errcode(new Error(\"Invalid RSA key size \".concat(size)), 'ERR_INVALID_KEY_SIZE')));\n\n              case 18:\n                return _context.abrupt(\"break\", 20);\n\n              case 19:\n                return _context.abrupt(\"break\", 20);\n\n              case 20:\n                _context.prev = 20;\n                _context.next = 23;\n                return crypto.keys.generateKeyPair(type, size);\n\n              case 23:\n                keypair = _context.sent;\n                _context.next = 26;\n                return keypair.id();\n\n              case 26:\n                kid = _context.sent;\n                _context.next = 29;\n                return keypair.export(this._());\n\n              case 29:\n                pem = _context.sent;\n                keyInfo = {\n                  name: name,\n                  id: kid\n                };\n                batch = self.store.batch();\n                batch.put(dsname, pem);\n                batch.put(DsInfoName(name), JSON.stringify(keyInfo));\n                _context.next = 36;\n                return batch.commit();\n\n              case 36:\n                _context.next = 41;\n                break;\n\n              case 38:\n                _context.prev = 38;\n                _context.t1 = _context[\"catch\"](20);\n                return _context.abrupt(\"return\", throwDelayed(_context.t1));\n\n              case 41:\n                return _context.abrupt(\"return\", keyInfo);\n\n              case 42:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[20, 38]]);\n      }));\n\n      function createKey(_x2, _x3, _x4) {\n        return _createKey.apply(this, arguments);\n      }\n\n      return createKey;\n    }()\n    /**\n     * List all the keys.\n     *\n      * @returns {KeyInfo[]}\n     */\n\n  }, {\n    key: \"listKeys\",\n    value: function () {\n      var _listKeys = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var self, query, info, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, value;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                self = this;\n                query = {\n                  prefix: infoPrefix\n                };\n                info = [];\n                _iteratorNormalCompletion = true;\n                _didIteratorError = false;\n                _context2.prev = 5;\n                _iterator = _asyncIterator(self.store.query(query));\n\n              case 7:\n                _context2.next = 9;\n                return _iterator.next();\n\n              case 9:\n                _step = _context2.sent;\n                _iteratorNormalCompletion = _step.done;\n                _context2.next = 13;\n                return _step.value;\n\n              case 13:\n                _value = _context2.sent;\n\n                if (_iteratorNormalCompletion) {\n                  _context2.next = 20;\n                  break;\n                }\n\n                value = _value;\n                info.push(JSON.parse(value.value));\n\n              case 17:\n                _iteratorNormalCompletion = true;\n                _context2.next = 7;\n                break;\n\n              case 20:\n                _context2.next = 26;\n                break;\n\n              case 22:\n                _context2.prev = 22;\n                _context2.t0 = _context2[\"catch\"](5);\n                _didIteratorError = true;\n                _iteratorError = _context2.t0;\n\n              case 26:\n                _context2.prev = 26;\n                _context2.prev = 27;\n\n                if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                  _context2.next = 31;\n                  break;\n                }\n\n                _context2.next = 31;\n                return _iterator.return();\n\n              case 31:\n                _context2.prev = 31;\n\n                if (!_didIteratorError) {\n                  _context2.next = 34;\n                  break;\n                }\n\n                throw _iteratorError;\n\n              case 34:\n                return _context2.finish(31);\n\n              case 35:\n                return _context2.finish(26);\n\n              case 36:\n                return _context2.abrupt(\"return\", info);\n\n              case 37:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[5, 22, 26, 36], [27,, 31, 35]]);\n      }));\n\n      function listKeys() {\n        return _listKeys.apply(this, arguments);\n      }\n\n      return listKeys;\n    }()\n    /**\n     * Find a key by it's id.\n     *\n     * @param {string} id - The universally unique key identifier.\n      * @returns {KeyInfo}\n     */\n\n  }, {\n    key: \"findKeyById\",\n    value: function () {\n      var _findKeyById = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(id) {\n        var keys;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.prev = 0;\n                _context3.next = 3;\n                return this.listKeys();\n\n              case 3:\n                keys = _context3.sent;\n                return _context3.abrupt(\"return\", keys.find(function (k) {\n                  return k.id === id;\n                }));\n\n              case 7:\n                _context3.prev = 7;\n                _context3.t0 = _context3[\"catch\"](0);\n                return _context3.abrupt(\"return\", throwDelayed(_context3.t0));\n\n              case 10:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[0, 7]]);\n      }));\n\n      function findKeyById(_x5) {\n        return _findKeyById.apply(this, arguments);\n      }\n\n      return findKeyById;\n    }()\n    /**\n     * Find a key by it's name.\n     *\n     * @param {string} name - The local key name.\n      * @returns {KeyInfo}\n     */\n\n  }, {\n    key: \"findKeyByName\",\n    value: function () {\n      var _findKeyByName = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(name) {\n        var dsname, res;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (validateKeyName(name)) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", throwDelayed(errcode(new Error(\"Invalid key name '\".concat(name, \"'\")), 'ERR_INVALID_KEY_NAME')));\n\n              case 2:\n                dsname = DsInfoName(name);\n                _context4.prev = 3;\n                _context4.next = 6;\n                return this.store.get(dsname);\n\n              case 6:\n                res = _context4.sent;\n                return _context4.abrupt(\"return\", JSON.parse(res.toString()));\n\n              case 10:\n                _context4.prev = 10;\n                _context4.t0 = _context4[\"catch\"](3);\n                return _context4.abrupt(\"return\", throwDelayed(errcode(new Error(\"Key '\".concat(name, \"' does not exist. \").concat(_context4.t0.message)), 'ERR_KEY_NOT_FOUND')));\n\n              case 13:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[3, 10]]);\n      }));\n\n      function findKeyByName(_x6) {\n        return _findKeyByName.apply(this, arguments);\n      }\n\n      return findKeyByName;\n    }()\n    /**\n     * Remove an existing key.\n     *\n     * @param {string} name - The local key name; must already exist.\n      * @returns {KeyInfo}\n     */\n\n  }, {\n    key: \"removeKey\",\n    value: function () {\n      var _removeKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(name) {\n        var self, dsname, keyInfo, batch;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                self = this;\n\n                if (!(!validateKeyName(name) || name === 'self')) {\n                  _context5.next = 3;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", throwDelayed(errcode(new Error(\"Invalid key name '\".concat(name, \"'\")), 'ERR_INVALID_KEY_NAME')));\n\n              case 3:\n                dsname = DsName(name);\n                _context5.next = 6;\n                return self.findKeyByName(name);\n\n              case 6:\n                keyInfo = _context5.sent;\n                batch = self.store.batch();\n                batch.delete(dsname);\n                batch.delete(DsInfoName(name));\n                _context5.next = 12;\n                return batch.commit();\n\n              case 12:\n                return _context5.abrupt(\"return\", keyInfo);\n\n              case 13:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function removeKey(_x7) {\n        return _removeKey.apply(this, arguments);\n      }\n\n      return removeKey;\n    }()\n    /**\n     * Rename a key\n     *\n     * @param {string} oldName - The old local key name; must already exist.\n     * @param {string} newName - The new local key name; must not already exist.\n      * @returns {KeyInfo}\n     */\n\n  }, {\n    key: \"renameKey\",\n    value: function () {\n      var _renameKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(oldName, newName) {\n        var self, oldDsname, newDsname, oldInfoName, newInfoName, exists, res, pem, keyInfo, batch;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                self = this;\n\n                if (!(!validateKeyName(oldName) || oldName === 'self')) {\n                  _context6.next = 3;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\", throwDelayed(errcode(new Error(\"Invalid old key name '\".concat(oldName, \"'\")), 'ERR_OLD_KEY_NAME_INVALID')));\n\n              case 3:\n                if (!(!validateKeyName(newName) || newName === 'self')) {\n                  _context6.next = 5;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\", throwDelayed(errcode(new Error(\"Invalid new key name '\".concat(newName, \"'\")), 'ERR_NEW_KEY_NAME_INVALID')));\n\n              case 5:\n                oldDsname = DsName(oldName);\n                newDsname = DsName(newName);\n                oldInfoName = DsInfoName(oldName);\n                newInfoName = DsInfoName(newName);\n                _context6.next = 11;\n                return self.store.has(newDsname);\n\n              case 11:\n                exists = _context6.sent;\n\n                if (!exists) {\n                  _context6.next = 14;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\", throwDelayed(errcode(new Error(\"Key '\".concat(newName, \"' already exists\")), 'ERR_KEY_ALREADY_EXISTS')));\n\n              case 14:\n                _context6.prev = 14;\n                _context6.next = 17;\n                return this.store.get(oldDsname);\n\n              case 17:\n                res = _context6.sent;\n                pem = res.toString();\n                _context6.next = 21;\n                return self.store.get(oldInfoName);\n\n              case 21:\n                res = _context6.sent;\n                keyInfo = JSON.parse(res.toString());\n                keyInfo.name = newName;\n                batch = self.store.batch();\n                batch.put(newDsname, pem);\n                batch.put(newInfoName, JSON.stringify(keyInfo));\n                batch.delete(oldDsname);\n                batch.delete(oldInfoName);\n                _context6.next = 31;\n                return batch.commit();\n\n              case 31:\n                return _context6.abrupt(\"return\", keyInfo);\n\n              case 34:\n                _context6.prev = 34;\n                _context6.t0 = _context6[\"catch\"](14);\n                return _context6.abrupt(\"return\", throwDelayed(_context6.t0));\n\n              case 37:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this, [[14, 34]]);\n      }));\n\n      function renameKey(_x8, _x9) {\n        return _renameKey.apply(this, arguments);\n      }\n\n      return renameKey;\n    }()\n    /**\n     * Export an existing key as a PEM encrypted PKCS #8 string\n     *\n     * @param {string} name - The local key name; must already exist.\n     * @param {string} password - The password\n      * @returns {string}\n     */\n\n  }, {\n    key: \"exportKey\",\n    value: function () {\n      var _exportKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(name, password) {\n        var dsname, res, pem, privateKey;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (validateKeyName(name)) {\n                  _context7.next = 2;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", throwDelayed(errcode(new Error(\"Invalid key name '\".concat(name, \"'\")), 'ERR_INVALID_KEY_NAME')));\n\n              case 2:\n                if (password) {\n                  _context7.next = 4;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", throwDelayed(errcode(new Error('Password is required'), 'ERR_PASSWORD_REQUIRED')));\n\n              case 4:\n                dsname = DsName(name);\n                _context7.prev = 5;\n                _context7.next = 8;\n                return this.store.get(dsname);\n\n              case 8:\n                res = _context7.sent;\n                pem = res.toString();\n                _context7.next = 12;\n                return crypto.keys.import(pem, this._());\n\n              case 12:\n                privateKey = _context7.sent;\n                return _context7.abrupt(\"return\", privateKey.export(password));\n\n              case 16:\n                _context7.prev = 16;\n                _context7.t0 = _context7[\"catch\"](5);\n                return _context7.abrupt(\"return\", throwDelayed(_context7.t0));\n\n              case 19:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[5, 16]]);\n      }));\n\n      function exportKey(_x10, _x11) {\n        return _exportKey.apply(this, arguments);\n      }\n\n      return exportKey;\n    }()\n    /**\n     * Import a new key from a PEM encoded PKCS #8 string\n     *\n     * @param {string} name - The local key name; must not already exist.\n     * @param {string} pem - The PEM encoded PKCS #8 string\n     * @param {string} password - The password.\n      * @returns {KeyInfo}\n     */\n\n  }, {\n    key: \"importKey\",\n    value: function () {\n      var _importKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(name, pem, password) {\n        var self, dsname, exists, privateKey, kid, keyInfo, batch;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                self = this;\n\n                if (!(!validateKeyName(name) || name === 'self')) {\n                  _context8.next = 3;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\", throwDelayed(errcode(new Error(\"Invalid key name '\".concat(name, \"'\")), 'ERR_INVALID_KEY_NAME')));\n\n              case 3:\n                if (pem) {\n                  _context8.next = 5;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\", throwDelayed(errcode(new Error('PEM encoded key is required'), 'ERR_PEM_REQUIRED')));\n\n              case 5:\n                dsname = DsName(name);\n                _context8.next = 8;\n                return self.store.has(dsname);\n\n              case 8:\n                exists = _context8.sent;\n\n                if (!exists) {\n                  _context8.next = 11;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\", throwDelayed(errcode(new Error(\"Key '\".concat(name, \"' already exists\")), 'ERR_KEY_ALREADY_EXISTS')));\n\n              case 11:\n                _context8.prev = 11;\n                _context8.next = 14;\n                return crypto.keys.import(pem, password);\n\n              case 14:\n                privateKey = _context8.sent;\n                _context8.next = 20;\n                break;\n\n              case 17:\n                _context8.prev = 17;\n                _context8.t0 = _context8[\"catch\"](11);\n                return _context8.abrupt(\"return\", throwDelayed(errcode(new Error('Cannot read the key, most likely the password is wrong'), 'ERR_CANNOT_READ_KEY')));\n\n              case 20:\n                _context8.prev = 20;\n                _context8.next = 23;\n                return privateKey.id();\n\n              case 23:\n                kid = _context8.sent;\n                _context8.next = 26;\n                return privateKey.export(this._());\n\n              case 26:\n                pem = _context8.sent;\n                _context8.next = 32;\n                break;\n\n              case 29:\n                _context8.prev = 29;\n                _context8.t1 = _context8[\"catch\"](20);\n                return _context8.abrupt(\"return\", throwDelayed(_context8.t1));\n\n              case 32:\n                keyInfo = {\n                  name: name,\n                  id: kid\n                };\n                batch = self.store.batch();\n                batch.put(dsname, pem);\n                batch.put(DsInfoName(name), JSON.stringify(keyInfo));\n                _context8.next = 38;\n                return batch.commit();\n\n              case 38:\n                return _context8.abrupt(\"return\", keyInfo);\n\n              case 39:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this, [[11, 17], [20, 29]]);\n      }));\n\n      function importKey(_x12, _x13, _x14) {\n        return _importKey.apply(this, arguments);\n      }\n\n      return importKey;\n    }()\n  }, {\n    key: \"importPeer\",\n    value: function () {\n      var _importPeer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(name, peer) {\n        var self, privateKey, dsname, exists, kid, pem, keyInfo, batch;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                self = this;\n\n                if (validateKeyName(name)) {\n                  _context9.next = 3;\n                  break;\n                }\n\n                return _context9.abrupt(\"return\", throwDelayed(errcode(new Error(\"Invalid key name '\".concat(name, \"'\")), 'ERR_INVALID_KEY_NAME')));\n\n              case 3:\n                if (!(!peer || !peer.privKey)) {\n                  _context9.next = 5;\n                  break;\n                }\n\n                return _context9.abrupt(\"return\", throwDelayed(errcode(new Error('Peer.privKey is required'), 'ERR_MISSING_PRIVATE_KEY')));\n\n              case 5:\n                privateKey = peer.privKey;\n                dsname = DsName(name);\n                _context9.next = 9;\n                return self.store.has(dsname);\n\n              case 9:\n                exists = _context9.sent;\n\n                if (!exists) {\n                  _context9.next = 12;\n                  break;\n                }\n\n                return _context9.abrupt(\"return\", throwDelayed(errcode(new Error(\"Key '\".concat(name, \"' already exists\")), 'ERR_KEY_ALREADY_EXISTS')));\n\n              case 12:\n                _context9.prev = 12;\n                _context9.next = 15;\n                return privateKey.id();\n\n              case 15:\n                kid = _context9.sent;\n                _context9.next = 18;\n                return privateKey.export(this._());\n\n              case 18:\n                pem = _context9.sent;\n                keyInfo = {\n                  name: name,\n                  id: kid\n                };\n                batch = self.store.batch();\n                batch.put(dsname, pem);\n                batch.put(DsInfoName(name), JSON.stringify(keyInfo));\n                _context9.next = 25;\n                return batch.commit();\n\n              case 25:\n                return _context9.abrupt(\"return\", keyInfo);\n\n              case 28:\n                _context9.prev = 28;\n                _context9.t0 = _context9[\"catch\"](12);\n                return _context9.abrupt(\"return\", throwDelayed(_context9.t0));\n\n              case 31:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this, [[12, 28]]);\n      }));\n\n      function importPeer(_x15, _x16) {\n        return _importPeer.apply(this, arguments);\n      }\n\n      return importPeer;\n    }()\n    /**\n     * Gets the private key as PEM encoded PKCS #8 string.\n     *\n     * @param {string} name\n      * @returns {string}\n     * @private\n     */\n\n  }, {\n    key: \"_getPrivateKey\",\n    value: function () {\n      var _getPrivateKey2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(name) {\n        var dsname, res;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                if (validateKeyName(name)) {\n                  _context10.next = 2;\n                  break;\n                }\n\n                return _context10.abrupt(\"return\", throwDelayed(errcode(new Error(\"Invalid key name '\".concat(name, \"'\")), 'ERR_INVALID_KEY_NAME')));\n\n              case 2:\n                _context10.prev = 2;\n                dsname = DsName(name);\n                _context10.next = 6;\n                return this.store.get(dsname);\n\n              case 6:\n                res = _context10.sent;\n                return _context10.abrupt(\"return\", res.toString());\n\n              case 10:\n                _context10.prev = 10;\n                _context10.t0 = _context10[\"catch\"](2);\n                return _context10.abrupt(\"return\", throwDelayed(errcode(new Error(\"Key '\".concat(name, \"' does not exist. \").concat(_context10.t0.message)), 'ERR_KEY_NOT_FOUND')));\n\n              case 13:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this, [[2, 10]]);\n      }));\n\n      function _getPrivateKey(_x17) {\n        return _getPrivateKey2.apply(this, arguments);\n      }\n\n      return _getPrivateKey;\n    }()\n  }], [{\n    key: \"generateOptions\",\n    value: function generateOptions() {\n      var options = Object.assign({}, defaultOptions);\n      var saltLength = Math.ceil(NIST.minSaltLength / 3) * 3; // no base64 padding\n\n      options.dek.salt = crypto.randomBytes(saltLength).toString('base64');\n      return options;\n    }\n    /**\n     * Gets an object that can encrypt/decrypt protected data.\n     * The default options for a keychain.\n     *\n     * @returns {object}\n     */\n\n  }, {\n    key: \"options\",\n    get: function get() {\n      return defaultOptions;\n    }\n  }]);\n\n  return Keychain;\n}();\n\nmodule.exports = Keychain;","map":null,"metadata":{},"sourceType":"script"}