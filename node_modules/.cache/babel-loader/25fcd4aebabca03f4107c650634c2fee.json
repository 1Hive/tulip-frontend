{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar protons = require('protons');\n\nvar pb = protons(require('./unixfs.proto'));\nvar unixfsData = pb.Data;\n\nvar errcode = require('err-code');\n\nvar types = ['raw', 'directory', 'file', 'metadata', 'symlink', 'hamt-sharded-directory'];\nvar dirTypes = ['directory', 'hamt-sharded-directory'];\nvar DEFAULT_FILE_MODE = parseInt('0644', 8);\nvar DEFAULT_DIRECTORY_MODE = parseInt('0755', 8);\n\nfunction parseArgs(args) {\n  if (args.length === 0) {\n    return {\n      type: 'file'\n    };\n  }\n\n  if (args.length === 2) {\n    // support old-style constructor\n    return {\n      type: args[0],\n      data: args[1]\n    };\n  }\n\n  if (typeof args[0] === 'string' || args[0] instanceof String) {\n    return {\n      type: args[0]\n    };\n  }\n\n  return args[0];\n}\n\nfunction parseMtime(mtime) {\n  if (mtime == null) {\n    return undefined;\n  } // { secs, nsecs }\n\n\n  if (Object.prototype.hasOwnProperty.call(mtime, 'secs')) {\n    mtime = {\n      secs: mtime.secs,\n      nsecs: mtime.nsecs\n    };\n  } // UnixFS TimeSpec\n\n\n  if (Object.prototype.hasOwnProperty.call(mtime, 'Seconds')) {\n    mtime = {\n      secs: mtime.Seconds,\n      nsecs: mtime.FractionalNanoseconds\n    };\n  } // process.hrtime()\n\n\n  if (Array.isArray(mtime)) {\n    mtime = {\n      secs: mtime[0],\n      nsecs: mtime[1]\n    };\n  } // Javascript Date\n\n\n  if (mtime instanceof Date) {\n    var ms = mtime.getTime();\n    var secs = Math.floor(ms / 1000);\n    mtime = {\n      secs: secs,\n      nsecs: (ms - secs * 1000) * 1000\n    };\n  }\n  /*\n  TODO: https://github.com/ipfs/aegir/issues/487\n   // process.hrtime.bigint()\n  if (typeof mtime === 'bigint') {\n    const secs = mtime / BigInt(1e9)\n    const nsecs = mtime - (secs * BigInt(1e9))\n     mtime = {\n      secs: parseInt(secs),\n      nsecs: parseInt(nsecs)\n    }\n  }\n  */\n\n\n  if (!Object.prototype.hasOwnProperty.call(mtime, 'secs')) {\n    return undefined;\n  }\n\n  if (mtime.nsecs < 0 || mtime.nsecs > 999999999) {\n    throw errcode(new Error('mtime-nsecs must be within the range [0,999999999]'), 'ERR_INVALID_MTIME_NSECS');\n  }\n\n  return mtime;\n}\n\nfunction parseMode(mode) {\n  if (mode == null) {\n    return undefined;\n  }\n\n  if (typeof mode === 'string' || mode instanceof String) {\n    mode = parseInt(mode, 8);\n  }\n\n  return mode & 0xFFF;\n}\n\nvar Data = /*#__PURE__*/function () {\n  function Data() {\n    _classCallCheck(this, Data);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var _parseArgs = parseArgs(args),\n        type = _parseArgs.type,\n        data = _parseArgs.data,\n        blockSizes = _parseArgs.blockSizes,\n        hashType = _parseArgs.hashType,\n        fanout = _parseArgs.fanout,\n        mtime = _parseArgs.mtime,\n        mode = _parseArgs.mode;\n\n    if (!types.includes(type)) {\n      throw errcode(new Error('Type: ' + type + ' is not valid'), 'ERR_INVALID_TYPE');\n    }\n\n    this.type = type;\n    this.data = data;\n    this.hashType = hashType;\n    this.fanout = fanout;\n    this.blockSizes = blockSizes || [];\n    var parsedMode = parseMode(mode);\n\n    if (parsedMode !== undefined) {\n      this.mode = parsedMode;\n    }\n\n    if (this.mode === undefined && type === 'file') {\n      this.mode = DEFAULT_FILE_MODE;\n    }\n\n    if (this.mode === undefined && this.isDirectory()) {\n      this.mode = DEFAULT_DIRECTORY_MODE;\n    }\n\n    var parsedMtime = parseMtime(mtime);\n\n    if (parsedMtime) {\n      this.mtime = parsedMtime;\n    }\n  }\n\n  _createClass(Data, [{\n    key: \"isDirectory\",\n    value: function isDirectory() {\n      return dirTypes.includes(this.type);\n    }\n  }, {\n    key: \"addBlockSize\",\n    value: function addBlockSize(size) {\n      this.blockSizes.push(size);\n    }\n  }, {\n    key: \"removeBlockSize\",\n    value: function removeBlockSize(index) {\n      this.blockSizes.splice(index, 1);\n    } // data.length + blockSizes\n\n  }, {\n    key: \"fileSize\",\n    value: function fileSize() {\n      if (this.isDirectory()) {\n        // dirs don't have file size\n        return undefined;\n      }\n\n      var sum = 0;\n      this.blockSizes.forEach(function (size) {\n        sum += size;\n      });\n\n      if (this.data) {\n        sum += this.data.length;\n      }\n\n      return sum;\n    } // encode to protobuf\n\n  }, {\n    key: \"marshal\",\n    value: function marshal() {\n      var type;\n\n      switch (this.type) {\n        case 'raw':\n          type = unixfsData.DataType.Raw;\n          break;\n\n        case 'directory':\n          type = unixfsData.DataType.Directory;\n          break;\n\n        case 'file':\n          type = unixfsData.DataType.File;\n          break;\n\n        case 'metadata':\n          type = unixfsData.DataType.Metadata;\n          break;\n\n        case 'symlink':\n          type = unixfsData.DataType.Symlink;\n          break;\n\n        case 'hamt-sharded-directory':\n          type = unixfsData.DataType.HAMTShard;\n          break;\n\n        default:\n          throw errcode(new Error('Type: ' + type + ' is not valid'), 'ERR_INVALID_TYPE');\n      }\n\n      var data = this.data;\n\n      if (!this.data || !this.data.length) {\n        data = undefined;\n      }\n\n      var blockSizes = this.blockSizes;\n\n      if (!this.blockSizes || !this.blockSizes.length) {\n        blockSizes = undefined;\n      }\n\n      var mode;\n\n      if (this.mode != null) {\n        mode = this._originalMode & 0xFFFFF000 | parseMode(this.mode);\n\n        if (mode === DEFAULT_FILE_MODE && this.type === 'file') {\n          mode = undefined;\n        }\n\n        if (mode === DEFAULT_DIRECTORY_MODE && this.isDirectory()) {\n          mode = undefined;\n        }\n      }\n\n      var mtime;\n\n      if (this.mtime != null) {\n        var parsed = parseMtime(this.mtime);\n\n        if (parsed) {\n          mtime = {\n            Seconds: parsed.secs,\n            FractionalNanoseconds: parsed.nsecs\n          };\n\n          if (mtime.FractionalNanoseconds === 0) {\n            delete mtime.FractionalNanoseconds;\n          }\n        }\n      }\n\n      return unixfsData.encode({\n        Type: type,\n        Data: data,\n        filesize: this.fileSize(),\n        blocksizes: blockSizes,\n        hashType: this.hashType,\n        fanout: this.fanout,\n        mode: mode,\n        mtime: mtime\n      });\n    }\n  }], [{\n    key: \"unmarshal\",\n    value: // decode from protobuf https://github.com/ipfs/specs/blob/master/UNIXFS.md\n    function unmarshal(marshaled) {\n      var decoded = unixfsData.decode(marshaled);\n      var data = new Data({\n        type: types[decoded.Type],\n        data: decoded.hasData() ? decoded.Data : undefined,\n        blockSizes: decoded.blocksizes,\n        mode: decoded.hasMode() ? decoded.mode : undefined,\n        mtime: decoded.hasMtime() ? decoded.mtime : undefined\n      }); // make sure we honor the original mode\n\n      data._originalMode = decoded.hasMode() ? decoded.mode : undefined;\n      return data;\n    }\n  }]);\n\n  return Data;\n}();\n\nmodule.exports = Data;","map":null,"metadata":{},"sourceType":"script"}