{"ast":null,"code":"'use strict'; // JS treats subjects of bitwise operators as SIGNED 32 bit numbers,\n// which means the maximum amount of bits we can store inside each byte\n// is 7..\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar BITS_PER_BYTE = 7;\n\nmodule.exports = /*#__PURE__*/function () {\n  function SparseArray() {\n    _classCallCheck(this, SparseArray);\n\n    this._bitArrays = [];\n    this._data = [];\n    this._length = 0;\n    this._changedLength = false;\n    this._changedData = false;\n  }\n\n  _createClass(SparseArray, [{\n    key: \"set\",\n    value: function set(index, value) {\n      var pos = this._internalPositionFor(index, false);\n\n      if (value === undefined) {\n        // unsetting\n        if (pos !== -1) {\n          // remove item from bit array and array itself\n          this._unsetInternalPos(pos);\n\n          this._unsetBit(index);\n\n          this._changedLength = true;\n          this._changedData = true;\n        }\n      } else {\n        var needsSort = false;\n\n        if (pos === -1) {\n          pos = this._data.length;\n\n          this._setBit(index);\n\n          this._changedData = true;\n        } else {\n          needsSort = true;\n        }\n\n        this._setInternalPos(pos, index, value, needsSort);\n\n        this._changedLength = true;\n      }\n    }\n  }, {\n    key: \"unset\",\n    value: function unset(index) {\n      this.set(index, undefined);\n    }\n  }, {\n    key: \"get\",\n    value: function get(index) {\n      this._sortData();\n\n      var pos = this._internalPositionFor(index, true);\n\n      if (pos === -1) {\n        return undefined;\n      }\n\n      return this._data[pos][1];\n    }\n  }, {\n    key: \"push\",\n    value: function push(value) {\n      this.set(this.length, value);\n      return this.length;\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      this._sortData();\n\n      if (this._changedLength) {\n        var last = this._data[this._data.length - 1];\n        this._length = last ? last[0] + 1 : 0;\n        this._changedLength = false;\n      }\n\n      return this._length;\n    }\n  }, {\n    key: \"forEach\",\n    value: function forEach(iterator) {\n      var i = 0;\n\n      while (i < this.length) {\n        iterator(this.get(i), i, this);\n        i++;\n      }\n    }\n  }, {\n    key: \"map\",\n    value: function map(iterator) {\n      var i = 0;\n      var mapped = new Array(this.length);\n\n      while (i < this.length) {\n        mapped[i] = iterator(this.get(i), i, this);\n        i++;\n      }\n\n      return mapped;\n    }\n  }, {\n    key: \"reduce\",\n    value: function reduce(reducer, initialValue) {\n      var i = 0;\n      var acc = initialValue;\n\n      while (i < this.length) {\n        var value = this.get(i);\n        acc = reducer(acc, value, i);\n        i++;\n      }\n\n      return acc;\n    }\n  }, {\n    key: \"find\",\n    value: function find(finder) {\n      var i = 0,\n          found,\n          last;\n\n      while (i < this.length && !found) {\n        last = this.get(i);\n        found = finder(last);\n        i++;\n      }\n\n      return found ? last : undefined;\n    }\n  }, {\n    key: \"_internalPositionFor\",\n    value: function _internalPositionFor(index, noCreate) {\n      var bytePos = this._bytePosFor(index, noCreate);\n\n      if (bytePos >= this._bitArrays.length) {\n        return -1;\n      }\n\n      var byte = this._bitArrays[bytePos];\n      var bitPos = index - bytePos * BITS_PER_BYTE;\n      var exists = (byte & 1 << bitPos) > 0;\n\n      if (!exists) {\n        return -1;\n      }\n\n      var previousPopCount = this._bitArrays.slice(0, bytePos).reduce(popCountReduce, 0);\n\n      var mask = ~(0xffffffff << bitPos + 1);\n      var bytePopCount = popCount(byte & mask);\n      var arrayPos = previousPopCount + bytePopCount - 1;\n      return arrayPos;\n    }\n  }, {\n    key: \"_bytePosFor\",\n    value: function _bytePosFor(index, noCreate) {\n      var bytePos = Math.floor(index / BITS_PER_BYTE);\n      var targetLength = bytePos + 1;\n\n      while (!noCreate && this._bitArrays.length < targetLength) {\n        this._bitArrays.push(0);\n      }\n\n      return bytePos;\n    }\n  }, {\n    key: \"_setBit\",\n    value: function _setBit(index) {\n      var bytePos = this._bytePosFor(index, false);\n\n      this._bitArrays[bytePos] |= 1 << index - bytePos * BITS_PER_BYTE;\n    }\n  }, {\n    key: \"_unsetBit\",\n    value: function _unsetBit(index) {\n      var bytePos = this._bytePosFor(index, false);\n\n      this._bitArrays[bytePos] &= ~(1 << index - bytePos * BITS_PER_BYTE);\n    }\n  }, {\n    key: \"_setInternalPos\",\n    value: function _setInternalPos(pos, index, value, needsSort) {\n      var data = this._data;\n      var elem = [index, value];\n\n      if (needsSort) {\n        this._sortData();\n\n        data[pos] = elem;\n      } else {\n        // new element. just shove it into the array\n        // but be nice about where we shove it\n        // in order to make sorting it later easier\n        if (data.length) {\n          if (data[data.length - 1][0] >= index) {\n            data.push(elem);\n          } else if (data[0][0] <= index) {\n            data.unshift(elem);\n          } else {\n            var randomIndex = Math.round(data.length / 2);\n            this._data = data.slice(0, randomIndex).concat(elem).concat(data.slice(randomIndex));\n          }\n        } else {\n          this._data.push(elem);\n        }\n\n        this._changedData = true;\n        this._changedLength = true;\n      }\n    }\n  }, {\n    key: \"_unsetInternalPos\",\n    value: function _unsetInternalPos(pos) {\n      this._data.splice(pos, 1);\n    }\n  }, {\n    key: \"_sortData\",\n    value: function _sortData() {\n      if (this._changedData) {\n        this._data.sort(sortInternal);\n      }\n\n      this._changedData = false;\n    }\n  }, {\n    key: \"bitField\",\n    value: function bitField() {\n      var bytes = [];\n      var pendingBitsForResultingByte = 8;\n      var pendingBitsForNewByte = 0;\n      var resultingByte = 0;\n      var newByte;\n\n      var pending = this._bitArrays.slice();\n\n      while (pending.length || pendingBitsForNewByte) {\n        if (pendingBitsForNewByte === 0) {\n          newByte = pending.shift();\n          pendingBitsForNewByte = 7;\n        }\n\n        var usingBits = Math.min(pendingBitsForNewByte, pendingBitsForResultingByte);\n        var mask = ~(255 << usingBits);\n        var masked = newByte & mask;\n        resultingByte |= masked << 8 - pendingBitsForResultingByte;\n        newByte = newByte >>> usingBits;\n        pendingBitsForNewByte -= usingBits;\n        pendingBitsForResultingByte -= usingBits;\n\n        if (!pendingBitsForResultingByte || !pendingBitsForNewByte && !pending.length) {\n          bytes.push(resultingByte);\n          resultingByte = 0;\n          pendingBitsForResultingByte = 8;\n        }\n      } // remove trailing zeroes\n\n\n      for (var i = bytes.length - 1; i > 0; i--) {\n        var value = bytes[i];\n\n        if (value === 0) {\n          bytes.pop();\n        } else {\n          break;\n        }\n      }\n\n      return bytes;\n    }\n  }, {\n    key: \"compactArray\",\n    value: function compactArray() {\n      this._sortData();\n\n      return this._data.map(valueOnly);\n    }\n  }]);\n\n  return SparseArray;\n}();\n\nfunction popCountReduce(count, byte) {\n  return count + popCount(byte);\n}\n\nfunction popCount(_v) {\n  var v = _v;\n  v = v - (v >> 1 & 0x55555555); // reuse input as temporary\n\n  v = (v & 0x33333333) + (v >> 2 & 0x33333333); // temp\n\n  return (v + (v >> 4) & 0xF0F0F0F) * 0x1010101 >> 24;\n}\n\nfunction sortInternal(a, b) {\n  return a[0] - b[0];\n}\n\nfunction valueOnly(elem) {\n  return elem[1];\n}","map":null,"metadata":{},"sourceType":"script"}