{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nrequire('node-forge/lib/x509');\n\nvar forge = require('node-forge/lib/forge');\n\nvar pki = forge.pki;\nexports = module.exports;\n/**\n * Gets a self-signed X.509 certificate for the key.\n *\n * The output Buffer contains the PKCS #7 message in DER.\n *\n * TODO: move to libp2p-crypto package\n *\n * @param {KeyInfo} key - The id and name of the key\n * @param {RsaPrivateKey} privateKey - The naked key\n * @returns {undefined}\n */\n\nexports.certificateForKey = function (key, privateKey) {\n  var publicKey = pki.setRsaPublicKey(privateKey.n, privateKey.e);\n  var cert = pki.createCertificate();\n  cert.publicKey = publicKey;\n  cert.serialNumber = '01';\n  cert.validity.notBefore = new Date();\n  cert.validity.notAfter = new Date();\n  cert.validity.notAfter.setFullYear(cert.validity.notBefore.getFullYear() + 10);\n  var attrs = [{\n    name: 'organizationName',\n    value: 'ipfs'\n  }, {\n    shortName: 'OU',\n    value: 'keystore'\n  }, {\n    name: 'commonName',\n    value: key.id\n  }];\n  cert.setSubject(attrs);\n  cert.setIssuer(attrs);\n  cert.setExtensions([{\n    name: 'basicConstraints',\n    cA: true\n  }, {\n    name: 'keyUsage',\n    keyCertSign: true,\n    digitalSignature: true,\n    nonRepudiation: true,\n    keyEncipherment: true,\n    dataEncipherment: true\n  }, {\n    name: 'extKeyUsage',\n    serverAuth: true,\n    clientAuth: true,\n    codeSigning: true,\n    emailProtection: true,\n    timeStamping: true\n  }, {\n    name: 'nsCertType',\n    client: true,\n    server: true,\n    email: true,\n    objsign: true,\n    sslCA: true,\n    emailCA: true,\n    objCA: true\n  }]); // self-sign certificate\n\n  cert.sign(privateKey);\n  return cert;\n};\n/**\n * Finds the first item in a collection that is matched in the\n * `asyncCompare` function.\n *\n * `asyncCompare` is an async function that must\n * resolve to either `true` or `false`.\n *\n * @param {Array} array\n * @param {function(*)} asyncCompare An async function that returns a boolean\n */\n\n\nfunction findAsync(_x, _x2) {\n  return _findAsync.apply(this, arguments);\n}\n\nfunction _findAsync() {\n  _findAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(array, asyncCompare) {\n    var promises, results, index;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            promises = array.map(asyncCompare);\n            _context.next = 3;\n            return Promise.all(promises);\n\n          case 3:\n            results = _context.sent;\n            index = results.findIndex(function (result) {\n              return result;\n            });\n            return _context.abrupt(\"return\", array[index]);\n\n          case 6:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _findAsync.apply(this, arguments);\n}\n\nmodule.exports.findAsync = findAsync;","map":null,"metadata":{},"sourceType":"script"}