{"ast":null,"code":"'use strict';\n\nvar _defineProperty = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar Store = require('orbit-db-store');\n\nvar EventIndex = require('./EventIndex'); // TODO: generalize the Iterator functions and spin to its own module\n\n\nvar EventStore = /*#__PURE__*/function (_Store) {\n  _inherits(EventStore, _Store);\n\n  var _super = _createSuper(EventStore);\n\n  function EventStore(ipfs, id, dbname) {\n    var _this;\n\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    _classCallCheck(this, EventStore);\n\n    if (options.Index === undefined) Object.assign(options, {\n      Index: EventIndex\n    });\n    _this = _super.call(this, ipfs, id, dbname, options);\n    _this._type = 'eventlog';\n\n    _this.events.on(\"log.op.ADD\", function (address, hash, payload) {\n      _this.events.emit(\"db.append\", payload.value);\n    });\n\n    return _this;\n  }\n\n  _createClass(EventStore, [{\n    key: \"add\",\n    value: function add(data) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this._addOperation({\n        op: 'ADD',\n        key: null,\n        value: data\n      }, options);\n    }\n  }, {\n    key: \"get\",\n    value: function get(hash) {\n      return this.iterator({\n        gte: hash,\n        limit: 1\n      }).collect()[0];\n    }\n  }, {\n    key: \"iterator\",\n    value: function iterator(options) {\n      var _iterator;\n\n      var messages = this._query(options);\n\n      var currentIndex = 0;\n      var iterator = (_iterator = {}, _defineProperty(_iterator, Symbol.iterator, function () {\n        return this;\n      }), _defineProperty(_iterator, \"next\", function next() {\n        var item = {\n          value: null,\n          done: true\n        };\n\n        if (currentIndex < messages.length) {\n          item = {\n            value: messages[currentIndex],\n            done: false\n          };\n          currentIndex++;\n        }\n\n        return item;\n      }), _defineProperty(_iterator, \"collect\", function collect() {\n        return messages;\n      }), _iterator);\n      return iterator;\n    }\n  }, {\n    key: \"_query\",\n    value: function _query(opts) {\n      if (!opts) opts = {};\n      var amount = opts.limit ? opts.limit > -1 ? opts.limit : this._index.get().length : 1; // Return 1 if no limit is provided\n\n      var events = this._index.get().slice();\n\n      var result = [];\n\n      if (opts.gt || opts.gte) {\n        // Greater than case\n        result = this._read(events, opts.gt ? opts.gt : opts.gte, amount, !!opts.gte);\n      } else {\n        // Lower than and lastN case, search latest first by reversing the sequence\n        result = this._read(events.reverse(), opts.lt ? opts.lt : opts.lte, amount, opts.lte || !opts.lt).reverse();\n      }\n\n      if (opts.reverse) {\n        result.reverse();\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_read\",\n    value: function _read(ops, hash, amount, inclusive) {\n      // Find the index of the gt/lt hash, or start from the beginning of the array if not found\n      var index = ops.map(function (e) {\n        return e.hash;\n      }).indexOf(hash);\n      var startIndex = Math.max(index, 0); // If gte/lte is set, we include the given hash, if not, start from the next element\n\n      startIndex += inclusive ? 0 : 1; // Slice the array to its requested size\n\n      var res = ops.slice(startIndex).slice(0, amount);\n      return res;\n    }\n  }]);\n\n  return EventStore;\n}(Store);\n\nmodule.exports = EventStore;","map":null,"metadata":{},"sourceType":"script"}