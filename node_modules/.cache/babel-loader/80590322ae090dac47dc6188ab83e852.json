{"ast":null,"code":"/*!\n * chacha20.js - chacha20 for bcrypto\n * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Resources\n *   https://en.wikipedia.org/wiki/Chacha20\n *   https://tools.ietf.org/html/rfc7539#section-2\n *   https://cr.yp.to/chacha.html\n */\n'use strict';\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar assert = require('../internal/assert');\n/*\n * Constants\n */\n\n\nvar BIG_ENDIAN = new Int8Array(new Int16Array([1]).buffer)[0] === 0;\n/**\n * ChaCha20\n */\n\nvar ChaCha20 = /*#__PURE__*/function () {\n  /**\n   * Create a ChaCha20 context.\n   * @constructor\n   */\n  function ChaCha20() {\n    _classCallCheck(this, ChaCha20);\n\n    this.state = new Uint32Array(16);\n    this.stream = new Uint32Array(16);\n    this.bytes = new Uint8Array(this.stream.buffer);\n    this.pos = -1;\n    if (BIG_ENDIAN) this.bytes = Buffer.alloc(64);\n  }\n  /**\n   * Initialize chacha20 with a key, nonce, and counter.\n   * @param {Buffer} key\n   * @param {Buffer} nonce\n   * @param {Number} counter\n   */\n\n\n  _createClass(ChaCha20, [{\n    key: \"init\",\n    value: function init(key, nonce, counter) {\n      if (counter == null) counter = 0;\n      assert(Buffer.isBuffer(key));\n      assert(Buffer.isBuffer(nonce));\n      assert(Number.isSafeInteger(counter));\n      if (key.length !== 16 && key.length !== 32) throw new RangeError('Invalid key size.');\n\n      if (nonce.length >= 24) {\n        key = ChaCha20.derive(key, nonce.slice(0, 16));\n        nonce = nonce.slice(16);\n      }\n\n      this.state[0] = 0x61707865;\n      this.state[1] = key.length < 32 ? 0x3120646e : 0x3320646e;\n      this.state[2] = key.length < 32 ? 0x79622d36 : 0x79622d32;\n      this.state[3] = 0x6b206574;\n      this.state[4] = readU32(key, 0);\n      this.state[5] = readU32(key, 4);\n      this.state[6] = readU32(key, 8);\n      this.state[7] = readU32(key, 12);\n      this.state[8] = readU32(key, 16 % key.length);\n      this.state[9] = readU32(key, 20 % key.length);\n      this.state[10] = readU32(key, 24 % key.length);\n      this.state[11] = readU32(key, 28 % key.length);\n      this.state[12] = counter >>> 0;\n\n      if (nonce.length === 8) {\n        this.state[13] = counter / 0x100000000 >>> 0;\n        this.state[14] = readU32(nonce, 0);\n        this.state[15] = readU32(nonce, 4);\n      } else if (nonce.length === 12) {\n        this.state[13] = readU32(nonce, 0);\n        this.state[14] = readU32(nonce, 4);\n        this.state[15] = readU32(nonce, 8);\n      } else if (nonce.length === 16) {\n        this.state[12] = readU32(nonce, 0);\n        this.state[13] = readU32(nonce, 4);\n        this.state[14] = readU32(nonce, 8);\n        this.state[15] = readU32(nonce, 12);\n      } else {\n        throw new RangeError('Invalid nonce size.');\n      }\n\n      this.pos = 0;\n      return this;\n    }\n    /**\n     * Encrypt/decrypt data.\n     * @param {Buffer} data - Will be mutated.\n     * @returns {Buffer}\n     */\n\n  }, {\n    key: \"encrypt\",\n    value: function encrypt(data) {\n      assert(Buffer.isBuffer(data));\n      if (this.pos === -1) throw new Error('Context is not initialized.');\n\n      for (var i = 0; i < data.length; i++) {\n        if ((this.pos & 63) === 0) {\n          this._block();\n\n          this.pos = 0;\n        }\n\n        data[i] ^= this.bytes[this.pos++];\n      }\n\n      return data;\n    }\n    /**\n     * Stir the stream.\n     */\n\n  }, {\n    key: \"_block\",\n    value: function _block() {\n      for (var i = 0; i < 16; i++) {\n        this.stream[i] = this.state[i];\n      }\n\n      for (var _i = 0; _i < 10; _i++) {\n        qround(this.stream, 0, 4, 8, 12);\n        qround(this.stream, 1, 5, 9, 13);\n        qround(this.stream, 2, 6, 10, 14);\n        qround(this.stream, 3, 7, 11, 15);\n        qround(this.stream, 0, 5, 10, 15);\n        qround(this.stream, 1, 6, 11, 12);\n        qround(this.stream, 2, 7, 8, 13);\n        qround(this.stream, 3, 4, 9, 14);\n      }\n\n      for (var _i2 = 0; _i2 < 16; _i2++) {\n        this.stream[_i2] += this.state[_i2];\n      }\n\n      if (BIG_ENDIAN) {\n        for (var _i3 = 0; _i3 < 16; _i3++) {\n          writeU32(this.bytes, this.stream[_i3], _i3 * 4);\n        }\n      }\n\n      this.state[12] += 1;\n      if (this.state[12] === 0) this.state[13] += 1;\n    }\n    /**\n     * Destroy context.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      for (var i = 0; i < 16; i++) {\n        this.state[i] = 0;\n        this.stream[i] = 0;\n      }\n\n      if (BIG_ENDIAN) {\n        for (var _i4 = 0; _i4 < 64; _i4++) {\n          this.bytes[_i4] = 0;\n        }\n      }\n\n      this.pos = -1;\n      return this;\n    }\n    /**\n     * Derive key with XChaCha20.\n     * @param {Buffer} key\n     * @param {Buffer} nonce\n     * @returns {Buffer}\n     */\n\n  }], [{\n    key: \"derive\",\n    value: function derive(key, nonce) {\n      assert(Buffer.isBuffer(key));\n      assert(Buffer.isBuffer(nonce));\n      if (key.length !== 16 && key.length !== 32) throw new RangeError('Invalid key size.');\n      if (nonce.length !== 16) throw new RangeError('Invalid nonce size.');\n      var state = new Uint32Array(16);\n      state[0] = 0x61707865;\n      state[1] = key.length < 32 ? 0x3120646e : 0x3320646e;\n      state[2] = key.length < 32 ? 0x79622d36 : 0x79622d32;\n      state[3] = 0x6b206574;\n      state[4] = readU32(key, 0);\n      state[5] = readU32(key, 4);\n      state[6] = readU32(key, 8);\n      state[7] = readU32(key, 12);\n      state[8] = readU32(key, 16 % key.length);\n      state[9] = readU32(key, 20 % key.length);\n      state[10] = readU32(key, 24 % key.length);\n      state[11] = readU32(key, 28 % key.length);\n      state[12] = readU32(nonce, 0);\n      state[13] = readU32(nonce, 4);\n      state[14] = readU32(nonce, 8);\n      state[15] = readU32(nonce, 12);\n\n      for (var i = 0; i < 10; i++) {\n        qround(state, 0, 4, 8, 12);\n        qround(state, 1, 5, 9, 13);\n        qround(state, 2, 6, 10, 14);\n        qround(state, 3, 7, 11, 15);\n        qround(state, 0, 5, 10, 15);\n        qround(state, 1, 6, 11, 12);\n        qround(state, 2, 7, 8, 13);\n        qround(state, 3, 4, 9, 14);\n      }\n\n      var out = Buffer.alloc(32);\n      writeU32(out, state[0], 0);\n      writeU32(out, state[1], 4);\n      writeU32(out, state[2], 8);\n      writeU32(out, state[3], 12);\n      writeU32(out, state[12], 16);\n      writeU32(out, state[13], 20);\n      writeU32(out, state[14], 24);\n      writeU32(out, state[15], 28);\n      return out;\n    }\n  }]);\n\n  return ChaCha20;\n}();\n/*\n * Static\n */\n\n\nChaCha20.native = 0;\n/*\n * Helpers\n */\n\nfunction qround(x, a, b, c, d) {\n  x[a] += x[b];\n  x[d] = rotl32(x[d] ^ x[a], 16);\n  x[c] += x[d];\n  x[b] = rotl32(x[b] ^ x[c], 12);\n  x[a] += x[b];\n  x[d] = rotl32(x[d] ^ x[a], 8);\n  x[c] += x[d];\n  x[b] = rotl32(x[b] ^ x[c], 7);\n}\n\nfunction rotl32(w, b) {\n  return w << b | w >>> 32 - b;\n}\n\nfunction readU32(data, off) {\n  return data[off++] + data[off++] * 0x100 + data[off++] * 0x10000 + data[off] * 0x1000000;\n}\n\nfunction writeU32(dst, num, off) {\n  dst[off++] = num;\n  num >>>= 8;\n  dst[off++] = num;\n  num >>>= 8;\n  dst[off++] = num;\n  num >>>= 8;\n  dst[off++] = num;\n  return off;\n}\n/*\n * Expose\n */\n\n\nmodule.exports = ChaCha20;","map":null,"metadata":{},"sourceType":"script"}