{"ast":null,"code":"var _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar pMap = require('p-map');\n\nvar Log = require('ipfs-log');\n\nvar Logger = require('logplease');\n\nvar logger = Logger.create('replicator', {\n  color: Logger.Colors.Cyan\n});\nLogger.setLogLevel('ERROR');\n\nvar getNext = function getNext(e) {\n  return e.next;\n};\n\nvar flatMap = function flatMap(res, val) {\n  return res.concat(val);\n};\n\nvar notNull = function notNull(entry) {\n  return entry !== null && entry !== undefined;\n};\n\nvar uniqueValues = function uniqueValues(res, val) {\n  res[val] = val;\n  return res;\n};\n\nvar batchSize = 1;\n\nvar Replicator = /*#__PURE__*/function (_EventEmitter) {\n  \"use strict\";\n\n  _inherits(Replicator, _EventEmitter);\n\n  var _super = _createSuper(Replicator);\n\n  function Replicator(store, concurrency) {\n    var _this;\n\n    _classCallCheck(this, Replicator);\n\n    _this = _super.call(this);\n    _this._store = store;\n    _this._fetching = {};\n    _this._stats = {\n      tasksRequested: 0,\n      tasksStarted: 0,\n      tasksProcessed: 0\n    };\n    _this._buffer = [];\n    _this._concurrency = concurrency || 128;\n    _this._queue = {};\n    _this._q = new Set(); // Flush the queue as an emergency switch\n\n    _this._flushTimer = setInterval(function () {\n      if (_this.tasksRunning === 0 && Object.keys(_this._queue).length > 0) {\n        logger.warn('Had to flush the queue!', Object.keys(_this._queue).length, 'items in the queue, ', _this.tasksRequested, _this.tasksFinished, ' tasks requested/finished');\n        setTimeout(function () {\n          return _this._processQueue();\n        }, 0);\n      }\n    }, 3000);\n    return _this;\n  }\n  /**\n   * Returns the number of tasks started during the life time\n   * @return {[Integer]} [Number of tasks started]\n   */\n\n\n  _createClass(Replicator, [{\n    key: \"tasksRequested\",\n    get: function get() {\n      return this._stats.tasksRequested;\n    }\n    /**\n     * Returns the number of tasks started during the life time\n     * @return {[Integer]} [Number of tasks running]\n     */\n\n  }, {\n    key: \"tasksStarted\",\n    get: function get() {\n      return this._stats.tasksStarted;\n    }\n    /**\n     * Returns the number of tasks running currently\n     * @return {[Integer]} [Number of tasks running]\n     */\n\n  }, {\n    key: \"tasksRunning\",\n    get: function get() {\n      return this._stats.tasksStarted - this._stats.tasksProcessed;\n    }\n    /**\n     * Returns the number of tasks currently queued\n     * @return {[Integer]} [Number of tasks queued]\n     */\n\n  }, {\n    key: \"tasksQueued\",\n    get: function get() {\n      return Math.max(Object.keys(this._queue).length - this.tasksRunning, 0);\n    }\n    /**\n     * Returns the number of tasks finished during the life time\n     * @return {[Integer]} [Number of tasks finished]\n     */\n\n  }, {\n    key: \"tasksFinished\",\n    get: function get() {\n      return this._stats.tasksProcessed;\n    }\n    /**\n     * Returns the hashes currently queued\n     * @return {[Array<String>]} [Queued hashes]\n     */\n\n  }, {\n    key: \"getQueue\",\n    value: function getQueue() {\n      return Object.values(this._queue);\n    }\n    /*\n      Process new heads.\n     */\n\n  }, {\n    key: \"load\",\n    value: function load(entries) {\n      var _this2 = this;\n\n      var notKnown = function notKnown(entry) {\n        var hash = entry.hash || entry;\n        return !_this2._store._oplog.has(hash) && !_this2._fetching[hash] && !_this2._queue[hash];\n      };\n\n      try {\n        entries.filter(notNull).filter(notKnown).forEach(this._addToQueue.bind(this));\n        setTimeout(function () {\n          return _this2._processQueue();\n        }, 0);\n      } catch (e) {\n        console.error(e);\n      }\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      // Clears the queue flusher\n      clearInterval(this._flushTimer); // Remove event listeners\n\n      this.removeAllListeners('load.added');\n      this.removeAllListeners('load.end');\n      this.removeAllListeners('load.progress');\n    }\n  }, {\n    key: \"_addToQueue\",\n    value: function _addToQueue(entry) {\n      var hash = entry.hash || entry;\n      this._stats.tasksRequested += 1;\n      this._queue[hash] = entry;\n    }\n  }, {\n    key: \"_processQueue\",\n    value: function () {\n      var _processQueue2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this3 = this;\n\n        var capacity, items, flattenAndGetUniques, processValues;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(this.tasksRunning < this._concurrency)) {\n                  _context.next = 7;\n                  break;\n                }\n\n                capacity = this._concurrency - this.tasksRunning;\n                items = Object.values(this._queue).slice(0, capacity).filter(notNull);\n                items.forEach(function (entry) {\n                  return delete _this3._queue[entry.hash || entry];\n                });\n\n                flattenAndGetUniques = function flattenAndGetUniques(nexts) {\n                  return nexts.reduce(flatMap, []).reduce(uniqueValues, {});\n                };\n\n                processValues = function processValues(nexts) {\n                  var values = Object.values(nexts).filter(notNull);\n\n                  if (items.length > 0 && _this3._buffer.length > 0 || _this3.tasksRunning === 0 && _this3._buffer.length > 0) {\n                    var logs = _this3._buffer.slice();\n\n                    _this3._buffer = [];\n\n                    _this3.emit('load.end', logs);\n                  }\n\n                  if (values.length > 0) {\n                    _this3.load(values);\n                  }\n                };\n\n                return _context.abrupt(\"return\", pMap(items, function (e) {\n                  return _this3._processOne(e);\n                }).then(flattenAndGetUniques).then(processValues));\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function _processQueue() {\n        return _processQueue2.apply(this, arguments);\n      }\n\n      return _processQueue;\n    }()\n  }, {\n    key: \"_processOne\",\n    value: function () {\n      var _processOne2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(entry) {\n        var hash, exclude, log, latest;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                hash = entry.hash || entry;\n\n                if (!(this._store._oplog.has(hash) || this._fetching[hash])) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 3:\n                this._fetching[hash] = hash;\n                this.emit('load.added', entry);\n                this._stats.tasksStarted += 1;\n                exclude = [];\n                _context2.next = 9;\n                return Log.fromEntryHash(this._store._ipfs, this._store.identity, hash, {\n                  logId: this._store._oplog.id,\n                  access: this._store.access,\n                  length: batchSize,\n                  exclude: exclude\n                });\n\n              case 9:\n                log = _context2.sent;\n\n                this._buffer.push(log);\n\n                latest = log.values[0];\n                delete this._queue[hash]; // Mark this task as processed\n\n                this._stats.tasksProcessed += 1; // Notify subscribers that we made progress\n\n                this.emit('load.progress', this._id, hash, latest, null, this._buffer.length); // Return all next pointers\n\n                return _context2.abrupt(\"return\", log.values.map(getNext).reduce(flatMap, []));\n\n              case 16:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _processOne(_x) {\n        return _processOne2.apply(this, arguments);\n      }\n\n      return _processOne;\n    }()\n  }]);\n\n  return Replicator;\n}(EventEmitter);\n\nmodule.exports = Replicator;","map":null,"metadata":{},"sourceType":"script"}