{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _didJwt = require(\"did-jwt\");\n\nvar _ipfsDidDocument = _interopRequireDefault(require(\"ipfs-did-document\"));\n\nvar _base64url = _interopRequireDefault(require(\"base64url\"));\n\nvar _didResolver = require(\"did-resolver\");\n\nvar PUBKEY_IDS = ['signingKey', 'managementKey', 'encryptionKey'];\nvar SUB_PUBKEY_IDS = ['subSigningKey', 'subEncryptionKey'];\n\nfunction validateDoc(doc) {\n  var pubKeyIds = PUBKEY_IDS;\n\n  if (!doc || !doc.publicKey || !doc.authentication) {\n    throw new Error('Not a valid 3ID');\n  }\n\n  if (doc.root) {\n    pubKeyIds = SUB_PUBKEY_IDS;\n    if (!doc.space) throw new Error('Not a valid 3ID');\n  }\n\n  doc.publicKey.map(function (entry) {\n    var id = entry.id.split('#')[1];\n    if (!pubKeyIds.includes(id)) throw new Error('Not a valid 3ID');\n  });\n}\n\nfunction encodeSection(data) {\n  return _base64url[\"default\"].encode(JSON.stringify(data));\n}\n\nfunction verifyProof(_x, _x2) {\n  return _verifyProof.apply(this, arguments);\n}\n\nfunction _verifyProof() {\n  _verifyProof = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee3(subDoc, resolver) {\n    var subSigningKey, subEncryptionKey, payload, header, jwt;\n    return _regenerator[\"default\"].wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            subSigningKey = subDoc.publicKey.find(function (entry) {\n              return entry.id.includes(SUB_PUBKEY_IDS[0]);\n            }).publicKeyHex;\n            subEncryptionKey = subDoc.publicKey.find(function (entry) {\n              return entry.id.includes(SUB_PUBKEY_IDS[1]);\n            }).publicKeyBase64;\n            payload = encodeSection({\n              iat: null,\n              subSigningKey: subSigningKey,\n              subEncryptionKey: subEncryptionKey,\n              space: subDoc.space,\n              iss: subDoc.root\n            });\n            header = encodeSection({\n              typ: 'JWT',\n              alg: subDoc.proof.alg\n            });\n            jwt = \"\".concat(header, \".\").concat(payload, \".\").concat(subDoc.proof.signature);\n            _context3.next = 7;\n            return (0, _didJwt.verifyJWT)(jwt, {\n              resolver: resolver\n            });\n\n          case 7:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _verifyProof.apply(this, arguments);\n}\n\nfunction mergeDocuments(doc, subDoc) {\n  subDoc.publicKey = doc.publicKey.concat(subDoc.publicKey);\n  return subDoc;\n}\n\nfunction getResolver(ipfs) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      pin = _ref.pin;\n\n  function resolve(_x3, _x4) {\n    return _resolve2.apply(this, arguments);\n  }\n\n  function _resolve2() {\n    _resolve2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee2(did, parsed) {\n      var _resolve, _resolve3;\n\n      return _regenerator[\"default\"].wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _resolve3 = function _resolve5() {\n                _resolve3 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee(cid) {\n                  var isRoot,\n                      doc,\n                      rootDoc,\n                      _args = arguments;\n                  return _regenerator[\"default\"].wrap(function _callee$(_context) {\n                    while (1) {\n                      switch (_context.prev = _context.next) {\n                        case 0:\n                          isRoot = _args.length > 1 && _args[1] !== undefined ? _args[1] : false;\n                          _context.prev = 1;\n                          _context.next = 4;\n                          return _ipfsDidDocument[\"default\"].cidToDocument(ipfs, cid);\n\n                        case 4:\n                          doc = _context.sent;\n                          validateDoc(doc);\n\n                          if (!doc.root) {\n                            _context.next = 15;\n                            break;\n                          }\n\n                          if (!isRoot) {\n                            _context.next = 9;\n                            break;\n                          }\n\n                          throw new Error('Only one layer subDoc allowed');\n\n                        case 9:\n                          _context.next = 11;\n                          return _resolve(doc.root.split(':')[2], true);\n\n                        case 11:\n                          rootDoc = _context.sent;\n                          _context.next = 14;\n                          return verifyProof(doc, localResolver);\n\n                        case 14:\n                          doc = mergeDocuments(rootDoc, doc);\n\n                        case 15:\n                          if (!pin) {\n                            _context.next = 18;\n                            break;\n                          }\n\n                          _context.next = 18;\n                          return ipfs.pin.add(cid);\n\n                        case 18:\n                          _context.next = 31;\n                          break;\n\n                        case 20:\n                          _context.prev = 20;\n                          _context.t0 = _context[\"catch\"](1);\n                          _context.prev = 22;\n\n                          if (!pin) {\n                            _context.next = 26;\n                            break;\n                          }\n\n                          _context.next = 26;\n                          return ipfs.pin.rm(cid);\n\n                        case 26:\n                          _context.next = 30;\n                          break;\n\n                        case 28:\n                          _context.prev = 28;\n                          _context.t1 = _context[\"catch\"](22);\n\n                        case 30:\n                          throw new Error('Invalid 3ID');\n\n                        case 31:\n                          return _context.abrupt(\"return\", doc);\n\n                        case 32:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }\n                  }, _callee, null, [[1, 20], [22, 28]]);\n                }));\n                return _resolve3.apply(this, arguments);\n              };\n\n              _resolve = function _resolve4(_x5) {\n                return _resolve3.apply(this, arguments);\n              };\n\n              return _context2.abrupt(\"return\", _resolve(parsed.id));\n\n            case 3:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n    return _resolve2.apply(this, arguments);\n  }\n\n  var resolveMethods = {\n    '3': resolve\n  };\n  var localResolver = new _didResolver.Resolver(resolveMethods);\n  return resolveMethods;\n}\n\nmodule.exports = {\n  getResolver: getResolver\n};","map":null,"metadata":{},"sourceType":"script"}