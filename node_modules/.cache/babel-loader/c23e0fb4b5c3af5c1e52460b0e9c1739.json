{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar errcode = require('err-code');\n\nvar hmac = require('../hmac');\n\nvar cipherMap = {\n  'AES-128': {\n    ivSize: 16,\n    keySize: 16\n  },\n  'AES-256': {\n    ivSize: 16,\n    keySize: 32\n  },\n  Blowfish: {\n    ivSize: 8,\n    cipherKeySize: 32\n  }\n}; // Generates a set of keys for each party by stretching the shared key.\n// (myIV, theirIV, myCipherKey, theirCipherKey, myMACKey, theirMACKey)\n\nmodule.exports = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(cipherType, hash, secret) {\n    var cipher, allowed, cipherKeySize, ivSize, hmacKeySize, seed, resultLength, m, a, result, j, b, todo, half, resultBuffer, r1, r2, createKey;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            cipher = cipherMap[cipherType];\n\n            if (cipher) {\n              _context.next = 4;\n              break;\n            }\n\n            allowed = Object.keys(cipherMap).join(' / ');\n            throw errcode(new Error(\"unknown cipher type '\".concat(cipherType, \"'. Must be \").concat(allowed)), 'ERR_INVALID_CIPHER_TYPE');\n\n          case 4:\n            if (hash) {\n              _context.next = 6;\n              break;\n            }\n\n            throw errcode(new Error('missing hash type'), 'ERR_MISSING_HASH_TYPE');\n\n          case 6:\n            cipherKeySize = cipher.keySize;\n            ivSize = cipher.ivSize;\n            hmacKeySize = 20;\n            seed = Buffer.from('key expansion');\n            resultLength = 2 * (ivSize + cipherKeySize + hmacKeySize);\n            _context.next = 13;\n            return hmac.create(hash, secret);\n\n          case 13:\n            m = _context.sent;\n            _context.next = 16;\n            return m.digest(seed);\n\n          case 16:\n            a = _context.sent;\n            result = [];\n            j = 0;\n\n          case 19:\n            if (!(j < resultLength)) {\n              _context.next = 32;\n              break;\n            }\n\n            _context.next = 22;\n            return m.digest(Buffer.concat([a, seed]));\n\n          case 22:\n            b = _context.sent;\n            todo = b.length;\n\n            if (j + todo > resultLength) {\n              todo = resultLength - j;\n            }\n\n            result.push(b);\n            j += todo;\n            _context.next = 29;\n            return m.digest(a);\n\n          case 29:\n            a = _context.sent;\n            _context.next = 19;\n            break;\n\n          case 32:\n            half = resultLength / 2;\n            resultBuffer = Buffer.concat(result);\n            r1 = resultBuffer.slice(0, half);\n            r2 = resultBuffer.slice(half, resultLength);\n\n            createKey = function createKey(res) {\n              return {\n                iv: res.slice(0, ivSize),\n                cipherKey: res.slice(ivSize, ivSize + cipherKeySize),\n                macKey: res.slice(ivSize + cipherKeySize)\n              };\n            };\n\n            return _context.abrupt(\"return\", {\n              k1: createKey(r1),\n              k2: createKey(r2)\n            });\n\n          case 38:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function (_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":null,"metadata":{},"sourceType":"script"}