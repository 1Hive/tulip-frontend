{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _require = require('ipld-dag-pb'),\n    DAGNode = _require.DAGNode,\n    DAGLink = _require.DAGLink;\n\nvar CID = require('cids');\n\nvar log = require('debug')('ipfs:mfs:core:utils:remove-link');\n\nvar UnixFS = require('ipfs-unixfs');\n\nvar _require2 = require('./hamt-utils'),\n    generatePath = _require2.generatePath,\n    updateHamtDirectory = _require2.updateHamtDirectory;\n\nvar errCode = require('err-code');\n\nvar mc = require('multicodec');\n\nvar mh = require('multihashes');\n\nvar removeLink = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(context, options) {\n    var meta;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!(!options.parentCid && !options.parent)) {\n              _context.next = 2;\n              break;\n            }\n\n            throw errCode(new Error('No parent node or CID passed to removeLink'), 'EINVALIDPARENT');\n\n          case 2:\n            if (!(options.parentCid && !CID.isCID(options.parentCid))) {\n              _context.next = 4;\n              break;\n            }\n\n            throw errCode(new Error('Invalid CID passed to removeLink'), 'EINVALIDPARENTCID');\n\n          case 4:\n            if (options.parent) {\n              _context.next = 9;\n              break;\n            }\n\n            log(\"Loading parent node \".concat(options.parentCid));\n            _context.next = 8;\n            return context.ipld.get(options.parentCid);\n\n          case 8:\n            options.parent = _context.sent;\n\n          case 9:\n            if (options.name) {\n              _context.next = 11;\n              break;\n            }\n\n            throw errCode(new Error('No child name passed to removeLink'), 'EINVALIDCHILDNAME');\n\n          case 11:\n            meta = UnixFS.unmarshal(options.parent.Data);\n\n            if (!(meta.type === 'hamt-sharded-directory')) {\n              _context.next = 15;\n              break;\n            }\n\n            log(\"Removing \".concat(options.name, \" from sharded directory\"));\n            return _context.abrupt(\"return\", removeFromShardedDirectory(context, options));\n\n          case 15:\n            log(\"Removing link \".concat(options.name, \" regular directory\"));\n            return _context.abrupt(\"return\", removeFromDirectory(context, options));\n\n          case 17:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function removeLink(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar removeFromDirectory = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(context, options) {\n    var hashAlg, cid;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            hashAlg = mh.names[options.hashAlg];\n            options.parent.rmLink(options.name);\n            _context2.next = 4;\n            return context.ipld.put(options.parent, mc.DAG_PB, {\n              cidVersion: options.cidVersion,\n              hashAlg: hashAlg\n            });\n\n          case 4:\n            cid = _context2.sent;\n            log(\"Updated regular directory \".concat(cid));\n            return _context2.abrupt(\"return\", {\n              node: options.parent,\n              cid: cid\n            });\n\n          case 7:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function removeFromDirectory(_x3, _x4) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nvar removeFromShardedDirectory = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(context, options) {\n    var _yield$generatePath, rootBucket, path, _yield$updateShard, node;\n\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return generatePath(context, options.name, options.parent);\n\n          case 2:\n            _yield$generatePath = _context3.sent;\n            rootBucket = _yield$generatePath.rootBucket;\n            path = _yield$generatePath.path;\n            _context3.next = 7;\n            return rootBucket.del(options.name);\n\n          case 7:\n            _context3.next = 9;\n            return updateShard(context, path, {\n              name: options.name,\n              cid: options.cid,\n              size: options.size,\n              hashAlg: options.hashAlg,\n              cidVersion: options.cidVersion,\n              flush: options.flush\n            }, options);\n\n          case 9:\n            _yield$updateShard = _context3.sent;\n            node = _yield$updateShard.node;\n            return _context3.abrupt(\"return\", updateHamtDirectory(context, node.Links, rootBucket, options));\n\n          case 12:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function removeFromShardedDirectory(_x5, _x6) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nvar updateShard = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(context, positions, child, options) {\n    var _positions$pop, bucket, prefix, node, link, result, newName, size;\n\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _positions$pop = positions.pop(), bucket = _positions$pop.bucket, prefix = _positions$pop.prefix, node = _positions$pop.node;\n            link = node.Links.find(function (link) {\n              return link.Name.substring(0, 2) === prefix;\n            });\n\n            if (link) {\n              _context4.next = 4;\n              break;\n            }\n\n            throw errCode(new Error(\"No link found with prefix \".concat(prefix, \" for file \").concat(child.name)), 'ERR_NOT_FOUND');\n\n          case 4:\n            if (!(link.Name === \"\".concat(prefix).concat(child.name))) {\n              _context4.next = 10;\n              break;\n            }\n\n            log(\"Removing existing link \".concat(link.Name));\n            node.rmLink(link.Name);\n            _context4.next = 9;\n            return bucket.del(child.name);\n\n          case 9:\n            return _context4.abrupt(\"return\", updateHamtDirectory(context, node.Links, bucket, options));\n\n          case 10:\n            log(\"Descending into sub-shard \".concat(link.Name, \" for \").concat(prefix).concat(child.name));\n            _context4.next = 13;\n            return updateShard(context, positions, child, options);\n\n          case 13:\n            result = _context4.sent;\n            newName = prefix;\n\n            if (result.node.Links.length === 1) {\n              log(\"Removing subshard for \".concat(prefix)); // convert shard back to normal dir\n\n              result.cid = result.node.Links[0].Hash;\n              result.node = result.node.Links[0];\n              newName = \"\".concat(prefix).concat(result.node.Name.substring(2));\n            }\n\n            log(\"Updating shard \".concat(prefix, \" with name \").concat(newName));\n            size = DAGNode.isDAGNode(result.node) ? result.node.size : result.node.Tsize;\n            return _context4.abrupt(\"return\", updateShardParent(context, bucket, node, prefix, newName, size, result.cid, options));\n\n          case 19:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n\n  return function updateShard(_x7, _x8, _x9, _x10) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\nvar updateShardParent = function updateShardParent(context, bucket, parent, oldName, newName, size, cid, options) {\n  parent.rmLink(oldName);\n  parent.addLink(new DAGLink(newName, size, cid));\n  return updateHamtDirectory(context, parent.Links, bucket, options);\n};\n\nmodule.exports = removeLink;","map":null,"metadata":{},"sourceType":"script"}