{"ast":null,"code":"'use strict';\n\nvar _toArray = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toArray\");\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _awaitAsyncGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _wrapAsyncGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar debug = require('debug');\n\nvar errcode = require('err-code');\n\nvar mergeOptions = require('merge-options');\n\nvar CID = require('cids');\n\nvar isDomain = require('is-domain-name');\n\nvar log = debug('ipfs:name:resolve');\nlog.error = debug('ipfs:name:resolve:error');\n\nvar _require = require('../../utils'),\n    OFFLINE_ERROR = _require.OFFLINE_ERROR,\n    withTimeoutOption = _require.withTimeoutOption;\n\nvar appendRemainder = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(result, remainder) {\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return result;\n\n          case 2:\n            result = _context.sent;\n\n            if (!remainder.length) {\n              _context.next = 5;\n              break;\n            }\n\n            return _context.abrupt(\"return\", result + '/' + remainder.join('/'));\n\n          case 5:\n            return _context.abrupt(\"return\", result);\n\n          case 6:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function appendRemainder(_x3, _x4) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * @typedef { import(\"../index\") } IPFS\n */\n\n/**\n * IPNS - Inter-Planetary Naming System\n *\n * @param {IPFS} self\n * @returns {Object}\n */\n\n\nmodule.exports = function (_ref2) {\n  var dns = _ref2.dns,\n      ipns = _ref2.ipns,\n      peerInfo = _ref2.peerInfo,\n      isOnline = _ref2.isOnline,\n      constructorOptions = _ref2.options;\n\n  /**\n   * Given a key, query the DHT for its best value.\n   *\n   * @param {String} name ipns name to resolve. Defaults to your node's peerID.\n   * @param {Object} options ipfs resolve options.\n   * @param {boolean} options.nocache do not use cached entries.\n   * @param {boolean} options.recursive resolve until the result is not an IPNS name.\n   * @param {function(Error)} [callback]\n   * @returns {Promise|void}\n   */\n  return withTimeoutOption( /*#__PURE__*/function () {\n    var _resolve = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(name, options) {\n      var offline, _name$slice$split, _name$slice$split2, namespace, hash, remainder;\n\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              // eslint-disable-line require-await\n              options = mergeOptions({\n                nocache: false,\n                recursive: true\n              }, options || {});\n              offline = constructorOptions.offline; // TODO: params related logic should be in the core implementation\n\n              if (!(offline && options.nocache)) {\n                _context2.next = 4;\n                break;\n              }\n\n              throw errcode(new Error('cannot specify both offline and nocache'), 'ERR_NOCACHE_AND_OFFLINE');\n\n            case 4:\n              // Set node id as name for being resolved, if it is not received\n              if (!name) {\n                name = peerInfo.id.toB58String();\n              }\n\n              if (!name.startsWith('/ipns/')) {\n                name = \"/ipns/\".concat(name);\n              }\n\n              _name$slice$split = name.slice(1).split('/'), _name$slice$split2 = _toArray(_name$slice$split), namespace = _name$slice$split2[0], hash = _name$slice$split2[1], remainder = _name$slice$split2.slice(2);\n              _context2.prev = 7;\n              new CID(hash); // eslint-disable-line no-new\n\n              _context2.next = 19;\n              break;\n\n            case 11:\n              _context2.prev = 11;\n              _context2.t0 = _context2[\"catch\"](7);\n\n              if (!isDomain(hash)) {\n                _context2.next = 17;\n                break;\n              }\n\n              _context2.next = 16;\n              return appendRemainder(dns(hash, options), remainder);\n\n            case 16:\n              return _context2.abrupt(\"return\");\n\n            case 17:\n              log.error(_context2.t0);\n              throw errcode(new Error('Invalid IPNS name'), 'ERR_IPNS_INVALID_NAME');\n\n            case 19:\n              if (!(!isOnline() && !offline)) {\n                _context2.next = 21;\n                break;\n              }\n\n              throw errcode(new Error(OFFLINE_ERROR), 'OFFLINE_ERROR');\n\n            case 21:\n              _context2.next = 23;\n              return appendRemainder(ipns.resolve(\"/\".concat(namespace, \"/\").concat(hash), options), remainder);\n\n            case 23:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[7, 11]]);\n    }));\n\n    function resolve(_x, _x2) {\n      return _resolve.apply(this, arguments);\n    }\n\n    return resolve;\n  }());\n};","map":null,"metadata":{},"sourceType":"script"}