{"ast":null,"code":"var _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar CID = require('cids');\n\nvar dagPB = require('ipld-dag-pb');\n\nvar defaultBase = 'base58btc';\n\nvar cidifyString = function cidifyString(str) {\n  if (!str) {\n    return str;\n  }\n\n  if (Array.isArray(str)) {\n    return str.map(cidifyString);\n  }\n\n  return new CID(str);\n};\n\nvar stringifyCid = function stringifyCid(cid, options) {\n  if (!cid || typeof cid === 'string') {\n    return cid;\n  }\n\n  if (Array.isArray(cid)) {\n    return cid.map(stringifyCid);\n  }\n\n  if (cid['/']) {\n    return cid['/'];\n  }\n\n  var base = options.base || defaultBase;\n  return cid.toBaseEncodedString(base);\n};\n\nvar writePb = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(ipfs, obj, options) {\n    var buffer, dagNode, cid, res, pin;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            buffer = Buffer.from(JSON.stringify(obj));\n            dagNode = new dagPB.DAGNode(buffer);\n            _context.next = 4;\n            return ipfs.dag.put(dagNode, {\n              format: 'dag-pb',\n              hashAlg: 'sha2-256'\n            });\n\n          case 4:\n            cid = _context.sent;\n            res = cid.toV0().toBaseEncodedString();\n            pin = options.pin || false;\n\n            if (!pin) {\n              _context.next = 10;\n              break;\n            }\n\n            _context.next = 10;\n            return ipfs.pin.add(res);\n\n          case 10:\n            return _context.abrupt(\"return\", res);\n\n          case 11:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function writePb(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar readPb = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(ipfs, cid) {\n    var result, dagNode;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return ipfs.dag.get(cid);\n\n          case 2:\n            result = _context2.sent;\n            dagNode = result.value;\n            return _context2.abrupt(\"return\", JSON.parse(dagNode.toJSON().data));\n\n          case 5:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function readPb(_x4, _x5) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nvar writeCbor = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(ipfs, obj, options) {\n    var dagNode, links, base, onlyHash, cid, res, pin;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            dagNode = Object.assign({}, obj);\n            links = options.links || [];\n            links.forEach(function (prop) {\n              if (dagNode[prop]) {\n                dagNode[prop] = cidifyString(dagNode[prop]);\n              }\n            });\n            base = options.base || defaultBase;\n            onlyHash = options.onlyHash || false;\n            _context3.next = 7;\n            return ipfs.dag.put(dagNode, {\n              onlyHash: onlyHash\n            });\n\n          case 7:\n            cid = _context3.sent;\n            res = cid.toBaseEncodedString(base);\n            pin = options.pin || false;\n\n            if (!pin) {\n              _context3.next = 13;\n              break;\n            }\n\n            _context3.next = 13;\n            return ipfs.pin.add(res);\n\n          case 13:\n            return _context3.abrupt(\"return\", res);\n\n          case 14:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function writeCbor(_x6, _x7, _x8) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nvar readCbor = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(ipfs, cid, options) {\n    var result, obj, links;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.next = 2;\n            return ipfs.dag.get(cid);\n\n          case 2:\n            result = _context4.sent;\n            obj = result.value;\n            links = options.links || [];\n            links.forEach(function (prop) {\n              if (obj[prop]) {\n                obj[prop] = stringifyCid(obj[prop], options);\n              }\n            });\n            return _context4.abrupt(\"return\", obj);\n\n          case 7:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n\n  return function readCbor(_x9, _x10, _x11) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\nvar writeObj = /*#__PURE__*/function () {\n  var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(ipfs, obj, options) {\n    var onlyHash, base, opts, cid, res, pin;\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            onlyHash = options.onlyHash || false;\n            base = options.base || defaultBase;\n            opts = Object.assign({}, {\n              onlyHash: onlyHash\n            }, options.format ? {\n              format: options.format,\n              hashAlg: 'sha2-256'\n            } : {});\n\n            if (opts.format === 'dag-pb') {\n              obj = new dagPB.DAGNode(obj);\n            }\n\n            _context5.next = 6;\n            return ipfs.dag.put(obj, opts);\n\n          case 6:\n            cid = _context5.sent;\n            res = cid.toBaseEncodedString(base);\n            pin = options.pin || false;\n\n            if (!pin) {\n              _context5.next = 12;\n              break;\n            }\n\n            _context5.next = 12;\n            return ipfs.pin.add(res);\n\n          case 12:\n            return _context5.abrupt(\"return\", res);\n\n          case 13:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n\n  return function writeObj(_x12, _x13, _x14) {\n    return _ref5.apply(this, arguments);\n  };\n}();\n\nvar formats = {\n  'dag-pb': {\n    read: readPb,\n    write: writePb\n  },\n  'dag-cbor': {\n    write: writeCbor,\n    read: readCbor\n  },\n  'raw': {\n    write: writeObj\n  }\n};\n\nvar write = function write(ipfs, codec, obj) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var format = formats[codec];\n  if (!format) throw new Error('Unsupported codec');\n  return format.write(ipfs, obj, options);\n};\n\nvar read = function read(ipfs, cid) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  cid = new CID(cid);\n  var format = formats[cid.codec];\n  if (!format) throw new Error('Unsupported codec');\n  return format.read(ipfs, cid, options);\n};\n\nmodule.exports = {\n  read: read,\n  write: write\n};","map":null,"metadata":{},"sourceType":"script"}