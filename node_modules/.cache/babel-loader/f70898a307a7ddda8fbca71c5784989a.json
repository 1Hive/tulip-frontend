{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _wrapNativeSuper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapNativeSuper\");\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar debug = require('debug');\n\nvar multihashing = require('multihashing-async');\n\nvar mh = require('multihashes');\n\nvar _require = require('interface-datastore'),\n    Key = _require.Key;\n\nvar base32 = require('base32.js');\n\nvar distance = require('xor-distance');\n\nvar pMap = require('p-map');\n\nvar _require2 = require('libp2p-record'),\n    Record = _require2.Record;\n\nvar PeerId = require('peer-id');\n\nvar errcode = require('err-code');\n\nvar _require3 = require('buffer'),\n    Buffer = _require3.Buffer;\n/**\n * Creates a DHT ID by hashing a given buffer.\n *\n * @param {Buffer} buf\n * @returns {Promise<Buffer>}\n */\n\n\nexports.convertBuffer = function (buf) {\n  return multihashing.digest(buf, 'sha2-256');\n};\n/**\n * Creates a DHT ID by hashing a Peer ID\n *\n * @param {PeerId} peer\n * @returns {Promise<Buffer>}\n */\n\n\nexports.convertPeerId = function (peer) {\n  return multihashing.digest(peer.id, 'sha2-256');\n};\n/**\n * Convert a buffer to their SHA2-256 hash.\n *\n * @param {Buffer} buf\n * @returns {Key}\n */\n\n\nexports.bufferToKey = function (buf) {\n  return new Key('/' + exports.encodeBase32(buf), false);\n};\n/**\n * Generate the key for a public key.\n *\n * @param {PeerId} peer\n * @returns {Buffer}\n */\n\n\nexports.keyForPublicKey = function (peer) {\n  return Buffer.concat([Buffer.from('/pk/'), peer.id]);\n};\n\nexports.isPublicKeyKey = function (key) {\n  return key.slice(0, 4).toString() === '/pk/';\n};\n\nexports.fromPublicKeyKey = function (key) {\n  return new PeerId(key.slice(4));\n};\n/**\n * Get the current time as timestamp.\n *\n * @returns {number}\n */\n\n\nexports.now = function () {\n  return Date.now();\n};\n/**\n * Encode a given buffer into a base32 string.\n * @param {Buffer} buf\n * @returns {string}\n */\n\n\nexports.encodeBase32 = function (buf) {\n  var enc = new base32.Encoder();\n  return enc.write(buf).finalize();\n};\n/**\n * Decode a given base32 string into a buffer.\n * @param {string} raw\n * @returns {Buffer}\n */\n\n\nexports.decodeBase32 = function (raw) {\n  var dec = new base32.Decoder();\n  return Buffer.from(dec.write(raw).finalize());\n};\n/**\n * Sort peers by distance to the given `target`.\n *\n * @param {Array<PeerId>} peers\n * @param {Buffer} target\n * @returns {Array<PeerId>}\n */\n\n\nexports.sortClosestPeers = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(peers, target) {\n    var distances;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return pMap(peers, /*#__PURE__*/function () {\n              var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(peer) {\n                var id;\n                return _regeneratorRuntime.wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        _context.next = 2;\n                        return exports.convertPeerId(peer);\n\n                      case 2:\n                        id = _context.sent;\n                        return _context.abrupt(\"return\", {\n                          peer: peer,\n                          distance: distance(id, target)\n                        });\n\n                      case 4:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee);\n              }));\n\n              return function (_x3) {\n                return _ref2.apply(this, arguments);\n              };\n            }());\n\n          case 2:\n            distances = _context2.sent;\n            return _context2.abrupt(\"return\", distances.sort(exports.xorCompare).map(function (d) {\n              return d.peer;\n            }));\n\n          case 4:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function (_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * Compare function to sort an array of elements which have a distance property which is the xor distance to a given element.\n *\n * @param {Object} a\n * @param {Object} b\n * @returns {number}\n */\n\n\nexports.xorCompare = function (a, b) {\n  return distance.compare(a.distance, b.distance);\n};\n/**\n * Computes how many results to collect on each disjoint path, rounding up.\n * This ensures that we look for at least one result per path.\n *\n * @param {number} resultsWanted\n * @param {number} numPaths - total number of paths\n * @returns {number}\n */\n\n\nexports.pathSize = function (resultsWanted, numPaths) {\n  return Math.ceil(resultsWanted / numPaths);\n};\n/**\n * Create a new put record, encodes and signs it if enabled.\n *\n * @param {Buffer} key\n * @param {Buffer} value\n * @returns {Buffer}\n */\n\n\nexports.createPutRecord = function (key, value) {\n  var timeReceived = new Date();\n  var rec = new Record(key, value, timeReceived);\n  return rec.serialize();\n};\n/**\n * Creates a logger for the given subsystem\n *\n * @param {PeerId} [id]\n * @param {string} [subsystem]\n * @returns {debug}\n *\n * @private\n */\n\n\nexports.logger = function (id, subsystem) {\n  var name = ['libp2p', 'dht'];\n\n  if (subsystem) {\n    name.push(subsystem);\n  }\n\n  if (id) {\n    name.push(\"\".concat(id.toB58String().slice(0, 8)));\n  } // Add a formatter for converting to a base58 string\n\n\n  debug.formatters.b = function (v) {\n    return mh.toB58String(v);\n  };\n\n  var logger = debug(name.join(':'));\n  logger.error = debug(name.concat(['error']).join(':'));\n  return logger;\n};\n\nexports.TimeoutError = /*#__PURE__*/function (_Error) {\n  _inherits(TimeoutError, _Error);\n\n  var _super = _createSuper(TimeoutError);\n\n  function TimeoutError() {\n    _classCallCheck(this, TimeoutError);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(TimeoutError, [{\n    key: \"code\",\n    get: function get() {\n      return 'ETIMEDOUT';\n    }\n  }]);\n\n  return TimeoutError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n/**\n * Creates an async function that calls the given `asyncFn` and Errors\n * if it does not resolve within `time` ms\n *\n * @param {Function} [asyncFn]\n * @param {Number} [time]\n * @returns {Function}\n *\n * @private\n */\n\n\nexports.withTimeout = function (asyncFn, time) {\n  return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n    var _args3 = arguments;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            return _context3.abrupt(\"return\", Promise.race([asyncFn.apply(void 0, _args3), new Promise(function (resolve, reject) {\n              setTimeout(function () {\n                reject(errcode(new Error('Async function did not complete before timeout'), 'ETIMEDOUT'));\n              }, time);\n            })]));\n\n          case 1:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n};","map":null,"metadata":{},"sourceType":"script"}