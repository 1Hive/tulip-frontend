{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar _require2 = require('interface-datastore'),\n    Adapter = _require2.Adapter,\n    Key = _require2.Key;\n\nvar sh = require('./shard');\n\nvar KeytransformStore = require('./keytransform');\n\nvar shardKey = new Key(sh.SHARDING_FN);\nvar shardReadmeKey = new Key(sh.README_FN);\n/**\n * Backend independent abstraction of go-ds-flatfs.\n *\n * Wraps another datastore such that all values are stored\n * sharded according to the given sharding function.\n */\n\nvar ShardingDatastore = /*#__PURE__*/function (_Adapter) {\n  _inherits(ShardingDatastore, _Adapter);\n\n  var _super = _createSuper(ShardingDatastore);\n\n  function ShardingDatastore(store, shard) {\n    var _this;\n\n    _classCallCheck(this, ShardingDatastore);\n\n    _this = _super.call(this);\n    _this.child = new KeytransformStore(store, {\n      convert: _this._convertKey.bind(_assertThisInitialized(_this)),\n      invert: _this._invertKey.bind(_assertThisInitialized(_this))\n    });\n    _this.shard = shard;\n    return _this;\n  }\n\n  _createClass(ShardingDatastore, [{\n    key: \"open\",\n    value: function open() {\n      return this.child.open();\n    }\n  }, {\n    key: \"_convertKey\",\n    value: function _convertKey(key) {\n      var s = key.toString();\n\n      if (s === shardKey.toString() || s === shardReadmeKey.toString()) {\n        return key;\n      }\n\n      var parent = new Key(this.shard.fun(s));\n      return parent.child(key);\n    }\n  }, {\n    key: \"_invertKey\",\n    value: function _invertKey(key) {\n      var s = key.toString();\n\n      if (s === shardKey.toString() || s === shardReadmeKey.toString()) {\n        return key;\n      }\n\n      return Key.withNamespaces(key.list().slice(1));\n    }\n  }, {\n    key: \"put\",\n    value: function put(key, val, options) {\n      return this.child.put(key, val, options);\n    }\n  }, {\n    key: \"get\",\n    value: function get(key, options) {\n      return this.child.get(key, options);\n    }\n  }, {\n    key: \"has\",\n    value: function has(key, options) {\n      return this.child.has(key, options);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key, options) {\n      return this.child.delete(key, options);\n    }\n  }, {\n    key: \"batch\",\n    value: function batch() {\n      return this.child.batch();\n    }\n  }, {\n    key: \"query\",\n    value: function query(q, options) {\n      var _this2 = this;\n\n      var tq = {\n        keysOnly: q.keysOnly,\n        offset: q.offset,\n        limit: q.limit,\n        filters: [function (e) {\n          return e.key.toString() !== shardKey.toString();\n        }, function (e) {\n          return e.key.toString() !== shardReadmeKey.toString();\n        }]\n      };\n\n      if (q.prefix != null) {\n        tq.filters.push(function (e) {\n          return _this2._invertKey(e.key).toString().startsWith(q.prefix);\n        });\n      }\n\n      if (q.filters != null) {\n        var filters = q.filters.map(function (f) {\n          return function (e) {\n            return f(Object.assign({}, e, {\n              key: _this2._invertKey(e.key)\n            }));\n          };\n        });\n        tq.filters = tq.filters.concat(filters);\n      }\n\n      if (q.orders != null) {\n        tq.orders = q.orders.map(function (o) {\n          return /*#__PURE__*/function () {\n            var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(res) {\n              var ordered;\n              return _regeneratorRuntime.wrap(function _callee$(_context) {\n                while (1) {\n                  switch (_context.prev = _context.next) {\n                    case 0:\n                      res.forEach(function (e) {\n                        e.key = _this2._invertKey(e.key);\n                      });\n                      _context.next = 3;\n                      return o(res);\n\n                    case 3:\n                      ordered = _context.sent;\n                      ordered.forEach(function (e) {\n                        e.key = _this2._convertKey(e.key);\n                      });\n                      return _context.abrupt(\"return\", ordered);\n\n                    case 6:\n                    case \"end\":\n                      return _context.stop();\n                  }\n                }\n              }, _callee);\n            }));\n\n            return function (_x) {\n              return _ref.apply(this, arguments);\n            };\n          }();\n        });\n      }\n\n      return this.child.query(tq, options);\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      return this.child.close();\n    }\n  }], [{\n    key: \"createOrOpen\",\n    value: function () {\n      var _createOrOpen = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(store, shard) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.prev = 0;\n                _context2.next = 3;\n                return ShardingDatastore.create(store, shard);\n\n              case 3:\n                _context2.next = 9;\n                break;\n\n              case 5:\n                _context2.prev = 5;\n                _context2.t0 = _context2[\"catch\"](0);\n\n                if (!(_context2.t0 && _context2.t0.message !== 'datastore exists')) {\n                  _context2.next = 9;\n                  break;\n                }\n\n                throw _context2.t0;\n\n              case 9:\n                return _context2.abrupt(\"return\", ShardingDatastore.open(store));\n\n              case 10:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, null, [[0, 5]]);\n      }));\n\n      function createOrOpen(_x2, _x3) {\n        return _createOrOpen.apply(this, arguments);\n      }\n\n      return createOrOpen;\n    }()\n  }, {\n    key: \"open\",\n    value: function () {\n      var _open = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(store) {\n        var shard;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return sh.readShardFun('/', store);\n\n              case 2:\n                shard = _context3.sent;\n                return _context3.abrupt(\"return\", new ShardingDatastore(store, shard));\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      function open(_x4) {\n        return _open.apply(this, arguments);\n      }\n\n      return open;\n    }()\n  }, {\n    key: \"create\",\n    value: function () {\n      var _create = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(store, shard) {\n        var exists, put, diskShard, a, b;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return store.has(shardKey);\n\n              case 2:\n                exists = _context4.sent;\n\n                if (exists) {\n                  _context4.next = 6;\n                  break;\n                }\n\n                put = typeof store.putRaw === 'function' ? store.putRaw.bind(store) : store.put.bind(store);\n                return _context4.abrupt(\"return\", Promise.all([put(shardKey, Buffer.from(shard.toString() + '\\n')), put(shardReadmeKey, Buffer.from(sh.readme))]));\n\n              case 6:\n                _context4.next = 8;\n                return sh.readShardFun('/', store);\n\n              case 8:\n                diskShard = _context4.sent;\n                a = (diskShard || '').toString();\n                b = shard.toString();\n\n                if (!(a !== b)) {\n                  _context4.next = 13;\n                  break;\n                }\n\n                throw new Error(\"specified fun \".concat(b, \" does not match repo shard fun \").concat(a));\n\n              case 13:\n                throw new Error('datastore exists');\n\n              case 14:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      function create(_x5, _x6) {\n        return _create.apply(this, arguments);\n      }\n\n      return create;\n    }()\n  }]);\n\n  return ShardingDatastore;\n}(Adapter);\n\nmodule.exports = ShardingDatastore;","map":null,"metadata":{},"sourceType":"script"}