{"ast":null,"code":"'use strict';\n\nconst SparseArray = require('sparse-array');\n\nconst wrapHash = require('./consumable-hash');\n\nconst defaultOptions = {\n  bits: 8\n};\n\nclass Bucket {\n  constructor(options, parent, posAtParent) {\n    this._options = Object.assign({}, defaultOptions, options);\n    this._popCount = 0;\n    this._parent = parent;\n    this._posAtParent = posAtParent;\n\n    if (!this._options.hashFn) {\n      throw new Error('please define an options.hashFn');\n    } // make sure we only wrap options.hashFn once in the whole tree\n\n\n    if (!this._options.hash) {\n      this._options.hash = wrapHash(this._options.hashFn);\n    }\n\n    this._children = new SparseArray();\n  }\n\n  static isBucket(o) {\n    return o instanceof Bucket;\n  }\n\n  async put(key, value) {\n    const place = await this._findNewBucketAndPos(key);\n    await place.bucket._putAt(place, key, value);\n  }\n\n  async get(key) {\n    const child = await this._findChild(key);\n\n    if (child) {\n      return child.value;\n    }\n  }\n\n  async del(key) {\n    const place = await this._findPlace(key);\n\n    const child = place.bucket._at(place.pos);\n\n    if (child && child.key === key) {\n      place.bucket._delAt(place.pos);\n    }\n  }\n\n  leafCount() {\n    return this._children.compactArray().reduce((acc, child) => {\n      if (child instanceof Bucket) {\n        return acc + child.leafCount();\n      }\n\n      return acc + 1;\n    }, 0);\n  }\n\n  childrenCount() {\n    return this._children.length;\n  }\n\n  onlyChild() {\n    return this._children.get(0);\n  }\n\n  *eachLeafSeries() {\n    const children = this._children.compactArray();\n\n    for (const child of children) {\n      if (child instanceof Bucket) {\n        for (const c2 of child.eachLeafSeries()) {\n          yield c2;\n        }\n      } else {\n        yield child;\n      }\n    }\n  }\n\n  serialize(map, reduce) {\n    // serialize to a custom non-sparse representation\n    return reduce(this._children.reduce((acc, child, index) => {\n      if (child) {\n        if (child instanceof Bucket) {\n          acc.push(child.serialize(map, reduce));\n        } else {\n          acc.push(map(child, index));\n        }\n      }\n\n      return acc;\n    }, []));\n  }\n\n  asyncTransform(asyncMap, asyncReduce) {\n    return asyncTransformBucket(this, asyncMap, asyncReduce);\n  }\n\n  toJSON() {\n    return this.serialize(mapNode, reduceNodes);\n  }\n\n  prettyPrint() {\n    return JSON.stringify(this.toJSON(), null, '  ');\n  }\n\n  tableSize() {\n    return Math.pow(2, this._options.bits);\n  }\n\n  async _findChild(key) {\n    const result = await this._findPlace(key);\n\n    const child = result.bucket._at(result.pos);\n\n    if (child && child.key === key) {\n      return child;\n    }\n  }\n\n  async _findPlace(key) {\n    const hashValue = this._options.hash(key);\n\n    const index = await hashValue.take(this._options.bits);\n\n    const child = this._children.get(index);\n\n    if (child instanceof Bucket) {\n      return child._findPlace(hashValue);\n    }\n\n    return {\n      bucket: this,\n      pos: index,\n      hash: hashValue\n    };\n  }\n\n  async _findNewBucketAndPos(key) {\n    const place = await this._findPlace(key);\n\n    const child = place.bucket._at(place.pos);\n\n    if (child && child.key !== key) {\n      // conflict\n      const bucket = new Bucket(this._options, place.bucket, place.pos);\n\n      place.bucket._putObjectAt(place.pos, bucket); // put the previous value\n\n\n      const newPlace = await bucket._findPlace(child.hash);\n\n      newPlace.bucket._putAt(newPlace, child.key, child.value);\n\n      return bucket._findNewBucketAndPos(place.hash);\n    } // no conflict, we found the place\n\n\n    return place;\n  }\n\n  _putAt(place, key, value) {\n    this._putObjectAt(place.pos, {\n      key: key,\n      value: value,\n      hash: place.hash\n    });\n  }\n\n  _putObjectAt(pos, object) {\n    if (!this._children.get(pos)) {\n      this._popCount++;\n    }\n\n    this._children.set(pos, object);\n  }\n\n  _delAt(pos) {\n    if (this._children.get(pos)) {\n      this._popCount--;\n    }\n\n    this._children.unset(pos);\n\n    this._level();\n  }\n\n  _level() {\n    if (this._parent && this._popCount <= 1) {\n      if (this._popCount === 1) {\n        // remove myself from parent, replacing me with my only child\n        const onlyChild = this._children.find(exists);\n\n        if (!(onlyChild instanceof Bucket)) {\n          const hash = onlyChild.hash;\n          hash.untake(this._options.bits);\n          const place = {\n            pos: this._posAtParent,\n            hash: hash\n          };\n\n          this._parent._putAt(place, onlyChild.key, onlyChild.value);\n        }\n      } else {\n        this._parent._delAt(this._posAtParent);\n      }\n    }\n  }\n\n  _at(index) {\n    return this._children.get(index);\n  }\n\n}\n\nfunction exists(o) {\n  return Boolean(o);\n}\n\nfunction mapNode(node, index) {\n  return node.key;\n}\n\nfunction reduceNodes(nodes) {\n  return nodes;\n}\n\nasync function asyncTransformBucket(bucket, asyncMap, asyncReduce) {\n  const output = [];\n\n  for (const child of bucket._children.compactArray()) {\n    if (child instanceof Bucket) {\n      await asyncTransformBucket(child, asyncMap, asyncReduce);\n    } else {\n      const mappedChildren = await asyncMap(child);\n      output.push({\n        bitField: bucket._children.bitField(),\n        children: mappedChildren\n      });\n    }\n\n    return asyncReduce(output);\n  }\n}\n\nmodule.exports = Bucket;","map":null,"metadata":{},"sourceType":"script"}