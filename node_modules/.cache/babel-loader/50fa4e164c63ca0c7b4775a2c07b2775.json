{"ast":null,"code":"'use strict';\n\nconst {\n  deepEqual\n} = require('./utils');\n\nconst sum = (acc, val) => acc + val;\n/**\n * G-Counter\n *\n * Operation-based Increment-Only Counter CRDT\n *\n * Sources: \n * \"A comprehensive study of Convergent and Commutative Replicated Data Types\"\n * http://hal.upmc.fr/inria-00555588/document, \"3.1.1 Op-based counter and 3.1.2  State-based increment-only Counter (G-Counter)\"\n */\n\n\nclass GCounter {\n  constructor(id, counter) {\n    this.id = id;\n    this._counters = counter ? counter : {};\n    this._counters[this.id] = this._counters[this.id] ? this._counters[this.id] : 0;\n  }\n\n  get value() {\n    return Object.values(this._counters).reduce(sum, 0);\n  }\n\n  increment(amount) {\n    if (amount && amount < 1) return;\n    if (amount === undefined || amount === null) amount = 1;\n    this._counters[this.id] = this._counters[this.id] + amount;\n  }\n\n  merge(other) {\n    // Go through each counter in the other counter\n    Object.entries(other._counters).forEach(([id, value]) => {\n      // Take the maximum of the counter value we have or the counter value they have\n      this._counters[id] = Math.max(this._counters[id] || 0, value);\n    });\n  }\n\n  toJSON() {\n    return {\n      id: this.id,\n      counters: this._counters\n    };\n  }\n\n  isEqual(other) {\n    return GCounter.isEqual(this, other);\n  }\n\n  static from(json) {\n    return new GCounter(json.id, json.counters);\n  }\n\n  static isEqual(a, b) {\n    if (a.id !== b.id) return false;\n    return deepEqual(a._counters, b._counters);\n  }\n\n}\n\nmodule.exports = GCounter;","map":null,"metadata":{},"sourceType":"script"}