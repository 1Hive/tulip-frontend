{"ast":null,"code":"'use strict';\n\nconst Clock = require('./lamport-clock');\n\nconst {\n  isDefined,\n  io\n} = require('./utils');\n\nconst stringify = require('json-stringify-deterministic');\n\nconst IpfsNotDefinedError = () => new Error('Ipfs instance not defined');\n\nconst IPLD_LINKS = ['next', 'refs'];\n\nconst getWriteFormatForVersion = v => v === 0 ? 'dag-pb' : 'dag-cbor';\n\nconst getWriteFormat = e => Entry.isEntry(e) ? getWriteFormatForVersion(e.v) : getWriteFormatForVersion(e);\n\nclass Entry {\n  /**\n   * Create an Entry\n   * @param {IPFS} ipfs An IPFS instance\n   * @param {Identity} identity The identity instance\n   * @param {string} logId The unique identifier for this log\n   * @param {*} data Data of the entry to be added. Can be any JSON.stringifyable data\n   * @param {Array<string|Entry>} [next=[]] Parent hashes or entries\n   * @param {LamportClock} [clock] The lamport clock\n   * @returns {Promise<Entry>}\n   * @example\n   * const entry = await Entry.create(ipfs, identity, 'hello')\n   * console.log(entry)\n   * // { hash: null, payload: \"hello\", next: [] }\n   */\n  static async create(ipfs, identity, logId, data, next = [], clock, refs = [], pin) {\n    if (!isDefined(ipfs)) throw IpfsNotDefinedError();\n    if (!isDefined(identity)) throw new Error('Identity is required, cannot create entry');\n    if (!isDefined(logId)) throw new Error('Entry requires an id');\n    if (!isDefined(data)) throw new Error('Entry requires data');\n    if (!isDefined(next) || !Array.isArray(next)) throw new Error(\"'next' argument is not an array\"); // Clean the next objects and convert to hashes\n\n    const toEntry = e => e.hash ? e.hash : e;\n\n    const nexts = next.filter(isDefined).map(toEntry);\n    const entry = {\n      hash: null,\n      // \"zd...Foo\", we'll set the hash after persisting the entry\n      id: logId,\n      // For determining a unique chain\n      payload: data,\n      // Can be any JSON.stringifyable data\n      next: nexts,\n      // Array of hashes\n      refs: refs,\n      v: 2,\n      // To tag the version of this data structure\n      clock: clock || new Clock(identity.publicKey)\n    };\n    const signature = await identity.provider.sign(identity, Entry.toBuffer(entry));\n    entry.key = identity.publicKey;\n    entry.identity = identity.toJSON();\n    entry.sig = signature;\n    entry.hash = await Entry.toMultihash(ipfs, entry, pin);\n    return entry;\n  }\n  /**\n   * Verifies an entry signature.\n   *\n   * @param {IdentityProvider} identityProvider The identity provider to use\n   * @param {Entry} entry The entry being verified\n   * @return {Promise} A promise that resolves to a boolean value indicating if the signature is valid\n   */\n\n\n  static async verify(identityProvider, entry) {\n    if (!identityProvider) throw new Error('Identity-provider is required, cannot verify entry');\n    if (!Entry.isEntry(entry)) throw new Error('Invalid Log entry');\n    if (!entry.key) throw new Error(\"Entry doesn't have a key\");\n    if (!entry.sig) throw new Error(\"Entry doesn't have a signature\");\n    const e = Entry.toEntry(entry, {\n      presigned: true\n    });\n    const verifier = entry.v < 1 ? 'v0' : 'v1';\n    return identityProvider.verify(entry.sig, entry.key, Entry.toBuffer(e), verifier);\n  }\n  /**\n   * Transforms an entry into a Buffer.\n   * @param {Entry} entry The entry\n   * @return {Buffer} The buffer\n   */\n\n\n  static toBuffer(entry) {\n    const stringifiedEntry = entry.v === 0 ? JSON.stringify(entry) : stringify(entry);\n    return Buffer.from(stringifiedEntry);\n  }\n  /**\n   * Get the multihash of an Entry.\n   * @param {IPFS} ipfs An IPFS instance\n   * @param {Entry} entry Entry to get a multihash for\n   * @returns {Promise<string>}\n   * @example\n   * const multihash = await Entry.toMultihash(ipfs, entry)\n   * console.log(multihash)\n   * // \"Qm...Foo\"\n   * @deprecated\n   */\n\n\n  static async toMultihash(ipfs, entry, pin = false) {\n    if (!ipfs) throw IpfsNotDefinedError();\n    if (!Entry.isEntry(entry)) throw new Error('Invalid object format, cannot generate entry hash'); // // Ensure `entry` follows the correct format\n\n    const e = Entry.toEntry(entry);\n    return io.write(ipfs, getWriteFormat(e.v), e, {\n      links: IPLD_LINKS,\n      pin\n    });\n  }\n\n  static toEntry(entry, {\n    presigned = false,\n    includeHash = false\n  } = {}) {\n    const e = {\n      hash: includeHash ? entry.hash : null,\n      id: entry.id,\n      payload: entry.payload,\n      next: entry.next\n    };\n    const v = entry.v;\n\n    if (v > 1) {\n      e.refs = entry.refs; // added in v2\n    }\n\n    e.v = entry.v;\n    e.clock = new Clock(entry.clock.id, entry.clock.time);\n\n    if (presigned) {\n      return e; // don't include key/sig information\n    }\n\n    e.key = entry.key;\n\n    if (v > 0) {\n      e.identity = entry.identity; // added in v1\n    }\n\n    e.sig = entry.sig;\n    return e;\n  }\n  /**\n   * Create an Entry from a hash.\n   * @param {IPFS} ipfs An IPFS instance\n   * @param {string} hash The hash to create an Entry from\n   * @returns {Promise<Entry>}\n   * @example\n   * const entry = await Entry.fromMultihash(ipfs, \"zd...Foo\")\n   * console.log(entry)\n   * // { hash: \"Zd...Foo\", payload: \"hello\", next: [] }\n   */\n\n\n  static async fromMultihash(ipfs, hash) {\n    if (!ipfs) throw IpfsNotDefinedError();\n    if (!hash) throw new Error(`Invalid hash: ${hash}`);\n    const e = await io.read(ipfs, hash, {\n      links: IPLD_LINKS\n    });\n    const entry = Entry.toEntry(e);\n    entry.hash = hash;\n    return entry;\n  }\n  /**\n   * Check if an object is an Entry.\n   * @param {Entry} obj\n   * @returns {boolean}\n   */\n\n\n  static isEntry(obj) {\n    return obj && obj.id !== undefined && obj.next !== undefined && obj.payload !== undefined && obj.v !== undefined && obj.hash !== undefined && obj.clock !== undefined && (obj.refs !== undefined || obj.v < 2); // 'refs' added in v2\n  }\n  /**\n   * Compares two entries.\n   * @param {Entry} a\n   * @param {Entry} b\n   * @returns {number} 1 if a is greater, -1 is b is greater\n   */\n\n\n  static compare(a, b) {\n    var distance = Clock.compare(a.clock, b.clock);\n    if (distance === 0) return a.clock.id < b.clock.id ? -1 : 1;\n    return distance;\n  }\n  /**\n   * Check if an entry equals another entry.\n   * @param {Entry} a\n   * @param {Entry} b\n   * @returns {boolean}\n   */\n\n\n  static isEqual(a, b) {\n    return a.hash === b.hash;\n  }\n  /**\n   * Check if an entry is a parent to another entry.\n   * @param {Entry} entry1 Entry to check\n   * @param {Entry} entry2 The parent Entry\n   * @returns {boolean}\n   */\n\n\n  static isParent(entry1, entry2) {\n    return entry2.next.indexOf(entry1.hash) > -1;\n  }\n  /**\n   * Find entry's children from an Array of entries.\n   * Returns entry's children as an Array up to the last know child.\n   * @param {Entry} entry Entry for which to find the parents\n   * @param {Array<Entry>} values Entries to search parents from\n   * @returns {Array<Entry>}\n   */\n\n\n  static findChildren(entry, values) {\n    var stack = [];\n    var parent = values.find(e => Entry.isParent(entry, e));\n    var prev = entry;\n\n    while (parent) {\n      stack.push(parent);\n      prev = parent;\n      parent = values.find(e => Entry.isParent(prev, e));\n    }\n\n    stack = stack.sort((a, b) => a.clock.time > b.clock.time);\n    return stack;\n  }\n\n}\n\nmodule.exports = Entry;\nmodule.exports.IPLD_LINKS = IPLD_LINKS;\nmodule.exports.getWriteFormat = getWriteFormat;","map":null,"metadata":{},"sourceType":"script"}