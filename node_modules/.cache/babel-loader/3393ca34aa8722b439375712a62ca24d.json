{"ast":null,"code":"'use strict';\n\nconst path = require('path');\n\nconst CID = require('cids');\n\nconst notEmpty = e => e !== '' && e !== ' ';\n\nclass OrbitDBAddress {\n  constructor(root, path) {\n    this.root = root;\n    this.path = path;\n  }\n\n  toString() {\n    return OrbitDBAddress.join(this.root, this.path);\n  }\n\n  static isValid(address) {\n    address = address.toString().replace(/\\\\/g, '/');\n\n    const containsProtocolPrefix = (e, i) => !((i === 0 || i === 1) && address.toString().indexOf('/orbit') === 0 && e === 'orbitdb');\n\n    const parts = address.toString().split('/').filter(containsProtocolPrefix).filter(notEmpty);\n    let accessControllerHash;\n\n    try {\n      accessControllerHash = parts[0].indexOf('zd') > -1 || parts[0].indexOf('Qm') > -1 || parts[0].indexOf('ba') > -1 ? new CID(parts[0]).toBaseEncodedString() : null;\n    } catch (e) {\n      return false;\n    }\n\n    return accessControllerHash !== null;\n  }\n\n  static parse(address) {\n    if (!address) {\n      throw new Error(`Not a valid OrbitDB address: ${address}`);\n    }\n\n    if (!OrbitDBAddress.isValid(address)) {\n      throw new Error(`Not a valid OrbitDB address: ${address}`);\n    }\n\n    address = address.toString().replace(/\\\\/g, '/');\n    const parts = address.toString().split('/').filter((e, i) => !((i === 0 || i === 1) && address.toString().indexOf('/orbit') === 0 && e === 'orbitdb')).filter(e => e !== '' && e !== ' ');\n    return new OrbitDBAddress(parts[0], parts.slice(1, parts.length).join('/'));\n  }\n\n  static join(...paths) {\n    return (path.posix || path).join('/orbitdb', ...paths);\n  }\n\n}\n\nmodule.exports = OrbitDBAddress;","map":null,"metadata":{},"sourceType":"script"}