{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar Key = require('interface-datastore').Key;\n\nvar _require2 = require('p-queue'),\n    Queue = _require2.default;\n\nvar _get = require('just-safe-get');\n\nvar _set = require('just-safe-set');\n\nvar errcode = require('err-code');\n\nvar errors = require('./errors');\n\nvar configKey = new Key('config');\n\nmodule.exports = function (store) {\n  var setQueue = new Queue({\n    concurrency: 1\n  });\n  var configStore = {\n    /**\n     * Get the current configuration from the repo.\n     *\n     * @param {Object} options - options\n     * @param {AbortSignal} options.signal - abort this config read\n     * @returns {Promise<Object>}\n     */\n    getAll: function getAll() {\n      var _arguments = arguments;\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var options;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                options = _arguments.length > 0 && _arguments[0] !== undefined ? _arguments[0] : {};\n                return _context.abrupt(\"return\", configStore.get(undefined, options));\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }))();\n    },\n\n    /**\n     * Get the value for the passed configuration key from the repo.\n     *\n     * @param {String} key - the config key to get\n     * @param {Object} options - options\n     * @param {AbortSignal} options.signal - abort this config read\n     * @returns {Promise<Object>}\n     */\n    get: function get(key) {\n      var _arguments2 = arguments;\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var options, encodedValue, config, value;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                options = _arguments2.length > 1 && _arguments2[1] !== undefined ? _arguments2[1] : {};\n\n                if (!key) {\n                  key = undefined;\n                }\n\n                _context2.next = 4;\n                return store.get(configKey);\n\n              case 4:\n                encodedValue = _context2.sent;\n\n                if (!(options.signal && options.signal.aborted)) {\n                  _context2.next = 7;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 7:\n                config = JSON.parse(encodedValue.toString());\n\n                if (!(key !== undefined && _get(config, key) === undefined)) {\n                  _context2.next = 10;\n                  break;\n                }\n\n                throw new errors.NotFoundError(\"Key \".concat(key, \" does not exist in config\"));\n\n              case 10:\n                value = key !== undefined ? _get(config, key) : config;\n                return _context2.abrupt(\"return\", value);\n\n              case 12:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }))();\n    },\n\n    /**\n     * Set the current configuration for this repo.\n     *\n     * @param {String} key - the config key to be written\n     * @param {Object} value - the config value to be written\n     * @param {Object} options - options\n     * @param {AbortSignal} options.signal - abort this config write\n     * @returns {void}\n     */\n    set: function set(key, value) {\n      var _arguments3 = arguments;\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var options;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                options = _arguments3.length > 2 && _arguments3[2] !== undefined ? _arguments3[2] : {};\n\n                if (!(_arguments3.length === 1)) {\n                  _context3.next = 6;\n                  break;\n                }\n\n                value = key;\n                key = undefined;\n                _context3.next = 8;\n                break;\n\n              case 6:\n                if (!(!key || typeof key !== 'string')) {\n                  _context3.next = 8;\n                  break;\n                }\n\n                throw errcode(new Error('Invalid key type: ' + typeof key), 'ERR_INVALID_KEY');\n\n              case 8:\n                if (!(value === undefined || Buffer.isBuffer(value))) {\n                  _context3.next = 10;\n                  break;\n                }\n\n                throw errcode(new Error('Invalid value type: ' + typeof value), 'ERR_INVALID_VALUE');\n\n              case 10:\n                return _context3.abrupt(\"return\", setQueue.add(function () {\n                  return _maybeDoSet({\n                    key: key,\n                    value: value\n                  }, options.signal);\n                }));\n\n              case 11:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }))();\n    },\n\n    /**\n     * Set the current configuration for this repo.\n     *\n     * @param {Object} value - the config value to be written\n     * @param {Object} options - options\n     * @param {AbortSignal} options.signal - abort this config write\n     * @returns {void}\n     */\n    replace: function replace(value) {\n      var _arguments4 = arguments;\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var options;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                options = _arguments4.length > 1 && _arguments4[1] !== undefined ? _arguments4[1] : {};\n\n                if (!(!value || Buffer.isBuffer(value))) {\n                  _context4.next = 3;\n                  break;\n                }\n\n                throw errcode(new Error('Invalid value type: ' + typeof value), 'ERR_INVALID_VALUE');\n\n              case 3:\n                return _context4.abrupt(\"return\", setQueue.add(function () {\n                  return _maybeDoSet({\n                    key: undefined,\n                    value: value\n                  }, options.signal);\n                }));\n\n              case 4:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }))();\n    },\n\n    /**\n     * Check if a config file exists.\n     *\n     * @returns {Promise<bool>}\n     */\n    exists: function exists() {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                return _context5.abrupt(\"return\", store.has(configKey));\n\n              case 1:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }))();\n    }\n  };\n  return configStore;\n\n  function _maybeDoSet(_x, _x2) {\n    return _maybeDoSet2.apply(this, arguments);\n  }\n\n  function _maybeDoSet2() {\n    _maybeDoSet2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(m, signal) {\n      var key, value, config;\n      return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              if (!(signal && signal.aborted)) {\n                _context6.next = 2;\n                break;\n              }\n\n              return _context6.abrupt(\"return\");\n\n            case 2:\n              key = m.key;\n              value = m.value;\n\n              if (!key) {\n                _context6.next = 10;\n                break;\n              }\n\n              _context6.next = 7;\n              return configStore.get();\n\n            case 7:\n              config = _context6.sent;\n\n              _set(config, key, value);\n\n              return _context6.abrupt(\"return\", _saveAll(config));\n\n            case 10:\n              return _context6.abrupt(\"return\", _saveAll(value));\n\n            case 11:\n            case \"end\":\n              return _context6.stop();\n          }\n        }\n      }, _callee6);\n    }));\n    return _maybeDoSet2.apply(this, arguments);\n  }\n\n  function _saveAll(config) {\n    var buf = Buffer.from(JSON.stringify(config, null, 2));\n    return store.put(configKey, buf);\n  }\n};","map":null,"metadata":{},"sourceType":"script"}