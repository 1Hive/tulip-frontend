{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\n\nconst Big = require('bignumber.js');\n\nconst MovingAverage = require('moving-average');\n\nclass Stats extends EventEmitter {\n  constructor(initialCounters, options) {\n    super();\n    this._options = options;\n    this._queue = [];\n    this._stats = {};\n    this._frequencyLastTime = Date.now();\n    this._frequencyAccumulators = {};\n    this._movingAverages = {};\n    this._update = this._update.bind(this);\n    initialCounters.forEach(key => {\n      this._stats[key] = Big(0);\n      this._movingAverages[key] = {};\n\n      this._options.movingAverageIntervals.forEach(interval => {\n        const ma = this._movingAverages[key][interval] = MovingAverage(interval);\n        ma.push(this._frequencyLastTime, 0);\n      });\n    });\n    this._enabled = this._options.enabled;\n  }\n\n  enable() {\n    this._enabled = true;\n  }\n\n  disable() {\n    this._disabled = true;\n  }\n\n  stop() {\n    if (this._timeout) {\n      clearTimeout(this._timeout);\n    }\n  }\n\n  get snapshot() {\n    return Object.assign({}, this._stats);\n  }\n\n  get movingAverages() {\n    return Object.assign({}, this._movingAverages);\n  }\n\n  push(counter, inc) {\n    if (this._enabled) {\n      this._queue.push([counter, inc, Date.now()]);\n\n      this._resetComputeTimeout();\n    }\n  }\n\n  _resetComputeTimeout() {\n    if (this._timeout) {\n      clearTimeout(this._timeout);\n    }\n\n    this._timeout = setTimeout(this._update, this._nextTimeout());\n  }\n\n  _nextTimeout() {\n    // calculate the need for an update, depending on the queue length\n    const urgency = this._queue.length / this._options.computeThrottleMaxQueueSize;\n    return Math.max(this._options.computeThrottleTimeout * (1 - urgency), 0);\n  }\n\n  _update() {\n    this._timeout = null;\n\n    if (this._queue.length) {\n      let last;\n\n      while (this._queue.length) {\n        const op = last = this._queue.shift();\n\n        this._applyOp(op);\n      }\n\n      this._updateFrequency(last[2]); // contains timestamp of last op\n\n\n      this.emit('update', this._stats);\n    }\n  }\n\n  _updateFrequency(latestTime) {\n    const timeDiff = latestTime - this._frequencyLastTime;\n    Object.keys(this._stats).forEach(key => {\n      this._updateFrequencyFor(key, timeDiff, latestTime);\n    });\n    this._frequencyLastTime = latestTime;\n  }\n\n  _updateFrequencyFor(key, timeDiffMS, latestTime) {\n    const count = this._frequencyAccumulators[key] || 0;\n    this._frequencyAccumulators[key] = 0;\n    const hz = count / timeDiffMS * 1000;\n    let movingAverages = this._movingAverages[key];\n\n    if (!movingAverages) {\n      movingAverages = this._movingAverages[key] = {};\n    }\n\n    this._options.movingAverageIntervals.forEach(movingAverageInterval => {\n      let movingAverage = movingAverages[movingAverageInterval];\n\n      if (!movingAverage) {\n        movingAverage = movingAverages[movingAverageInterval] = MovingAverage(movingAverageInterval);\n      }\n\n      movingAverage.push(latestTime, hz);\n    });\n  }\n\n  _applyOp(op) {\n    const key = op[0];\n    const inc = op[1];\n\n    if (typeof inc !== 'number') {\n      throw new Error('invalid increment number:', inc);\n    }\n\n    let n;\n\n    if (!Object.prototype.hasOwnProperty.call(this._stats, key)) {\n      n = this._stats[key] = Big(0);\n    } else {\n      n = this._stats[key];\n    }\n\n    this._stats[key] = n.plus(inc);\n\n    if (!this._frequencyAccumulators[key]) {\n      this._frequencyAccumulators[key] = 0;\n    }\n\n    this._frequencyAccumulators[key] += inc;\n  }\n\n}\n\nmodule.exports = Stats;","map":null,"metadata":{},"sourceType":"script"}