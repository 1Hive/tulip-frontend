{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar concat = require('uint8arrays/concat');\n\nvar fromString = require('uint8arrays/from-string');\n\nvar webcrypto = require('../webcrypto'); // Based off of code from https://github.com/luke-park/SecureCompatibleEncryptionExamples\n\n/**\n *\n * @param {object} [options]\n * @param {string} [options.algorithm=AES-GCM]\n * @param {Number} [options.nonceLength=12]\n * @param {Number} [options.keyLength=16]\n * @param {string} [options.digest=sha256]\n * @param {Number} [options.saltLength=16]\n * @param {Number} [options.iterations=32767]\n * @returns {*}\n */\n\n\nfunction create() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref$algorithm = _ref.algorithm,\n      algorithm = _ref$algorithm === void 0 ? 'AES-GCM' : _ref$algorithm,\n      _ref$nonceLength = _ref.nonceLength,\n      nonceLength = _ref$nonceLength === void 0 ? 12 : _ref$nonceLength,\n      _ref$keyLength = _ref.keyLength,\n      keyLength = _ref$keyLength === void 0 ? 16 : _ref$keyLength,\n      _ref$digest = _ref.digest,\n      digest = _ref$digest === void 0 ? 'SHA-256' : _ref$digest,\n      _ref$saltLength = _ref.saltLength,\n      saltLength = _ref$saltLength === void 0 ? 16 : _ref$saltLength,\n      _ref$iterations = _ref.iterations,\n      iterations = _ref$iterations === void 0 ? 32767 : _ref$iterations;\n\n  var crypto = webcrypto.get();\n  keyLength *= 8; // Browser crypto uses bits instead of bytes\n\n  /**\n   * Uses the provided password to derive a pbkdf2 key. The key\n   * will then be used to encrypt the data.\n   *\n   * @param {Uint8Array} data The data to decrypt\n   * @param {string} password A plain password\n   * @returns {Promise<Uint8Array>}\n   */\n\n  function encrypt(_x, _x2) {\n    return _encrypt.apply(this, arguments);\n  }\n  /**\n   * Uses the provided password to derive a pbkdf2 key. The key\n   * will then be used to decrypt the data. The options used to create\n   * this decryption cipher must be the same as those used to create\n   * the encryption cipher.\n   *\n   * @param {Uint8Array} data The data to decrypt\n   * @param {string} password A plain password\n   * @returns {Promise<Uint8Array>}\n   */\n\n\n  function _encrypt() {\n    _encrypt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(data, password) {\n      var salt, nonce, aesGcm, deriveParams, rawKey, cryptoKey, ciphertext;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              // eslint-disable-line require-await\n              salt = crypto.getRandomValues(new Uint8Array(saltLength));\n              nonce = crypto.getRandomValues(new Uint8Array(nonceLength));\n              aesGcm = {\n                name: algorithm,\n                iv: nonce\n              }; // Derive a key using PBKDF2.\n\n              deriveParams = {\n                name: 'PBKDF2',\n                salt: salt,\n                iterations: iterations,\n                hash: {\n                  name: digest\n                }\n              };\n              _context.next = 6;\n              return crypto.subtle.importKey('raw', fromString(password), {\n                name: 'PBKDF2'\n              }, false, ['deriveKey', 'deriveBits']);\n\n            case 6:\n              rawKey = _context.sent;\n              _context.next = 9;\n              return crypto.subtle.deriveKey(deriveParams, rawKey, {\n                name: algorithm,\n                length: keyLength\n              }, true, ['encrypt']);\n\n            case 9:\n              cryptoKey = _context.sent;\n              _context.next = 12;\n              return crypto.subtle.encrypt(aesGcm, cryptoKey, data);\n\n            case 12:\n              ciphertext = _context.sent;\n              return _context.abrupt(\"return\", concat([salt, aesGcm.iv, new Uint8Array(ciphertext)]));\n\n            case 14:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n    return _encrypt.apply(this, arguments);\n  }\n\n  function decrypt(_x3, _x4) {\n    return _decrypt.apply(this, arguments);\n  }\n\n  function _decrypt() {\n    _decrypt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(data, password) {\n      var salt, nonce, ciphertext, aesGcm, deriveParams, rawKey, cryptoKey, plaintext;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              salt = data.slice(0, saltLength);\n              nonce = data.slice(saltLength, saltLength + nonceLength);\n              ciphertext = data.slice(saltLength + nonceLength);\n              aesGcm = {\n                name: algorithm,\n                iv: nonce\n              }; // Derive the key using PBKDF2.\n\n              deriveParams = {\n                name: 'PBKDF2',\n                salt: salt,\n                iterations: iterations,\n                hash: {\n                  name: digest\n                }\n              };\n              _context2.next = 7;\n              return crypto.subtle.importKey('raw', fromString(password), {\n                name: 'PBKDF2'\n              }, false, ['deriveKey', 'deriveBits']);\n\n            case 7:\n              rawKey = _context2.sent;\n              _context2.next = 10;\n              return crypto.subtle.deriveKey(deriveParams, rawKey, {\n                name: algorithm,\n                length: keyLength\n              }, true, ['decrypt']);\n\n            case 10:\n              cryptoKey = _context2.sent;\n              _context2.next = 13;\n              return crypto.subtle.decrypt(aesGcm, cryptoKey, ciphertext);\n\n            case 13:\n              plaintext = _context2.sent;\n              return _context2.abrupt(\"return\", new Uint8Array(plaintext));\n\n            case 15:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n    return _decrypt.apply(this, arguments);\n  }\n\n  return {\n    encrypt: encrypt,\n    decrypt: decrypt\n  };\n}\n\nmodule.exports = {\n  create: create\n};","map":null,"metadata":{},"sourceType":"script"}