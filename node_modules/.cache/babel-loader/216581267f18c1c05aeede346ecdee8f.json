{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst parseDuration = require('parse-duration');\n\nconst crypto = require('libp2p-crypto');\n\nconst errcode = require('err-code');\n\nconst log = debug('ipfs:name:publish');\nlog.error = debug('ipfs:name:publish:error');\n\nconst {\n  OFFLINE_ERROR,\n  normalizePath,\n  withTimeoutOption\n} = require('../../utils');\n\nconst {\n  resolvePath\n} = require('./utils');\n/**\n * @typedef { import(\"../index\") } IPFS\n */\n\n/**\n * IPNS - Inter-Planetary Naming System\n *\n * @param {IPFS} self\n * @returns {Object}\n */\n\n\nmodule.exports = ({\n  ipns,\n  dag,\n  peerInfo,\n  isOnline,\n  keychain,\n  options: constructorOptions\n}) => {\n  const lookupKey = async keyName => {\n    if (keyName === 'self') {\n      return peerInfo.id.privKey;\n    }\n\n    try {\n      const pass = constructorOptions.pass;\n      const pem = await keychain.exportKey(keyName, pass);\n      const privateKey = await crypto.keys.import(pem, pass);\n      return privateKey;\n    } catch (err) {\n      log.error(err);\n      throw errcode(err, 'ERR_CANNOT_GET_KEY');\n    }\n  };\n  /**\n   * IPNS is a PKI namespace, where names are the hashes of public keys, and\n   * the private key enables publishing new (signed) values. In both publish\n   * and resolve, the default name used is the node's own PeerID,\n   * which is the hash of its public key.\n   *\n   * @param {String} value ipfs path of the object to be published.\n   * @param {Object} options ipfs publish options.\n   * @param {boolean} options.resolve resolve given path before publishing.\n   * @param {String} options.lifetime time duration that the record will be valid for.\n  This accepts durations such as \"300s\", \"1.5h\" or \"2h45m\". Valid time units are\n  \"ns\", \"ms\", \"s\", \"m\", \"h\". Default is 24h.\n    * @param {String} options.ttl time duration this record should be cached for (NOT IMPLEMENTED YET).\n    * This accepts durations such as \"300s\", \"1.5h\" or \"2h45m\". Valid time units are\n    \"ns\", \"ms\", \"s\", \"m\", \"h\" (caution: experimental).\n    * @param {String} options.key name of the key to be used, as listed by 'ipfs key list -l'.\n    * @param {function(Error)} [callback]\n    * @returns {Promise|void}\n    */\n\n\n  return withTimeoutOption(async function publish(value, options) {\n    options = options || {};\n    const resolve = !(options.resolve === false);\n    const lifetime = options.lifetime || '24h';\n    const key = options.key || 'self';\n\n    if (!isOnline()) {\n      throw errcode(new Error(OFFLINE_ERROR), 'OFFLINE_ERROR');\n    } // TODO: params related logic should be in the core implementation\n    // Normalize path value\n\n\n    try {\n      value = normalizePath(value);\n    } catch (err) {\n      log.error(err);\n      throw err;\n    }\n\n    let pubLifetime;\n\n    try {\n      pubLifetime = parseDuration(lifetime); // Calculate lifetime with nanoseconds precision\n\n      pubLifetime = pubLifetime.toFixed(6);\n    } catch (err) {\n      log.error(err);\n      throw err;\n    } // TODO: ttl human for cache\n\n\n    const results = await Promise.all([// verify if the path exists, if not, an error will stop the execution\n    lookupKey(key), resolve ? resolvePath({\n      ipns,\n      dag\n    }, value) : Promise.resolve()]); // Start publishing process\n\n    return ipns.publish(results[0], value, pubLifetime);\n  });\n};","map":null,"metadata":{},"sourceType":"script"}