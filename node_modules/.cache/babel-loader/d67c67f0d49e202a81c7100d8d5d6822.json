{"ast":null,"code":"'use strict';\n\nconst Bitswap = require('ipfs-bitswap');\n\nconst multiaddr = require('multiaddr');\n\nconst get = require('dlv');\n\nconst defer = require('p-defer');\n\nconst IPNS = require('../ipns');\n\nconst routingConfig = require('../ipns/routing/config');\n\nconst {\n  AlreadyInitializedError,\n  NotEnabledError\n} = require('../errors');\n\nconst Components = require('./');\n\nconst createMfsPreload = require('../mfs-preload');\n\nconst {\n  withTimeoutOption\n} = require('../utils');\n\nmodule.exports = ({\n  apiManager,\n  options: constructorOptions,\n  blockService,\n  gcLock,\n  initOptions,\n  ipld,\n  keychain,\n  peerInfo,\n  pinManager,\n  preload,\n  print,\n  repo\n}) => withTimeoutOption(async function start() {\n  const startPromise = defer();\n  const {\n    cancel\n  } = apiManager.update({\n    start: () => startPromise.promise\n  });\n\n  try {\n    // The repo may be closed if previously stopped\n    if (repo.closed) {\n      await repo.open();\n    }\n\n    const config = await repo.config.get();\n\n    if (config.Addresses && config.Addresses.Swarm) {\n      config.Addresses.Swarm.forEach(addr => {\n        let ma = multiaddr(addr); // multiaddrs that go via a signalling server or other intermediary (e.g. stardust,\n        // webrtc-star) can have the intermediary's peer ID in the address, so append our\n        // peer ID to the end of it\n\n        const maId = ma.getPeerId();\n\n        if (maId && maId !== peerInfo.id.toB58String()) {\n          ma = ma.encapsulate(`/p2p/${peerInfo.id.toB58String()}`);\n        }\n\n        peerInfo.multiaddrs.add(ma);\n      });\n    }\n\n    const libp2p = Components.libp2p({\n      options: constructorOptions,\n      repo,\n      peerInfo,\n      print,\n      config\n    });\n    await libp2p.start();\n    peerInfo.multiaddrs.forEach(ma => print(`Swarm listening on ${ma}/p2p/${peerInfo.id.toB58String()}`));\n    const ipnsRouting = routingConfig({\n      libp2p,\n      repo,\n      peerInfo,\n      options: constructorOptions\n    });\n    const ipns = new IPNS(ipnsRouting, repo.datastore, peerInfo, keychain, {\n      pass: initOptions.pass\n    });\n    const bitswap = new Bitswap(libp2p, repo.blocks, {\n      statsEnabled: true\n    });\n    await bitswap.start();\n    blockService.setExchange(bitswap);\n    const dag = {\n      get: Components.dag.get({\n        ipld,\n        preload\n      }),\n      resolve: Components.dag.resolve({\n        ipld,\n        preload\n      }),\n      tree: Components.dag.tree({\n        ipld,\n        preload\n      })\n    };\n    const pin = {\n      add: Components.pin.add({\n        pinManager,\n        gcLock,\n        dag\n      }),\n      ls: Components.pin.ls({\n        pinManager,\n        dag\n      }),\n      rm: Components.pin.rm({\n        pinManager,\n        gcLock,\n        dag\n      })\n    }; // FIXME: resolve this circular dependency\n\n    dag.put = Components.dag.put({\n      ipld,\n      pin,\n      gcLock,\n      preload\n    });\n    const block = {\n      get: Components.block.get({\n        blockService,\n        preload\n      }),\n      put: Components.block.put({\n        blockService,\n        pin,\n        gcLock,\n        preload\n      }),\n      rm: Components.block.rm({\n        blockService,\n        gcLock,\n        pinManager\n      }),\n      stat: Components.block.stat({\n        blockService,\n        preload\n      })\n    };\n    const files = Components.files({\n      ipld,\n      block,\n      blockService,\n      repo,\n      preload,\n      options: constructorOptions\n    });\n    const mfsPreload = createMfsPreload({\n      files,\n      preload,\n      options: constructorOptions.preload\n    });\n    await Promise.all([ipns.republisher.start(), preload.start(), mfsPreload.start()]);\n    const api = createApi({\n      apiManager,\n      bitswap,\n      block,\n      blockService,\n      config,\n      constructorOptions,\n      dag,\n      files,\n      gcLock,\n      initOptions,\n      ipld,\n      ipns,\n      keychain,\n      libp2p,\n      mfsPreload,\n      peerInfo,\n      pin,\n      pinManager,\n      preload,\n      print,\n      repo\n    });\n    apiManager.update(api, () => undefined);\n  } catch (err) {\n    cancel();\n    startPromise.reject(err);\n    throw err;\n  }\n\n  startPromise.resolve(apiManager.api);\n  return apiManager.api;\n});\n\nfunction createApi({\n  apiManager,\n  bitswap,\n  block,\n  blockService,\n  config,\n  constructorOptions,\n  dag,\n  files,\n  gcLock,\n  initOptions,\n  ipld,\n  ipns,\n  keychain,\n  libp2p,\n  mfsPreload,\n  peerInfo,\n  pin,\n  pinManager,\n  preload,\n  print,\n  repo\n}) {\n  const object = {\n    data: Components.object.data({\n      ipld,\n      preload\n    }),\n    get: Components.object.get({\n      ipld,\n      preload\n    }),\n    links: Components.object.links({\n      dag\n    }),\n    new: Components.object.new({\n      ipld,\n      preload\n    }),\n    patch: {\n      addLink: Components.object.patch.addLink({\n        ipld,\n        gcLock,\n        preload\n      }),\n      appendData: Components.object.patch.appendData({\n        ipld,\n        gcLock,\n        preload\n      }),\n      rmLink: Components.object.patch.rmLink({\n        ipld,\n        gcLock,\n        preload\n      }),\n      setData: Components.object.patch.setData({\n        ipld,\n        gcLock,\n        preload\n      })\n    },\n    put: Components.object.put({\n      ipld,\n      gcLock,\n      preload\n    }),\n    stat: Components.object.stat({\n      ipld,\n      preload\n    })\n  };\n  const add = Components.add({\n    block,\n    preload,\n    pin,\n    gcLock,\n    options: constructorOptions\n  });\n  const isOnline = Components.isOnline({\n    libp2p\n  });\n\n  const dhtNotEnabled = async () => {\n    // eslint-disable-line require-await\n    throw new NotEnabledError('dht not enabled');\n  };\n\n  const dht = get(libp2p, '_config.dht.enabled', false) ? Components.dht({\n    libp2p,\n    repo\n  }) : {\n    get: dhtNotEnabled,\n    put: dhtNotEnabled,\n    findProvs: dhtNotEnabled,\n    findPeer: dhtNotEnabled,\n    provide: dhtNotEnabled,\n    query: dhtNotEnabled\n  };\n  const dns = Components.dns();\n  const name = {\n    pubsub: {\n      cancel: Components.name.pubsub.cancel({\n        ipns,\n        options: constructorOptions\n      }),\n      state: Components.name.pubsub.state({\n        ipns,\n        options: constructorOptions\n      }),\n      subs: Components.name.pubsub.subs({\n        ipns,\n        options: constructorOptions\n      })\n    },\n    publish: Components.name.publish({\n      ipns,\n      dag,\n      peerInfo,\n      isOnline,\n      keychain,\n      options: constructorOptions\n    }),\n    resolve: Components.name.resolve({\n      dns,\n      ipns,\n      peerInfo,\n      isOnline,\n      options: constructorOptions\n    })\n  };\n  const resolve = Components.resolve({\n    name,\n    ipld\n  });\n  const refs = Components.refs({\n    ipld,\n    resolve,\n    preload\n  });\n  refs.local = Components.refs.local({\n    repo\n  });\n\n  const pubsubNotEnabled = async () => {\n    // eslint-disable-line require-await\n    throw new NotEnabledError('pubsub not enabled');\n  };\n\n  const pubsub = get(constructorOptions, 'config.Pubsub.Enabled', get(config, 'Pubsub.Enabled', true)) ? Components.pubsub({\n    libp2p\n  }) : {\n    subscribe: pubsubNotEnabled,\n    unsubscribe: pubsubNotEnabled,\n    publish: pubsubNotEnabled,\n    ls: pubsubNotEnabled,\n    peers: pubsubNotEnabled\n  };\n  const api = {\n    add,\n    bitswap: {\n      stat: Components.bitswap.stat({\n        bitswap\n      }),\n      unwant: Components.bitswap.unwant({\n        bitswap\n      }),\n      wantlist: Components.bitswap.wantlist({\n        bitswap\n      })\n    },\n    block,\n    bootstrap: {\n      add: Components.bootstrap.add({\n        repo\n      }),\n      list: Components.bootstrap.list({\n        repo\n      }),\n      rm: Components.bootstrap.rm({\n        repo\n      })\n    },\n    cat: Components.cat({\n      ipld,\n      preload\n    }),\n    config: Components.config({\n      repo\n    }),\n    dag,\n    dht,\n    dns,\n    files,\n    get: Components.get({\n      ipld,\n      preload\n    }),\n    id: Components.id({\n      peerInfo,\n      libp2p\n    }),\n    init: async () => {\n      throw new AlreadyInitializedError();\n    },\n    // eslint-disable-line require-await\n    isOnline,\n    key: {\n      export: Components.key.export({\n        keychain\n      }),\n      gen: Components.key.gen({\n        keychain\n      }),\n      import: Components.key.import({\n        keychain\n      }),\n      info: Components.key.info({\n        keychain\n      }),\n      list: Components.key.list({\n        keychain\n      }),\n      rename: Components.key.rename({\n        keychain\n      }),\n      rm: Components.key.rm({\n        keychain\n      })\n    },\n    libp2p,\n    ls: Components.ls({\n      ipld,\n      preload\n    }),\n    name,\n    object,\n    pin,\n    ping: Components.ping({\n      libp2p\n    }),\n    pubsub,\n    refs,\n    repo: {\n      gc: Components.repo.gc({\n        gcLock,\n        pin,\n        pinManager,\n        refs,\n        repo\n      }),\n      stat: Components.repo.stat({\n        repo\n      }),\n      version: Components.repo.version({\n        repo\n      })\n    },\n    resolve,\n    start: () => apiManager.api,\n    stats: {\n      bitswap: Components.bitswap.stat({\n        bitswap\n      }),\n      bw: libp2p.metrics ? Components.stats.bw({\n        libp2p\n      }) : async () => {\n        // eslint-disable-line require-await\n        throw new NotEnabledError('libp2p metrics not enabled');\n      },\n      repo: Components.repo.stat({\n        repo\n      })\n    },\n    stop: Components.stop({\n      apiManager,\n      bitswap,\n      options: constructorOptions,\n      blockService,\n      gcLock,\n      initOptions,\n      ipld,\n      ipns,\n      keychain,\n      libp2p,\n      mfsPreload,\n      peerInfo,\n      preload,\n      print,\n      repo\n    }),\n    swarm: {\n      addrs: Components.swarm.addrs({\n        libp2p\n      }),\n      connect: Components.swarm.connect({\n        libp2p\n      }),\n      disconnect: Components.swarm.disconnect({\n        libp2p\n      }),\n      localAddrs: Components.swarm.localAddrs({\n        peerInfo\n      }),\n      peers: Components.swarm.peers({\n        libp2p\n      })\n    },\n    version: Components.version({\n      repo\n    })\n  };\n  return api;\n}","map":null,"metadata":{},"sourceType":"script"}