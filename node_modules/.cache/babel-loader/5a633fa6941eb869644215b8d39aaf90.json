{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst events_1 = require(\"events\");\n\nconst store_1 = __importDefault(require(\"store\"));\n\nconst did_jwt_1 = require(\"did-jwt\");\n\nconst ipfs_did_document_1 = __importDefault(require(\"ipfs-did-document\"));\n\nconst _3id_blockchain_utils_1 = require(\"3id-blockchain-utils\");\n\nconst crypto_1 = require(\"./crypto\");\n\nconst did_provider_1 = require(\"./did-provider\");\n\nconst keyring_1 = __importDefault(require(\"./keyring\"));\n\nconst threeIdProvider_1 = __importDefault(require(\"./threeIdProvider\"));\n\nconst utils_1 = require(\"./utils\");\n\nconst DID_METHOD_NAME = '3';\n\nclass IdentityWallet {\n  constructor(getConsent, config = {}) {\n    this.events = new events_1.EventEmitter();\n    if (typeof getConsent !== 'function') throw new Error('getConsent parameter has to be a function');\n    this._getConsent = getConsent;\n\n    if (config.seed) {\n      this._seed = config.seed;\n    } else if (config.authSecret) {\n      this._authSecret = config.authSecret;\n    } else if (config.externalAuth) {\n      this._externalAuth = config.externalAuth;\n    } else {\n      throw new Error('Either seed, or authSecret has to be passed to create an IdentityWallet instance');\n    }\n  }\n\n  get3idProvider() {\n    return new threeIdProvider_1.default(this);\n  }\n\n  getDidProvider() {\n    return new did_provider_1.DidProvider(this);\n  }\n\n  hasConsent(spaces = [], origin, {\n    address\n  } = {}) {\n    var _a;\n\n    const key = (_a = address !== null && address !== void 0 ? address : this._keyring.getPublicKeys().managementKey) !== null && _a !== void 0 ? _a : '';\n    const prefix = `3id_consent_${key}_${origin !== null && origin !== void 0 ? origin : ''}_`;\n\n    const consentExists = (space = '') => Boolean(store_1.default.get(prefix + space));\n\n    return spaces.reduce((acc, space) => acc && consentExists(space), consentExists());\n  }\n\n  getConsent(spaces = [], origin, {\n    address\n  } = {}) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.hasConsent(spaces, origin, {\n        address\n      })) {\n        const consent = yield this._getConsent({\n          type: 'authenticate',\n          origin,\n          spaces,\n          opts: {\n            address\n          }\n        });\n        if (!consent) return false;\n        const key = (_a = address !== null && address !== void 0 ? address : this._keyring.getPublicKeys().managementKey) !== null && _a !== void 0 ? _a : '';\n        const prefix = `3id_consent_${key}_${origin !== null && origin !== void 0 ? origin : ''}_`;\n\n        const saveConsent = (space = '') => store_1.default.set(prefix + space, true);\n\n        saveConsent();\n        spaces.map(saveConsent);\n      }\n\n      return true;\n    });\n  }\n\n  getLink() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this._seed) {\n        this._keyring = new keyring_1.default(this._seed);\n        this.DID = yield this._get3id();\n        delete this._seed;\n        yield this._linkManagementAddress();\n      }\n\n      return this._keyring ? this._keyring.getPublicKeys().managementKey : keyring_1.default.walletForAuthSecret(this._authSecret).address;\n    });\n  }\n\n  getRootSigner(pubKeyId) {\n    if (pubKeyId == null) {\n      return this._keyring.getRootSigner();\n    }\n\n    const [did, keyId] = pubKeyId.split('#');\n\n    if (this.DID == null || did !== this.DID) {\n      throw new Error('Invalid DID');\n    }\n\n    return this._keyring.getRootSigner(keyId);\n  }\n\n  _linkManagementAddress() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const managementWallet = this._keyring.managementWallet();\n\n      this.events.emit('new-link-proof', yield _3id_blockchain_utils_1.createLink(this.DID, managementWallet.address, utils_1.fakeEthProvider(managementWallet)));\n    });\n  }\n\n  linkAddress(address, provider) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this._keyring) throw new Error('This method can only be called after authenticate has been called');\n      const proof = yield _3id_blockchain_utils_1.createLink(this.DID, address, provider);\n      this.events.emit('new-link-proof', proof);\n      return proof;\n    });\n  }\n\n  linkManagementKey() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this._externalAuth) return null;\n      const timestamp = Math.floor(new Date().getTime() / 1000);\n      const msg = `Create a new 3Box profile\\n\\n- \\nYour unique profile ID is ${this.DID} \\nTimestamp: ${timestamp}`;\n      return {\n        msg,\n        timestamp,\n        sig: yield this._keyring.managementPersonalSign(msg)\n      };\n    });\n  }\n\n  _initKeyring(authData, address, spaces) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this._seed) {\n        yield this.getLink();\n      } else if (authData && authData.length > 0) {\n        let seed;\n        authData.find(({\n          ciphertext,\n          nonce\n        }) => {\n          seed = keyring_1.default.decryptWithAuthSecret(ciphertext, nonce, this._authSecret);\n          return Boolean(seed);\n        });\n        if (!seed) throw new Error('No valid auth-secret for this identity');\n        this._keyring = new keyring_1.default(seed);\n        this.DID = yield this._get3id();\n      } else if (this._externalAuth) {\n        if (!address) throw new Error('External authentication requires an address');\n        const migratedKeys = yield this._externalAuth({\n          address,\n          spaces,\n          type: '3id_migration'\n        });\n        this._keyring = new keyring_1.default(null, migratedKeys);\n        this.DID = yield this._get3id();\n        const proof = yield this._externalAuth({\n          address,\n          type: '3id_createLink',\n          did: this.DID\n        });\n        if (proof) this.events.emit('new-link-proof', proof);\n      } else {\n        const seed = '0x' + Buffer.from(crypto_1.naclRandom(32)).toString('hex');\n        this._keyring = new keyring_1.default(seed);\n        this.DID = yield this._get3id();\n        yield this.addAuthMethod(this._authSecret);\n      }\n    });\n  }\n\n  authenticate(spaces = [], {\n    authData,\n    address,\n    mgmtPub\n  } = {}, origin) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let consent;\n      if (address) consent = yield this.getConsent(spaces, origin, {\n        address\n      });\n      if (!this._keyring || this._externalAuth) yield this._initKeyring(authData, address, spaces);\n      if (!address) consent = this.getConsent(spaces, origin);\n      if (!consent) throw new Error('Authentication not authorized by user');\n      return {\n        main: this._keyring.getPublicKeys({\n          mgmtPub\n        }),\n        spaces: spaces.reduce((acc, space) => {\n          acc[space] = this._keyring.getPublicKeys({\n            space,\n            uncompressed: true\n          });\n          return acc;\n        }, {})\n      };\n    });\n  }\n\n  isAuthenticated(spaces = [], origin, {\n    address\n  } = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return Boolean(this._keyring) && this.hasConsent(spaces, origin, {\n        address\n      });\n    });\n  }\n\n  addAuthMethod(authSecret) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this._keyring) throw new Error('This method can only be called after authenticate has been called');\n\n      const message = this._keyring.serialize();\n\n      const encAuthData = keyring_1.default.encryptWithAuthSecret(message, authSecret);\n      this.events.emit('new-auth-method', encAuthData);\n      const authWallet = keyring_1.default.walletForAuthSecret(authSecret);\n      this.events.emit('new-link-proof', yield _3id_blockchain_utils_1.createLink(this.DID, authWallet.address, utils_1.fakeEthProvider(authWallet)));\n    });\n  }\n\n  signClaim(payload, {\n    DID,\n    space,\n    expiresIn,\n    useMgmt\n  } = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this._keyring) {\n        throw new Error('This method can only be called after authenticate has been called');\n      }\n\n      const issuer = DID || (yield this._get3id(space));\n      const settings = {\n        signer: this._keyring.getJWTSigner(space, useMgmt),\n        issuer,\n        expiresIn\n      };\n      return did_jwt_1.createJWT(payload, settings);\n    });\n  }\n\n  encrypt(message, space, {\n    nonce,\n    blockSize,\n    to\n  } = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this._keyring) throw new Error('This method can only be called after authenticate has been called');\n      const paddedMsg = typeof message === 'string' ? utils_1.pad(message, blockSize) : message;\n\n      if (to) {\n        return this._keyring.asymEncrypt(paddedMsg, to, {\n          nonce\n        });\n      } else {\n        return this._keyring.symEncrypt(paddedMsg, {\n          space,\n          nonce\n        });\n      }\n    });\n  }\n\n  decrypt(encObj, space, toBuffer) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this._keyring) throw new Error('This method can only be called after authenticate has been called');\n      let paddedMsg;\n\n      if (encObj.ephemeralFrom) {\n        paddedMsg = this._keyring.asymDecrypt(encObj.ciphertext, encObj.ephemeralFrom, encObj.nonce, {\n          space,\n          toBuffer\n        });\n      } else {\n        paddedMsg = this._keyring.symDecrypt(encObj.ciphertext, encObj.nonce, {\n          space,\n          toBuffer\n        });\n      }\n\n      if (!paddedMsg) throw new Error('IdentityWallet: Could not decrypt message');\n      return toBuffer ? paddedMsg : utils_1.unpad(paddedMsg);\n    });\n  }\n\n  hashDBKey(key, space) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const salt = this._keyring.getDBSalt(space);\n\n      return utils_1.sha256Multihash(salt + key);\n    });\n  }\n\n  _get3id(space) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const pubkeys = this._keyring.getPublicKeys({\n        space,\n        uncompressed: true\n      });\n\n      const doc = new ipfs_did_document_1.default(utils_1.fakeIpfs, DID_METHOD_NAME);\n\n      if (!space) {\n        if (this.DID) return this.DID;\n        doc.addPublicKey('signingKey', 'Secp256k1VerificationKey2018', 'publicKeyHex', pubkeys.signingKey);\n        doc.addPublicKey('encryptionKey', 'Curve25519EncryptionPublicKey', 'publicKeyBase64', pubkeys.asymEncryptionKey);\n        doc.addPublicKey('managementKey', 'Secp256k1VerificationKey2018', 'ethereumAddress', pubkeys.managementKey);\n        doc.addAuthentication('Secp256k1SignatureAuthentication2018', 'signingKey');\n      } else {\n        doc.addPublicKey('subSigningKey', 'Secp256k1VerificationKey2018', 'publicKeyHex', pubkeys.signingKey);\n        doc.addPublicKey('subEncryptionKey', 'Curve25519EncryptionPublicKey', 'publicKeyBase64', pubkeys.asymEncryptionKey);\n        doc.addAuthentication('Secp256k1SignatureAuthentication2018', 'subSigningKey');\n        doc.addCustomProperty('space', space);\n        doc.addCustomProperty('root', this.DID);\n        const payload = {\n          subSigningKey: pubkeys.signingKey,\n          subEncryptionKey: pubkeys.asymEncryptionKey,\n          space: space,\n          iat: null\n        };\n        const signature = (yield this.signClaim(payload)).split('.')[2];\n        doc.addCustomProperty('proof', {\n          alg: 'ES256K',\n          signature\n        });\n      }\n\n      yield doc.commit({\n        noTimestamp: true\n      });\n      return doc.DID;\n    });\n  }\n\n}\n\nexports.default = IdentityWallet;","map":null,"metadata":{},"sourceType":"script"}