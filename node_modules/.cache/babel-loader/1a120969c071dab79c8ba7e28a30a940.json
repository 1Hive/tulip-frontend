{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar debug = require('debug');\n\nvar pb = require('it-protocol-buffers');\n\nvar lp = require('it-length-prefixed');\n\nvar pipe = require('it-pipe');\n\nvar _require2 = require('streaming-iterables'),\n    collect = _require2.collect,\n    take = _require2.take,\n    consume = _require2.consume;\n\nvar PeerInfo = require('peer-info');\n\nvar PeerId = require('peer-id');\n\nvar multiaddr = require('multiaddr');\n\nvar _require3 = require('it-buffer'),\n    toBuffer = _require3.toBuffer;\n\nvar Message = require('./message');\n\nvar log = debug('libp2p:identify');\nlog.error = debug('libp2p:identify:error');\n\nvar _require4 = require('./consts'),\n    MULTICODEC_IDENTIFY = _require4.MULTICODEC_IDENTIFY,\n    MULTICODEC_IDENTIFY_PUSH = _require4.MULTICODEC_IDENTIFY_PUSH,\n    AGENT_VERSION = _require4.AGENT_VERSION,\n    PROTOCOL_VERSION = _require4.PROTOCOL_VERSION;\n\nvar errCode = require('err-code');\n\nvar _require5 = require('../errors'),\n    codes = _require5.codes;\n\nvar IdentifyService = /*#__PURE__*/function () {\n  /**\n   * @constructor\n   * @param {object} options\n   * @param {Registrar} options.registrar\n   * @param {Map<string, handler>} options.protocols A reference to the protocols we support\n   * @param {PeerInfo} options.peerInfo The peer running the identify service\n   */\n  function IdentifyService(options) {\n    _classCallCheck(this, IdentifyService);\n\n    /**\n     * @property {Registrar}\n     */\n    this.registrar = options.registrar;\n    /**\n     * @property {PeerInfo}\n     */\n\n    this.peerInfo = options.peerInfo;\n    this._protocols = options.protocols;\n    this.handleMessage = this.handleMessage.bind(this);\n  }\n  /**\n   * Send an Identify Push update to the list of connections\n   * @param {Array<Connection>} connections\n   * @returns {Promise<void>}\n   */\n\n\n  _createClass(IdentifyService, [{\n    key: \"push\",\n    value: function push(connections) {\n      var _this = this;\n\n      var pushes = connections.map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(connection) {\n          var _yield$connection$new, stream;\n\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.prev = 0;\n                  _context.next = 3;\n                  return connection.newStream(MULTICODEC_IDENTIFY_PUSH);\n\n                case 3:\n                  _yield$connection$new = _context.sent;\n                  stream = _yield$connection$new.stream;\n                  _context.next = 7;\n                  return pipe([{\n                    listenAddrs: _this.peerInfo.multiaddrs.toArray().map(function (ma) {\n                      return ma.buffer;\n                    }),\n                    protocols: Array.from(_this._protocols.keys())\n                  }], pb.encode(Message), stream, consume);\n\n                case 7:\n                  _context.next = 12;\n                  break;\n\n                case 9:\n                  _context.prev = 9;\n                  _context.t0 = _context[\"catch\"](0);\n                  // Just log errors\n                  log.error('could not push identify update to peer', _context.t0);\n\n                case 12:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, null, [[0, 9]]);\n        }));\n\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n      return Promise.all(pushes);\n    }\n    /**\n     * Calls `push` for all peers in the `peerStore` that are connected\n     * @param {PeerStore} peerStore\n     */\n\n  }, {\n    key: \"pushToPeerStore\",\n    value: function pushToPeerStore(peerStore) {\n      var connections = [];\n      var connection;\n\n      var _iterator = _createForOfIteratorHelper(peerStore.peers.values()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var peer = _step.value;\n\n          if (peer.protocols.has(MULTICODEC_IDENTIFY_PUSH) && (connection = this.registrar.getConnection(peer))) {\n            connections.push(connection);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      this.push(connections);\n    }\n    /**\n     * Requests the `Identify` message from peer associated with the given `connection`.\n     * If the identified peer does not match the `PeerId` associated with the connection,\n     * an error will be thrown.\n     *\n     * @async\n     * @param {Connection} connection\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"identify\",\n    value: function () {\n      var _identify = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(connection) {\n        var _yield$connection$new2, stream, _yield$pipe, _yield$pipe2, data, message, _message, publicKey, listenAddrs, protocols, observedAddr, id, peerInfo;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return connection.newStream(MULTICODEC_IDENTIFY);\n\n              case 2:\n                _yield$connection$new2 = _context2.sent;\n                stream = _yield$connection$new2.stream;\n                _context2.next = 6;\n                return pipe([], stream, lp.decode(), take(1), toBuffer, collect);\n\n              case 6:\n                _yield$pipe = _context2.sent;\n                _yield$pipe2 = _slicedToArray(_yield$pipe, 1);\n                data = _yield$pipe2[0];\n\n                if (data) {\n                  _context2.next = 11;\n                  break;\n                }\n\n                throw errCode(new Error('No data could be retrieved'), codes.ERR_CONNECTION_ENDED);\n\n              case 11:\n                _context2.prev = 11;\n                message = Message.decode(data);\n                _context2.next = 18;\n                break;\n\n              case 15:\n                _context2.prev = 15;\n                _context2.t0 = _context2[\"catch\"](11);\n                throw errCode(_context2.t0, codes.ERR_INVALID_MESSAGE);\n\n              case 18:\n                _message = message, publicKey = _message.publicKey, listenAddrs = _message.listenAddrs, protocols = _message.protocols, observedAddr = _message.observedAddr;\n                _context2.next = 21;\n                return PeerId.createFromPubKey(publicKey);\n\n              case 21:\n                id = _context2.sent;\n                peerInfo = new PeerInfo(id);\n\n                if (!(connection.remotePeer.toB58String() !== id.toB58String())) {\n                  _context2.next = 25;\n                  break;\n                }\n\n                throw errCode(new Error('identified peer does not match the expected peer'), codes.ERR_INVALID_PEER);\n\n              case 25:\n                // Get the observedAddr if there is one\n                observedAddr = IdentifyService.getCleanMultiaddr(observedAddr); // Copy the listenAddrs and protocols\n\n                IdentifyService.updatePeerAddresses(peerInfo, listenAddrs);\n                IdentifyService.updatePeerProtocols(peerInfo, protocols);\n                this.registrar.peerStore.replace(peerInfo); // TODO: Track our observed address so that we can score it\n\n                log('received observed address of %s', observedAddr);\n\n              case 30:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[11, 15]]);\n      }));\n\n      function identify(_x2) {\n        return _identify.apply(this, arguments);\n      }\n\n      return identify;\n    }()\n    /**\n     * A handler to register with Libp2p to process identify messages.\n     *\n     * @param {object} options\n     * @param {String} options.protocol\n     * @param {*} options.stream\n     * @param {Connection} options.connection\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"handleMessage\",\n    value: function handleMessage(_ref2) {\n      var connection = _ref2.connection,\n          stream = _ref2.stream,\n          protocol = _ref2.protocol;\n\n      switch (protocol) {\n        case MULTICODEC_IDENTIFY:\n          return this._handleIdentify({\n            connection: connection,\n            stream: stream\n          });\n\n        case MULTICODEC_IDENTIFY_PUSH:\n          return this._handlePush({\n            connection: connection,\n            stream: stream\n          });\n\n        default:\n          log.error('cannot handle unknown protocol %s', protocol);\n      }\n    }\n    /**\n     * Sends the `Identify` response to the requesting peer over the\n     * given `connection`\n     * @private\n     * @param {object} options\n     * @param {*} options.stream\n     * @param {Connection} options.connection\n     */\n\n  }, {\n    key: \"_handleIdentify\",\n    value: function () {\n      var _handleIdentify2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(_ref3) {\n        var connection, stream, publicKey, message;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                connection = _ref3.connection, stream = _ref3.stream;\n                publicKey = Buffer.alloc(0);\n\n                if (this.peerInfo.id.pubKey) {\n                  publicKey = this.peerInfo.id.pubKey.bytes;\n                }\n\n                message = Message.encode({\n                  protocolVersion: PROTOCOL_VERSION,\n                  agentVersion: AGENT_VERSION,\n                  publicKey: publicKey,\n                  listenAddrs: this.peerInfo.multiaddrs.toArray().map(function (ma) {\n                    return ma.buffer;\n                  }),\n                  observedAddr: connection.remoteAddr.buffer,\n                  protocols: Array.from(this._protocols.keys())\n                });\n                _context3.prev = 4;\n                _context3.next = 7;\n                return pipe([message], lp.encode(), stream, consume);\n\n              case 7:\n                _context3.next = 12;\n                break;\n\n              case 9:\n                _context3.prev = 9;\n                _context3.t0 = _context3[\"catch\"](4);\n                log.error('could not respond to identify request', _context3.t0);\n\n              case 12:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[4, 9]]);\n      }));\n\n      function _handleIdentify(_x3) {\n        return _handleIdentify2.apply(this, arguments);\n      }\n\n      return _handleIdentify;\n    }()\n    /**\n     * Reads the Identify Push message from the given `connection`\n     * @private\n     * @param {object} options\n     * @param {*} options.stream\n     * @param {Connection} options.connection\n     */\n\n  }, {\n    key: \"_handlePush\",\n    value: function () {\n      var _handlePush2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(_ref4) {\n        var connection, stream, message, _yield$pipe3, _yield$pipe4, data, peerInfo;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                connection = _ref4.connection, stream = _ref4.stream;\n                _context4.prev = 1;\n                _context4.next = 4;\n                return pipe([], stream, lp.decode(), take(1), toBuffer, collect);\n\n              case 4:\n                _yield$pipe3 = _context4.sent;\n                _yield$pipe4 = _slicedToArray(_yield$pipe3, 1);\n                data = _yield$pipe4[0];\n                message = Message.decode(data);\n                _context4.next = 13;\n                break;\n\n              case 10:\n                _context4.prev = 10;\n                _context4.t0 = _context4[\"catch\"](1);\n                return _context4.abrupt(\"return\", log.error('received invalid message', _context4.t0));\n\n              case 13:\n                // Update the listen addresses\n                peerInfo = new PeerInfo(connection.remotePeer);\n                _context4.prev = 14;\n                IdentifyService.updatePeerAddresses(peerInfo, message.listenAddrs);\n                _context4.next = 21;\n                break;\n\n              case 18:\n                _context4.prev = 18;\n                _context4.t1 = _context4[\"catch\"](14);\n                return _context4.abrupt(\"return\", log.error('received invalid listen addrs', _context4.t1));\n\n              case 21:\n                // Update the protocols\n                IdentifyService.updatePeerProtocols(peerInfo, message.protocols); // Update the peer in the PeerStore\n\n                this.registrar.peerStore.replace(peerInfo);\n\n              case 23:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[1, 10], [14, 18]]);\n      }));\n\n      function _handlePush(_x4) {\n        return _handlePush2.apply(this, arguments);\n      }\n\n      return _handlePush;\n    }()\n  }], [{\n    key: \"updatePeerAddresses\",\n    value:\n    /**\n     * Replaces the multiaddrs on the given `peerInfo`,\n     * with the provided `multiaddrs`\n     * @param {PeerInfo} peerInfo\n     * @param {Array<Multiaddr>|Array<Buffer>} multiaddrs\n     */\n    function updatePeerAddresses(peerInfo, multiaddrs) {\n      if (multiaddrs && multiaddrs.length > 0) {\n        peerInfo.multiaddrs.clear();\n        multiaddrs.forEach(function (ma) {\n          try {\n            peerInfo.multiaddrs.add(ma);\n          } catch (err) {\n            log.error('could not add multiaddr', err);\n          }\n        });\n      }\n    }\n    /**\n     * Replaces the protocols on the given `peerInfo`,\n     * with the provided `protocols`\n     * @static\n     * @param {PeerInfo} peerInfo\n     * @param {Array<string>} protocols\n     */\n\n  }, {\n    key: \"updatePeerProtocols\",\n    value: function updatePeerProtocols(peerInfo, protocols) {\n      if (protocols && protocols.length > 0) {\n        peerInfo.protocols.clear();\n        protocols.forEach(function (proto) {\n          return peerInfo.protocols.add(proto);\n        });\n      }\n    }\n    /**\n     * Takes the `addr` and converts it to a Multiaddr if possible\n     * @param {Buffer|String} addr\n     * @returns {Multiaddr|null}\n     */\n\n  }, {\n    key: \"getCleanMultiaddr\",\n    value: function getCleanMultiaddr(addr) {\n      if (addr && addr.length > 0) {\n        try {\n          return multiaddr(addr);\n        } catch (_) {\n          return null;\n        }\n      }\n\n      return null;\n    }\n  }]);\n\n  return IdentifyService;\n}();\n\nmodule.exports.IdentifyService = IdentifyService;\n/**\n * The protocols the IdentifyService supports\n * @property multicodecs\n */\n\nmodule.exports.multicodecs = {\n  IDENTIFY: MULTICODEC_IDENTIFY,\n  IDENTIFY_PUSH: MULTICODEC_IDENTIFY_PUSH\n};\nmodule.exports.Message = Message;","map":null,"metadata":{},"sourceType":"script"}