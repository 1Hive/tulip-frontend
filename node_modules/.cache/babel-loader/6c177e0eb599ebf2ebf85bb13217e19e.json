{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _require = require('peer-id'),\n    createFromPrivKey = _require.createFromPrivKey;\n\nvar errcode = require('err-code');\n\nvar debug = require('debug');\n\nvar log = debug('ipfs:ipns');\nlog.error = debug('ipfs:ipns:error');\n\nvar IpnsPublisher = require('./publisher');\n\nvar IpnsRepublisher = require('./republisher');\n\nvar IpnsResolver = require('./resolver');\n\nvar _require2 = require('../utils'),\n    normalizePath = _require2.normalizePath;\n\nvar TLRU = require('../../utils/tlru');\n\nvar defaultRecordTtl = 60 * 1000;\n\nvar IPNS = /*#__PURE__*/function () {\n  function IPNS(routing, datastore, peerInfo, keychain, options) {\n    _classCallCheck(this, IPNS);\n\n    this.publisher = new IpnsPublisher(routing, datastore);\n    this.republisher = new IpnsRepublisher(this.publisher, datastore, peerInfo, keychain, options);\n    this.resolver = new IpnsResolver(routing);\n    this.cache = new TLRU(1000);\n    this.routing = routing;\n  } // Publish\n\n\n  _createClass(IPNS, [{\n    key: \"publish\",\n    value: function () {\n      var _publish = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(privKey, value) {\n        var lifetime,\n            peerId,\n            id,\n            ttEol,\n            ttl,\n            _args = arguments;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                lifetime = _args.length > 2 && _args[2] !== undefined ? _args[2] : IpnsPublisher.defaultRecordLifetime;\n                _context.prev = 1;\n                value = normalizePath(value);\n                _context.next = 5;\n                return createFromPrivKey(privKey.bytes);\n\n              case 5:\n                peerId = _context.sent;\n                _context.next = 8;\n                return this.publisher.publishWithEOL(privKey, value, lifetime);\n\n              case 8:\n                log(\"IPNS value \".concat(value, \" was published correctly\")); // // Add to cache\n\n                id = peerId.toB58String();\n                ttEol = parseFloat(lifetime);\n                ttl = ttEol < defaultRecordTtl ? ttEol : defaultRecordTtl;\n                this.cache.set(id, value, ttl);\n                log(\"IPNS value \".concat(value, \" was cached correctly\"));\n                return _context.abrupt(\"return\", {\n                  name: id,\n                  value: value\n                });\n\n              case 17:\n                _context.prev = 17;\n                _context.t0 = _context[\"catch\"](1);\n                log.error(_context.t0);\n                throw _context.t0;\n\n              case 21:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[1, 17]]);\n      }));\n\n      function publish(_x, _x2) {\n        return _publish.apply(this, arguments);\n      }\n\n      return publish;\n    }() // Resolve\n\n  }, {\n    key: \"resolve\",\n    value: function () {\n      var _resolve = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(name, options) {\n        var id, result, _result;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(typeof name !== 'string')) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                throw errcode(new Error('name received is not valid'), 'ERR_INVALID_NAME');\n\n              case 2:\n                options = options || {}; // If recursive, we should not try to get the cached value\n\n                if (!(!options.nocache && !options.recursive)) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                // Try to get the record from cache\n                id = name.split('/')[2];\n                result = this.cache.get(id);\n\n                if (!result) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", result);\n\n              case 8:\n                _context2.prev = 8;\n                _context2.next = 11;\n                return this.resolver.resolve(name, options);\n\n              case 11:\n                _result = _context2.sent;\n                log(\"IPNS record from \".concat(name, \" was resolved correctly\"));\n                return _context2.abrupt(\"return\", _result);\n\n              case 16:\n                _context2.prev = 16;\n                _context2.t0 = _context2[\"catch\"](8);\n                log.error(_context2.t0);\n                throw _context2.t0;\n\n              case 20:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[8, 16]]);\n      }));\n\n      function resolve(_x3, _x4) {\n        return _resolve.apply(this, arguments);\n      }\n\n      return resolve;\n    }() // Initialize keyspace\n    // sets the ipns record for the given key to point to an empty directory\n\n  }, {\n    key: \"initializeKeyspace\",\n    value: function () {\n      var _initializeKeyspace = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(privKey, value) {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", this.publish(privKey, value, IpnsPublisher.defaultRecordLifetime));\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function initializeKeyspace(_x5, _x6) {\n        return _initializeKeyspace.apply(this, arguments);\n      }\n\n      return initializeKeyspace;\n    }()\n  }]);\n\n  return IPNS;\n}();\n\nmodule.exports = IPNS;","map":null,"metadata":{},"sourceType":"script"}