{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar path = require('path');\n\nvar EventEmitter = require('events');\n\nvar PROTOCOL = require('./protocol');\n\nvar encode = require('./encoding');\n\nvar waitForPeers = require('./wait-for-peers');\n\nvar getPeerID = require('./get-peer-id');\n/**\n * Communication channel over Pubsub between two IPFS nodes\n */\n\n\nvar DirectChannel = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(DirectChannel, _EventEmitter);\n\n  var _super = _createSuper(DirectChannel);\n\n  function DirectChannel(ipfs, receiverID) {\n    var _this;\n\n    _classCallCheck(this, DirectChannel);\n\n    _this = _super.call(this); // IPFS instance to use internally\n\n    _this._ipfs = ipfs;\n\n    if (!ipfs.pubsub) {\n      throw new Error('This IPFS node does not support pubsub.');\n    }\n\n    _this._receiverID = receiverID;\n\n    if (!_this._receiverID) {\n      throw new Error('Receiver ID was undefined');\n    } // See _setup() for more state initialization\n\n\n    return _this;\n  }\n  /**\n   * Channel ID\n   * @return {[String]} Channel's ID\n   */\n\n\n  _createClass(DirectChannel, [{\n    key: \"id\",\n    get: function get() {\n      return this._id;\n    }\n    /**\n     * Peers participating in this channel\n     * @return {[Array]} Array of peer IDs participating in this channel\n     */\n\n  }, {\n    key: \"peers\",\n    get: function get() {\n      return this._peers;\n    }\n  }, {\n    key: \"connect\",\n    value: function () {\n      var _connect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return waitForPeers(this._ipfs, [this._receiverID], this._id);\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function connect() {\n        return _connect.apply(this, arguments);\n      }\n\n      return connect;\n    }()\n    /**\n     * Send a message to the other peer\n     * @param  {[Any]} message Payload\n     */\n\n  }, {\n    key: \"send\",\n    value: function () {\n      var _send = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(message) {\n        var m;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                m = encode(message);\n                _context2.next = 3;\n                return this._ipfs.pubsub.publish(this._id, m);\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function send(_x) {\n        return _send.apply(this, arguments);\n      }\n\n      return send;\n    }()\n    /**\n     * Close the channel\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      this.removeAllListeners('message');\n\n      this._ipfs.pubsub.unsubscribe(this._id, this._messageHandler);\n    }\n  }, {\n    key: \"_setup\",\n    value: function () {\n      var _setup2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var _this2 = this;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return getPeerID(this._ipfs);\n\n              case 2:\n                this._senderID = _context3.sent;\n                // Channel's participants\n                this._peers = Array.from([this._senderID, this._receiverID]).sort(); // ID of the channel is \"<peer1 id>/<peer 2 id>\"\"\n\n                this._id = '/' + PROTOCOL + '/' + this._peers.join('/'); // Function to use to handle incoming messages\n\n                this._messageHandler = function (message) {\n                  // Make sure the message is coming from the correct peer\n                  var isValid = message && message.from === _this2._receiverID; // Filter out all messages that didn't come from the second peer\n\n                  if (isValid) {\n                    _this2.emit('message', message);\n                  }\n                };\n\n              case 6:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function _setup() {\n        return _setup2.apply(this, arguments);\n      }\n\n      return _setup;\n    }()\n  }, {\n    key: \"_openChannel\",\n    value: function () {\n      var _openChannel2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this._setup();\n\n              case 2:\n                _context4.next = 4;\n                return this._ipfs.pubsub.subscribe(this._id, this._messageHandler);\n\n              case 4:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function _openChannel() {\n        return _openChannel2.apply(this, arguments);\n      }\n\n      return _openChannel;\n    }()\n  }], [{\n    key: \"open\",\n    value: function () {\n      var _open = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(ipfs, receiverID) {\n        var channel;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                channel = new DirectChannel(ipfs, receiverID);\n                _context5.next = 3;\n                return channel._openChannel();\n\n              case 3:\n                return _context5.abrupt(\"return\", channel);\n\n              case 4:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }));\n\n      function open(_x2, _x3) {\n        return _open.apply(this, arguments);\n      }\n\n      return open;\n    }()\n  }]);\n\n  return DirectChannel;\n}(EventEmitter);\n\nmodule.exports = DirectChannel;","map":null,"metadata":{},"sourceType":"script"}