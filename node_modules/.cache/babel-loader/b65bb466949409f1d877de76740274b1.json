{"ast":null,"code":"'use strict';\n\nconst BufferList = require('bl/BufferList');\n\nconst {\n  InvalidCryptoTransmissionError\n} = require('libp2p-interfaces/src/crypto/errors');\n\nexports.createBoxStream = (cipher, mac) => {\n  return async function* (source) {\n    for await (const chunk of source) {\n      const data = await cipher.encrypt(BufferList.isBufferList(chunk) ? chunk.slice() : chunk);\n      const digest = await mac.digest(data);\n      yield new BufferList([data, digest]);\n    }\n  };\n};\n\nexports.createUnboxStream = (decipher, mac) => {\n  return async function* (source) {\n    for await (const chunk of source) {\n      const l = chunk.length;\n      const macSize = mac.length;\n\n      if (l < macSize) {\n        throw new InvalidCryptoTransmissionError(`buffer (${l}) shorter than MAC size (${macSize})`);\n      }\n\n      const mark = l - macSize;\n      const data = chunk.slice(0, mark);\n      const macd = chunk.slice(mark);\n      const expected = await mac.digest(data);\n\n      if (!macd.equals(expected)) {\n        throw new InvalidCryptoTransmissionError(`MAC Invalid: ${macd.toString('hex')} != ${expected.toString('hex')}`);\n      }\n\n      const decrypted = await decipher.decrypt(data);\n      yield decrypted;\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"script"}