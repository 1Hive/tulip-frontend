{"ast":null,"code":"'use strict';\n\nconst fetch = require('node-fetch');\n\nconst MAX_PAGE_SIZE = 1000; // The Graph max page size\n\n/**\n * Page results from The Graph protocol\n *\n * @param {string} api - The API address\n * @param {Object} query - The Query object\n * @param {string} query.entity - The entity name\n * @param {Object} query.selection - The selection mapping object for GraphQL filters and sorts\n * @param {Object} query.properties - The list of fields to include in the output\n * @param {number} timeout - Number of ms timeout for any single graph paging result (default: 10seconds)\n * @param {number} max - Maximum number of results to return (default: Infinity)\n */\n\nconst pageResults = ({\n  api,\n  query: {\n    entity,\n    selection = {},\n    properties = []\n  },\n  timeout = 10e3,\n  max = Infinity\n}) => {\n  max = Number(max);\n  const pageSize = MAX_PAGE_SIZE; // Note: this approach will call each page in linear order, ensuring it stops as soon as all results\n  // are fetched. This could be sped up with a number of requests done in parallel, stopping as soon as any return\n  // empty. - JJM\n\n  const runner = ({\n    lastId\n  }) => {\n    const propToString = obj => Object.entries(obj).filter(([, value]) => typeof value !== 'undefined').map(([key, value]) => `${key}:${typeof value === 'object' ? '{' + propToString(value) + '}' : value}`).join(',');\n\n    const first = MAX_PAGE_SIZE;\n\n    if (!properties.includes('id')) {\n      properties.push('id');\n    }\n\n    ; // mix the page size and skip fields into the selection object\n\n    const selectionObj = Object.assign({}, selection, {\n      first,\n      orderBy: 'id',\n      where: { ...selection.where,\n        ...(lastId ? {\n          id_gt: `\\\\\"${lastId}\\\\\"`\n        } : {})\n      }\n    });\n    const body = `{\"query\":\"{${entity}(${propToString(selectionObj)}){${properties.join(',')}}}\", \"variables\": null}`; // support query logging in nodejs\n\n    if (typeof process === 'object' && process.env.DEBUG === 'true') {\n      console.log(body);\n    }\n\n    ;\n    return fetch(api, {\n      method: 'POST',\n      body,\n      timeout\n    }).then(response => response.json()).then(json => {\n      if (json.errors) {\n        throw Error(JSON.stringify(json.errors));\n      }\n\n      const {\n        data: {\n          [entity]: results\n        }\n      } = json; // stop if we are on the last page\n\n      if (results.length < pageSize || results.length >= max) {\n        if (results.length >= max) {\n          return results.slice(0, max);\n        }\n\n        return results;\n      }\n\n      return runner({\n        lastId: results[results.length - 1].id\n      }).then(newResults => results.concat(newResults));\n    });\n  };\n\n  return runner({\n    lastId: undefined\n  });\n};\n\nmodule.exports = pageResults;","map":null,"metadata":{},"sourceType":"script"}