{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _objectSpread = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _get = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _asyncIterator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar errcode = require('err-code');\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar TimeCache = require('time-cache');\n\nvar pipe = require('it-pipe');\n\nvar lp = require('it-length-prefixed');\n\nvar pMap = require('p-map');\n\nvar _require2 = require('../src/constants'),\n    GossipSubID = _require2.GossipSubID;\n\nvar floodsubMulticodec = '/floodsub/1.0.0';\n\nvar Pubsub = require('libp2p-pubsub');\n\nvar _require3 = require('libp2p-pubsub'),\n    utils = _require3.utils;\n\nvar _require4 = require('./message'),\n    rpc = _require4.rpc;\n\nvar BasicPubSub = /*#__PURE__*/function (_Pubsub) {\n  _inherits(BasicPubSub, _Pubsub);\n\n  var _super = _createSuper(BasicPubSub);\n\n  /**\n   * @param {Object} props\n   * @param {String} props.debugName log namespace\n   * @param {string} props.multicodec protocol identificer to connect\n   * @param {PeerInfo} props.peerInfo peer's peerInfo\n   * @param {Object} props.registrar registrar for libp2p protocols\n   * @param {function} props.registrar.handle\n   * @param {function} props.registrar.register\n   * @param {function} props.registrar.unregister\n   * @param {Object} [props.options]\n   * @param {bool} [props.options.emitSelf] if publish should emit to self, if subscribed, defaults to false\n   * @param {bool} [props.options.gossipIncoming] if incoming messages on a subscribed topic should be automatically gossiped, defaults to true\n   * @param {bool} [props.options.fallbackToFloodsub] if dial should fallback to floodsub, defaults to true\n   * @constructor\n   */\n  function BasicPubSub(_ref) {\n    var _this;\n\n    var debugName = _ref.debugName,\n        multicodec = _ref.multicodec,\n        peerInfo = _ref.peerInfo,\n        registrar = _ref.registrar,\n        _ref$options = _ref.options,\n        options = _ref$options === void 0 ? {} : _ref$options;\n\n    _classCallCheck(this, BasicPubSub);\n\n    var multicodecs = [multicodec];\n\n    var _options = _objectSpread({\n      emitSelf: false,\n      gossipIncoming: true,\n      fallbackToFloodsub: true\n    }, options); // Also wants to get notified of peers connected using floodsub\n\n\n    if (_options.fallbackToFloodsub) {\n      multicodecs.push(floodsubMulticodec);\n    }\n\n    _this = _super.call(this, _objectSpread({\n      debugName: debugName,\n      multicodecs: multicodecs,\n      peerInfo: peerInfo,\n      registrar: registrar\n    }, _options));\n    /**\n     * A set of subscriptions\n     */\n\n    _this.subscriptions = new Set();\n    /**\n     * Cache of seen messages\n     *\n     * @type {TimeCache}\n     */\n\n    _this.seenCache = new TimeCache();\n    /**\n     * Pubsub options\n     */\n\n    _this._options = _options;\n    _this._onRpc = _this._onRpc.bind(_assertThisInitialized(_this));\n    /**\n     * The default msgID implementation\n     * @param {rpc.RPC.Message} msg the message object\n     * @returns {string} message id as string\n     */\n\n    _this.defaultMsgIdFn = function (msg) {\n      return utils.msgId(msg.from, msg.seqno);\n    };\n\n    return _this;\n  }\n  /**\n   * Peer connected successfully with pubsub protocol.\n   * @override\n   * @param {PeerInfo} peerInfo peer info\n   * @param {Connection} conn connection to the peer\n   * @returns {Promise<void>}\n   */\n\n\n  _createClass(BasicPubSub, [{\n    key: \"_onPeerConnected\",\n    value: function () {\n      var _onPeerConnected2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(peerInfo, conn) {\n        var idB58Str, peer;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return _get(_getPrototypeOf(BasicPubSub.prototype), \"_onPeerConnected\", this).call(this, peerInfo, conn);\n\n              case 2:\n                idB58Str = peerInfo.id.toB58String();\n                peer = this.peers.get(idB58Str);\n\n                if (peer && peer.isWritable) {\n                  // Immediately send my own subscriptions to the newly established conn\n                  peer.sendSubscriptions(this.subscriptions);\n                }\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function _onPeerConnected(_x, _x2) {\n        return _onPeerConnected2.apply(this, arguments);\n      }\n\n      return _onPeerConnected;\n    }()\n    /**\n     * Overriding the implementation of _processConnection should keep the connection and is\n     * responsible for processing each RPC message received by other peers.\n     * @override\n     * @param {string} idB58Str peer id string in base58\n     * @param {Connection} conn connection\n     * @param {Peer} peer PubSub peer\n     * @returns {void}\n     *\n     */\n\n  }, {\n    key: \"_processMessages\",\n    value: function () {\n      var _processMessages2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(idB58Str, conn, peer) {\n        var onRpcFunc;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                onRpcFunc = this._onRpc;\n                _context3.prev = 1;\n                _context3.next = 4;\n                return pipe(conn, lp.decode(), /*#__PURE__*/function () {\n                  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(source) {\n                    var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, data, rpcMsg;\n\n                    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                      while (1) {\n                        switch (_context2.prev = _context2.next) {\n                          case 0:\n                            _iteratorNormalCompletion = true;\n                            _didIteratorError = false;\n                            _context2.prev = 2;\n                            _iterator = _asyncIterator(source);\n\n                          case 4:\n                            _context2.next = 6;\n                            return _iterator.next();\n\n                          case 6:\n                            _step = _context2.sent;\n                            _iteratorNormalCompletion = _step.done;\n                            _context2.next = 10;\n                            return _step.value;\n\n                          case 10:\n                            _value = _context2.sent;\n\n                            if (_iteratorNormalCompletion) {\n                              _context2.next = 18;\n                              break;\n                            }\n\n                            data = _value;\n                            rpcMsg = Buffer.isBuffer(data) ? data : data.slice();\n                            onRpcFunc(idB58Str, rpc.RPC.decode(rpcMsg));\n\n                          case 15:\n                            _iteratorNormalCompletion = true;\n                            _context2.next = 4;\n                            break;\n\n                          case 18:\n                            _context2.next = 24;\n                            break;\n\n                          case 20:\n                            _context2.prev = 20;\n                            _context2.t0 = _context2[\"catch\"](2);\n                            _didIteratorError = true;\n                            _iteratorError = _context2.t0;\n\n                          case 24:\n                            _context2.prev = 24;\n                            _context2.prev = 25;\n\n                            if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                              _context2.next = 29;\n                              break;\n                            }\n\n                            _context2.next = 29;\n                            return _iterator.return();\n\n                          case 29:\n                            _context2.prev = 29;\n\n                            if (!_didIteratorError) {\n                              _context2.next = 32;\n                              break;\n                            }\n\n                            throw _iteratorError;\n\n                          case 32:\n                            return _context2.finish(29);\n\n                          case 33:\n                            return _context2.finish(24);\n\n                          case 34:\n                          case \"end\":\n                            return _context2.stop();\n                        }\n                      }\n                    }, _callee2, null, [[2, 20, 24, 34], [25,, 29, 33]]);\n                  }));\n\n                  return function (_x6) {\n                    return _ref2.apply(this, arguments);\n                  };\n                }());\n\n              case 4:\n                _context3.next = 9;\n                break;\n\n              case 6:\n                _context3.prev = 6;\n                _context3.t0 = _context3[\"catch\"](1);\n\n                this._onPeerDisconnected(peer.info, _context3.t0);\n\n              case 9:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[1, 6]]);\n      }));\n\n      function _processMessages(_x3, _x4, _x5) {\n        return _processMessages2.apply(this, arguments);\n      }\n\n      return _processMessages;\n    }()\n    /**\n     * Handles an rpc request from a peer\n     *\n     * @param {String} idB58Str\n     * @param {Object} rpc\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_onRpc\",\n    value: function _onRpc(idB58Str, rpc) {\n      var _this2 = this;\n\n      if (!rpc) {\n        return;\n      }\n\n      var peer = this.peers.get(idB58Str);\n\n      if (!peer) {\n        return;\n      }\n\n      this.log('rpc from', idB58Str);\n      var subs = rpc.subscriptions;\n      var msgs = rpc.msgs;\n\n      if (subs.length) {\n        // update peer subscriptions\n        peer.updateSubscriptions(subs);\n        subs.forEach(function (subOptMsg) {\n          var t = subOptMsg.topicID;\n\n          if (!_this2.topics.has(t)) {\n            _this2.topics.set(t, new Set());\n          }\n\n          var topicSet = _this2.topics.get(t);\n\n          if (subOptMsg.subscribe) {\n            // subscribe peer to new topic\n            topicSet.add(peer);\n          } else {\n            // unsubscribe from existing topic\n            topicSet.delete(peer);\n          }\n        });\n        this.emit('pubsub:subscription-change', peer.info, peer.topics, subs);\n      }\n\n      if (msgs.length) {\n        msgs.forEach( /*#__PURE__*/function () {\n          var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(message) {\n            var msg, msgID, isValid, error;\n            return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n              while (1) {\n                switch (_context4.prev = _context4.next) {\n                  case 0:\n                    msg = utils.normalizeInRpcMessage(message);\n                    msgID = _this2.getMsgId(msg); // Ignore if we've already seen the message\n\n                    if (!_this2.seenCache.has(msgID)) {\n                      _context4.next = 4;\n                      break;\n                    }\n\n                    return _context4.abrupt(\"return\");\n\n                  case 4:\n                    _this2.seenCache.put(msgID); // Ensure the message is valid before processing it\n\n\n                    _context4.prev = 5;\n                    _context4.next = 8;\n                    return _this2.validate(message);\n\n                  case 8:\n                    isValid = _context4.sent;\n                    _context4.next = 14;\n                    break;\n\n                  case 11:\n                    _context4.prev = 11;\n                    _context4.t0 = _context4[\"catch\"](5);\n                    error = _context4.t0;\n\n                  case 14:\n                    if (!(error || !isValid)) {\n                      _context4.next = 17;\n                      break;\n                    }\n\n                    _this2.log('Message could not be validated, dropping it. isValid=%s', isValid, error);\n\n                    return _context4.abrupt(\"return\");\n\n                  case 17:\n                    _this2._processRpcMessage(msg);\n\n                  case 18:\n                  case \"end\":\n                    return _context4.stop();\n                }\n              }\n            }, _callee4, null, [[5, 11]]);\n          }));\n\n          return function (_x7) {\n            return _ref3.apply(this, arguments);\n          };\n        }());\n      }\n\n      this._handleRpcControl(peer, rpc);\n    }\n    /**\n     * @param {rpc.RPC.Message} msg\n     */\n\n  }, {\n    key: \"_processRpcMessage\",\n    value: function _processRpcMessage(msg) {\n      if (this.peerInfo.id.toB58String() === msg.from && !this._options.emitSelf) {\n        return;\n      } // Emit to self\n\n\n      this._emitMessage(msg.topicIDs, msg);\n    }\n  }, {\n    key: \"_emitMessage\",\n    value: function _emitMessage(topics, message) {\n      var _this3 = this;\n\n      topics.forEach(function (topic) {\n        if (_this3.subscriptions.has(topic)) {\n          _this3.emit(topic, message);\n        }\n      });\n    }\n  }, {\n    key: \"_handleRpcControl\",\n    value: function _handleRpcControl(peer, rpc) {\n      throw errcode(new Error('_handleRpcControl must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED');\n    }\n    /**\n     * Returns a buffer of a RPC message that contains a control message\n     * @param {Array<rpc.RPC.Message>} msgs\n     * @param {Array<rpc.RPC.ControlIHave>} ihave\n     * @param {Array<rpc.RPC.ControlIWant>} iwant\n     * @param {Array<rpc.RPC.ControlGraft>} graft\n     * @param {Array<rpc.RPC.Prune>} prune\n     * @returns {rpc.RPC}\n     */\n\n  }, {\n    key: \"_rpcWithControl\",\n    value: function _rpcWithControl() {\n      var msgs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var ihave = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var iwant = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      var graft = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n      var prune = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n      return {\n        subscriptions: [],\n        msgs: msgs,\n        control: {\n          ihave: ihave,\n          iwant: iwant,\n          graft: graft,\n          prune: prune\n        }\n      };\n    }\n    /**\n     * Unmounts the protocol and shuts down every connection\n     * @override\n     * @returns {void}\n     */\n\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return _get(_getPrototypeOf(BasicPubSub.prototype), \"stop\", this).call(this);\n\n              case 2:\n                this.subscriptions = new Set();\n\n              case 3:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function stop() {\n        return _stop.apply(this, arguments);\n      }\n\n      return stop;\n    }()\n    /**\n     * Subscribes to topics\n     * @override\n     * @param {Array<string>|string} topics\n     * @returns {void}\n     */\n\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(topics) {\n      var _this4 = this;\n\n      if (!this.started) {\n        throw new Error('Pubsub has not started');\n      }\n\n      topics = utils.ensureArray(topics);\n      var newTopics = topics.filter(function (topic) {\n        return !_this4.subscriptions.has(topic);\n      });\n\n      if (newTopics.length === 0) {\n        return;\n      } // set subscriptions\n\n\n      newTopics.forEach(function (topic) {\n        _this4.subscriptions.add(topic);\n      }); // Broadcast SUBSCRIBE to all peers\n\n      this.peers.forEach(function (peer) {\n        return sendSubscriptionsOnceReady(peer);\n      }); // make sure that Gossipsub is already mounted\n\n      function sendSubscriptionsOnceReady(peer) {\n        if (peer && peer.isWritable) {\n          return peer.sendSubscriptions(topics);\n        }\n\n        var onConnection = function onConnection() {\n          peer.removeListener('connection', onConnection);\n          sendSubscriptionsOnceReady(peer);\n        };\n\n        peer.on('connection', onConnection);\n        peer.once('close', function () {\n          return peer.removeListener('connection', onConnection);\n        });\n      }\n\n      this.join(newTopics);\n    }\n  }, {\n    key: \"join\",\n    value: function join(topics) {\n      throw errcode(new Error('join must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED');\n    }\n    /**\n     * Leaves a topic\n     * @override\n     * @param {Array<string>|string} topics\n     * @returns {void}\n     */\n\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(topics) {\n      var _this5 = this;\n\n      if (!this.started) {\n        throw new Error('Pubsub has not started');\n      }\n\n      topics = utils.ensureArray(topics);\n      var unTopics = topics.filter(function (topic) {\n        return _this5.subscriptions.has(topic);\n      });\n\n      if (!unTopics.length) {\n        return;\n      } // delete subscriptions\n\n\n      unTopics.forEach(function (topic) {\n        _this5.subscriptions.delete(topic);\n      }); // Broadcast UNSUBSCRIBE to all peers ready\n\n      this.peers.forEach(function (peer) {\n        return sendUnsubscriptionsOnceReady(peer);\n      }); // make sure that Gossipsub is already mounted\n\n      function sendUnsubscriptionsOnceReady(peer) {\n        if (peer && peer.isWritable) {\n          return peer.sendUnsubscriptions(topics);\n        }\n\n        var onConnection = function onConnection() {\n          peer.removeListener('connection', onConnection);\n          sendUnsubscriptionsOnceReady(peer);\n        };\n\n        peer.on('connection', onConnection);\n        peer.once('close', function () {\n          return peer.removeListener('connection', onConnection);\n        });\n      }\n\n      this.leave(unTopics);\n    }\n  }, {\n    key: \"leave\",\n    value: function leave(topics) {\n      throw errcode(new Error('leave must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED');\n    }\n    /**\n     * Publishes messages to all subscribed peers\n     * @override\n     * @param {Array<string>|string} topics\n     * @param {Array<any>|any} messages\n     * @returns {void}\n     */\n\n  }, {\n    key: \"publish\",\n    value: function () {\n      var _publish2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(topics, messages) {\n        var _this6 = this;\n\n        var from, buildMessage, msgObjects;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (this.started) {\n                  _context6.next = 2;\n                  break;\n                }\n\n                throw new Error('Pubsub has not started');\n\n              case 2:\n                this.log('publish', topics, messages);\n                topics = utils.ensureArray(topics);\n                messages = utils.ensureArray(messages);\n                from = this.peerInfo.id.toB58String();\n\n                buildMessage = function buildMessage(msg, cb) {\n                  var seqno = utils.randomSeqno();\n                  var msgObj = {\n                    from: from,\n                    data: msg,\n                    seqno: seqno,\n                    topicIDs: topics\n                  }; // put in seen cache\n\n                  _this6.seenCache.put(msgObj.seqno); // Emit to self if I'm interested and emitSelf enabled\n\n\n                  _this6._options.emitSelf && _this6._emitMessages(topics, [msgObj]);\n                  return _this6._buildMessage(msgObj);\n                };\n\n                _context6.next = 9;\n                return pMap(messages, buildMessage);\n\n              case 9:\n                msgObjects = _context6.sent;\n\n                // send to all the other peers\n                this._publish(utils.normalizeOutRpcMessages(msgObjects));\n\n              case 11:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function publish(_x8, _x9) {\n        return _publish2.apply(this, arguments);\n      }\n\n      return publish;\n    }()\n    /**\n     * Get the list of topics which the peer is subscribed to.\n     * @override\n     * @returns {Array<String>}\n     */\n\n  }, {\n    key: \"getTopics\",\n    value: function getTopics() {\n      if (!this.started) {\n        throw new Error('Pubsub is not started');\n      }\n\n      return Array.from(this.subscriptions);\n    }\n    /**\n     * Child class can override this.\n     * @param {rpc.RPC.Message} msg the message object\n     * @returns {string} message id as string\n     */\n\n  }, {\n    key: \"getMsgId\",\n    value: function getMsgId(msg) {\n      return this.defaultMsgIdFn(msg);\n    }\n  }, {\n    key: \"_emitMessages\",\n    value: function _emitMessages(topics, messages) {\n      var _this7 = this;\n\n      topics.forEach(function (topic) {\n        if (!_this7.subscriptions.has(topic)) {\n          return;\n        }\n\n        messages.forEach(function (message) {\n          _this7.emit(topic, message);\n        });\n      });\n    }\n  }, {\n    key: \"_publish\",\n    value: function _publish(rpcs) {\n      throw errcode(new Error('_publish must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED');\n    }\n    /**\n     * Given a topic, returns up to count peers subscribed to that topic\n     *\n     * @param {String} topic\n     * @param {Number} count\n     * @returns {Set<Peer>}\n     *\n     */\n\n  }, {\n    key: \"_getPeers\",\n    value: function _getPeers(topic, count) {\n      var peersInTopic = this.topics.get(topic);\n\n      if (!peersInTopic) {\n        return new Set();\n      } // Adds all peers using our protocol\n\n\n      var peers = [];\n      peersInTopic.forEach(function (peer) {\n        if (peer.info.protocols.has(GossipSubID)) {\n          peers.push(peer);\n        }\n      }); // Pseudo-randomly shuffles peers\n\n      peers = this._shufflePeers(peers);\n\n      if (count > 0 && peers.length > count) {\n        peers = peers.slice(0, count);\n      }\n\n      return new Set(peers);\n    }\n    /**\n     * Pseudo-randomly shuffles peers\n     *\n     * @param {Array<Peers>} peers\n     * @returns {Array<Peers>}\n     */\n\n  }, {\n    key: \"_shufflePeers\",\n    value: function _shufflePeers(peers) {\n      if (peers.length <= 1) {\n        return peers;\n      }\n\n      for (var i = 0; i < peers.length; i++) {\n        var randInt = function randInt() {\n          return Math.floor(Math.random() * Math.floor(peers.length));\n        };\n\n        var j = randInt();\n        var tmp = peers[i];\n        peers[i] = peers[j];\n        peers[j] = tmp;\n        return peers;\n      }\n    }\n  }]);\n\n  return BasicPubSub;\n}(Pubsub);\n\nmodule.exports = BasicPubSub;","map":null,"metadata":{},"sourceType":"script"}