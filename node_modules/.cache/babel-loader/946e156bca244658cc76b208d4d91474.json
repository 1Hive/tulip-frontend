{"ast":null,"code":"/*!\n * random.js - random number generator for bcrypto\n * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Resources:\n *   https://wiki.openssl.org/index.php/Random_Numbers\n *   https://csrc.nist.gov/projects/random-bit-generation/\n *   http://www.pcg-random.org/posts/bounded-rands.html\n *   https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues\n */\n'use strict';\n\nconst assert = require('../internal/assert');\n/*\n * Constants\n */\n\n\nconst crypto = global.crypto || global.msCrypto;\nconst HAS_CRYPTO = crypto && typeof crypto.getRandomValues === 'function';\nconst randomValues = HAS_CRYPTO ? crypto.getRandomValues.bind(crypto) : null;\nconst pool = new Uint32Array(1);\nconst MAX_BYTES = 65536;\n/**\n * Generate pseudo-random bytes.\n * @param {Number} size\n * @returns {Buffer}\n */\n\nfunction randomBytes(size) {\n  assert(size >>> 0 === size);\n  const data = Buffer.alloc(size);\n  randomFillSync(data, 0, size);\n  return data;\n}\n/**\n * Generate pseudo-random bytes.\n * @param {Buffer} data\n * @param {Number} [off=0]\n * @param {Number} [size=data.length-off]\n * @returns {Buffer}\n */\n\n\nfunction randomFill(data, off, size) {\n  assert(Buffer.isBuffer(data));\n  if (off == null) off = 0;\n  assert(off >>> 0 === off);\n  if (size == null) size = data.length - off;\n  assert(size >>> 0 === size);\n  assert(off + size <= data.length);\n  data.fill(0x00, off, off + size);\n  randomFillSync(data, off, size);\n  return data;\n}\n/**\n * Generate a random uint32.\n * @returns {Number}\n */\n\n\nfunction randomInt() {\n  getRandomValues(pool);\n  const r = pool[0];\n  pool[0] = 0;\n  return r;\n}\n/**\n * Generate a random uint32 within a range.\n * @param {Number} min - Inclusive.\n * @param {Number} max - Exclusive.\n * @returns {Number}\n */\n\n\nfunction randomRange(min, max) {\n  assert(min >>> 0 === min);\n  assert(max >>> 0 === max);\n  assert(max >= min);\n  const space = max - min;\n  if (space === 0) return min;\n  const top = -space >>> 0;\n  let x, r;\n\n  do {\n    x = randomInt();\n    r = x % space;\n  } while (x - r > top);\n\n  return r + min;\n}\n/*\n * Helpers\n */\n\n\nfunction getRandomValues(array) {\n  if (!HAS_CRYPTO) throw new Error('Entropy source not available.');\n  return randomValues(array);\n}\n\nfunction randomFillSync(data, off, size) {\n  assert(Buffer.isBuffer(data));\n  assert(data.buffer instanceof ArrayBuffer);\n  assert(data.byteOffset >>> 0 === data.byteOffset);\n  assert(data.byteLength >>> 0 === data.byteLength);\n  assert(off >>> 0 === off);\n  assert(size >>> 0 === size);\n  assert(off + size <= data.byteLength);\n  if (size > 2 ** 31 - 1) throw new RangeError('The value \"size\" is out of range.');\n  const offset = data.byteOffset + off;\n  const array = new Uint8Array(data.buffer, offset, size);\n\n  if (array.length > MAX_BYTES) {\n    for (let i = 0; i < array.length; i += MAX_BYTES) {\n      let j = i + MAX_BYTES;\n      if (j > array.length) j = array.length;\n      getRandomValues(array.subarray(i, j));\n    }\n  } else {\n    if (array.length > 0) getRandomValues(array);\n  }\n}\n/*\n * Expose\n */\n\n\nexports.native = 0;\nexports.randomBytes = randomBytes;\nexports.randomFill = randomFill;\nexports.randomInt = randomInt;\nexports.randomRange = randomRange;","map":null,"metadata":{},"sourceType":"script"}