{"ast":null,"code":"'use strict';\n\nconst pMap = (iterable, mapper, options) => new Promise((resolve, reject) => {\n  options = Object.assign({\n    concurrency: Infinity\n  }, options);\n\n  if (typeof mapper !== 'function') {\n    throw new TypeError('Mapper function is required');\n  }\n\n  const {\n    concurrency\n  } = options;\n\n  if (!(typeof concurrency === 'number' && concurrency >= 1)) {\n    throw new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${concurrency}\\` (${typeof concurrency})`);\n  }\n\n  const ret = [];\n  const iterator = iterable[Symbol.iterator]();\n  let isRejected = false;\n  let isIterableDone = false;\n  let resolvingCount = 0;\n  let currentIndex = 0;\n\n  const next = () => {\n    if (isRejected) {\n      return;\n    }\n\n    const nextItem = iterator.next();\n    const i = currentIndex;\n    currentIndex++;\n\n    if (nextItem.done) {\n      isIterableDone = true;\n\n      if (resolvingCount === 0) {\n        resolve(ret);\n      }\n\n      return;\n    }\n\n    resolvingCount++;\n    Promise.resolve(nextItem.value).then(element => mapper(element, i)).then(value => {\n      ret[i] = value;\n      resolvingCount--;\n      next();\n    }, error => {\n      isRejected = true;\n      reject(error);\n    });\n  };\n\n  for (let i = 0; i < concurrency; i++) {\n    next();\n\n    if (isIterableDone) {\n      break;\n    }\n  }\n});\n\nmodule.exports = pMap; // TODO: Remove this for the next major release\n\nmodule.exports.default = pMap;","map":null,"metadata":{},"sourceType":"script"}