{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _defineProperty = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _awaitAsyncGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _wrapAsyncGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar _asyncIterator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar _ReadHandlers;\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar BufferList = require('bl/BufferList');\n\nvar varintDecode = require('./varint-decode'); // Maximum length of the length section of the message\n\n\nvar MAX_LENGTH_LENGTH = 8; // Varint.encode(Number.MAX_SAFE_INTEGER).length\n// Maximum length of the data section of the message\n\nvar MAX_DATA_LENGTH = 1024 * 1024 * 4;\nvar Empty = Buffer.alloc(0);\nvar ReadModes = {\n  LENGTH: 'readLength',\n  DATA: 'readData'\n};\nvar ReadHandlers = (_ReadHandlers = {}, _defineProperty(_ReadHandlers, ReadModes.LENGTH, function (chunk, buffer, state, options) {\n  // console.log(ReadModes.LENGTH, chunk.length)\n  buffer = buffer.append(chunk);\n  var dataLength;\n\n  try {\n    dataLength = options.lengthDecoder(buffer);\n  } catch (err) {\n    if (buffer.length > options.maxLengthLength) {\n      throw Object.assign(err, {\n        message: 'message length too long',\n        code: 'ERR_MSG_LENGTH_TOO_LONG'\n      });\n    }\n\n    if (err instanceof RangeError) {\n      return {\n        mode: ReadModes.LENGTH,\n        buffer: buffer\n      };\n    }\n\n    throw err;\n  }\n\n  if (dataLength > options.maxDataLength) {\n    throw Object.assign(new Error('message data too long'), {\n      code: 'ERR_MSG_DATA_TOO_LONG'\n    });\n  }\n\n  chunk = buffer.shallowSlice(options.lengthDecoder.bytes);\n  buffer = new BufferList();\n  if (options.onLength) options.onLength(dataLength);\n\n  if (dataLength <= 0) {\n    if (options.onData) options.onData(Empty);\n    return {\n      mode: ReadModes.LENGTH,\n      chunk: chunk,\n      buffer: buffer,\n      data: Empty\n    };\n  }\n\n  return {\n    mode: ReadModes.DATA,\n    chunk: chunk,\n    buffer: buffer,\n    state: {\n      dataLength: dataLength\n    }\n  };\n}), _defineProperty(_ReadHandlers, ReadModes.DATA, function (chunk, buffer, state, options) {\n  // console.log(ReadModes.DATA, chunk.length)\n  buffer = buffer.append(chunk);\n\n  if (buffer.length < state.dataLength) {\n    return {\n      mode: ReadModes.DATA,\n      buffer: buffer,\n      state: state\n    };\n  }\n\n  var dataLength = state.dataLength;\n  var data = buffer.shallowSlice(0, dataLength);\n  chunk = buffer.length > dataLength ? buffer.shallowSlice(dataLength) : null;\n  buffer = new BufferList();\n  if (options.onData) options.onData(data);\n  return {\n    mode: ReadModes.LENGTH,\n    chunk: chunk,\n    buffer: buffer,\n    data: data\n  };\n}), _ReadHandlers);\n\nfunction decode(options) {\n  options = options || {};\n  options.lengthDecoder = options.lengthDecoder || varintDecode;\n  options.maxLengthLength = options.maxLengthLength || MAX_LENGTH_LENGTH;\n  options.maxDataLength = options.maxDataLength || MAX_DATA_LENGTH;\n  return function (source) {\n    return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var buffer, mode, state, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, chunk, result;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              buffer = new BufferList();\n              mode = ReadModes.LENGTH; // current parsing mode\n\n              // accumulated state for the current mode\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _context.prev = 4;\n              _iterator = _asyncIterator(source);\n\n            case 6:\n              _context.next = 8;\n              return _awaitAsyncGenerator(_iterator.next());\n\n            case 8:\n              _step = _context.sent;\n              _iteratorNormalCompletion = _step.done;\n              _context.next = 12;\n              return _awaitAsyncGenerator(_step.value);\n\n            case 12:\n              _value = _context.sent;\n\n              if (_iteratorNormalCompletion) {\n                _context.next = 29;\n                break;\n              }\n\n              chunk = _value;\n\n            case 15:\n              if (!chunk) {\n                _context.next = 26;\n                break;\n              }\n\n              result = ReadHandlers[mode](chunk, buffer, state, options);\n              mode = result.mode;\n              chunk = result.chunk;\n              buffer = result.buffer;\n              state = result.state;\n\n              if (!result.data) {\n                _context.next = 24;\n                break;\n              }\n\n              _context.next = 24;\n              return result.data;\n\n            case 24:\n              _context.next = 15;\n              break;\n\n            case 26:\n              _iteratorNormalCompletion = true;\n              _context.next = 6;\n              break;\n\n            case 29:\n              _context.next = 35;\n              break;\n\n            case 31:\n              _context.prev = 31;\n              _context.t0 = _context[\"catch\"](4);\n              _didIteratorError = true;\n              _iteratorError = _context.t0;\n\n            case 35:\n              _context.prev = 35;\n              _context.prev = 36;\n\n              if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                _context.next = 40;\n                break;\n              }\n\n              _context.next = 40;\n              return _awaitAsyncGenerator(_iterator.return());\n\n            case 40:\n              _context.prev = 40;\n\n              if (!_didIteratorError) {\n                _context.next = 43;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 43:\n              return _context.finish(40);\n\n            case 44:\n              return _context.finish(35);\n\n            case 45:\n              if (!buffer.length) {\n                _context.next = 47;\n                break;\n              }\n\n              throw Object.assign(new Error('unexpected end of input'), {\n                code: 'ERR_UNEXPECTED_EOF'\n              });\n\n            case 47:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[4, 31, 35, 45], [36,, 40, 44]]);\n    }))();\n  };\n}\n\ndecode.fromReader = function (reader, options) {\n  var _varByteSource;\n\n  options = options || {};\n  var byteLength = 1; // Read single byte chunks until the length is known\n\n  var varByteSource = (_varByteSource = {}, _defineProperty(_varByteSource, Symbol.asyncIterator, function () {\n    return this;\n  }), _defineProperty(_varByteSource, \"next\", function () {\n    var _next = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.prev = 0;\n              _context2.next = 3;\n              return reader.next(byteLength);\n\n            case 3:\n              return _context2.abrupt(\"return\", _context2.sent);\n\n            case 6:\n              _context2.prev = 6;\n              _context2.t0 = _context2[\"catch\"](0);\n\n              if (!(_context2.t0.code === 'ERR_UNDER_READ')) {\n                _context2.next = 10;\n                break;\n              }\n\n              return _context2.abrupt(\"return\", {\n                done: true,\n                value: null\n              });\n\n            case 10:\n              throw _context2.t0;\n\n            case 11:\n              _context2.prev = 11;\n              // Reset the byteLength so we continue to check for varints\n              byteLength = 1;\n              return _context2.finish(11);\n\n            case 14:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[0, 6, 11, 14]]);\n    }));\n\n    function next() {\n      return _next.apply(this, arguments);\n    }\n\n    return next;\n  }()), _varByteSource); // Once the length has been parsed, read chunk for that length\n\n  options.onLength = function (l) {\n    byteLength = l;\n  };\n\n  return decode(options)(varByteSource);\n};\n\nmodule.exports = decode;\nmodule.exports.MAX_LENGTH_LENGTH = MAX_LENGTH_LENGTH;\nmodule.exports.MAX_DATA_LENGTH = MAX_DATA_LENGTH;","map":null,"metadata":{},"sourceType":"script"}