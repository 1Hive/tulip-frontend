{"ast":null,"code":"import _regeneratorRuntime from \"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\n\nfunction _awaitAsyncGenerator(value) {\n  return new _AwaitValue(value);\n}\n\nfunction _wrapAsyncGenerator(fn) {\n  return function () {\n    return new _AsyncGenerator(fn.apply(this, arguments));\n  };\n}\n\nfunction _AsyncGenerator(gen) {\n  var front, back;\n\n  function send(key, arg) {\n    return new Promise(function (resolve, reject) {\n      var request = {\n        key: key,\n        arg: arg,\n        resolve: resolve,\n        reject: reject,\n        next: null\n      };\n\n      if (back) {\n        back = back.next = request;\n      } else {\n        front = back = request;\n        resume(key, arg);\n      }\n    });\n  }\n\n  function resume(key, arg) {\n    try {\n      var result = gen[key](arg);\n      var value = result.value;\n      var wrappedAwait = value instanceof _AwaitValue;\n      Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) {\n        if (wrappedAwait) {\n          resume(key === \"return\" ? \"return\" : \"next\", arg);\n          return;\n        }\n\n        settle(result.done ? \"return\" : \"normal\", arg);\n      }, function (err) {\n        resume(\"throw\", err);\n      });\n    } catch (err) {\n      settle(\"throw\", err);\n    }\n  }\n\n  function settle(type, value) {\n    switch (type) {\n      case \"return\":\n        front.resolve({\n          value: value,\n          done: true\n        });\n        break;\n\n      case \"throw\":\n        front.reject(value);\n        break;\n\n      default:\n        front.resolve({\n          value: value,\n          done: false\n        });\n        break;\n    }\n\n    front = front.next;\n\n    if (front) {\n      resume(front.key, front.arg);\n    } else {\n      back = null;\n    }\n  }\n\n  this._invoke = send;\n\n  if (typeof gen.return !== \"function\") {\n    this.return = undefined;\n  }\n}\n\nif (typeof Symbol === \"function\" && Symbol.asyncIterator) {\n  _AsyncGenerator.prototype[Symbol.asyncIterator] = function () {\n    return this;\n  };\n}\n\n_AsyncGenerator.prototype.next = function (arg) {\n  return this._invoke(\"next\", arg);\n};\n\n_AsyncGenerator.prototype.throw = function (arg) {\n  return this._invoke(\"throw\", arg);\n};\n\n_AsyncGenerator.prototype.return = function (arg) {\n  return this._invoke(\"return\", arg);\n};\n\nfunction _AwaitValue(value) {\n  this.wrapped = value;\n}\n\nfunction _asyncIterator(iterable) {\n  var method;\n\n  if (typeof Symbol !== \"undefined\") {\n    if (Symbol.asyncIterator) {\n      method = iterable[Symbol.asyncIterator];\n      if (method != null) return method.call(iterable);\n    }\n\n    if (Symbol.iterator) {\n      method = iterable[Symbol.iterator];\n      if (method != null) return method.call(iterable);\n    }\n  }\n\n  throw new TypeError(\"Object is not async iterable\");\n}\n\nimport { Buffer } from \"buffer\";\nimport { NOISE_MSG_MAX_LENGTH_BYTES, NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG } from \"./constants\"; // Returns generator that encrypts payload from the user\n\nexport function encryptStream(handshake) {\n  return /*#__PURE__*/function () {\n    var _ref = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(source) {\n      var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, chunk, chunkBuffer, i, end, data;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _context.prev = 2;\n              _iterator = _asyncIterator(source);\n\n            case 4:\n              _context.next = 6;\n              return _awaitAsyncGenerator(_iterator.next());\n\n            case 6:\n              _step = _context.sent;\n              _iteratorNormalCompletion = _step.done;\n              _context.next = 10;\n              return _awaitAsyncGenerator(_step.value);\n\n            case 10:\n              _value = _context.sent;\n\n              if (_iteratorNormalCompletion) {\n                _context.next = 27;\n                break;\n              }\n\n              chunk = _value;\n              chunkBuffer = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.length);\n              i = 0;\n\n            case 15:\n              if (!(i < chunkBuffer.length)) {\n                _context.next = 24;\n                break;\n              }\n\n              end = i + NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;\n\n              if (end > chunkBuffer.length) {\n                end = chunkBuffer.length;\n              }\n\n              data = handshake.encrypt(chunkBuffer.slice(i, end), handshake.session);\n              _context.next = 21;\n              return data;\n\n            case 21:\n              i += NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;\n              _context.next = 15;\n              break;\n\n            case 24:\n              _iteratorNormalCompletion = true;\n              _context.next = 4;\n              break;\n\n            case 27:\n              _context.next = 33;\n              break;\n\n            case 29:\n              _context.prev = 29;\n              _context.t0 = _context[\"catch\"](2);\n              _didIteratorError = true;\n              _iteratorError = _context.t0;\n\n            case 33:\n              _context.prev = 33;\n              _context.prev = 34;\n\n              if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                _context.next = 38;\n                break;\n              }\n\n              _context.next = 38;\n              return _awaitAsyncGenerator(_iterator.return());\n\n            case 38:\n              _context.prev = 38;\n\n              if (!_didIteratorError) {\n                _context.next = 41;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 41:\n              return _context.finish(38);\n\n            case 42:\n              return _context.finish(33);\n\n            case 43:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[2, 29, 33, 43], [34,, 38, 42]]);\n    }));\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n} // Decrypt received payload to the user\n\nexport function decryptStream(handshake) {\n  return /*#__PURE__*/function () {\n    var _ref2 = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(source) {\n      var _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _value2, chunk, chunkBuffer, i, end, _chunk, _yield$_awaitAsyncGen, decrypted, valid;\n\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _iteratorNormalCompletion2 = true;\n              _didIteratorError2 = false;\n              _context2.prev = 2;\n              _iterator2 = _asyncIterator(source);\n\n            case 4:\n              _context2.next = 6;\n              return _awaitAsyncGenerator(_iterator2.next());\n\n            case 6:\n              _step2 = _context2.sent;\n              _iteratorNormalCompletion2 = _step2.done;\n              _context2.next = 10;\n              return _awaitAsyncGenerator(_step2.value);\n\n            case 10:\n              _value2 = _context2.sent;\n\n              if (_iteratorNormalCompletion2) {\n                _context2.next = 34;\n                break;\n              }\n\n              chunk = _value2;\n              chunkBuffer = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.length);\n              i = 0;\n\n            case 15:\n              if (!(i < chunkBuffer.length)) {\n                _context2.next = 31;\n                break;\n              }\n\n              end = i + NOISE_MSG_MAX_LENGTH_BYTES;\n\n              if (end > chunkBuffer.length) {\n                end = chunkBuffer.length;\n              }\n\n              _chunk = chunkBuffer.slice(i, end);\n              _context2.next = 21;\n              return _awaitAsyncGenerator(handshake.decrypt(_chunk, handshake.session));\n\n            case 21:\n              _yield$_awaitAsyncGen = _context2.sent;\n              decrypted = _yield$_awaitAsyncGen.plaintext;\n              valid = _yield$_awaitAsyncGen.valid;\n\n              if (valid) {\n                _context2.next = 26;\n                break;\n              }\n\n              throw new Error(\"Failed to validate decrypted chunk\");\n\n            case 26:\n              _context2.next = 28;\n              return decrypted;\n\n            case 28:\n              i += NOISE_MSG_MAX_LENGTH_BYTES;\n              _context2.next = 15;\n              break;\n\n            case 31:\n              _iteratorNormalCompletion2 = true;\n              _context2.next = 4;\n              break;\n\n            case 34:\n              _context2.next = 40;\n              break;\n\n            case 36:\n              _context2.prev = 36;\n              _context2.t0 = _context2[\"catch\"](2);\n              _didIteratorError2 = true;\n              _iteratorError2 = _context2.t0;\n\n            case 40:\n              _context2.prev = 40;\n              _context2.prev = 41;\n\n              if (!(!_iteratorNormalCompletion2 && _iterator2.return != null)) {\n                _context2.next = 45;\n                break;\n              }\n\n              _context2.next = 45;\n              return _awaitAsyncGenerator(_iterator2.return());\n\n            case 45:\n              _context2.prev = 45;\n\n              if (!_didIteratorError2) {\n                _context2.next = 48;\n                break;\n              }\n\n              throw _iteratorError2;\n\n            case 48:\n              return _context2.finish(45);\n\n            case 49:\n              return _context2.finish(40);\n\n            case 50:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[2, 36, 40, 50], [41,, 45, 49]]);\n    }));\n\n    return function (_x2) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n}","map":null,"metadata":{},"sourceType":"module"}