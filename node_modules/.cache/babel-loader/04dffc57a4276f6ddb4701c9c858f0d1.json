{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _toConsumableArray = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar errcode = require('err-code');\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:peer-store');\nlog.error = debug('libp2p:peer-store:error');\n\nvar _require = require('events'),\n    EventEmitter = _require.EventEmitter;\n\nvar PeerId = require('peer-id');\n\nvar PeerInfo = require('peer-info');\n\nvar _require2 = require('../errors'),\n    ERR_INVALID_PARAMETERS = _require2.ERR_INVALID_PARAMETERS;\n/**\n * Responsible for managing known peers, as well as their addresses and metadata\n * @fires PeerStore#peer Emitted when a peer is connected to this node\n * @fires PeerStore#change:protocols\n * @fires PeerStore#change:multiaddrs\n */\n\n\nvar PeerStore = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(PeerStore, _EventEmitter);\n\n  var _super = _createSuper(PeerStore);\n\n  function PeerStore() {\n    var _this;\n\n    _classCallCheck(this, PeerStore);\n\n    _this = _super.call(this);\n    /**\n     * Map of peers\n     *\n     * @type {Map<string, PeerInfo>}\n     */\n\n    _this.peers = new Map(); // TODO: Track ourselves. We should split `peerInfo` up into its pieces so we get better\n    // control and observability. This will be the initial step for removing PeerInfo\n    // https://github.com/libp2p/go-libp2p-core/blob/master/peerstore/peerstore.go\n    // this.addressBook = new Map()\n    // this.protoBook = new Map()\n\n    return _this;\n  }\n  /**\n   * Stores the peerInfo of a new peer.\n   * If already exist, its info is updated. If `silent` is set to\n   * true, no 'peer' event will be emitted. This can be useful if you\n   * are already in the process of dialing the peer. The peer is technically\n   * known, but may not have been added to the PeerStore yet.\n   * @param {PeerInfo} peerInfo\n   * @param {object} [options]\n   * @param {boolean} [options.silent] (Default=false)\n   * @return {PeerInfo}\n   */\n\n\n  _createClass(PeerStore, [{\n    key: \"put\",\n    value: function put(peerInfo) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        silent: false\n      };\n\n      if (!PeerInfo.isPeerInfo(peerInfo)) {\n        throw errcode(new Error('peerInfo must be an instance of peer-info'), ERR_INVALID_PARAMETERS);\n      }\n\n      var peer; // Already know the peer?\n\n      if (this.has(peerInfo.id)) {\n        peer = this.update(peerInfo);\n      } else {\n        peer = this.add(peerInfo); // Emit the peer if silent = false\n\n        !options.silent && this.emit('peer', peerInfo);\n      }\n\n      return peer;\n    }\n    /**\n     * Add a new peer to the store.\n     * @param {PeerInfo} peerInfo\n     * @return {PeerInfo}\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(peerInfo) {\n      var _arguments = arguments,\n          _this2 = this;\n\n      if (!PeerInfo.isPeerInfo(peerInfo)) {\n        throw errcode(new Error('peerInfo must be an instance of peer-info'), ERR_INVALID_PARAMETERS);\n      } // Create new instance and add values to it\n\n\n      var newPeerInfo = new PeerInfo(peerInfo.id);\n      peerInfo.multiaddrs.forEach(function (ma) {\n        return newPeerInfo.multiaddrs.add(ma);\n      });\n      peerInfo.protocols.forEach(function (p) {\n        return newPeerInfo.protocols.add(p);\n      });\n      var connectedMa = peerInfo.isConnected();\n      connectedMa && newPeerInfo.connect(connectedMa);\n      var peerProxy = new Proxy(newPeerInfo, {\n        set: function set(obj, prop, value) {\n          if (prop === 'multiaddrs') {\n            _this2.emit('change:multiaddrs', {\n              peerInfo: obj,\n              multiaddrs: value.toArray()\n            });\n          } else if (prop === 'protocols') {\n            _this2.emit('change:protocols', {\n              peerInfo: obj,\n              protocols: Array.from(value)\n            });\n          }\n\n          return Reflect.set.apply(Reflect, _toConsumableArray(_arguments));\n        }\n      });\n      this.peers.set(peerInfo.id.toB58String(), peerProxy);\n      return peerProxy;\n    }\n    /**\n     * Updates an already known peer.\n     * @param {PeerInfo} peerInfo\n     * @return {PeerInfo}\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(peerInfo) {\n      if (!PeerInfo.isPeerInfo(peerInfo)) {\n        throw errcode(new Error('peerInfo must be an instance of peer-info'), ERR_INVALID_PARAMETERS);\n      }\n\n      var id = peerInfo.id.toB58String();\n      var recorded = this.peers.get(id); // pass active connection state\n\n      var ma = peerInfo.isConnected();\n\n      if (ma) {\n        recorded.connect(ma);\n      } // Verify new multiaddrs\n      // TODO: better track added and removed multiaddrs\n\n\n      var multiaddrsIntersection = _toConsumableArray(recorded.multiaddrs.toArray()).filter(function (m) {\n        return peerInfo.multiaddrs.has(m);\n      });\n\n      if (multiaddrsIntersection.length !== peerInfo.multiaddrs.size || multiaddrsIntersection.length !== recorded.multiaddrs.size) {\n        var _iterator = _createForOfIteratorHelper(peerInfo.multiaddrs.toArray()),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _ma = _step.value;\n            recorded.multiaddrs.add(_ma);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        this.emit('change:multiaddrs', {\n          peerInfo: recorded,\n          multiaddrs: recorded.multiaddrs.toArray()\n        });\n      } // Update protocols\n      // TODO: better track added and removed protocols\n\n\n      var protocolsIntersection = new Set(_toConsumableArray(recorded.protocols).filter(function (p) {\n        return peerInfo.protocols.has(p);\n      }));\n\n      if (protocolsIntersection.size !== peerInfo.protocols.size || protocolsIntersection.size !== recorded.protocols.size) {\n        var _iterator2 = _createForOfIteratorHelper(peerInfo.protocols),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var protocol = _step2.value;\n            recorded.protocols.add(protocol);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        this.emit('change:protocols', {\n          peerInfo: recorded,\n          protocols: Array.from(recorded.protocols)\n        });\n      } // Add the public key if missing\n\n\n      if (!recorded.id.pubKey && peerInfo.id.pubKey) {\n        recorded.id.pubKey = peerInfo.id.pubKey;\n      }\n\n      return recorded;\n    }\n    /**\n     * Get the info to the given id.\n     * @param {PeerId|string} peerId b58str id\n     * @returns {PeerInfo}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(peerId) {\n      // TODO: deprecate this and just accept `PeerId` instances\n      if (PeerId.isPeerId(peerId)) {\n        peerId = peerId.toB58String();\n      }\n\n      return this.peers.get(peerId);\n    }\n    /**\n     * Has the info to the given id.\n     * @param {PeerId|string} peerId b58str id\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"has\",\n    value: function has(peerId) {\n      // TODO: deprecate this and just accept `PeerId` instances\n      if (PeerId.isPeerId(peerId)) {\n        peerId = peerId.toB58String();\n      }\n\n      return this.peers.has(peerId);\n    }\n    /**\n     * Removes the Peer with the matching `peerId` from the PeerStore\n     * @param {PeerId|string} peerId b58str id\n     * @returns {boolean} true if found and removed\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(peerId) {\n      // TODO: deprecate this and just accept `PeerId` instances\n      if (PeerId.isPeerId(peerId)) {\n        peerId = peerId.toB58String();\n      }\n\n      return this.peers.delete(peerId);\n    }\n    /**\n     * Completely replaces the existing peers metadata with the given `peerInfo`\n     * @param {PeerInfo} peerInfo\n     * @returns {void}\n     */\n\n  }, {\n    key: \"replace\",\n    value: function replace(peerInfo) {\n      if (!PeerInfo.isPeerInfo(peerInfo)) {\n        throw errcode(new Error('peerInfo must be an instance of peer-info'), ERR_INVALID_PARAMETERS);\n      }\n\n      this.remove(peerInfo.id.toB58String());\n      this.add(peerInfo); // This should be cleaned up in PeerStore v2\n\n      this.emit('change:multiaddrs', {\n        peerInfo: peerInfo,\n        multiaddrs: peerInfo.multiaddrs.toArray()\n      });\n      this.emit('change:protocols', {\n        peerInfo: peerInfo,\n        protocols: Array.from(peerInfo.protocols)\n      });\n    }\n    /**\n     * Returns the known multiaddrs for a given `PeerInfo`. All returned multiaddrs\n     * will include the encapsulated `PeerId` of the peer.\n     * @param {PeerInfo} peer\n     * @returns {Array<Multiaddr>}\n     */\n\n  }, {\n    key: \"multiaddrsForPeer\",\n    value: function multiaddrsForPeer(peer) {\n      return this.put(peer, true).multiaddrs.toArray().map(function (addr) {\n        var idString = addr.getPeerId();\n        if (idString && idString === peer.id.toB58String()) return addr;\n        return addr.encapsulate(\"/p2p/\".concat(peer.id.toB58String()));\n      });\n    }\n  }]);\n\n  return PeerStore;\n}(EventEmitter);\n\nmodule.exports = PeerStore;","map":null,"metadata":{},"sourceType":"script"}