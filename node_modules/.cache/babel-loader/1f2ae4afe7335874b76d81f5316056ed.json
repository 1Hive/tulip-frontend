{"ast":null,"code":"'use strict';\n\nconst {\n  createFromPrivKey\n} = require('peer-id');\n\nconst errcode = require('err-code');\n\nconst debug = require('debug');\n\nconst log = debug('ipfs:ipns');\nlog.error = debug('ipfs:ipns:error');\n\nconst IpnsPublisher = require('./publisher');\n\nconst IpnsRepublisher = require('./republisher');\n\nconst IpnsResolver = require('./resolver');\n\nconst {\n  normalizePath\n} = require('../utils');\n\nconst TLRU = require('../../utils/tlru');\n\nconst defaultRecordTtl = 60 * 1000;\n\nclass IPNS {\n  constructor(routing, datastore, peerInfo, keychain, options) {\n    this.publisher = new IpnsPublisher(routing, datastore);\n    this.republisher = new IpnsRepublisher(this.publisher, datastore, peerInfo, keychain, options);\n    this.resolver = new IpnsResolver(routing);\n    this.cache = new TLRU(1000);\n    this.routing = routing;\n  } // Publish\n\n\n  async publish(privKey, value, lifetime = IpnsPublisher.defaultRecordLifetime) {\n    try {\n      value = normalizePath(value);\n      const peerId = await createFromPrivKey(privKey.bytes);\n      await this.publisher.publishWithEOL(privKey, value, lifetime);\n      log(`IPNS value ${value} was published correctly`); // // Add to cache\n\n      const id = peerId.toB58String();\n      const ttEol = parseFloat(lifetime);\n      const ttl = ttEol < defaultRecordTtl ? ttEol : defaultRecordTtl;\n      this.cache.set(id, value, ttl);\n      log(`IPNS value ${value} was cached correctly`);\n      return {\n        name: id,\n        value: value\n      };\n    } catch (err) {\n      log.error(err);\n      throw err;\n    }\n  } // Resolve\n\n\n  async resolve(name, options) {\n    if (typeof name !== 'string') {\n      throw errcode(new Error('name received is not valid'), 'ERR_INVALID_NAME');\n    }\n\n    options = options || {}; // If recursive, we should not try to get the cached value\n\n    if (!options.nocache && !options.recursive) {\n      // Try to get the record from cache\n      const id = name.split('/')[2];\n      const result = this.cache.get(id);\n\n      if (result) {\n        return result;\n      }\n    }\n\n    try {\n      const result = await this.resolver.resolve(name, options);\n      log(`IPNS record from ${name} was resolved correctly`);\n      return result;\n    } catch (err) {\n      log.error(err);\n      throw err;\n    }\n  } // Initialize keyspace\n  // sets the ipns record for the given key to point to an empty directory\n\n\n  async initializeKeyspace(privKey, value) {\n    // eslint-disable-line require-await\n    return this.publish(privKey, value, IpnsPublisher.defaultRecordLifetime);\n  }\n\n}\n\nmodule.exports = IPNS;","map":null,"metadata":{},"sourceType":"script"}