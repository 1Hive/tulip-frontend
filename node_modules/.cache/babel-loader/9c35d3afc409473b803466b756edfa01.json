{"ast":null,"code":"import _slicedToArray from \"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { Buffer } from \"buffer\";\nimport AEAD from 'bcrypto/lib/js/aead';\nimport x25519 from 'bcrypto/lib/js/x25519';\nimport SHA256 from 'bcrypto/lib/js/sha256';\nimport { getHkdf } from \"../utils\";\nimport { logger } from \"../logger\";\nexport var MIN_NONCE = 0;\nexport var AbstractHandshake = /*#__PURE__*/function () {\n  function AbstractHandshake() {\n    _classCallCheck(this, AbstractHandshake);\n  }\n\n  _createClass(AbstractHandshake, [{\n    key: \"encryptWithAd\",\n    value: function encryptWithAd(cs, ad, plaintext) {\n      var e = this.encrypt(cs.k, cs.n, ad, plaintext);\n      this.setNonce(cs, this.incrementNonce(cs.n));\n      return e;\n    }\n  }, {\n    key: \"decryptWithAd\",\n    value: function decryptWithAd(cs, ad, ciphertext) {\n      var _this$decrypt = this.decrypt(cs.k, cs.n, ad, ciphertext),\n          plaintext = _this$decrypt.plaintext,\n          valid = _this$decrypt.valid;\n\n      this.setNonce(cs, this.incrementNonce(cs.n));\n      return {\n        plaintext: plaintext,\n        valid: valid\n      };\n    } // Cipher state related\n\n  }, {\n    key: \"hasKey\",\n    value: function hasKey(cs) {\n      return !this.isEmptyKey(cs.k);\n    }\n  }, {\n    key: \"setNonce\",\n    value: function setNonce(cs, nonce) {\n      cs.n = nonce;\n    }\n  }, {\n    key: \"createEmptyKey\",\n    value: function createEmptyKey() {\n      return Buffer.alloc(32);\n    }\n  }, {\n    key: \"isEmptyKey\",\n    value: function isEmptyKey(k) {\n      var emptyKey = this.createEmptyKey();\n      return emptyKey.equals(k);\n    }\n  }, {\n    key: \"incrementNonce\",\n    value: function incrementNonce(n) {\n      return n + 1;\n    }\n  }, {\n    key: \"nonceToBytes\",\n    value: function nonceToBytes(n) {\n      var nonce = Buffer.alloc(12);\n      nonce.writeUInt32LE(n, 4);\n      return nonce;\n    }\n  }, {\n    key: \"encrypt\",\n    value: function encrypt(k, n, ad, plaintext) {\n      var nonce = this.nonceToBytes(n);\n      var ctx = new AEAD();\n      plaintext = Buffer.from(plaintext);\n      ctx.init(k, nonce);\n      ctx.aad(ad);\n      ctx.encrypt(plaintext); // Encryption is done on the sent reference\n\n      return Buffer.concat([plaintext, ctx.final()]);\n    }\n  }, {\n    key: \"encryptAndHash\",\n    value: function encryptAndHash(ss, plaintext) {\n      var ciphertext;\n\n      if (this.hasKey(ss.cs)) {\n        ciphertext = this.encryptWithAd(ss.cs, ss.h, plaintext);\n      } else {\n        ciphertext = plaintext;\n      }\n\n      this.mixHash(ss, ciphertext);\n      return ciphertext;\n    }\n  }, {\n    key: \"decrypt\",\n    value: function decrypt(k, n, ad, ciphertext) {\n      var nonce = this.nonceToBytes(n);\n      var ctx = new AEAD();\n      ciphertext = Buffer.from(ciphertext);\n      var tag = ciphertext.slice(ciphertext.length - 16);\n      ciphertext = ciphertext.slice(0, ciphertext.length - 16);\n      ctx.init(k, nonce);\n      ctx.aad(ad);\n      ctx.decrypt(ciphertext); // Decryption is done on the sent reference\n\n      return {\n        plaintext: ciphertext,\n        valid: ctx.verify(tag)\n      };\n    }\n  }, {\n    key: \"decryptAndHash\",\n    value: function decryptAndHash(ss, ciphertext) {\n      var plaintext,\n          valid = true;\n\n      if (this.hasKey(ss.cs)) {\n        var _this$decryptWithAd = this.decryptWithAd(ss.cs, ss.h, ciphertext);\n\n        plaintext = _this$decryptWithAd.plaintext;\n        valid = _this$decryptWithAd.valid;\n      } else {\n        plaintext = ciphertext;\n      }\n\n      this.mixHash(ss, ciphertext);\n      return {\n        plaintext: plaintext,\n        valid: valid\n      };\n    }\n  }, {\n    key: \"dh\",\n    value: function dh(privateKey, publicKey) {\n      try {\n        var derived = x25519.derive(publicKey, privateKey);\n        var result = Buffer.alloc(32);\n        derived.copy(result);\n        return result;\n      } catch (e) {\n        logger(e.message);\n        return Buffer.alloc(32);\n      }\n    }\n  }, {\n    key: \"mixHash\",\n    value: function mixHash(ss, data) {\n      ss.h = this.getHash(ss.h, data);\n    }\n  }, {\n    key: \"getHash\",\n    value: function getHash(a, b) {\n      return SHA256.digest(Buffer.from([].concat(_toConsumableArray(a), _toConsumableArray(b))));\n    }\n  }, {\n    key: \"mixKey\",\n    value: function mixKey(ss, ikm) {\n      var _getHkdf = getHkdf(ss.ck, ikm),\n          _getHkdf2 = _slicedToArray(_getHkdf, 2),\n          ck = _getHkdf2[0],\n          tempK = _getHkdf2[1];\n\n      ss.cs = this.initializeKey(tempK);\n      ss.ck = ck;\n    }\n  }, {\n    key: \"initializeKey\",\n    value: function initializeKey(k) {\n      var n = MIN_NONCE;\n      return {\n        k: k,\n        n: n\n      };\n    } // Symmetric state related\n\n  }, {\n    key: \"initializeSymmetric\",\n    value: function initializeSymmetric(protocolName) {\n      var protocolNameBytes = Buffer.from(protocolName, 'utf-8');\n      var h = this.hashProtocolName(protocolNameBytes);\n      var ck = h;\n      var key = this.createEmptyKey();\n      var cs = this.initializeKey(key);\n      return {\n        cs: cs,\n        ck: ck,\n        h: h\n      };\n    }\n  }, {\n    key: \"hashProtocolName\",\n    value: function hashProtocolName(protocolName) {\n      if (protocolName.length <= 32) {\n        var h = Buffer.alloc(32);\n        protocolName.copy(h);\n        return h;\n      } else {\n        return this.getHash(protocolName, Buffer.alloc(0));\n      }\n    }\n  }, {\n    key: \"split\",\n    value: function split(ss) {\n      var _getHkdf3 = getHkdf(ss.ck, Buffer.alloc(0)),\n          _getHkdf4 = _slicedToArray(_getHkdf3, 2),\n          tempk1 = _getHkdf4[0],\n          tempk2 = _getHkdf4[1];\n\n      var cs1 = this.initializeKey(tempk1);\n      var cs2 = this.initializeKey(tempk2);\n      return {\n        cs1: cs1,\n        cs2: cs2\n      };\n    }\n  }, {\n    key: \"writeMessageRegular\",\n    value: function writeMessageRegular(cs, payload) {\n      var ciphertext = this.encryptWithAd(cs, Buffer.alloc(0), payload);\n      var ne = this.createEmptyKey();\n      var ns = Buffer.alloc(0);\n      return {\n        ne: ne,\n        ns: ns,\n        ciphertext: ciphertext\n      };\n    }\n  }, {\n    key: \"readMessageRegular\",\n    value: function readMessageRegular(cs, message) {\n      return this.decryptWithAd(cs, Buffer.alloc(0), message.ciphertext);\n    }\n  }]);\n\n  return AbstractHandshake;\n}();","map":null,"metadata":{},"sourceType":"module"}