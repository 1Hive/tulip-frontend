{"ast":null,"code":"/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/\n(function (global, factory) {\n  /* global define, require, module */\n\n  /* AMD */\n  if (typeof define === 'function' && define.amd) define([\"protobufjs/minimal\"], factory);\n  /* CommonJS */\n  else if (typeof require === 'function' && typeof module === 'object' && module && module.exports) module.exports = factory(require(\"protobufjs/minimal\"));\n})(this, function ($protobuf) {\n  \"use strict\"; // Common aliases\n\n  var $Reader = $protobuf.Reader,\n      $Writer = $protobuf.Writer,\n      $util = $protobuf.util; // Exported root namespace\n\n  var $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\n\n  $root.pb = function () {\n    /**\n     * Namespace pb.\n     * @exports pb\n     * @namespace\n     */\n    var pb = {};\n\n    pb.NoiseHandshakePayload = function () {\n      /**\n       * Properties of a NoiseHandshakePayload.\n       * @memberof pb\n       * @interface INoiseHandshakePayload\n       * @property {Uint8Array|null} [identityKey] NoiseHandshakePayload identityKey\n       * @property {Uint8Array|null} [identitySig] NoiseHandshakePayload identitySig\n       * @property {Uint8Array|null} [data] NoiseHandshakePayload data\n       */\n\n      /**\n       * Constructs a new NoiseHandshakePayload.\n       * @memberof pb\n       * @classdesc Represents a NoiseHandshakePayload.\n       * @implements INoiseHandshakePayload\n       * @constructor\n       * @param {pb.INoiseHandshakePayload=} [properties] Properties to set\n       */\n      function NoiseHandshakePayload(properties) {\n        if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n      /**\n       * NoiseHandshakePayload identityKey.\n       * @member {Uint8Array} identityKey\n       * @memberof pb.NoiseHandshakePayload\n       * @instance\n       */\n\n\n      NoiseHandshakePayload.prototype.identityKey = $util.newBuffer([]);\n      /**\n       * NoiseHandshakePayload identitySig.\n       * @member {Uint8Array} identitySig\n       * @memberof pb.NoiseHandshakePayload\n       * @instance\n       */\n\n      NoiseHandshakePayload.prototype.identitySig = $util.newBuffer([]);\n      /**\n       * NoiseHandshakePayload data.\n       * @member {Uint8Array} data\n       * @memberof pb.NoiseHandshakePayload\n       * @instance\n       */\n\n      NoiseHandshakePayload.prototype.data = $util.newBuffer([]);\n      /**\n       * Creates a new NoiseHandshakePayload instance using the specified properties.\n       * @function create\n       * @memberof pb.NoiseHandshakePayload\n       * @static\n       * @param {pb.INoiseHandshakePayload=} [properties] Properties to set\n       * @returns {pb.NoiseHandshakePayload} NoiseHandshakePayload instance\n       */\n\n      NoiseHandshakePayload.create = function create(properties) {\n        return new NoiseHandshakePayload(properties);\n      };\n      /**\n       * Encodes the specified NoiseHandshakePayload message. Does not implicitly {@link pb.NoiseHandshakePayload.verify|verify} messages.\n       * @function encode\n       * @memberof pb.NoiseHandshakePayload\n       * @static\n       * @param {pb.INoiseHandshakePayload} message NoiseHandshakePayload message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n\n      NoiseHandshakePayload.encode = function encode(message, writer) {\n        if (!writer) writer = $Writer.create();\n        if (message.identityKey != null && message.hasOwnProperty(\"identityKey\")) writer.uint32(\n        /* id 1, wireType 2 =*/\n        10).bytes(message.identityKey);\n        if (message.identitySig != null && message.hasOwnProperty(\"identitySig\")) writer.uint32(\n        /* id 2, wireType 2 =*/\n        18).bytes(message.identitySig);\n        if (message.data != null && message.hasOwnProperty(\"data\")) writer.uint32(\n        /* id 3, wireType 2 =*/\n        26).bytes(message.data);\n        return writer;\n      };\n      /**\n       * Encodes the specified NoiseHandshakePayload message, length delimited. Does not implicitly {@link pb.NoiseHandshakePayload.verify|verify} messages.\n       * @function encodeDelimited\n       * @memberof pb.NoiseHandshakePayload\n       * @static\n       * @param {pb.INoiseHandshakePayload} message NoiseHandshakePayload message or plain object to encode\n       * @param {$protobuf.Writer} [writer] Writer to encode to\n       * @returns {$protobuf.Writer} Writer\n       */\n\n\n      NoiseHandshakePayload.encodeDelimited = function encodeDelimited(message, writer) {\n        return this.encode(message, writer).ldelim();\n      };\n      /**\n       * Decodes a NoiseHandshakePayload message from the specified reader or buffer.\n       * @function decode\n       * @memberof pb.NoiseHandshakePayload\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {pb.NoiseHandshakePayload} NoiseHandshakePayload\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      NoiseHandshakePayload.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        var end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.pb.NoiseHandshakePayload();\n\n        while (reader.pos < end) {\n          var tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              message.identityKey = reader.bytes();\n              break;\n\n            case 2:\n              message.identitySig = reader.bytes();\n              break;\n\n            case 3:\n              message.data = reader.bytes();\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return message;\n      };\n      /**\n       * Decodes a NoiseHandshakePayload message from the specified reader or buffer, length delimited.\n       * @function decodeDelimited\n       * @memberof pb.NoiseHandshakePayload\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @returns {pb.NoiseHandshakePayload} NoiseHandshakePayload\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n\n      NoiseHandshakePayload.decodeDelimited = function decodeDelimited(reader) {\n        if (!(reader instanceof $Reader)) reader = new $Reader(reader);\n        return this.decode(reader, reader.uint32());\n      };\n      /**\n       * Verifies a NoiseHandshakePayload message.\n       * @function verify\n       * @memberof pb.NoiseHandshakePayload\n       * @static\n       * @param {Object.<string,*>} message Plain object to verify\n       * @returns {string|null} `null` if valid, otherwise the reason why it is not\n       */\n\n\n      NoiseHandshakePayload.verify = function verify(message) {\n        if (typeof message !== \"object\" || message === null) return \"object expected\";\n        if (message.identityKey != null && message.hasOwnProperty(\"identityKey\")) if (!(message.identityKey && typeof message.identityKey.length === \"number\" || $util.isString(message.identityKey))) return \"identityKey: buffer expected\";\n        if (message.identitySig != null && message.hasOwnProperty(\"identitySig\")) if (!(message.identitySig && typeof message.identitySig.length === \"number\" || $util.isString(message.identitySig))) return \"identitySig: buffer expected\";\n        if (message.data != null && message.hasOwnProperty(\"data\")) if (!(message.data && typeof message.data.length === \"number\" || $util.isString(message.data))) return \"data: buffer expected\";\n        return null;\n      };\n      /**\n       * Creates a NoiseHandshakePayload message from a plain object. Also converts values to their respective internal types.\n       * @function fromObject\n       * @memberof pb.NoiseHandshakePayload\n       * @static\n       * @param {Object.<string,*>} object Plain object\n       * @returns {pb.NoiseHandshakePayload} NoiseHandshakePayload\n       */\n\n\n      NoiseHandshakePayload.fromObject = function fromObject(object) {\n        if (object instanceof $root.pb.NoiseHandshakePayload) return object;\n        var message = new $root.pb.NoiseHandshakePayload();\n        if (object.identityKey != null) if (typeof object.identityKey === \"string\") $util.base64.decode(object.identityKey, message.identityKey = $util.newBuffer($util.base64.length(object.identityKey)), 0);else if (object.identityKey.length) message.identityKey = object.identityKey;\n        if (object.identitySig != null) if (typeof object.identitySig === \"string\") $util.base64.decode(object.identitySig, message.identitySig = $util.newBuffer($util.base64.length(object.identitySig)), 0);else if (object.identitySig.length) message.identitySig = object.identitySig;\n        if (object.data != null) if (typeof object.data === \"string\") $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);else if (object.data.length) message.data = object.data;\n        return message;\n      };\n      /**\n       * Creates a plain object from a NoiseHandshakePayload message. Also converts values to other types if specified.\n       * @function toObject\n       * @memberof pb.NoiseHandshakePayload\n       * @static\n       * @param {pb.NoiseHandshakePayload} message NoiseHandshakePayload\n       * @param {$protobuf.IConversionOptions} [options] Conversion options\n       * @returns {Object.<string,*>} Plain object\n       */\n\n\n      NoiseHandshakePayload.toObject = function toObject(message, options) {\n        if (!options) options = {};\n        var object = {};\n\n        if (options.defaults) {\n          if (options.bytes === String) object.identityKey = \"\";else {\n            object.identityKey = [];\n            if (options.bytes !== Array) object.identityKey = $util.newBuffer(object.identityKey);\n          }\n          if (options.bytes === String) object.identitySig = \"\";else {\n            object.identitySig = [];\n            if (options.bytes !== Array) object.identitySig = $util.newBuffer(object.identitySig);\n          }\n          if (options.bytes === String) object.data = \"\";else {\n            object.data = [];\n            if (options.bytes !== Array) object.data = $util.newBuffer(object.data);\n          }\n        }\n\n        if (message.identityKey != null && message.hasOwnProperty(\"identityKey\")) object.identityKey = options.bytes === String ? $util.base64.encode(message.identityKey, 0, message.identityKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.identityKey) : message.identityKey;\n        if (message.identitySig != null && message.hasOwnProperty(\"identitySig\")) object.identitySig = options.bytes === String ? $util.base64.encode(message.identitySig, 0, message.identitySig.length) : options.bytes === Array ? Array.prototype.slice.call(message.identitySig) : message.identitySig;\n        if (message.data != null && message.hasOwnProperty(\"data\")) object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;\n        return object;\n      };\n      /**\n       * Converts this NoiseHandshakePayload to JSON.\n       * @function toJSON\n       * @memberof pb.NoiseHandshakePayload\n       * @instance\n       * @returns {Object.<string,*>} JSON object\n       */\n\n\n      NoiseHandshakePayload.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n      };\n\n      return NoiseHandshakePayload;\n    }();\n\n    return pb;\n  }();\n\n  return $root;\n});","map":null,"metadata":{},"sourceType":"script"}