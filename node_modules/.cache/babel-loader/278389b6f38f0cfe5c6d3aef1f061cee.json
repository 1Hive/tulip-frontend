{"ast":null,"code":"'use strict';\n\nconst concat = require('uint8arrays/concat');\n\nconst fromString = require('uint8arrays/from-string');\n\nconst webcrypto = require('../webcrypto'); // Based off of code from https://github.com/luke-park/SecureCompatibleEncryptionExamples\n\n/**\n *\n * @param {object} [options]\n * @param {string} [options.algorithm=AES-GCM]\n * @param {Number} [options.nonceLength=12]\n * @param {Number} [options.keyLength=16]\n * @param {string} [options.digest=sha256]\n * @param {Number} [options.saltLength=16]\n * @param {Number} [options.iterations=32767]\n * @returns {*}\n */\n\n\nfunction create({\n  algorithm = 'AES-GCM',\n  nonceLength = 12,\n  keyLength = 16,\n  digest = 'SHA-256',\n  saltLength = 16,\n  iterations = 32767\n} = {}) {\n  const crypto = webcrypto.get();\n  keyLength *= 8; // Browser crypto uses bits instead of bytes\n\n  /**\n   * Uses the provided password to derive a pbkdf2 key. The key\n   * will then be used to encrypt the data.\n   *\n   * @param {Uint8Array} data The data to decrypt\n   * @param {string} password A plain password\n   * @returns {Promise<Uint8Array>}\n   */\n\n  async function encrypt(data, password) {\n    // eslint-disable-line require-await\n    const salt = crypto.getRandomValues(new Uint8Array(saltLength));\n    const nonce = crypto.getRandomValues(new Uint8Array(nonceLength));\n    const aesGcm = {\n      name: algorithm,\n      iv: nonce\n    }; // Derive a key using PBKDF2.\n\n    const deriveParams = {\n      name: 'PBKDF2',\n      salt,\n      iterations,\n      hash: {\n        name: digest\n      }\n    };\n    const rawKey = await crypto.subtle.importKey('raw', fromString(password), {\n      name: 'PBKDF2'\n    }, false, ['deriveKey', 'deriveBits']);\n    const cryptoKey = await crypto.subtle.deriveKey(deriveParams, rawKey, {\n      name: algorithm,\n      length: keyLength\n    }, true, ['encrypt']); // Encrypt the string.\n\n    const ciphertext = await crypto.subtle.encrypt(aesGcm, cryptoKey, data);\n    return concat([salt, aesGcm.iv, new Uint8Array(ciphertext)]);\n  }\n  /**\n   * Uses the provided password to derive a pbkdf2 key. The key\n   * will then be used to decrypt the data. The options used to create\n   * this decryption cipher must be the same as those used to create\n   * the encryption cipher.\n   *\n   * @param {Uint8Array} data The data to decrypt\n   * @param {string} password A plain password\n   * @returns {Promise<Uint8Array>}\n   */\n\n\n  async function decrypt(data, password) {\n    const salt = data.slice(0, saltLength);\n    const nonce = data.slice(saltLength, saltLength + nonceLength);\n    const ciphertext = data.slice(saltLength + nonceLength);\n    const aesGcm = {\n      name: algorithm,\n      iv: nonce\n    }; // Derive the key using PBKDF2.\n\n    const deriveParams = {\n      name: 'PBKDF2',\n      salt,\n      iterations,\n      hash: {\n        name: digest\n      }\n    };\n    const rawKey = await crypto.subtle.importKey('raw', fromString(password), {\n      name: 'PBKDF2'\n    }, false, ['deriveKey', 'deriveBits']);\n    const cryptoKey = await crypto.subtle.deriveKey(deriveParams, rawKey, {\n      name: algorithm,\n      length: keyLength\n    }, true, ['decrypt']); // Decrypt the string.\n\n    const plaintext = await crypto.subtle.decrypt(aesGcm, cryptoKey, ciphertext);\n    return new Uint8Array(plaintext);\n  }\n\n  return {\n    encrypt,\n    decrypt\n  };\n}\n\nmodule.exports = {\n  create\n};","map":null,"metadata":{},"sourceType":"script"}