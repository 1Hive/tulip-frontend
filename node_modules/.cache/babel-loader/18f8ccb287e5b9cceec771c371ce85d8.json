{"ast":null,"code":"'use strict';\n\nconst {\n  EventEmitter\n} = require('events');\n\nconst debug = require('debug');\n\nconst globalThis = require('ipfs-utils/src/globalthis');\n\nconst log = debug('libp2p');\nlog.error = debug('libp2p:error');\n\nconst PeerInfo = require('peer-info');\n\nconst peerRouting = require('./peer-routing');\n\nconst contentRouting = require('./content-routing');\n\nconst pubsub = require('./pubsub');\n\nconst {\n  getPeerInfo\n} = require('./get-peer-info');\n\nconst {\n  validate: validateConfig\n} = require('./config');\n\nconst {\n  codes\n} = require('./errors');\n\nconst ConnectionManager = require('./connection-manager');\n\nconst Circuit = require('./circuit');\n\nconst Dialer = require('./dialer');\n\nconst Metrics = require('./metrics');\n\nconst TransportManager = require('./transport-manager');\n\nconst Upgrader = require('./upgrader');\n\nconst PeerStore = require('./peer-store');\n\nconst Registrar = require('./registrar');\n\nconst ping = require('./ping');\n\nconst {\n  IdentifyService,\n  multicodecs: IDENTIFY_PROTOCOLS\n} = require('./identify');\n/**\n * @fires Libp2p#error Emitted when an error occurs\n * @fires Libp2p#peer:connect Emitted when a peer is connected to this node\n * @fires Libp2p#peer:disconnect Emitted when a peer disconnects from this node\n * @fires Libp2p#peer:discovery Emitted when a peer is discovered\n */\n\n\nclass Libp2p extends EventEmitter {\n  constructor(_options) {\n    super(); // validateConfig will ensure the config is correct,\n    // and add default values where appropriate\n\n    this._options = validateConfig(_options);\n    this.datastore = this._options.datastore;\n    this.peerInfo = this._options.peerInfo;\n    this.peerStore = new PeerStore();\n    this._modules = this._options.modules;\n    this._config = this._options.config;\n    this._transport = []; // Transport instances/references\n\n    this._discovery = new Map(); // Discovery service instances/references\n\n    if (this._options.metrics.enabled) {\n      this.metrics = new Metrics(this._options.metrics);\n    } // Setup the Upgrader\n\n\n    this.upgrader = new Upgrader({\n      localPeer: this.peerInfo.id,\n      metrics: this.metrics,\n      onConnection: connection => {\n        const peerInfo = this.peerStore.put(new PeerInfo(connection.remotePeer), {\n          silent: true\n        });\n        this.registrar.onConnect(peerInfo, connection);\n        this.connectionManager.onConnect(connection);\n        this.emit('peer:connect', peerInfo); // Run identify for every connection\n\n        if (this.identifyService) {\n          this.identifyService.identify(connection, connection.remotePeer).catch(log.error);\n        }\n      },\n      onConnectionEnd: connection => {\n        const peerInfo = Dialer.getDialable(connection.remotePeer);\n        this.registrar.onDisconnect(peerInfo, connection);\n        this.connectionManager.onDisconnect(connection); // If there are no connections to the peer, disconnect\n\n        if (!this.registrar.getConnection(peerInfo)) {\n          this.emit('peer:disconnect', peerInfo);\n          this.metrics && this.metrics.onPeerDisconnected(peerInfo.id);\n        }\n      }\n    }); // Create the Registrar\n\n    this.registrar = new Registrar({\n      peerStore: this.peerStore\n    });\n    this.handle = this.handle.bind(this);\n    this.registrar.handle = this.handle; // Create the Connection Manager\n\n    this.connectionManager = new ConnectionManager(this, this._options.connectionManager); // Setup the transport manager\n\n    this.transportManager = new TransportManager({\n      libp2p: this,\n      upgrader: this.upgrader\n    }); // Attach crypto channels\n\n    if (this._modules.connEncryption) {\n      const cryptos = this._modules.connEncryption;\n      cryptos.forEach(crypto => {\n        this.upgrader.cryptos.set(crypto.protocol, crypto);\n      });\n    }\n\n    this.dialer = new Dialer({\n      transportManager: this.transportManager,\n      peerStore: this.peerStore,\n      concurrency: this._options.dialer.maxParallelDials,\n      perPeerLimit: this._options.dialer.maxDialsPerPeer,\n      timeout: this._options.dialer.dialTimeout\n    });\n\n    this._modules.transport.forEach(Transport => {\n      const key = Transport.prototype[Symbol.toStringTag];\n      const transportOptions = this._config.transport[key];\n      this.transportManager.add(key, Transport, transportOptions);\n    });\n\n    if (this._config.relay.enabled) {\n      this.transportManager.add(Circuit.prototype[Symbol.toStringTag], Circuit);\n    } // Attach stream multiplexers\n\n\n    if (this._modules.streamMuxer) {\n      const muxers = this._modules.streamMuxer;\n      muxers.forEach(muxer => {\n        this.upgrader.muxers.set(muxer.multicodec, muxer);\n      }); // Add the identify service since we can multiplex\n\n      this.identifyService = new IdentifyService({\n        registrar: this.registrar,\n        peerInfo: this.peerInfo,\n        protocols: this.upgrader.protocols\n      });\n      this.handle(Object.values(IDENTIFY_PROTOCOLS), this.identifyService.handleMessage);\n    } // Attach private network protector\n\n\n    if (this._modules.connProtector) {\n      this.upgrader.protector = this._modules.connProtector;\n    } else if (globalThis.process !== undefined && globalThis.process.env && globalThis.process.env.LIBP2P_FORCE_PNET) {\n      throw new Error('Private network is enforced, but no protector was provided');\n    } // dht provided components (peerRouting, contentRouting, dht)\n\n\n    if (this._modules.dht) {\n      const DHT = this._modules.dht;\n      this._dht = new DHT({\n        dialer: this.dialer,\n        peerInfo: this.peerInfo,\n        peerStore: this.peerStore,\n        registrar: this.registrar,\n        datastore: this.datastore,\n        ...this._config.dht\n      });\n    } // start pubsub\n\n\n    if (this._modules.pubsub) {\n      this.pubsub = pubsub(this, this._modules.pubsub, this._config.pubsub);\n    } // Attach remaining APIs\n    // peer and content routing will automatically get modules from _modules and _dht\n\n\n    this.peerRouting = peerRouting(this);\n    this.contentRouting = contentRouting(this); // Mount default protocols\n\n    ping.mount(this);\n    this._onDiscoveryPeer = this._onDiscoveryPeer.bind(this);\n  }\n  /**\n   * Overrides EventEmitter.emit to conditionally emit errors\n   * if there is a handler. If not, errors will be logged.\n   * @param {string} eventName\n   * @param  {...any} args\n   * @returns {void}\n   */\n\n\n  emit(eventName, ...args) {\n    if (eventName === 'error' && !this._events.error) {\n      log.error(...args);\n    } else {\n      super.emit(eventName, ...args);\n    }\n  }\n  /**\n   * Starts the libp2p node and all its subsystems\n   *\n   * @returns {Promise<void>}\n   */\n\n\n  async start() {\n    log('libp2p is starting');\n\n    try {\n      await this._onStarting();\n      await this._onDidStart();\n      log('libp2p has started');\n    } catch (err) {\n      this.emit('error', err);\n      log.error('An error occurred starting libp2p', err);\n      await this.stop();\n      throw err;\n    }\n  }\n  /**\n   * Stop the libp2p node by closing its listeners and open connections\n   * @async\n   * @returns {void}\n   */\n\n\n  async stop() {\n    log('libp2p is stopping');\n\n    try {\n      for (const service of this._discovery.values()) {\n        service.removeListener('peer', this._onDiscoveryPeer);\n      }\n\n      await Promise.all(Array.from(this._discovery.values(), s => s.stop()));\n      this._discovery = new Map();\n      this.connectionManager.stop();\n      await Promise.all([this.pubsub && this.pubsub.stop(), this._dht && this._dht.stop(), this.metrics && this.metrics.stop()]);\n      await this.transportManager.close();\n      await this.registrar.close();\n      ping.unmount(this);\n      this.dialer.destroy();\n    } catch (err) {\n      if (err) {\n        log.error(err);\n        this.emit('error', err);\n      }\n    }\n\n    this._isStarted = false;\n    log('libp2p has stopped');\n  }\n\n  isStarted() {\n    return this._isStarted;\n  }\n  /**\n   * Gets a Map of the current connections. The keys are the stringified\n   * `PeerId` of the peer. The value is an array of Connections to that peer.\n   * @returns {Map<string, Connection[]>}\n   */\n\n\n  get connections() {\n    return this.registrar.connections;\n  }\n  /**\n   * Dials to the provided peer. If successful, the `PeerInfo` of the\n   * peer will be added to the nodes `peerStore`\n   *\n   * @param {PeerInfo|PeerId|Multiaddr|string} peer The peer to dial\n   * @param {object} options\n   * @param {AbortSignal} [options.signal]\n   * @returns {Promise<Connection>}\n   */\n\n\n  dial(peer, options) {\n    return this.dialProtocol(peer, null, options);\n  }\n  /**\n   * Dials to the provided peer and handshakes with the given protocol.\n   * If successful, the `PeerInfo` of the peer will be added to the nodes `peerStore`,\n   * and the `Connection` will be sent in the callback\n   *\n   * @async\n   * @param {PeerInfo|PeerId|Multiaddr|string} peer The peer to dial\n   * @param {string[]|string} protocols\n   * @param {object} options\n   * @param {AbortSignal} [options.signal]\n   * @returns {Promise<Connection|*>}\n   */\n\n\n  async dialProtocol(peer, protocols, options) {\n    const dialable = Dialer.getDialable(peer);\n    let connection;\n\n    if (PeerInfo.isPeerInfo(dialable)) {\n      this.peerStore.put(dialable, {\n        silent: true\n      });\n      connection = this.registrar.getConnection(dialable);\n    }\n\n    if (!connection) {\n      connection = await this.dialer.connectToPeer(dialable, options);\n    } // If a protocol was provided, create a new stream\n\n\n    if (protocols) {\n      return connection.newStream(protocols);\n    }\n\n    return connection;\n  }\n  /**\n   * Disconnects all connections to the given `peer`\n   *\n   * @param {PeerInfo|PeerId|multiaddr|string} peer the peer to close connections to\n   * @returns {Promise<void>}\n   */\n\n\n  async hangUp(peer) {\n    const peerInfo = getPeerInfo(peer, this.peerStore);\n    const connections = this.registrar.connections.get(peerInfo.id.toB58String());\n\n    if (!connections) {\n      return;\n    }\n\n    await Promise.all(connections.map(connection => {\n      return connection.close();\n    }));\n  }\n  /**\n   * Pings the given peer\n   * @param {PeerInfo|PeerId|Multiaddr|string} peer The peer to ping\n   * @returns {Promise<number>}\n   */\n\n\n  async ping(peer) {\n    const peerInfo = await getPeerInfo(peer, this.peerStore);\n    return ping(this, peerInfo);\n  }\n  /**\n   * Registers the `handler` for each protocol\n   * @param {string[]|string} protocols\n   * @param {function({ connection:*, stream:*, protocol:string })} handler\n   */\n\n\n  handle(protocols, handler) {\n    protocols = Array.isArray(protocols) ? protocols : [protocols];\n    protocols.forEach(protocol => {\n      this.upgrader.protocols.set(protocol, handler);\n    }); // Only push if libp2p is running\n\n    if (this.isStarted() && this.identifyService) {\n      this.identifyService.pushToPeerStore(this.peerStore);\n    }\n  }\n  /**\n   * Removes the handler for each protocol. The protocol\n   * will no longer be supported on streams.\n   * @param {string[]|string} protocols\n   */\n\n\n  unhandle(protocols) {\n    protocols = Array.isArray(protocols) ? protocols : [protocols];\n    protocols.forEach(protocol => {\n      this.upgrader.protocols.delete(protocol);\n    }); // Only push if libp2p is running\n\n    if (this.isStarted() && this.identifyService) {\n      this.identifyService.pushToPeerStore(this.peerStore);\n    }\n  }\n\n  async _onStarting() {\n    // Listen on the addresses supplied in the peerInfo\n    const multiaddrs = this.peerInfo.multiaddrs.toArray();\n    await this.transportManager.listen(multiaddrs); // The addresses may change once the listener starts\n    // eg /ip4/0.0.0.0/tcp/0 => /ip4/192.168.1.0/tcp/58751\n\n    this.peerInfo.multiaddrs.clear();\n\n    for (const ma of this.transportManager.getAddrs()) {\n      this.peerInfo.multiaddrs.add(ma);\n    }\n\n    if (this._config.pubsub.enabled) {\n      this.pubsub && this.pubsub.start();\n    } // DHT subsystem\n\n\n    if (this._config.dht.enabled) {\n      this._dht && this._dht.start(); // TODO: this should be modified once random-walk is used as\n      // the other discovery modules\n\n      this._dht.on('peer', this._onDiscoveryPeer);\n    } // Start metrics if present\n\n\n    this.metrics && this.metrics.start();\n  }\n  /**\n   * Called when libp2p has started and before it returns\n   * @private\n   */\n\n\n  async _onDidStart() {\n    this._isStarted = true;\n    this.connectionManager.start();\n    this.peerStore.on('peer', peerInfo => {\n      this.emit('peer:discovery', peerInfo);\n\n      this._maybeConnect(peerInfo);\n    }); // Peer discovery\n\n    await this._setupPeerDiscovery(); // Once we start, emit and dial any peers we may have already discovered\n\n    for (const peerInfo of this.peerStore.peers.values()) {\n      this.emit('peer:discovery', peerInfo);\n\n      this._maybeConnect(peerInfo);\n    }\n  }\n  /**\n   * Called whenever peer discovery services emit `peer` events.\n   * Known peers may be emitted.\n   * @private\n   * @param {PeerInfo} peerInfo\n   */\n\n\n  _onDiscoveryPeer(peerInfo) {\n    if (peerInfo.id.toB58String() === this.peerInfo.id.toB58String()) {\n      log.error(new Error(codes.ERR_DISCOVERED_SELF));\n      return;\n    }\n\n    this.peerStore.put(peerInfo);\n  }\n  /**\n   * Will dial to the given `peerInfo` if the current number of\n   * connected peers is less than the configured `ConnectionManager`\n   * minPeers.\n   * @private\n   * @param {PeerInfo} peerInfo\n   */\n\n\n  async _maybeConnect(peerInfo) {\n    // If auto dialing is on and we have no connection to the peer, check if we should dial\n    if (this._config.peerDiscovery.autoDial === true && !this.registrar.getConnection(peerInfo)) {\n      const minPeers = this._options.connectionManager.minPeers || 0;\n\n      if (minPeers > this.connectionManager._connections.size) {\n        log('connecting to discovered peer %s', peerInfo.id.toB58String());\n\n        try {\n          await this.dialer.connectToPeer(peerInfo);\n        } catch (err) {\n          log.error('could not connect to discovered peer', err);\n        }\n      }\n    }\n  }\n  /**\n   * Initializes and starts peer discovery services\n   *\n   * @async\n   * @private\n   */\n\n\n  async _setupPeerDiscovery() {\n    const setupService = DiscoveryService => {\n      let config = {\n        enabled: true // on by default\n\n      };\n\n      if (DiscoveryService.tag && this._config.peerDiscovery && this._config.peerDiscovery[DiscoveryService.tag]) {\n        config = { ...config,\n          ...this._config.peerDiscovery[DiscoveryService.tag]\n        };\n      }\n\n      if (config.enabled && !this._discovery.has(DiscoveryService.tag)) {\n        // not already added\n        let discoveryService;\n\n        if (typeof DiscoveryService === 'function') {\n          discoveryService = new DiscoveryService(Object.assign({}, config, {\n            peerInfo: this.peerInfo,\n            libp2p: this\n          }));\n        } else {\n          discoveryService = DiscoveryService;\n        }\n\n        discoveryService.on('peer', this._onDiscoveryPeer);\n\n        this._discovery.set(DiscoveryService.tag, discoveryService);\n      }\n    }; // Discovery modules\n\n\n    for (const DiscoveryService of this._modules.peerDiscovery || []) {\n      setupService(DiscoveryService);\n    } // Transport modules with discovery\n\n\n    for (const Transport of this.transportManager.getTransports()) {\n      if (Transport.discovery) {\n        setupService(Transport.discovery);\n      }\n    }\n\n    await Promise.all(Array.from(this._discovery.values(), d => d.start()));\n  }\n\n}\n/**\n * Like `new Libp2p(options)` except it will create a `PeerInfo`\n * instance if one is not provided in options.\n * @param {object} options Libp2p configuration options\n * @returns {Libp2p}\n */\n\n\nLibp2p.create = async function create(options = {}) {\n  if (options.peerInfo) {\n    return new Libp2p(options);\n  }\n\n  const peerInfo = await PeerInfo.create();\n  options.peerInfo = peerInfo;\n  return new Libp2p(options);\n};\n\nmodule.exports = Libp2p;","map":null,"metadata":{},"sourceType":"script"}