{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _wrapAsyncGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar _awaitAsyncGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _asyncIterator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar _asyncGeneratorDelegate = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate\");\n\nvar CID = require('cids');\n\nvar _require = require('../../../utils/cid'),\n    cidToString = _require.cidToString;\n\nvar log = require('debug')('ipfs:repo:gc');\n\nvar _require2 = require('../../utils'),\n    MFS_ROOT_KEY = _require2.MFS_ROOT_KEY,\n    withTimeoutOption = _require2.withTimeoutOption;\n\nvar Repo = require('ipfs-repo');\n\nvar _require3 = require('interface-datastore'),\n    Errors = _require3.Errors;\n\nvar ERR_NOT_FOUND = Errors.notFoundError().code;\n\nvar _require4 = require('streaming-iterables'),\n    parallelMerge = _require4.parallelMerge,\n    transform = _require4.transform,\n    map = _require4.map; // Limit on the number of parallel block remove operations\n\n\nvar BLOCK_RM_CONCURRENCY = 256; // Perform mark and sweep garbage collection\n\nmodule.exports = function (_ref3) {\n  var gcLock = _ref3.gcLock,\n      pin = _ref3.pin,\n      pinManager = _ref3.pinManager,\n      refs = _ref3.refs,\n      repo = _ref3.repo;\n  return withTimeoutOption( /*#__PURE__*/function () {\n    var _gc = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var options,\n          start,\n          release,\n          markedSet,\n          blockKeys,\n          _args = arguments;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              options = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};\n              start = Date.now();\n              log('Creating set of marked blocks');\n              _context.next = 5;\n              return _awaitAsyncGenerator(gcLock.writeLock());\n\n            case 5:\n              release = _context.sent;\n              _context.prev = 6;\n              _context.next = 9;\n              return _awaitAsyncGenerator(createMarkedSet({\n                pin: pin,\n                pinManager: pinManager,\n                refs: refs,\n                repo: repo\n              }));\n\n            case 9:\n              markedSet = _context.sent;\n              // Get all blocks keys from the blockstore\n              blockKeys = repo.blocks.query({\n                keysOnly: true\n              }); // Delete blocks that are not being used\n\n              return _context.delegateYield(_asyncGeneratorDelegate(_asyncIterator(deleteUnmarkedBlocks({\n                repo: repo,\n                refs: refs\n              }, markedSet, blockKeys)), _awaitAsyncGenerator), \"t0\", 12);\n\n            case 12:\n              log(\"Complete (\".concat(Date.now() - start, \"ms)\"));\n\n            case 13:\n              _context.prev = 13;\n              release();\n              return _context.finish(13);\n\n            case 16:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[6,, 13, 16]]);\n    }));\n\n    function gc() {\n      return _gc.apply(this, arguments);\n    }\n\n    return gc;\n  }());\n}; // Get Set of CIDs of blocks to keep\n\n\nfunction createMarkedSet(_x4) {\n  return _createMarkedSet.apply(this, arguments);\n} // Delete all blocks that are not marked as in use\n\n\nfunction _createMarkedSet() {\n  _createMarkedSet = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(_ref4) {\n    var pin, pinManager, refs, repo, pinsSource, pinInternalsSource, mfsSource, output, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, cid;\n\n    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            pin = _ref4.pin, pinManager = _ref4.pinManager, refs = _ref4.refs, repo = _ref4.repo;\n            pinsSource = map(function (_ref8) {\n              var cid = _ref8.cid;\n              return cid;\n            }, pin.ls());\n            pinInternalsSource = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n              var cids;\n              return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n                while (1) {\n                  switch (_context4.prev = _context4.next) {\n                    case 0:\n                      _context4.next = 2;\n                      return _awaitAsyncGenerator(pinManager.getInternalBlocks());\n\n                    case 2:\n                      cids = _context4.sent;\n                      return _context4.delegateYield(_asyncGeneratorDelegate(_asyncIterator(cids), _awaitAsyncGenerator), \"t0\", 4);\n\n                    case 4:\n                    case \"end\":\n                      return _context4.stop();\n                  }\n                }\n              }, _callee4);\n            }))();\n            mfsSource = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n              var mh, rootCid, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _value2, _value4, ref;\n\n              return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n                while (1) {\n                  switch (_context5.prev = _context5.next) {\n                    case 0:\n                      _context5.prev = 0;\n                      _context5.next = 3;\n                      return _awaitAsyncGenerator(repo.root.get(MFS_ROOT_KEY));\n\n                    case 3:\n                      mh = _context5.sent;\n                      _context5.next = 12;\n                      break;\n\n                    case 6:\n                      _context5.prev = 6;\n                      _context5.t0 = _context5[\"catch\"](0);\n\n                      if (!(_context5.t0.code === ERR_NOT_FOUND)) {\n                        _context5.next = 11;\n                        break;\n                      }\n\n                      log('No blocks in MFS');\n                      return _context5.abrupt(\"return\");\n\n                    case 11:\n                      throw _context5.t0;\n\n                    case 12:\n                      rootCid = new CID(mh);\n                      _context5.next = 15;\n                      return rootCid;\n\n                    case 15:\n                      _iteratorNormalCompletion2 = true;\n                      _didIteratorError2 = false;\n                      _context5.prev = 17;\n                      _iterator2 = _asyncIterator(refs(rootCid, {\n                        recursive: true\n                      }));\n\n                    case 19:\n                      _context5.next = 21;\n                      return _awaitAsyncGenerator(_iterator2.next());\n\n                    case 21:\n                      _step2 = _context5.sent;\n                      _iteratorNormalCompletion2 = _step2.done;\n                      _context5.next = 25;\n                      return _awaitAsyncGenerator(_step2.value);\n\n                    case 25:\n                      _value2 = _context5.sent;\n\n                      if (_iteratorNormalCompletion2) {\n                        _context5.next = 33;\n                        break;\n                      }\n\n                      _value4 = _value2, ref = _value4.ref;\n                      _context5.next = 30;\n                      return new CID(ref);\n\n                    case 30:\n                      _iteratorNormalCompletion2 = true;\n                      _context5.next = 19;\n                      break;\n\n                    case 33:\n                      _context5.next = 39;\n                      break;\n\n                    case 35:\n                      _context5.prev = 35;\n                      _context5.t1 = _context5[\"catch\"](17);\n                      _didIteratorError2 = true;\n                      _iteratorError2 = _context5.t1;\n\n                    case 39:\n                      _context5.prev = 39;\n                      _context5.prev = 40;\n\n                      if (!(!_iteratorNormalCompletion2 && _iterator2.return != null)) {\n                        _context5.next = 44;\n                        break;\n                      }\n\n                      _context5.next = 44;\n                      return _awaitAsyncGenerator(_iterator2.return());\n\n                    case 44:\n                      _context5.prev = 44;\n\n                      if (!_didIteratorError2) {\n                        _context5.next = 47;\n                        break;\n                      }\n\n                      throw _iteratorError2;\n\n                    case 47:\n                      return _context5.finish(44);\n\n                    case 48:\n                      return _context5.finish(39);\n\n                    case 49:\n                    case \"end\":\n                      return _context5.stop();\n                  }\n                }\n              }, _callee5, null, [[0, 6], [17, 35, 39, 49], [40,, 44, 48]]);\n            }))();\n            output = new Set();\n            _iteratorNormalCompletion = true;\n            _didIteratorError = false;\n            _context6.prev = 7;\n            _iterator = _asyncIterator(parallelMerge(pinsSource, pinInternalsSource, mfsSource));\n\n          case 9:\n            _context6.next = 11;\n            return _iterator.next();\n\n          case 11:\n            _step = _context6.sent;\n            _iteratorNormalCompletion = _step.done;\n            _context6.next = 15;\n            return _step.value;\n\n          case 15:\n            _value = _context6.sent;\n\n            if (_iteratorNormalCompletion) {\n              _context6.next = 22;\n              break;\n            }\n\n            cid = _value;\n            output.add(cidToString(cid, {\n              base: 'base32'\n            }));\n\n          case 19:\n            _iteratorNormalCompletion = true;\n            _context6.next = 9;\n            break;\n\n          case 22:\n            _context6.next = 28;\n            break;\n\n          case 24:\n            _context6.prev = 24;\n            _context6.t0 = _context6[\"catch\"](7);\n            _didIteratorError = true;\n            _iteratorError = _context6.t0;\n\n          case 28:\n            _context6.prev = 28;\n            _context6.prev = 29;\n\n            if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n              _context6.next = 33;\n              break;\n            }\n\n            _context6.next = 33;\n            return _iterator.return();\n\n          case 33:\n            _context6.prev = 33;\n\n            if (!_didIteratorError) {\n              _context6.next = 36;\n              break;\n            }\n\n            throw _iteratorError;\n\n          case 36:\n            return _context6.finish(33);\n\n          case 37:\n            return _context6.finish(28);\n\n          case 38:\n            return _context6.abrupt(\"return\", output);\n\n          case 39:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6, null, [[7, 24, 28, 38], [29,, 33, 37]]);\n  }));\n  return _createMarkedSet.apply(this, arguments);\n}\n\nfunction deleteUnmarkedBlocks(_x, _x2, _x3) {\n  return _deleteUnmarkedBlocks.apply(this, arguments);\n}\n\nfunction _deleteUnmarkedBlocks() {\n  _deleteUnmarkedBlocks = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(_ref5, markedSet, blockKeys) {\n    var repo, refs, blocksCount, removedBlocksCount, removeBlock, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, _value3, res;\n\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            repo = _ref5.repo, refs = _ref5.refs;\n            // Iterate through all blocks and find those that are not in the marked set\n            // blockKeys yields { key: Key() }\n            blocksCount = 0;\n            removedBlocksCount = 0;\n\n            removeBlock = /*#__PURE__*/function () {\n              var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref6) {\n                var k, cid, b32, res, msg;\n                return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                  while (1) {\n                    switch (_context2.prev = _context2.next) {\n                      case 0:\n                        k = _ref6.key;\n                        blocksCount++;\n                        _context2.prev = 2;\n                        cid = Repo.utils.blockstore.keyToCid(k);\n                        b32 = cid.toV1().toString('base32');\n\n                        if (!markedSet.has(b32)) {\n                          _context2.next = 7;\n                          break;\n                        }\n\n                        return _context2.abrupt(\"return\", null);\n\n                      case 7:\n                        res = {\n                          cid: cid\n                        };\n                        _context2.prev = 8;\n                        _context2.next = 11;\n                        return repo.blocks.delete(cid);\n\n                      case 11:\n                        removedBlocksCount++;\n                        _context2.next = 17;\n                        break;\n\n                      case 14:\n                        _context2.prev = 14;\n                        _context2.t0 = _context2[\"catch\"](8);\n                        res.err = new Error(\"Could not delete block with CID \".concat(cid, \": \").concat(_context2.t0.message));\n\n                      case 17:\n                        return _context2.abrupt(\"return\", res);\n\n                      case 20:\n                        _context2.prev = 20;\n                        _context2.t1 = _context2[\"catch\"](2);\n                        msg = \"Could not convert block with key '\".concat(k, \"' to CID\");\n                        log(msg, _context2.t1);\n                        return _context2.abrupt(\"return\", {\n                          err: new Error(msg + \": \".concat(_context2.t1.message))\n                        });\n\n                      case 25:\n                      case \"end\":\n                        return _context2.stop();\n                    }\n                  }\n                }, _callee2, null, [[2, 20], [8, 14]]);\n              }));\n\n              return function removeBlock(_x5) {\n                return _ref7.apply(this, arguments);\n              };\n            }();\n\n            _iteratorNormalCompletion3 = true;\n            _didIteratorError3 = false;\n            _context3.prev = 6;\n            _iterator3 = _asyncIterator(transform(BLOCK_RM_CONCURRENCY, removeBlock, blockKeys));\n\n          case 8:\n            _context3.next = 10;\n            return _awaitAsyncGenerator(_iterator3.next());\n\n          case 10:\n            _step3 = _context3.sent;\n            _iteratorNormalCompletion3 = _step3.done;\n            _context3.next = 14;\n            return _awaitAsyncGenerator(_step3.value);\n\n          case 14:\n            _value3 = _context3.sent;\n\n            if (_iteratorNormalCompletion3) {\n              _context3.next = 23;\n              break;\n            }\n\n            res = _value3;\n\n            if (!res) {\n              _context3.next = 20;\n              break;\n            }\n\n            _context3.next = 20;\n            return res;\n\n          case 20:\n            _iteratorNormalCompletion3 = true;\n            _context3.next = 8;\n            break;\n\n          case 23:\n            _context3.next = 29;\n            break;\n\n          case 25:\n            _context3.prev = 25;\n            _context3.t0 = _context3[\"catch\"](6);\n            _didIteratorError3 = true;\n            _iteratorError3 = _context3.t0;\n\n          case 29:\n            _context3.prev = 29;\n            _context3.prev = 30;\n\n            if (!(!_iteratorNormalCompletion3 && _iterator3.return != null)) {\n              _context3.next = 34;\n              break;\n            }\n\n            _context3.next = 34;\n            return _awaitAsyncGenerator(_iterator3.return());\n\n          case 34:\n            _context3.prev = 34;\n\n            if (!_didIteratorError3) {\n              _context3.next = 37;\n              break;\n            }\n\n            throw _iteratorError3;\n\n          case 37:\n            return _context3.finish(34);\n\n          case 38:\n            return _context3.finish(29);\n\n          case 39:\n            log(\"Marked set has \".concat(markedSet.size, \" unique blocks. Blockstore has \").concat(blocksCount, \" blocks. \") + \"Deleted \".concat(removedBlocksCount, \" blocks.\"));\n\n          case 40:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, null, [[6, 25, 29, 39], [30,, 34, 38]]);\n  }));\n  return _deleteUnmarkedBlocks.apply(this, arguments);\n}","map":null,"metadata":{},"sourceType":"script"}