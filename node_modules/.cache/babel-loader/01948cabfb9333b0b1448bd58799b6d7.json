{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _createForOfIteratorHelper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _toConsumableArray = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar multiaddr = require('multiaddr');\n\nvar errCode = require('err-code');\n\nvar TimeoutController = require('timeout-abort-controller');\n\nvar anySignal = require('any-signal');\n\nvar PeerId = require('peer-id');\n\nvar PeerInfo = require('peer-info');\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:dialer');\nlog.error = debug('libp2p:dialer:error');\n\nvar _require = require('./dial-request'),\n    DialRequest = _require.DialRequest;\n\nvar _require2 = require('../errors'),\n    codes = _require2.codes;\n\nvar _require3 = require('../constants'),\n    DIAL_TIMEOUT = _require3.DIAL_TIMEOUT,\n    MAX_PARALLEL_DIALS = _require3.MAX_PARALLEL_DIALS,\n    MAX_PER_PEER_DIALS = _require3.MAX_PER_PEER_DIALS;\n\nvar Dialer = /*#__PURE__*/function () {\n  /**\n   * @constructor\n   * @param {object} options\n   * @param {TransportManager} options.transportManager\n   * @param {Peerstore} peerStore\n   * @param {number} options.concurrency Number of max concurrent dials. Defaults to `MAX_PARALLEL_DIALS`\n   * @param {number} options.timeout How long a dial attempt is allowed to take. Defaults to `DIAL_TIMEOUT`\n   */\n  function Dialer(_ref) {\n    var transportManager = _ref.transportManager,\n        peerStore = _ref.peerStore,\n        _ref$concurrency = _ref.concurrency,\n        concurrency = _ref$concurrency === void 0 ? MAX_PARALLEL_DIALS : _ref$concurrency,\n        _ref$timeout = _ref.timeout,\n        timeout = _ref$timeout === void 0 ? DIAL_TIMEOUT : _ref$timeout,\n        _ref$perPeerLimit = _ref.perPeerLimit,\n        perPeerLimit = _ref$perPeerLimit === void 0 ? MAX_PER_PEER_DIALS : _ref$perPeerLimit;\n\n    _classCallCheck(this, Dialer);\n\n    this.transportManager = transportManager;\n    this.peerStore = peerStore;\n    this.concurrency = concurrency;\n    this.timeout = timeout;\n    this.perPeerLimit = perPeerLimit;\n    this.tokens = _toConsumableArray(new Array(concurrency)).map(function (_, index) {\n      return index;\n    });\n    this._pendingDials = new Map();\n  }\n  /**\n   * Clears any pending dials\n   */\n\n\n  _createClass(Dialer, [{\n    key: \"destroy\",\n    value: function destroy() {\n      var _iterator = _createForOfIteratorHelper(this._pendingDials.values()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var dial = _step.value;\n\n          try {\n            dial.controller.abort();\n          } catch (err) {\n            log.error(err);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      this._pendingDials.clear();\n    }\n    /**\n     * Connects to a given `PeerId` or `Multiaddr` by dialing all of its known addresses.\n     * The dial to the first address that is successfully able to upgrade a connection\n     * will be used.\n     *\n     * @param {PeerInfo|Multiaddr} peer The peer to dial\n     * @param {object} [options]\n     * @param {AbortSignal} [options.signal] An AbortController signal\n     * @returns {Promise<Connection>}\n     */\n\n  }, {\n    key: \"connectToPeer\",\n    value: function () {\n      var _connectToPeer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(peer) {\n        var options,\n            dialTarget,\n            pendingDial,\n            connection,\n            _args = arguments;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n                dialTarget = this._createDialTarget(peer);\n\n                if (!(dialTarget.addrs.length === 0)) {\n                  _context.next = 4;\n                  break;\n                }\n\n                throw errCode(new Error('The dial request has no addresses'), codes.ERR_NO_VALID_ADDRESSES);\n\n              case 4:\n                pendingDial = this._pendingDials.get(dialTarget.id) || this._createPendingDial(dialTarget, options);\n                _context.prev = 5;\n                _context.next = 8;\n                return pendingDial.promise;\n\n              case 8:\n                connection = _context.sent;\n                log('dial succeeded to %s', dialTarget.id);\n                return _context.abrupt(\"return\", connection);\n\n              case 13:\n                _context.prev = 13;\n                _context.t0 = _context[\"catch\"](5);\n\n                // Error is a timeout\n                if (pendingDial.controller.signal.aborted) {\n                  _context.t0.code = codes.ERR_TIMEOUT;\n                }\n\n                log.error(_context.t0);\n                throw _context.t0;\n\n              case 18:\n                _context.prev = 18;\n                pendingDial.destroy();\n                return _context.finish(18);\n\n              case 21:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[5, 13, 18, 21]]);\n      }));\n\n      function connectToPeer(_x) {\n        return _connectToPeer.apply(this, arguments);\n      }\n\n      return connectToPeer;\n    }()\n    /**\n     * @typedef DialTarget\n     * @property {string} id\n     * @property {Multiaddr[]} addrs\n     */\n\n    /**\n     * Creates a DialTarget. The DialTarget is used to create and track\n     * the DialRequest to a given peer.\n     * @private\n     * @param {PeerInfo|Multiaddr} peer A PeerId or Multiaddr\n     * @returns {DialTarget}\n     */\n\n  }, {\n    key: \"_createDialTarget\",\n    value: function _createDialTarget(peer) {\n      var dialable = Dialer.getDialable(peer);\n\n      if (multiaddr.isMultiaddr(dialable)) {\n        return {\n          id: dialable.toString(),\n          addrs: [dialable]\n        };\n      }\n\n      var addrs = this.peerStore.multiaddrsForPeer(dialable);\n      return {\n        id: dialable.id.toB58String(),\n        addrs: addrs\n      };\n    }\n    /**\n     * @typedef PendingDial\n     * @property {DialRequest} dialRequest\n     * @property {TimeoutController} controller\n     * @property {Promise} promise\n     * @property {function():void} destroy\n     */\n\n    /**\n     * Creates a PendingDial that wraps the underlying DialRequest\n     * @private\n     * @param {DialTarget} dialTarget\n     * @param {object} [options]\n     * @param {AbortSignal} [options.signal] An AbortController signal\n     * @returns {PendingDial}\n     */\n\n  }, {\n    key: \"_createPendingDial\",\n    value: function _createPendingDial(dialTarget, options) {\n      var _this = this;\n\n      var dialAction = function dialAction(addr, options) {\n        if (options.signal.aborted) throw errCode(new Error('already aborted'), codes.ERR_ALREADY_ABORTED);\n        return _this.transportManager.dial(addr, options);\n      };\n\n      var dialRequest = new DialRequest({\n        addrs: dialTarget.addrs,\n        dialAction: dialAction,\n        dialer: this\n      }); // Combine the timeout signal and options.signal, if provided\n\n      var timeoutController = new TimeoutController(this.timeout);\n      var signals = [timeoutController.signal];\n      options.signal && signals.push(options.signal);\n      var signal = anySignal(signals);\n      var pendingDial = {\n        dialRequest: dialRequest,\n        controller: timeoutController,\n        promise: dialRequest.run(_objectSpread(_objectSpread({}, options), {}, {\n          signal: signal\n        })),\n        destroy: function destroy() {\n          timeoutController.clear();\n\n          _this._pendingDials.delete(dialTarget.id);\n        }\n      };\n\n      this._pendingDials.set(dialTarget.id, pendingDial);\n\n      return pendingDial;\n    }\n  }, {\n    key: \"getTokens\",\n    value: function getTokens(num) {\n      var total = Math.min(num, this.perPeerLimit, this.tokens.length);\n      var tokens = this.tokens.splice(0, total);\n      log('%d tokens request, returning %d, %d remaining', num, total, this.tokens.length);\n      return tokens;\n    }\n  }, {\n    key: \"releaseToken\",\n    value: function releaseToken(token) {\n      // Guard against duplicate releases\n      if (this.tokens.indexOf(token) > -1) return;\n      log('token %d released', token);\n      this.tokens.push(token);\n    }\n    /**\n     * Converts the given `peer` into a `PeerInfo` or `Multiaddr`.\n     * @static\n     * @param {PeerInfo|PeerId|Multiaddr|string} peer\n     * @returns {PeerInfo|Multiaddr}\n     */\n\n  }], [{\n    key: \"getDialable\",\n    value: function getDialable(peer) {\n      if (PeerInfo.isPeerInfo(peer)) return peer;\n\n      if (typeof peer === 'string') {\n        peer = multiaddr(peer);\n      }\n\n      var addr;\n\n      if (multiaddr.isMultiaddr(peer)) {\n        addr = peer;\n\n        try {\n          peer = PeerId.createFromCID(peer.getPeerId());\n        } catch (err) {\n          throw errCode(new Error('The multiaddr did not contain a valid peer id'), codes.ERR_INVALID_PEER);\n        }\n      }\n\n      if (PeerId.isPeerId(peer)) {\n        peer = new PeerInfo(peer);\n      }\n\n      addr && peer.multiaddrs.add(addr);\n      return peer;\n    }\n  }]);\n\n  return Dialer;\n}();\n\nmodule.exports = Dialer;","map":null,"metadata":{},"sourceType":"script"}