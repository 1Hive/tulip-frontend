{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar defer = require('p-defer');\n\nvar _require = require('../errors'),\n    NotStartedError = _require.NotStartedError,\n    AlreadyInitializedError = _require.AlreadyInitializedError;\n\nvar Components = require('./');\n\nvar _require2 = require('../utils'),\n    withTimeoutOption = _require2.withTimeoutOption;\n\nmodule.exports = function (_ref) {\n  var apiManager = _ref.apiManager,\n      constructorOptions = _ref.options,\n      bitswap = _ref.bitswap,\n      blockService = _ref.blockService,\n      gcLock = _ref.gcLock,\n      initOptions = _ref.initOptions,\n      ipld = _ref.ipld,\n      ipns = _ref.ipns,\n      keychain = _ref.keychain,\n      libp2p = _ref.libp2p,\n      mfsPreload = _ref.mfsPreload,\n      peerInfo = _ref.peerInfo,\n      pinManager = _ref.pinManager,\n      preload = _ref.preload,\n      print = _ref.print,\n      repo = _ref.repo;\n  return withTimeoutOption( /*#__PURE__*/function () {\n    var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var stopPromise, _apiManager$update, cancel, api;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              stopPromise = defer();\n              _apiManager$update = apiManager.update({\n                stop: function stop() {\n                  return stopPromise.promise;\n                }\n              }), cancel = _apiManager$update.cancel;\n              _context.prev = 2;\n              blockService.unsetExchange();\n              bitswap.stop();\n              preload.stop();\n              _context.next = 8;\n              return Promise.all([ipns.republisher.stop(), mfsPreload.stop(), libp2p.stop(), repo.close()]);\n\n            case 8:\n              // Clear our addresses so we can start clean\n              peerInfo.multiaddrs.clear();\n              api = createApi({\n                apiManager: apiManager,\n                constructorOptions: constructorOptions,\n                blockService: blockService,\n                gcLock: gcLock,\n                initOptions: initOptions,\n                ipld: ipld,\n                keychain: keychain,\n                peerInfo: peerInfo,\n                pinManager: pinManager,\n                preload: preload,\n                print: print,\n                repo: repo\n              });\n              apiManager.update(api, function () {\n                throw new NotStartedError();\n              });\n              _context.next = 18;\n              break;\n\n            case 13:\n              _context.prev = 13;\n              _context.t0 = _context[\"catch\"](2);\n              cancel();\n              stopPromise.reject(_context.t0);\n              throw _context.t0;\n\n            case 18:\n              stopPromise.resolve();\n\n            case 19:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[2, 13]]);\n    }));\n\n    function stop() {\n      return _stop.apply(this, arguments);\n    }\n\n    return stop;\n  }());\n};\n\nfunction createApi(_ref2) {\n  var apiManager = _ref2.apiManager,\n      constructorOptions = _ref2.constructorOptions,\n      blockService = _ref2.blockService,\n      gcLock = _ref2.gcLock,\n      initOptions = _ref2.initOptions,\n      ipld = _ref2.ipld,\n      keychain = _ref2.keychain,\n      peerInfo = _ref2.peerInfo,\n      pinManager = _ref2.pinManager,\n      preload = _ref2.preload,\n      print = _ref2.print,\n      repo = _ref2.repo;\n  var dag = {\n    get: Components.dag.get({\n      ipld: ipld,\n      preload: preload\n    }),\n    resolve: Components.dag.resolve({\n      ipld: ipld,\n      preload: preload\n    }),\n    tree: Components.dag.tree({\n      ipld: ipld,\n      preload: preload\n    })\n  };\n  var object = {\n    data: Components.object.data({\n      ipld: ipld,\n      preload: preload\n    }),\n    get: Components.object.get({\n      ipld: ipld,\n      preload: preload\n    }),\n    links: Components.object.links({\n      dag: dag\n    }),\n    new: Components.object.new({\n      ipld: ipld,\n      preload: preload\n    }),\n    patch: {\n      addLink: Components.object.patch.addLink({\n        ipld: ipld,\n        gcLock: gcLock,\n        preload: preload\n      }),\n      appendData: Components.object.patch.appendData({\n        ipld: ipld,\n        gcLock: gcLock,\n        preload: preload\n      }),\n      rmLink: Components.object.patch.rmLink({\n        ipld: ipld,\n        gcLock: gcLock,\n        preload: preload\n      }),\n      setData: Components.object.patch.setData({\n        ipld: ipld,\n        gcLock: gcLock,\n        preload: preload\n      })\n    },\n    put: Components.object.put({\n      ipld: ipld,\n      gcLock: gcLock,\n      preload: preload\n    }),\n    stat: Components.object.stat({\n      ipld: ipld,\n      preload: preload\n    })\n  };\n  var pin = {\n    add: Components.pin.add({\n      pinManager: pinManager,\n      gcLock: gcLock,\n      dag: dag\n    }),\n    ls: Components.pin.ls({\n      pinManager: pinManager,\n      dag: dag\n    }),\n    rm: Components.pin.rm({\n      pinManager: pinManager,\n      gcLock: gcLock,\n      dag: dag\n    })\n  }; // FIXME: resolve this circular dependency\n\n  dag.put = Components.dag.put({\n    ipld: ipld,\n    pin: pin,\n    gcLock: gcLock,\n    preload: preload\n  });\n  var block = {\n    get: Components.block.get({\n      blockService: blockService,\n      preload: preload\n    }),\n    put: Components.block.put({\n      blockService: blockService,\n      pin: pin,\n      gcLock: gcLock,\n      preload: preload\n    }),\n    rm: Components.block.rm({\n      blockService: blockService,\n      gcLock: gcLock,\n      pinManager: pinManager\n    }),\n    stat: Components.block.stat({\n      blockService: blockService,\n      preload: preload\n    })\n  };\n  var add = Components.add({\n    block: block,\n    preload: preload,\n    pin: pin,\n    gcLock: gcLock,\n    options: constructorOptions\n  });\n  var resolve = Components.resolve({\n    ipld: ipld\n  });\n  var refs = Components.refs({\n    ipld: ipld,\n    resolve: resolve,\n    preload: preload\n  });\n  refs.local = Components.refs.local({\n    repo: repo\n  });\n\n  var notStarted = /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              throw new NotStartedError();\n\n            case 1:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    return function notStarted() {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n\n  var api = {\n    add: add,\n    bitswap: {\n      stat: notStarted,\n      unwant: notStarted,\n      wantlist: notStarted\n    },\n    block: block,\n    bootstrap: {\n      add: Components.bootstrap.add({\n        repo: repo\n      }),\n      list: Components.bootstrap.list({\n        repo: repo\n      }),\n      rm: Components.bootstrap.rm({\n        repo: repo\n      })\n    },\n    cat: Components.cat({\n      ipld: ipld,\n      preload: preload\n    }),\n    config: Components.config({\n      repo: repo\n    }),\n    dag: dag,\n    dns: Components.dns(),\n    files: Components.files({\n      ipld: ipld,\n      block: block,\n      blockService: blockService,\n      repo: repo,\n      preload: preload,\n      options: constructorOptions\n    }),\n    get: Components.get({\n      ipld: ipld,\n      preload: preload\n    }),\n    id: Components.id({\n      peerInfo: peerInfo\n    }),\n    init: function () {\n      var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                throw new AlreadyInitializedError();\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      function init() {\n        return _init.apply(this, arguments);\n      }\n\n      return init;\n    }(),\n    isOnline: Components.isOnline({}),\n    key: {\n      export: Components.key.export({\n        keychain: keychain\n      }),\n      gen: Components.key.gen({\n        keychain: keychain\n      }),\n      import: Components.key.import({\n        keychain: keychain\n      }),\n      info: Components.key.info({\n        keychain: keychain\n      }),\n      list: Components.key.list({\n        keychain: keychain\n      }),\n      rename: Components.key.rename({\n        keychain: keychain\n      }),\n      rm: Components.key.rm({\n        keychain: keychain\n      })\n    },\n    ls: Components.ls({\n      ipld: ipld,\n      preload: preload\n    }),\n    object: object,\n    pin: pin,\n    refs: refs,\n    repo: {\n      gc: Components.repo.gc({\n        gcLock: gcLock,\n        pin: pin,\n        pinManager: pinManager,\n        refs: refs,\n        repo: repo\n      }),\n      stat: Components.repo.stat({\n        repo: repo\n      }),\n      version: Components.repo.version({\n        repo: repo\n      })\n    },\n    resolve: resolve,\n    start: Components.start({\n      apiManager: apiManager,\n      options: constructorOptions,\n      blockService: blockService,\n      gcLock: gcLock,\n      initOptions: initOptions,\n      ipld: ipld,\n      keychain: keychain,\n      peerInfo: peerInfo,\n      pinManager: pinManager,\n      preload: preload,\n      print: print,\n      repo: repo\n    }),\n    stats: {\n      bitswap: notStarted,\n      bw: notStarted,\n      repo: Components.repo.stat({\n        repo: repo\n      })\n    },\n    stop: function stop() {},\n    swarm: {\n      addrs: notStarted,\n      connect: notStarted,\n      disconnect: notStarted,\n      localAddrs: Components.swarm.localAddrs({\n        peerInfo: peerInfo\n      }),\n      peers: notStarted\n    },\n    version: Components.version({\n      repo: repo\n    })\n  };\n  return api;\n}","map":null,"metadata":{},"sourceType":"script"}