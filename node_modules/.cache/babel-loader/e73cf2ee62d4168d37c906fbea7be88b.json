{"ast":null,"code":"import { pipe, map, share, filter, tap, merge, take, toPromise } from \"wonka\";\nimport { __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED } from \"react\";\n\nfunction _extends() {\n  return (_extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  }).apply(this, arguments);\n}\n\nvar DevtoolsExchangeIncomingEventType = \"urql-devtools-exchange-in\";\nvar DevtoolsExchangeOutgoingEventType = \"urql-devtools-exchange\";\nvar CurrentOwner = __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner;\n\nvar isComponentFiber = function (fiber) {\n  return fiber && (0 === fiber.tag || 1 === fiber.tag || 2 === fiber.tag);\n};\n\nvar getDisplayName = function () {\n  var source = \"Component\";\n  var owner = CurrentOwner.current;\n\n  if (null !== owner && isComponentFiber(owner)) {\n    var Component = owner.type;\n\n    if (function (Component) {\n      return \"Query\" === Component.name || \"Mutation\" === Component.name || \"Subscription\" === Component.name;\n    }(Component) && isComponentFiber(owner._debugOwner)) {\n      Component = owner._debugOwner.type;\n    }\n\n    if (\"function\" == typeof Component) {\n      source = Component.displayName || Component.name || source;\n    }\n  }\n\n  return source;\n};\n\nvar nodejsCustomInspectSymbol = \"function\" == typeof Symbol && \"function\" == typeof Symbol.for ? Symbol.for(\"nodejs.util.inspect.custom\") : void 0;\n\nfunction _typeof(obj) {\n  if (\"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator) {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nvar MAX_ARRAY_LENGTH = 10;\nvar MAX_RECURSIVE_DEPTH = 2;\n\nfunction formatValue(value, seenValues) {\n  switch (_typeof(value)) {\n    case \"string\":\n      return JSON.stringify(value);\n\n    case \"function\":\n      return value.name ? \"[function \".concat(value.name, \"]\") : \"[function]\";\n\n    case \"object\":\n      if (null === value) {\n        return \"null\";\n      }\n\n      return function formatObjectValue(value, previouslySeenValues) {\n        if (-1 !== previouslySeenValues.indexOf(value)) {\n          return \"[Circular]\";\n        }\n\n        var seenValues = [].concat(previouslySeenValues, [value]);\n\n        var customInspectFn = function getCustomFn(object) {\n          var customInspectFn = object[String(nodejsCustomInspectSymbol)];\n\n          if (\"function\" == typeof customInspectFn) {\n            return customInspectFn;\n          }\n\n          if (\"function\" == typeof object.inspect) {\n            return object.inspect;\n          }\n        }(value);\n\n        if (void 0 !== customInspectFn) {\n          var customValue = customInspectFn.call(value);\n\n          if (customValue !== value) {\n            return \"string\" == typeof customValue ? customValue : formatValue(customValue, seenValues);\n          }\n        } else if (Array.isArray(value)) {\n          return function formatArray(array, seenValues) {\n            if (0 === array.length) {\n              return \"[]\";\n            }\n\n            if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n              return \"[Array]\";\n            }\n\n            var len = Math.min(MAX_ARRAY_LENGTH, array.length);\n            var remaining = array.length - len;\n            var items = [];\n\n            for (var i = 0; i < len; ++i) {\n              items.push(formatValue(array[i], seenValues));\n            }\n\n            if (1 === remaining) {\n              items.push(\"... 1 more item\");\n            } else if (remaining > 1) {\n              items.push(\"... \".concat(remaining, \" more items\"));\n            }\n\n            return \"[\" + items.join(\", \") + \"]\";\n          }(value, seenValues);\n        }\n\n        return function formatObject(object, seenValues) {\n          var keys = Object.keys(object);\n\n          if (0 === keys.length) {\n            return \"{}\";\n          }\n\n          if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n            return \"[\" + function getObjectTag(object) {\n              var tag = Object.prototype.toString.call(object).replace(/^\\[object /, \"\").replace(/]$/, \"\");\n\n              if (\"Object\" === tag && \"function\" == typeof object.constructor) {\n                var name = object.constructor.name;\n\n                if (\"string\" == typeof name && \"\" !== name) {\n                  return name;\n                }\n              }\n\n              return tag;\n            }(object) + \"]\";\n          }\n\n          return \"{ \" + keys.map(function (key) {\n            return key + \": \" + formatValue(object[key], seenValues);\n          }).join(\", \") + \" }\";\n        }(value, seenValues);\n      }(value, seenValues);\n\n    default:\n      return String(value);\n  }\n}\n\nfunction devAssert(condition, message) {\n  if (!Boolean(condition)) {\n    throw new Error(message);\n  }\n}\n\nfunction defineToJSON(classObject) {\n  var fn = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : classObject.prototype.toString;\n  classObject.prototype.toJSON = fn;\n  classObject.prototype.inspect = fn;\n\n  if (nodejsCustomInspectSymbol) {\n    classObject.prototype[nodejsCustomInspectSymbol] = fn;\n  }\n}\n\nfunction _typeof$1(obj) {\n  if (\"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator) {\n    _typeof$1 = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof$1 = function _typeof(obj) {\n      return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof$1(obj);\n}\n\nfunction getLocation(source, position) {\n  var lineRegexp = /\\r\\n|[\\n\\r]/g;\n  var line = 1;\n  var column = position + 1;\n  var match;\n\n  while ((match = lineRegexp.exec(source.body)) && match.index < position) {\n    line += 1;\n    column = position + 1 - (match.index + match[0].length);\n  }\n\n  return {\n    line: line,\n    column: column\n  };\n}\n\nfunction printLocation(location) {\n  return printSourceLocation(location.source, getLocation(location.source, location.start));\n}\n\nfunction printSourceLocation(source, sourceLocation) {\n  var firstLineColumnOffset = source.locationOffset.column - 1;\n  var body = whitespace(firstLineColumnOffset) + source.body;\n  var lineIndex = sourceLocation.line - 1;\n  var lineNum = sourceLocation.line + (source.locationOffset.line - 1);\n  var columnNum = sourceLocation.column + (1 === sourceLocation.line ? firstLineColumnOffset : 0);\n  var locationStr = \"\".concat(source.name, \":\").concat(lineNum, \":\").concat(columnNum, \"\\n\");\n  var lines = body.split(/\\r\\n|[\\n\\r]/g);\n  var locationLine = lines[lineIndex];\n\n  if (locationLine.length > 120) {\n    var sublineIndex = Math.floor(columnNum / 80);\n    var sublineColumnNum = columnNum % 80;\n    var sublines = [];\n\n    for (var i = 0; i < locationLine.length; i += 80) {\n      sublines.push(locationLine.slice(i, i + 80));\n    }\n\n    return locationStr + printPrefixedLines([[\"\".concat(lineNum), sublines[0]]].concat(sublines.slice(1, sublineIndex + 1).map(function (subline) {\n      return [\"\", subline];\n    }), [[\" \", whitespace(sublineColumnNum - 1) + \"^\"], [\"\", sublines[sublineIndex + 1]]]));\n  }\n\n  return locationStr + printPrefixedLines([[\"\".concat(lineNum - 1), lines[lineIndex - 1]], [\"\".concat(lineNum), locationLine], [\"\", whitespace(columnNum - 1) + \"^\"], [\"\".concat(lineNum + 1), lines[lineIndex + 1]]]);\n}\n\nfunction printPrefixedLines(lines) {\n  var existingLines = lines.filter(function (_ref) {\n    return void 0 !== _ref[1];\n  });\n  var padLen = Math.max.apply(Math, existingLines.map(function (_ref2) {\n    return _ref2[0].length;\n  }));\n  return existingLines.map(function (_ref3) {\n    var line = _ref3[1];\n    return function lpad(len, str) {\n      return whitespace(len - str.length) + str;\n    }(padLen, _ref3[0]) + (line ? \" | \" + line : \" |\");\n  }).join(\"\\n\");\n}\n\nfunction whitespace(len) {\n  return Array(len + 1).join(\" \");\n}\n\nfunction GraphQLError(message, nodes, source, positions, path, originalError, extensions) {\n  var _nodes = Array.isArray(nodes) ? 0 !== nodes.length ? nodes : void 0 : nodes ? [nodes] : void 0;\n\n  var _source = source;\n\n  if (!_source && _nodes) {\n    var node = _nodes[0];\n    _source = node && node.loc && node.loc.source;\n  }\n\n  var _positions = positions;\n\n  if (!_positions && _nodes) {\n    _positions = _nodes.reduce(function (list, node) {\n      if (node.loc) {\n        list.push(node.loc.start);\n      }\n\n      return list;\n    }, []);\n  }\n\n  if (_positions && 0 === _positions.length) {\n    _positions = void 0;\n  }\n\n  var _locations;\n\n  if (positions && source) {\n    _locations = positions.map(function (pos) {\n      return getLocation(source, pos);\n    });\n  } else if (_nodes) {\n    _locations = _nodes.reduce(function (list, node) {\n      if (node.loc) {\n        list.push(getLocation(node.loc.source, node.loc.start));\n      }\n\n      return list;\n    }, []);\n  }\n\n  var _extensions = extensions;\n\n  if (null == _extensions && null != originalError) {\n    var originalExtensions = originalError.extensions;\n\n    if (function isObjectLike(value) {\n      return \"object\" == _typeof$1(value) && null !== value;\n    }(originalExtensions)) {\n      _extensions = originalExtensions;\n    }\n  }\n\n  Object.defineProperties(this, {\n    message: {\n      value: message,\n      enumerable: !0,\n      writable: !0\n    },\n    locations: {\n      value: _locations || void 0,\n      enumerable: Boolean(_locations)\n    },\n    path: {\n      value: path || void 0,\n      enumerable: Boolean(path)\n    },\n    nodes: {\n      value: _nodes || void 0\n    },\n    source: {\n      value: _source || void 0\n    },\n    positions: {\n      value: _positions || void 0\n    },\n    originalError: {\n      value: originalError\n    },\n    extensions: {\n      value: _extensions || void 0,\n      enumerable: Boolean(_extensions)\n    }\n  });\n\n  if (originalError && originalError.stack) {\n    Object.defineProperty(this, \"stack\", {\n      value: originalError.stack,\n      writable: !0,\n      configurable: !0\n    });\n  } else if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, GraphQLError);\n  } else {\n    Object.defineProperty(this, \"stack\", {\n      value: Error().stack,\n      writable: !0,\n      configurable: !0\n    });\n  }\n}\n\nGraphQLError.prototype = Object.create(Error.prototype, {\n  constructor: {\n    value: GraphQLError\n  },\n  name: {\n    value: \"GraphQLError\"\n  },\n  toString: {\n    value: function toString() {\n      return function printError(error) {\n        var output = error.message;\n\n        if (error.nodes) {\n          for (var _i2 = 0, _error$nodes2 = error.nodes; _i2 < _error$nodes2.length; _i2++) {\n            var node = _error$nodes2[_i2];\n\n            if (node.loc) {\n              output += \"\\n\\n\" + printLocation(node.loc);\n            }\n          }\n        } else if (error.source && error.locations) {\n          for (var _i4 = 0, _error$locations2 = error.locations; _i4 < _error$locations2.length; _i4++) {\n            output += \"\\n\\n\" + printSourceLocation(error.source, _error$locations2[_i4]);\n          }\n        }\n\n        return output;\n      }(this);\n    }\n  }\n});\n\nfunction syntaxError(source, position, description) {\n  return new GraphQLError(\"Syntax Error: \".concat(description), void 0, source, [position]);\n}\n\nvar Kind = Object.freeze({\n  NAME: \"Name\",\n  DOCUMENT: \"Document\",\n  OPERATION_DEFINITION: \"OperationDefinition\",\n  VARIABLE_DEFINITION: \"VariableDefinition\",\n  SELECTION_SET: \"SelectionSet\",\n  FIELD: \"Field\",\n  ARGUMENT: \"Argument\",\n  FRAGMENT_SPREAD: \"FragmentSpread\",\n  INLINE_FRAGMENT: \"InlineFragment\",\n  FRAGMENT_DEFINITION: \"FragmentDefinition\",\n  VARIABLE: \"Variable\",\n  INT: \"IntValue\",\n  FLOAT: \"FloatValue\",\n  STRING: \"StringValue\",\n  BOOLEAN: \"BooleanValue\",\n  NULL: \"NullValue\",\n  ENUM: \"EnumValue\",\n  LIST: \"ListValue\",\n  OBJECT: \"ObjectValue\",\n  OBJECT_FIELD: \"ObjectField\",\n  DIRECTIVE: \"Directive\",\n  NAMED_TYPE: \"NamedType\",\n  LIST_TYPE: \"ListType\",\n  NON_NULL_TYPE: \"NonNullType\",\n  SCHEMA_DEFINITION: \"SchemaDefinition\",\n  OPERATION_TYPE_DEFINITION: \"OperationTypeDefinition\",\n  SCALAR_TYPE_DEFINITION: \"ScalarTypeDefinition\",\n  OBJECT_TYPE_DEFINITION: \"ObjectTypeDefinition\",\n  FIELD_DEFINITION: \"FieldDefinition\",\n  INPUT_VALUE_DEFINITION: \"InputValueDefinition\",\n  INTERFACE_TYPE_DEFINITION: \"InterfaceTypeDefinition\",\n  UNION_TYPE_DEFINITION: \"UnionTypeDefinition\",\n  ENUM_TYPE_DEFINITION: \"EnumTypeDefinition\",\n  ENUM_VALUE_DEFINITION: \"EnumValueDefinition\",\n  INPUT_OBJECT_TYPE_DEFINITION: \"InputObjectTypeDefinition\",\n  DIRECTIVE_DEFINITION: \"DirectiveDefinition\",\n  SCHEMA_EXTENSION: \"SchemaExtension\",\n  SCALAR_TYPE_EXTENSION: \"ScalarTypeExtension\",\n  OBJECT_TYPE_EXTENSION: \"ObjectTypeExtension\",\n  INTERFACE_TYPE_EXTENSION: \"InterfaceTypeExtension\",\n  UNION_TYPE_EXTENSION: \"UnionTypeExtension\",\n  ENUM_TYPE_EXTENSION: \"EnumTypeExtension\",\n  INPUT_OBJECT_TYPE_EXTENSION: \"InputObjectTypeExtension\"\n});\n\nvar Source = function Source(body, name, locationOffset) {\n  this.body = body;\n  this.name = name || \"GraphQL request\";\n  this.locationOffset = locationOffset || {\n    line: 1,\n    column: 1\n  };\n  this.locationOffset.line > 0 || devAssert(0, \"line in locationOffset is 1-indexed and must be positive\");\n  this.locationOffset.column > 0 || devAssert(0, \"column in locationOffset is 1-indexed and must be positive\");\n};\n\n!function defineToStringTag(classObject) {\n  if (\"function\" == typeof Symbol && Symbol.toStringTag) {\n    Object.defineProperty(classObject.prototype, Symbol.toStringTag, {\n      get: function get() {\n        return this.constructor.name;\n      }\n    });\n  }\n}(Source);\n\nfunction dedentBlockStringValue(rawString) {\n  var lines = rawString.split(/\\r\\n|[\\n\\r]/g);\n\n  var commonIndent = function getBlockStringIndentation(lines) {\n    var commonIndent = null;\n\n    for (var i = 1; i < lines.length; i++) {\n      var line = lines[i];\n      var indent = leadingWhitespace(line);\n\n      if (indent === line.length) {\n        continue;\n      }\n\n      if (null === commonIndent || indent < commonIndent) {\n        if (0 === (commonIndent = indent)) {\n          break;\n        }\n      }\n    }\n\n    return null === commonIndent ? 0 : commonIndent;\n  }(lines);\n\n  if (0 !== commonIndent) {\n    for (var i = 1; i < lines.length; i++) {\n      lines[i] = lines[i].slice(commonIndent);\n    }\n  }\n\n  while (lines.length > 0 && isBlank(lines[0])) {\n    lines.shift();\n  }\n\n  while (lines.length > 0 && isBlank(lines[lines.length - 1])) {\n    lines.pop();\n  }\n\n  return lines.join(\"\\n\");\n}\n\nfunction leadingWhitespace(str) {\n  var i = 0;\n\n  while (i < str.length && (\" \" === str[i] || \"\\t\" === str[i])) {\n    i++;\n  }\n\n  return i;\n}\n\nfunction isBlank(str) {\n  return leadingWhitespace(str) === str.length;\n}\n\nvar TokenKind = Object.freeze({\n  SOF: \"<SOF>\",\n  EOF: \"<EOF>\",\n  BANG: \"!\",\n  DOLLAR: \"$\",\n  AMP: \"&\",\n  PAREN_L: \"(\",\n  PAREN_R: \")\",\n  SPREAD: \"...\",\n  COLON: \":\",\n  EQUALS: \"=\",\n  AT: \"@\",\n  BRACKET_L: \"[\",\n  BRACKET_R: \"]\",\n  BRACE_L: \"{\",\n  PIPE: \"|\",\n  BRACE_R: \"}\",\n  NAME: \"Name\",\n  INT: \"Int\",\n  FLOAT: \"Float\",\n  STRING: \"String\",\n  BLOCK_STRING: \"BlockString\",\n  COMMENT: \"Comment\"\n});\n\nfunction advanceLexer() {\n  this.lastToken = this.token;\n  return this.token = this.lookahead();\n}\n\nfunction lookahead() {\n  var token = this.token;\n\n  if (token.kind !== TokenKind.EOF) {\n    do {\n      token = token.next || (token.next = readToken(this, token));\n    } while (token.kind === TokenKind.COMMENT);\n  }\n\n  return token;\n}\n\nfunction Tok(kind, start, end, line, column, prev, value) {\n  this.kind = kind;\n  this.start = start;\n  this.end = end;\n  this.line = line;\n  this.column = column;\n  this.value = value;\n  this.prev = prev;\n  this.next = null;\n}\n\ndefineToJSON(Tok, function () {\n  return {\n    kind: this.kind,\n    value: this.value,\n    line: this.line,\n    column: this.column\n  };\n});\n\nfunction printCharCode(code) {\n  return isNaN(code) ? TokenKind.EOF : code < 127 ? JSON.stringify(String.fromCharCode(code)) : '\"\\\\u'.concat((\"00\" + code.toString(16).toUpperCase()).slice(-4), '\"');\n}\n\nfunction readToken(lexer, prev) {\n  var source = lexer.source;\n  var body = source.body;\n  var bodyLength = body.length;\n\n  var pos = function positionAfterWhitespace(body, startPosition, lexer) {\n    var bodyLength = body.length;\n    var position = startPosition;\n\n    while (position < bodyLength) {\n      var code = body.charCodeAt(position);\n\n      if (9 === code || 32 === code || 44 === code || 65279 === code) {\n        ++position;\n      } else if (10 === code) {\n        ++position;\n        ++lexer.line;\n        lexer.lineStart = position;\n      } else if (13 === code) {\n        if (10 === body.charCodeAt(position + 1)) {\n          position += 2;\n        } else {\n          ++position;\n        }\n\n        ++lexer.line;\n        lexer.lineStart = position;\n      } else {\n        break;\n      }\n    }\n\n    return position;\n  }(body, prev.end, lexer);\n\n  var line = lexer.line;\n  var col = 1 + pos - lexer.lineStart;\n\n  if (pos >= bodyLength) {\n    return new Tok(TokenKind.EOF, bodyLength, bodyLength, line, col, prev);\n  }\n\n  var code = body.charCodeAt(pos);\n\n  switch (code) {\n    case 33:\n      return new Tok(TokenKind.BANG, pos, pos + 1, line, col, prev);\n\n    case 35:\n      return function readComment(source, start, line, col, prev) {\n        var body = source.body;\n        var code;\n        var position = start;\n\n        do {\n          code = body.charCodeAt(++position);\n        } while (!isNaN(code) && (code > 31 || 9 === code));\n\n        return new Tok(TokenKind.COMMENT, start, position, line, col, prev, body.slice(start + 1, position));\n      }(source, pos, line, col, prev);\n\n    case 36:\n      return new Tok(TokenKind.DOLLAR, pos, pos + 1, line, col, prev);\n\n    case 38:\n      return new Tok(TokenKind.AMP, pos, pos + 1, line, col, prev);\n\n    case 40:\n      return new Tok(TokenKind.PAREN_L, pos, pos + 1, line, col, prev);\n\n    case 41:\n      return new Tok(TokenKind.PAREN_R, pos, pos + 1, line, col, prev);\n\n    case 46:\n      if (46 === body.charCodeAt(pos + 1) && 46 === body.charCodeAt(pos + 2)) {\n        return new Tok(TokenKind.SPREAD, pos, pos + 3, line, col, prev);\n      }\n\n      break;\n\n    case 58:\n      return new Tok(TokenKind.COLON, pos, pos + 1, line, col, prev);\n\n    case 61:\n      return new Tok(TokenKind.EQUALS, pos, pos + 1, line, col, prev);\n\n    case 64:\n      return new Tok(TokenKind.AT, pos, pos + 1, line, col, prev);\n\n    case 91:\n      return new Tok(TokenKind.BRACKET_L, pos, pos + 1, line, col, prev);\n\n    case 93:\n      return new Tok(TokenKind.BRACKET_R, pos, pos + 1, line, col, prev);\n\n    case 123:\n      return new Tok(TokenKind.BRACE_L, pos, pos + 1, line, col, prev);\n\n    case 124:\n      return new Tok(TokenKind.PIPE, pos, pos + 1, line, col, prev);\n\n    case 125:\n      return new Tok(TokenKind.BRACE_R, pos, pos + 1, line, col, prev);\n\n    case 65:\n    case 66:\n    case 67:\n    case 68:\n    case 69:\n    case 70:\n    case 71:\n    case 72:\n    case 73:\n    case 74:\n    case 75:\n    case 76:\n    case 77:\n    case 78:\n    case 79:\n    case 80:\n    case 81:\n    case 82:\n    case 83:\n    case 84:\n    case 85:\n    case 86:\n    case 87:\n    case 88:\n    case 89:\n    case 90:\n    case 95:\n    case 97:\n    case 98:\n    case 99:\n    case 100:\n    case 101:\n    case 102:\n    case 103:\n    case 104:\n    case 105:\n    case 106:\n    case 107:\n    case 108:\n    case 109:\n    case 110:\n    case 111:\n    case 112:\n    case 113:\n    case 114:\n    case 115:\n    case 116:\n    case 117:\n    case 118:\n    case 119:\n    case 120:\n    case 121:\n    case 122:\n      return function readName(source, start, line, col, prev) {\n        var body = source.body;\n        var bodyLength = body.length;\n        var position = start + 1;\n        var code = 0;\n\n        while (position !== bodyLength && !isNaN(code = body.charCodeAt(position)) && (95 === code || code >= 48 && code <= 57 || code >= 65 && code <= 90 || code >= 97 && code <= 122)) {\n          ++position;\n        }\n\n        return new Tok(TokenKind.NAME, start, position, line, col, prev, body.slice(start, position));\n      }(source, pos, line, col, prev);\n\n    case 45:\n    case 48:\n    case 49:\n    case 50:\n    case 51:\n    case 52:\n    case 53:\n    case 54:\n    case 55:\n    case 56:\n    case 57:\n      return function readNumber(source, start, firstCode, line, col, prev) {\n        var body = source.body;\n        var code = firstCode;\n        var position = start;\n        var isFloat = !1;\n\n        if (45 === code) {\n          code = body.charCodeAt(++position);\n        }\n\n        if (48 === code) {\n          if ((code = body.charCodeAt(++position)) >= 48 && code <= 57) {\n            throw syntaxError(source, position, \"Invalid number, unexpected digit after 0: \".concat(printCharCode(code), \".\"));\n          }\n        } else {\n          position = readDigits(source, position, code);\n          code = body.charCodeAt(position);\n        }\n\n        if (46 === code) {\n          isFloat = !0;\n          code = body.charCodeAt(++position);\n          position = readDigits(source, position, code);\n          code = body.charCodeAt(position);\n        }\n\n        if (69 === code || 101 === code) {\n          isFloat = !0;\n\n          if (43 === (code = body.charCodeAt(++position)) || 45 === code) {\n            code = body.charCodeAt(++position);\n          }\n\n          position = readDigits(source, position, code);\n          code = body.charCodeAt(position);\n        }\n\n        if (46 === code || 69 === code || 101 === code) {\n          throw syntaxError(source, position, \"Invalid number, expected digit but got: \".concat(printCharCode(code), \".\"));\n        }\n\n        return new Tok(isFloat ? TokenKind.FLOAT : TokenKind.INT, start, position, line, col, prev, body.slice(start, position));\n      }(source, pos, code, line, col, prev);\n\n    case 34:\n      if (34 === body.charCodeAt(pos + 1) && 34 === body.charCodeAt(pos + 2)) {\n        return function readBlockString(source, start, line, col, prev, lexer) {\n          var body = source.body;\n          var position = start + 3;\n          var chunkStart = position;\n          var code = 0;\n          var rawValue = \"\";\n\n          while (position < body.length && !isNaN(code = body.charCodeAt(position))) {\n            if (34 === code && 34 === body.charCodeAt(position + 1) && 34 === body.charCodeAt(position + 2)) {\n              rawValue += body.slice(chunkStart, position);\n              return new Tok(TokenKind.BLOCK_STRING, start, position + 3, line, col, prev, dedentBlockStringValue(rawValue));\n            }\n\n            if (code < 32 && 9 !== code && 10 !== code && 13 !== code) {\n              throw syntaxError(source, position, \"Invalid character within String: \".concat(printCharCode(code), \".\"));\n            }\n\n            if (10 === code) {\n              ++position;\n              ++lexer.line;\n              lexer.lineStart = position;\n            } else if (13 === code) {\n              if (10 === body.charCodeAt(position + 1)) {\n                position += 2;\n              } else {\n                ++position;\n              }\n\n              ++lexer.line;\n              lexer.lineStart = position;\n            } else if (92 === code && 34 === body.charCodeAt(position + 1) && 34 === body.charCodeAt(position + 2) && 34 === body.charCodeAt(position + 3)) {\n              rawValue += body.slice(chunkStart, position) + '\"\"\"';\n              chunkStart = position += 4;\n            } else {\n              ++position;\n            }\n          }\n\n          throw syntaxError(source, position, \"Unterminated string.\");\n        }(source, pos, line, col, prev, lexer);\n      }\n\n      return function readString(source, start, line, col, prev) {\n        var body = source.body;\n        var position = start + 1;\n        var chunkStart = position;\n        var code = 0;\n        var value = \"\";\n\n        while (position < body.length && !isNaN(code = body.charCodeAt(position)) && 10 !== code && 13 !== code) {\n          if (34 === code) {\n            value += body.slice(chunkStart, position);\n            return new Tok(TokenKind.STRING, start, position + 1, line, col, prev, value);\n          }\n\n          if (code < 32 && 9 !== code) {\n            throw syntaxError(source, position, \"Invalid character within String: \".concat(printCharCode(code), \".\"));\n          }\n\n          ++position;\n\n          if (92 === code) {\n            value += body.slice(chunkStart, position - 1);\n\n            switch (code = body.charCodeAt(position)) {\n              case 34:\n                value += '\"';\n                break;\n\n              case 47:\n                value += \"/\";\n                break;\n\n              case 92:\n                value += \"\\\\\";\n                break;\n\n              case 98:\n                value += \"\\b\";\n                break;\n\n              case 102:\n                value += \"\\f\";\n                break;\n\n              case 110:\n                value += \"\\n\";\n                break;\n\n              case 114:\n                value += \"\\r\";\n                break;\n\n              case 116:\n                value += \"\\t\";\n                break;\n\n              case 117:\n                var charCode = (a = body.charCodeAt(position + 1), b = body.charCodeAt(position + 2), c = body.charCodeAt(position + 3), d = body.charCodeAt(position + 4), char2hex(a) << 12 | char2hex(b) << 8 | char2hex(c) << 4 | char2hex(d));\n\n                if (charCode < 0) {\n                  var invalidSequence = body.slice(position + 1, position + 5);\n                  throw syntaxError(source, position, \"Invalid character escape sequence: \\\\u\".concat(invalidSequence, \".\"));\n                }\n\n                value += String.fromCharCode(charCode);\n                position += 4;\n                break;\n\n              default:\n                throw syntaxError(source, position, \"Invalid character escape sequence: \\\\\".concat(String.fromCharCode(code), \".\"));\n            }\n\n            ++position;\n            chunkStart = position;\n          }\n        }\n\n        var a, b, c, d;\n        throw syntaxError(source, position, \"Unterminated string.\");\n      }(source, pos, line, col, prev);\n  }\n\n  throw syntaxError(source, pos, function unexpectedCharacterMessage(code) {\n    if (code < 32 && 9 !== code && 10 !== code && 13 !== code) {\n      return \"Cannot contain the invalid character \".concat(printCharCode(code), \".\");\n    }\n\n    if (39 === code) {\n      return \"Unexpected single quote character ('), did you mean to use a double quote (\\\")?\";\n    }\n\n    return \"Cannot parse the unexpected character \".concat(printCharCode(code), \".\");\n  }(code));\n}\n\nfunction readDigits(source, start, firstCode) {\n  var body = source.body;\n  var position = start;\n  var code = firstCode;\n\n  if (code >= 48 && code <= 57) {\n    do {\n      code = body.charCodeAt(++position);\n    } while (code >= 48 && code <= 57);\n\n    return position;\n  }\n\n  throw syntaxError(source, position, \"Invalid number, expected digit but got: \".concat(printCharCode(code), \".\"));\n}\n\nfunction char2hex(a) {\n  return a >= 48 && a <= 57 ? a - 48 : a >= 65 && a <= 70 ? a - 55 : a >= 97 && a <= 102 ? a - 87 : -1;\n}\n\nvar DirectiveLocation = Object.freeze({\n  QUERY: \"QUERY\",\n  MUTATION: \"MUTATION\",\n  SUBSCRIPTION: \"SUBSCRIPTION\",\n  FIELD: \"FIELD\",\n  FRAGMENT_DEFINITION: \"FRAGMENT_DEFINITION\",\n  FRAGMENT_SPREAD: \"FRAGMENT_SPREAD\",\n  INLINE_FRAGMENT: \"INLINE_FRAGMENT\",\n  VARIABLE_DEFINITION: \"VARIABLE_DEFINITION\",\n  SCHEMA: \"SCHEMA\",\n  SCALAR: \"SCALAR\",\n  OBJECT: \"OBJECT\",\n  FIELD_DEFINITION: \"FIELD_DEFINITION\",\n  ARGUMENT_DEFINITION: \"ARGUMENT_DEFINITION\",\n  INTERFACE: \"INTERFACE\",\n  UNION: \"UNION\",\n  ENUM: \"ENUM\",\n  ENUM_VALUE: \"ENUM_VALUE\",\n  INPUT_OBJECT: \"INPUT_OBJECT\",\n  INPUT_FIELD_DEFINITION: \"INPUT_FIELD_DEFINITION\"\n});\n\nvar Parser = function () {\n  function Parser(source, options) {\n    var sourceObj = \"string\" == typeof source ? new Source(source) : source;\n    sourceObj instanceof Source || devAssert(0, \"Must provide Source. Received: \".concat(function inspect(value) {\n      return formatValue(value, []);\n    }(sourceObj)));\n\n    this._lexer = function createLexer(source, options) {\n      var startOfFileToken = new Tok(TokenKind.SOF, 0, 0, 0, 0, null);\n      return {\n        source: source,\n        options: options,\n        lastToken: startOfFileToken,\n        token: startOfFileToken,\n        line: 1,\n        lineStart: 0,\n        advance: advanceLexer,\n        lookahead: lookahead\n      };\n    }(sourceObj);\n\n    this._options = options || {};\n  }\n\n  var _proto = Parser.prototype;\n\n  _proto.parseName = function parseName() {\n    var token = this.expectToken(TokenKind.NAME);\n    return {\n      kind: Kind.NAME,\n      value: token.value,\n      loc: this.loc(token)\n    };\n  };\n\n  _proto.parseDocument = function parseDocument() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.DOCUMENT,\n      definitions: this.many(TokenKind.SOF, this.parseDefinition, TokenKind.EOF),\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseDefinition = function parseDefinition() {\n    if (this.peek(TokenKind.NAME)) {\n      switch (this._lexer.token.value) {\n        case \"query\":\n        case \"mutation\":\n        case \"subscription\":\n          return this.parseOperationDefinition();\n\n        case \"fragment\":\n          return this.parseFragmentDefinition();\n\n        case \"schema\":\n        case \"scalar\":\n        case \"type\":\n        case \"interface\":\n        case \"union\":\n        case \"enum\":\n        case \"input\":\n        case \"directive\":\n          return this.parseTypeSystemDefinition();\n\n        case \"extend\":\n          return this.parseTypeSystemExtension();\n      }\n    } else if (this.peek(TokenKind.BRACE_L)) {\n      return this.parseOperationDefinition();\n    } else if (this.peekDescription()) {\n      return this.parseTypeSystemDefinition();\n    }\n\n    throw this.unexpected();\n  };\n\n  _proto.parseOperationDefinition = function parseOperationDefinition() {\n    var start = this._lexer.token;\n\n    if (this.peek(TokenKind.BRACE_L)) {\n      return {\n        kind: Kind.OPERATION_DEFINITION,\n        operation: \"query\",\n        name: void 0,\n        variableDefinitions: [],\n        directives: [],\n        selectionSet: this.parseSelectionSet(),\n        loc: this.loc(start)\n      };\n    }\n\n    var operation = this.parseOperationType();\n    var name;\n\n    if (this.peek(TokenKind.NAME)) {\n      name = this.parseName();\n    }\n\n    return {\n      kind: Kind.OPERATION_DEFINITION,\n      operation: operation,\n      name: name,\n      variableDefinitions: this.parseVariableDefinitions(),\n      directives: this.parseDirectives(!1),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseOperationType = function parseOperationType() {\n    var operationToken = this.expectToken(TokenKind.NAME);\n\n    switch (operationToken.value) {\n      case \"query\":\n        return \"query\";\n\n      case \"mutation\":\n        return \"mutation\";\n\n      case \"subscription\":\n        return \"subscription\";\n    }\n\n    throw this.unexpected(operationToken);\n  };\n\n  _proto.parseVariableDefinitions = function parseVariableDefinitions() {\n    return this.optionalMany(TokenKind.PAREN_L, this.parseVariableDefinition, TokenKind.PAREN_R);\n  };\n\n  _proto.parseVariableDefinition = function parseVariableDefinition() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.VARIABLE_DEFINITION,\n      variable: this.parseVariable(),\n      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),\n      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseValueLiteral(!0) : void 0,\n      directives: this.parseDirectives(!0),\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseVariable = function parseVariable() {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.DOLLAR);\n    return {\n      kind: Kind.VARIABLE,\n      name: this.parseName(),\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseSelectionSet = function parseSelectionSet() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.SELECTION_SET,\n      selections: this.many(TokenKind.BRACE_L, this.parseSelection, TokenKind.BRACE_R),\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseSelection = function parseSelection() {\n    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();\n  };\n\n  _proto.parseField = function parseField() {\n    var start = this._lexer.token;\n    var nameOrAlias = this.parseName();\n    var alias;\n    var name;\n\n    if (this.expectOptionalToken(TokenKind.COLON)) {\n      alias = nameOrAlias;\n      name = this.parseName();\n    } else {\n      name = nameOrAlias;\n    }\n\n    return {\n      kind: Kind.FIELD,\n      alias: alias,\n      name: name,\n      arguments: this.parseArguments(!1),\n      directives: this.parseDirectives(!1),\n      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0,\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseArguments = function parseArguments(isConst) {\n    return this.optionalMany(TokenKind.PAREN_L, isConst ? this.parseConstArgument : this.parseArgument, TokenKind.PAREN_R);\n  };\n\n  _proto.parseArgument = function parseArgument() {\n    var start = this._lexer.token;\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return {\n      kind: Kind.ARGUMENT,\n      name: name,\n      value: this.parseValueLiteral(!1),\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseConstArgument = function parseConstArgument() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.ARGUMENT,\n      name: this.parseName(),\n      value: (this.expectToken(TokenKind.COLON), this.parseValueLiteral(!0)),\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseFragment = function parseFragment() {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.SPREAD);\n    var hasTypeCondition = this.expectOptionalKeyword(\"on\");\n\n    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {\n      return {\n        kind: Kind.FRAGMENT_SPREAD,\n        name: this.parseFragmentName(),\n        directives: this.parseDirectives(!1),\n        loc: this.loc(start)\n      };\n    }\n\n    return {\n      kind: Kind.INLINE_FRAGMENT,\n      typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,\n      directives: this.parseDirectives(!1),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseFragmentDefinition = function parseFragmentDefinition() {\n    var start = this._lexer.token;\n    this.expectKeyword(\"fragment\");\n\n    if (this._options.experimentalFragmentVariables) {\n      return {\n        kind: Kind.FRAGMENT_DEFINITION,\n        name: this.parseFragmentName(),\n        variableDefinitions: this.parseVariableDefinitions(),\n        typeCondition: (this.expectKeyword(\"on\"), this.parseNamedType()),\n        directives: this.parseDirectives(!1),\n        selectionSet: this.parseSelectionSet(),\n        loc: this.loc(start)\n      };\n    }\n\n    return {\n      kind: Kind.FRAGMENT_DEFINITION,\n      name: this.parseFragmentName(),\n      typeCondition: (this.expectKeyword(\"on\"), this.parseNamedType()),\n      directives: this.parseDirectives(!1),\n      selectionSet: this.parseSelectionSet(),\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseFragmentName = function parseFragmentName() {\n    if (\"on\" === this._lexer.token.value) {\n      throw this.unexpected();\n    }\n\n    return this.parseName();\n  };\n\n  _proto.parseValueLiteral = function parseValueLiteral(isConst) {\n    var token = this._lexer.token;\n\n    switch (token.kind) {\n      case TokenKind.BRACKET_L:\n        return this.parseList(isConst);\n\n      case TokenKind.BRACE_L:\n        return this.parseObject(isConst);\n\n      case TokenKind.INT:\n        this._lexer.advance();\n\n        return {\n          kind: Kind.INT,\n          value: token.value,\n          loc: this.loc(token)\n        };\n\n      case TokenKind.FLOAT:\n        this._lexer.advance();\n\n        return {\n          kind: Kind.FLOAT,\n          value: token.value,\n          loc: this.loc(token)\n        };\n\n      case TokenKind.STRING:\n      case TokenKind.BLOCK_STRING:\n        return this.parseStringLiteral();\n\n      case TokenKind.NAME:\n        if (\"true\" === token.value || \"false\" === token.value) {\n          this._lexer.advance();\n\n          return {\n            kind: Kind.BOOLEAN,\n            value: \"true\" === token.value,\n            loc: this.loc(token)\n          };\n        } else if (\"null\" === token.value) {\n          this._lexer.advance();\n\n          return {\n            kind: Kind.NULL,\n            loc: this.loc(token)\n          };\n        }\n\n        this._lexer.advance();\n\n        return {\n          kind: Kind.ENUM,\n          value: token.value,\n          loc: this.loc(token)\n        };\n\n      case TokenKind.DOLLAR:\n        if (!isConst) {\n          return this.parseVariable();\n        }\n\n    }\n\n    throw this.unexpected();\n  };\n\n  _proto.parseStringLiteral = function parseStringLiteral() {\n    var token = this._lexer.token;\n\n    this._lexer.advance();\n\n    return {\n      kind: Kind.STRING,\n      value: token.value,\n      block: token.kind === TokenKind.BLOCK_STRING,\n      loc: this.loc(token)\n    };\n  };\n\n  _proto.parseList = function parseList(isConst) {\n    var _this = this;\n\n    var start = this._lexer.token;\n    return {\n      kind: Kind.LIST,\n      values: this.any(TokenKind.BRACKET_L, function item() {\n        return _this.parseValueLiteral(isConst);\n      }, TokenKind.BRACKET_R),\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseObject = function parseObject(isConst) {\n    var _this2 = this;\n\n    var start = this._lexer.token;\n    return {\n      kind: Kind.OBJECT,\n      fields: this.any(TokenKind.BRACE_L, function item() {\n        return _this2.parseObjectField(isConst);\n      }, TokenKind.BRACE_R),\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseObjectField = function parseObjectField(isConst) {\n    var start = this._lexer.token;\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    return {\n      kind: Kind.OBJECT_FIELD,\n      name: name,\n      value: this.parseValueLiteral(isConst),\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseDirectives = function parseDirectives(isConst) {\n    var directives = [];\n\n    while (this.peek(TokenKind.AT)) {\n      directives.push(this.parseDirective(isConst));\n    }\n\n    return directives;\n  };\n\n  _proto.parseDirective = function parseDirective(isConst) {\n    var start = this._lexer.token;\n    this.expectToken(TokenKind.AT);\n    return {\n      kind: Kind.DIRECTIVE,\n      name: this.parseName(),\n      arguments: this.parseArguments(isConst),\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseTypeReference = function parseTypeReference() {\n    var start = this._lexer.token;\n    var type;\n\n    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {\n      type = this.parseTypeReference();\n      this.expectToken(TokenKind.BRACKET_R);\n      type = {\n        kind: Kind.LIST_TYPE,\n        type: type,\n        loc: this.loc(start)\n      };\n    } else {\n      type = this.parseNamedType();\n    }\n\n    if (this.expectOptionalToken(TokenKind.BANG)) {\n      return {\n        kind: Kind.NON_NULL_TYPE,\n        type: type,\n        loc: this.loc(start)\n      };\n    }\n\n    return type;\n  };\n\n  _proto.parseNamedType = function parseNamedType() {\n    var start = this._lexer.token;\n    return {\n      kind: Kind.NAMED_TYPE,\n      name: this.parseName(),\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseTypeSystemDefinition = function parseTypeSystemDefinition() {\n    var keywordToken = this.peekDescription() ? this._lexer.lookahead() : this._lexer.token;\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case \"schema\":\n          return this.parseSchemaDefinition();\n\n        case \"scalar\":\n          return this.parseScalarTypeDefinition();\n\n        case \"type\":\n          return this.parseObjectTypeDefinition();\n\n        case \"interface\":\n          return this.parseInterfaceTypeDefinition();\n\n        case \"union\":\n          return this.parseUnionTypeDefinition();\n\n        case \"enum\":\n          return this.parseEnumTypeDefinition();\n\n        case \"input\":\n          return this.parseInputObjectTypeDefinition();\n\n        case \"directive\":\n          return this.parseDirectiveDefinition();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  };\n\n  _proto.peekDescription = function peekDescription() {\n    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);\n  };\n\n  _proto.parseDescription = function parseDescription() {\n    if (this.peekDescription()) {\n      return this.parseStringLiteral();\n    }\n  };\n\n  _proto.parseSchemaDefinition = function parseSchemaDefinition() {\n    var start = this._lexer.token;\n    this.expectKeyword(\"schema\");\n    var directives = this.parseDirectives(!0);\n    var operationTypes = this.many(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\n    return {\n      kind: Kind.SCHEMA_DEFINITION,\n      directives: directives,\n      operationTypes: operationTypes,\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseOperationTypeDefinition = function parseOperationTypeDefinition() {\n    var start = this._lexer.token;\n    var operation = this.parseOperationType();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseNamedType();\n    return {\n      kind: Kind.OPERATION_TYPE_DEFINITION,\n      operation: operation,\n      type: type,\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseScalarTypeDefinition = function parseScalarTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword(\"scalar\");\n    var name = this.parseName();\n    var directives = this.parseDirectives(!0);\n    return {\n      kind: Kind.SCALAR_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseObjectTypeDefinition = function parseObjectTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword(\"type\");\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(!0);\n    var fields = this.parseFieldsDefinition();\n    return {\n      kind: Kind.OBJECT_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseImplementsInterfaces = function parseImplementsInterfaces() {\n    var types = [];\n\n    if (this.expectOptionalKeyword(\"implements\")) {\n      this.expectOptionalToken(TokenKind.AMP);\n\n      do {\n        types.push(this.parseNamedType());\n      } while (this.expectOptionalToken(TokenKind.AMP) || this._options.allowLegacySDLImplementsInterfaces && this.peek(TokenKind.NAME));\n    }\n\n    return types;\n  };\n\n  _proto.parseFieldsDefinition = function parseFieldsDefinition() {\n    if (this._options.allowLegacySDLEmptyFields && this.peek(TokenKind.BRACE_L) && this._lexer.lookahead().kind === TokenKind.BRACE_R) {\n      this._lexer.advance();\n\n      this._lexer.advance();\n\n      return [];\n    }\n\n    return this.optionalMany(TokenKind.BRACE_L, this.parseFieldDefinition, TokenKind.BRACE_R);\n  };\n\n  _proto.parseFieldDefinition = function parseFieldDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    var args = this.parseArgumentDefs();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseTypeReference();\n    var directives = this.parseDirectives(!0);\n    return {\n      kind: Kind.FIELD_DEFINITION,\n      description: description,\n      name: name,\n      arguments: args,\n      type: type,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseArgumentDefs = function parseArgumentDefs() {\n    return this.optionalMany(TokenKind.PAREN_L, this.parseInputValueDef, TokenKind.PAREN_R);\n  };\n\n  _proto.parseInputValueDef = function parseInputValueDef() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    this.expectToken(TokenKind.COLON);\n    var type = this.parseTypeReference();\n    var defaultValue;\n\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\n      defaultValue = this.parseValueLiteral(!0);\n    }\n\n    var directives = this.parseDirectives(!0);\n    return {\n      kind: Kind.INPUT_VALUE_DEFINITION,\n      description: description,\n      name: name,\n      type: type,\n      defaultValue: defaultValue,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseInterfaceTypeDefinition = function parseInterfaceTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword(\"interface\");\n    var name = this.parseName();\n    var directives = this.parseDirectives(!0);\n    var fields = this.parseFieldsDefinition();\n    return {\n      kind: Kind.INTERFACE_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseUnionTypeDefinition = function parseUnionTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword(\"union\");\n    var name = this.parseName();\n    var directives = this.parseDirectives(!0);\n    var types = this.parseUnionMemberTypes();\n    return {\n      kind: Kind.UNION_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      types: types,\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseUnionMemberTypes = function parseUnionMemberTypes() {\n    var types = [];\n\n    if (this.expectOptionalToken(TokenKind.EQUALS)) {\n      this.expectOptionalToken(TokenKind.PIPE);\n\n      do {\n        types.push(this.parseNamedType());\n      } while (this.expectOptionalToken(TokenKind.PIPE));\n    }\n\n    return types;\n  };\n\n  _proto.parseEnumTypeDefinition = function parseEnumTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword(\"enum\");\n    var name = this.parseName();\n    var directives = this.parseDirectives(!0);\n    var values = this.parseEnumValuesDefinition();\n    return {\n      kind: Kind.ENUM_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      values: values,\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseEnumValuesDefinition = function parseEnumValuesDefinition() {\n    return this.optionalMany(TokenKind.BRACE_L, this.parseEnumValueDefinition, TokenKind.BRACE_R);\n  };\n\n  _proto.parseEnumValueDefinition = function parseEnumValueDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    var name = this.parseName();\n    var directives = this.parseDirectives(!0);\n    return {\n      kind: Kind.ENUM_VALUE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseInputObjectTypeDefinition = function parseInputObjectTypeDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword(\"input\");\n    var name = this.parseName();\n    var directives = this.parseDirectives(!0);\n    var fields = this.parseInputFieldsDefinition();\n    return {\n      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,\n      description: description,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseInputFieldsDefinition = function parseInputFieldsDefinition() {\n    return this.optionalMany(TokenKind.BRACE_L, this.parseInputValueDef, TokenKind.BRACE_R);\n  };\n\n  _proto.parseTypeSystemExtension = function parseTypeSystemExtension() {\n    var keywordToken = this._lexer.lookahead();\n\n    if (keywordToken.kind === TokenKind.NAME) {\n      switch (keywordToken.value) {\n        case \"schema\":\n          return this.parseSchemaExtension();\n\n        case \"scalar\":\n          return this.parseScalarTypeExtension();\n\n        case \"type\":\n          return this.parseObjectTypeExtension();\n\n        case \"interface\":\n          return this.parseInterfaceTypeExtension();\n\n        case \"union\":\n          return this.parseUnionTypeExtension();\n\n        case \"enum\":\n          return this.parseEnumTypeExtension();\n\n        case \"input\":\n          return this.parseInputObjectTypeExtension();\n      }\n    }\n\n    throw this.unexpected(keywordToken);\n  };\n\n  _proto.parseSchemaExtension = function parseSchemaExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword(\"extend\");\n    this.expectKeyword(\"schema\");\n    var directives = this.parseDirectives(!0);\n    var operationTypes = this.optionalMany(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);\n\n    if (0 === directives.length && 0 === operationTypes.length) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.SCHEMA_EXTENSION,\n      directives: directives,\n      operationTypes: operationTypes,\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseScalarTypeExtension = function parseScalarTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword(\"extend\");\n    this.expectKeyword(\"scalar\");\n    var name = this.parseName();\n    var directives = this.parseDirectives(!0);\n\n    if (0 === directives.length) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.SCALAR_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseObjectTypeExtension = function parseObjectTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword(\"extend\");\n    this.expectKeyword(\"type\");\n    var name = this.parseName();\n    var interfaces = this.parseImplementsInterfaces();\n    var directives = this.parseDirectives(!0);\n    var fields = this.parseFieldsDefinition();\n\n    if (0 === interfaces.length && 0 === directives.length && 0 === fields.length) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.OBJECT_TYPE_EXTENSION,\n      name: name,\n      interfaces: interfaces,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseInterfaceTypeExtension = function parseInterfaceTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword(\"extend\");\n    this.expectKeyword(\"interface\");\n    var name = this.parseName();\n    var directives = this.parseDirectives(!0);\n    var fields = this.parseFieldsDefinition();\n\n    if (0 === directives.length && 0 === fields.length) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.INTERFACE_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseUnionTypeExtension = function parseUnionTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword(\"extend\");\n    this.expectKeyword(\"union\");\n    var name = this.parseName();\n    var directives = this.parseDirectives(!0);\n    var types = this.parseUnionMemberTypes();\n\n    if (0 === directives.length && 0 === types.length) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.UNION_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      types: types,\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseEnumTypeExtension = function parseEnumTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword(\"extend\");\n    this.expectKeyword(\"enum\");\n    var name = this.parseName();\n    var directives = this.parseDirectives(!0);\n    var values = this.parseEnumValuesDefinition();\n\n    if (0 === directives.length && 0 === values.length) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.ENUM_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      values: values,\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseInputObjectTypeExtension = function parseInputObjectTypeExtension() {\n    var start = this._lexer.token;\n    this.expectKeyword(\"extend\");\n    this.expectKeyword(\"input\");\n    var name = this.parseName();\n    var directives = this.parseDirectives(!0);\n    var fields = this.parseInputFieldsDefinition();\n\n    if (0 === directives.length && 0 === fields.length) {\n      throw this.unexpected();\n    }\n\n    return {\n      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n      name: name,\n      directives: directives,\n      fields: fields,\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseDirectiveDefinition = function parseDirectiveDefinition() {\n    var start = this._lexer.token;\n    var description = this.parseDescription();\n    this.expectKeyword(\"directive\");\n    this.expectToken(TokenKind.AT);\n    var name = this.parseName();\n    var args = this.parseArgumentDefs();\n    var repeatable = this.expectOptionalKeyword(\"repeatable\");\n    this.expectKeyword(\"on\");\n    var locations = this.parseDirectiveLocations();\n    return {\n      kind: Kind.DIRECTIVE_DEFINITION,\n      description: description,\n      name: name,\n      arguments: args,\n      repeatable: repeatable,\n      locations: locations,\n      loc: this.loc(start)\n    };\n  };\n\n  _proto.parseDirectiveLocations = function parseDirectiveLocations() {\n    this.expectOptionalToken(TokenKind.PIPE);\n    var locations = [];\n\n    do {\n      locations.push(this.parseDirectiveLocation());\n    } while (this.expectOptionalToken(TokenKind.PIPE));\n\n    return locations;\n  };\n\n  _proto.parseDirectiveLocation = function parseDirectiveLocation() {\n    var start = this._lexer.token;\n    var name = this.parseName();\n\n    if (void 0 !== DirectiveLocation[name.value]) {\n      return name;\n    }\n\n    throw this.unexpected(start);\n  };\n\n  _proto.loc = function loc(startToken) {\n    if (!this._options.noLocation) {\n      return new Loc(startToken, this._lexer.lastToken, this._lexer.source);\n    }\n  };\n\n  _proto.peek = function peek(kind) {\n    return this._lexer.token.kind === kind;\n  };\n\n  _proto.expectToken = function expectToken(kind) {\n    var token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return token;\n    }\n\n    throw syntaxError(this._lexer.source, token.start, \"Expected \".concat(kind, \", found \").concat(getTokenDesc(token)));\n  };\n\n  _proto.expectOptionalToken = function expectOptionalToken(kind) {\n    var token = this._lexer.token;\n\n    if (token.kind === kind) {\n      this._lexer.advance();\n\n      return token;\n    }\n\n    return;\n  };\n\n  _proto.expectKeyword = function expectKeyword(value) {\n    var token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n    } else {\n      throw syntaxError(this._lexer.source, token.start, 'Expected \"'.concat(value, '\", found ').concat(getTokenDesc(token)));\n    }\n  };\n\n  _proto.expectOptionalKeyword = function expectOptionalKeyword(value) {\n    var token = this._lexer.token;\n\n    if (token.kind === TokenKind.NAME && token.value === value) {\n      this._lexer.advance();\n\n      return !0;\n    }\n\n    return !1;\n  };\n\n  _proto.unexpected = function unexpected(atToken) {\n    var token = atToken || this._lexer.token;\n    return syntaxError(this._lexer.source, token.start, \"Unexpected \".concat(getTokenDesc(token)));\n  };\n\n  _proto.any = function any(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    var nodes = [];\n\n    while (!this.expectOptionalToken(closeKind)) {\n      nodes.push(parseFn.call(this));\n    }\n\n    return nodes;\n  };\n\n  _proto.optionalMany = function optionalMany(openKind, parseFn, closeKind) {\n    if (this.expectOptionalToken(openKind)) {\n      var nodes = [];\n\n      do {\n        nodes.push(parseFn.call(this));\n      } while (!this.expectOptionalToken(closeKind));\n\n      return nodes;\n    }\n\n    return [];\n  };\n\n  _proto.many = function many(openKind, parseFn, closeKind) {\n    this.expectToken(openKind);\n    var nodes = [];\n\n    do {\n      nodes.push(parseFn.call(this));\n    } while (!this.expectOptionalToken(closeKind));\n\n    return nodes;\n  };\n\n  return Parser;\n}();\n\nfunction Loc(startToken, endToken, source) {\n  this.start = startToken.start;\n  this.end = endToken.end;\n  this.startToken = startToken;\n  this.endToken = endToken;\n  this.source = source;\n}\n\ndefineToJSON(Loc, function () {\n  return {\n    start: this.start,\n    end: this.end\n  };\n});\n\nfunction getTokenDesc(token) {\n  var value = token.value;\n  return value ? \"\".concat(token.kind, ' \"').concat(value, '\"') : token.kind;\n}\n\nfunction _ref2(o) {\n  return Boolean(o.context.meta && \"Devtools\" === o.context.meta.source);\n}\n\nvar devtoolsExchange = function (ref) {\n  var client = ref.client;\n  var forward = ref.forward;\n\n  if (\"undefined\" == typeof window) {\n    return function _ref(ops$) {\n      return pipe(ops$, forward);\n    };\n  }\n\n  window.__urql__ = {\n    url: client.url\n  };\n  window.addEventListener(\"urql-devtools-exchange-in\", function (event) {\n    var e = event;\n    var handler = messageHandlers[e.detail.type];\n    handler && handler(client)(e.detail);\n  });\n  sendToContentScript({\n    type: \"init\"\n  });\n  return function (ops$) {\n    var sharedOps$ = pipe(ops$, map(addOperationContext), share);\n    var isDevtoolsOp = _ref2;\n    var appOps$ = pipe(sharedOps$, filter(function (o) {\n      return !isDevtoolsOp(o);\n    }), tap(handleOperation), forward, map(addOperationResponseContext), tap(handleOperation));\n    var devtoolsOps$ = pipe(sharedOps$, filter(function (o) {\n      return isDevtoolsOp(o);\n    }), forward);\n    return merge([appOps$, devtoolsOps$]);\n  };\n};\n\nvar addOperationResponseContext = function (op) {\n  return _extends(_extends({}, op), {\n    operation: _extends(_extends({}, op.operation), {\n      context: _extends(_extends({}, op.operation.context), {\n        meta: _extends(_extends({}, op.operation.context.meta), {\n          networkLatency: Date.now() - op.operation.context.meta.startTime\n        })\n      })\n    })\n  });\n};\n\nvar addOperationContext = function (op) {\n  return _extends(_extends({}, op), {\n    context: _extends(_extends({}, op.context), {\n      meta: _extends(_extends({}, op.context.meta), {\n        source: op.context.meta && op.context.meta.source || getDisplayName(),\n        startTime: Date.now()\n      })\n    })\n  });\n};\n\nvar handleOperation = function (op) {\n  var event = JSON.parse(JSON.stringify(parseStreamData(op)));\n  sendToContentScript(event);\n};\n\nvar messageHandlers = {\n  request: function (client) {\n    return function (message) {\n      var isMutation = /(^|\\W)+mutation\\W/.test(message.query);\n      var op = client.createRequestOperation(isMutation ? \"mutation\" : \"query\", {\n        key: (x = JSON.stringify(message.query), function (h, x) {\n          h |= 0;\n\n          for (var i = 0, l = 0 | x.length; i < l; i++) {\n            h = (h << 5) + h + x.charCodeAt(i);\n          }\n\n          return h;\n        }(5381, x) >>> 0),\n        query: (source = message.query, new Parser(source, options).parseDocument())\n      }, {\n        meta: {\n          source: \"Devtools\"\n        }\n      });\n      var source, options;\n      var x;\n      handleOperation(op);\n      pipe(client.executeRequestOperation(op), tap(handleOperation), take(1), toPromise);\n    };\n  }\n};\n\nvar parseStreamData = function (op) {\n  var timestamp = Date.now();\n\n  if (\"operationName\" in op) {\n    return {\n      type: \"operation\",\n      data: op,\n      timestamp: timestamp\n    };\n  }\n\n  if (void 0 !== op.error) {\n    return {\n      type: \"error\",\n      data: op,\n      timestamp: timestamp\n    };\n  }\n\n  return {\n    type: \"response\",\n    data: op,\n    timestamp: timestamp\n  };\n};\n\nvar sendToContentScript = function (detail) {\n  return window.dispatchEvent(new CustomEvent(\"urql-devtools-exchange\", {\n    detail: detail\n  }));\n};\n\nexport { DevtoolsExchangeIncomingEventType, DevtoolsExchangeOutgoingEventType, devtoolsExchange };","map":null,"metadata":{},"sourceType":"module"}