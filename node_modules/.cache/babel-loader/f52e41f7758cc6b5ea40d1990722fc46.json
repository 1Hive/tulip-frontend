{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _slicedToArray = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _asyncIterator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar cache = require('hashlru');\n\nvar varint = require('varint');\n\nvar PeerId = require('peer-id');\n\nvar _require = require('interface-datastore'),\n    Key = _require.Key;\n\nvar _require2 = require('p-queue'),\n    Queue = _require2.default;\n\nvar _require3 = require('buffer'),\n    Buffer = _require3.Buffer;\n\nvar c = require('./constants');\n\nvar utils = require('./utils');\n/**\n * This class manages known providers.\n * A provider is a peer that we know to have the content for a given CID.\n *\n * Every `cleanupInterval` providers are checked if they\n * are still valid, i.e. younger than the `provideValidity`.\n * If they are not, they are deleted.\n *\n * To ensure the list survives restarts of the daemon,\n * providers are stored in the datastore, but to ensure\n * access is fast there is an LRU cache in front of that.\n */\n\n\nvar Providers = /*#__PURE__*/function () {\n  /**\n   * @param {Object} datastore\n   * @param {PeerId} [self]\n   * @param {number} [cacheSize=256]\n   */\n  function Providers(datastore, self, cacheSize) {\n    _classCallCheck(this, Providers);\n\n    this.datastore = datastore;\n    this._log = utils.logger(self, 'providers');\n    /**\n     * How often invalid records are cleaned. (in seconds)\n     *\n     * @type {number}\n     */\n\n    this.cleanupInterval = c.PROVIDERS_CLEANUP_INTERVAL;\n    /**\n     * How long is a provider valid for. (in seconds)\n     *\n     * @type {number}\n     */\n\n    this.provideValidity = c.PROVIDERS_VALIDITY;\n    /**\n     * LRU cache size\n     *\n     * @type {number}\n     */\n\n    this.lruCacheSize = cacheSize || c.PROVIDERS_LRU_CACHE_SIZE;\n    this.providers = cache(this.lruCacheSize);\n    this.syncQueue = new Queue({\n      concurrency: 1\n    });\n  }\n  /**\n   * Release any resources.\n   *\n   * @returns {void}\n   */\n\n\n  _createClass(Providers, [{\n    key: \"stop\",\n    value: function stop() {\n      if (this._cleaner) {\n        clearInterval(this._cleaner);\n        this._cleaner = null;\n      }\n    }\n    /**\n     * Check all providers if they are still valid, and if not delete them.\n     *\n     * @returns {Promise<void>}\n     * @private\n     */\n\n  }, {\n    key: \"_cleanup\",\n    value: function _cleanup() {\n      var _this = this;\n\n      return this.syncQueue.add( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var start, count, deleteCount, deleted, batch, query, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, entry, _parseProviderKey, cid, peerId, time, now, delta, expired, peers, _iterator3, _step3, _step3$value, _cid, _peers, key, provs, _iterator4, _step4, _peerId;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _this._log('start cleanup');\n\n                start = Date.now();\n                count = 0;\n                deleteCount = 0;\n                deleted = new Map();\n                batch = _this.datastore.batch(); // Get all provider entries from the datastore\n\n                query = _this.datastore.query({\n                  prefix: c.PROVIDERS_KEY_PREFIX\n                });\n                _iteratorNormalCompletion = true;\n                _didIteratorError = false;\n                _context.prev = 9;\n                _iterator = _asyncIterator(query);\n\n              case 11:\n                _context.next = 13;\n                return _iterator.next();\n\n              case 13:\n                _step = _context.sent;\n                _iteratorNormalCompletion = _step.done;\n                _context.next = 17;\n                return _step.value;\n\n              case 17:\n                _value = _context.sent;\n\n                if (_iteratorNormalCompletion) {\n                  _context.next = 24;\n                  break;\n                }\n\n                entry = _value;\n\n                try {\n                  // Add a delete to the batch for each expired entry\n                  _parseProviderKey = parseProviderKey(entry.key), cid = _parseProviderKey.cid, peerId = _parseProviderKey.peerId;\n                  time = readTime(entry.value);\n                  now = Date.now();\n                  delta = now - time;\n                  expired = delta > _this.provideValidity;\n\n                  _this._log('comparing: %d - %d = %d > %d %s', now, time, delta, _this.provideValidity, expired ? '(expired)' : '');\n\n                  if (expired) {\n                    deleteCount++;\n                    batch.delete(entry.key);\n                    peers = deleted.get(cid) || new Set();\n                    peers.add(peerId);\n                    deleted.set(cid, peers);\n                  }\n\n                  count++;\n                } catch (err) {\n                  _this._log.error(err.message);\n                }\n\n              case 21:\n                _iteratorNormalCompletion = true;\n                _context.next = 11;\n                break;\n\n              case 24:\n                _context.next = 30;\n                break;\n\n              case 26:\n                _context.prev = 26;\n                _context.t0 = _context[\"catch\"](9);\n                _didIteratorError = true;\n                _iteratorError = _context.t0;\n\n              case 30:\n                _context.prev = 30;\n                _context.prev = 31;\n\n                if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                  _context.next = 35;\n                  break;\n                }\n\n                _context.next = 35;\n                return _iterator.return();\n\n              case 35:\n                _context.prev = 35;\n\n                if (!_didIteratorError) {\n                  _context.next = 38;\n                  break;\n                }\n\n                throw _iteratorError;\n\n              case 38:\n                return _context.finish(35);\n\n              case 39:\n                return _context.finish(30);\n\n              case 40:\n                _this._log('deleting %d / %d entries', deleteCount, count); // Commit the deletes to the datastore\n\n\n                if (!deleted.size) {\n                  _context.next = 44;\n                  break;\n                }\n\n                _context.next = 44;\n                return batch.commit();\n\n              case 44:\n                // Clear expired entries from the cache\n                _iterator3 = _createForOfIteratorHelper(deleted);\n\n                try {\n                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                    _step3$value = _slicedToArray(_step3.value, 2), _cid = _step3$value[0], _peers = _step3$value[1];\n                    key = makeProviderKey(_cid);\n                    provs = _this.providers.get(key);\n\n                    if (provs) {\n                      _iterator4 = _createForOfIteratorHelper(_peers);\n\n                      try {\n                        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                          _peerId = _step4.value;\n                          provs.delete(_peerId);\n                        }\n                      } catch (err) {\n                        _iterator4.e(err);\n                      } finally {\n                        _iterator4.f();\n                      }\n\n                      if (provs.size === 0) {\n                        _this.providers.remove(key);\n                      } else {\n                        _this.providers.set(key, provs);\n                      }\n                    }\n                  }\n                } catch (err) {\n                  _iterator3.e(err);\n                } finally {\n                  _iterator3.f();\n                }\n\n                _this._log('Cleanup successful (%dms)', Date.now() - start);\n\n              case 47:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[9, 26, 30, 40], [31,, 35, 39]]);\n      })));\n    }\n    /**\n     * Get the currently known provider peer ids for a given CID.\n     *\n     * @param {CID} cid\n     * @returns {Promise<Map<String, Date>>}\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_getProvidersMap\",\n    value: function () {\n      var _getProvidersMap2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(cid) {\n        var cacheKey, provs;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                cacheKey = makeProviderKey(cid);\n                provs = this.providers.get(cacheKey);\n\n                if (provs) {\n                  _context2.next = 7;\n                  break;\n                }\n\n                _context2.next = 5;\n                return loadProviders(this.datastore, cid);\n\n              case 5:\n                provs = _context2.sent;\n                this.providers.set(cacheKey, provs);\n\n              case 7:\n                return _context2.abrupt(\"return\", provs);\n\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _getProvidersMap(_x) {\n        return _getProvidersMap2.apply(this, arguments);\n      }\n\n      return _getProvidersMap;\n    }()\n  }, {\n    key: \"cleanupInterval\",\n    get: function get() {\n      return this._cleanupInterval;\n    },\n    set: function set(val) {\n      var _this2 = this;\n\n      this._cleanupInterval = val;\n\n      if (this._cleaner) {\n        clearInterval(this._cleaner);\n      }\n\n      this._cleaner = setInterval(function () {\n        return _this2._cleanup();\n      }, this.cleanupInterval);\n    }\n    /**\n     * Add a new provider for the given CID.\n     *\n     * @param {CID} cid\n     * @param {PeerId} provider\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"addProvider\",\n    value: function () {\n      var _addProvider = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(cid, provider) {\n        var _this3 = this;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                return _context4.abrupt(\"return\", this.syncQueue.add( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n                  var provs, now, dsKey;\n                  return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                    while (1) {\n                      switch (_context3.prev = _context3.next) {\n                        case 0:\n                          _this3._log('addProvider %s', cid.toBaseEncodedString());\n\n                          _context3.next = 3;\n                          return _this3._getProvidersMap(cid);\n\n                        case 3:\n                          provs = _context3.sent;\n\n                          _this3._log('loaded %s provs', provs.size);\n\n                          now = Date.now();\n                          provs.set(utils.encodeBase32(provider.id), now);\n                          dsKey = makeProviderKey(cid);\n\n                          _this3.providers.set(dsKey, provs);\n\n                          return _context3.abrupt(\"return\", writeProviderEntry(_this3.datastore, cid, provider, now));\n\n                        case 10:\n                        case \"end\":\n                          return _context3.stop();\n                      }\n                    }\n                  }, _callee3);\n                }))));\n\n              case 1:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function addProvider(_x2, _x3) {\n        return _addProvider.apply(this, arguments);\n      }\n\n      return addProvider;\n    }()\n    /**\n     * Get a list of providers for the given CID.\n     *\n     * @param {CID} cid\n     * @returns {Promise<Array<PeerId>>}\n     */\n\n  }, {\n    key: \"getProviders\",\n    value: function () {\n      var _getProviders = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(cid) {\n        var _this4 = this;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                return _context6.abrupt(\"return\", this.syncQueue.add( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n                  var provs;\n                  return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n                    while (1) {\n                      switch (_context5.prev = _context5.next) {\n                        case 0:\n                          _this4._log('getProviders %s', cid.toBaseEncodedString());\n\n                          _context5.next = 3;\n                          return _this4._getProvidersMap(cid);\n\n                        case 3:\n                          provs = _context5.sent;\n                          return _context5.abrupt(\"return\", _toConsumableArray(provs.keys()).map(function (base32PeerId) {\n                            return new PeerId(utils.decodeBase32(base32PeerId));\n                          }));\n\n                        case 5:\n                        case \"end\":\n                          return _context5.stop();\n                      }\n                    }\n                  }, _callee5);\n                }))));\n\n              case 1:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function getProviders(_x4) {\n        return _getProviders.apply(this, arguments);\n      }\n\n      return getProviders;\n    }()\n  }]);\n\n  return Providers;\n}();\n/**\n * Encode the given key its matching datastore key.\n *\n * @param {CID|string} cid - cid or base32 encoded string\n * @returns {string}\n *\n * @private\n */\n\n\nfunction makeProviderKey(cid) {\n  cid = typeof cid === 'string' ? cid : utils.encodeBase32(cid.buffer);\n  return c.PROVIDERS_KEY_PREFIX + cid;\n}\n/**\n * Write a provider into the given store.\n *\n * @param {Datastore} store\n * @param {CID} cid\n * @param {PeerId} peer\n * @param {number} time\n * @returns {Promise<void>}\n *\n * @private\n */\n\n\nfunction writeProviderEntry(_x5, _x6, _x7, _x8) {\n  return _writeProviderEntry.apply(this, arguments);\n}\n/**\n * Parse the CID and provider peer id from the key\n *\n * @param {DKey} key\n * @returns {Object} object with peer id and cid\n *\n * @private\n */\n\n\nfunction _writeProviderEntry() {\n  _writeProviderEntry = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(store, cid, peer, time) {\n    var dsKey, key, buffer;\n    return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            // eslint-disable-line require-await\n            dsKey = [makeProviderKey(cid), '/', utils.encodeBase32(peer.id)].join('');\n            key = new Key(dsKey);\n            buffer = Buffer.from(varint.encode(time));\n            return _context7.abrupt(\"return\", store.put(key, buffer));\n\n          case 4:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7);\n  }));\n  return _writeProviderEntry.apply(this, arguments);\n}\n\nfunction parseProviderKey(key) {\n  var parts = key.toString().split('/');\n\n  if (parts.length !== 4) {\n    throw new Error('incorrectly formatted provider entry key in datastore: ' + key);\n  }\n\n  return {\n    cid: parts[2],\n    peerId: parts[3]\n  };\n}\n/**\n * Load providers for the given CID from the store.\n *\n * @param {Datastore} store\n * @param {CID} cid\n * @returns {Promise<Map<PeerId, Date>>}\n *\n * @private\n */\n\n\nfunction loadProviders(_x9, _x10) {\n  return _loadProviders.apply(this, arguments);\n}\n\nfunction _loadProviders() {\n  _loadProviders = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(store, cid) {\n    var providers, query, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _value2, entry, _parseProviderKey2, peerId;\n\n    return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            providers = new Map();\n            query = store.query({\n              prefix: makeProviderKey(cid)\n            });\n            _iteratorNormalCompletion2 = true;\n            _didIteratorError2 = false;\n            _context8.prev = 4;\n            _iterator2 = _asyncIterator(query);\n\n          case 6:\n            _context8.next = 8;\n            return _iterator2.next();\n\n          case 8:\n            _step2 = _context8.sent;\n            _iteratorNormalCompletion2 = _step2.done;\n            _context8.next = 12;\n            return _step2.value;\n\n          case 12:\n            _value2 = _context8.sent;\n\n            if (_iteratorNormalCompletion2) {\n              _context8.next = 20;\n              break;\n            }\n\n            entry = _value2;\n            _parseProviderKey2 = parseProviderKey(entry.key), peerId = _parseProviderKey2.peerId;\n            providers.set(peerId, readTime(entry.value));\n\n          case 17:\n            _iteratorNormalCompletion2 = true;\n            _context8.next = 6;\n            break;\n\n          case 20:\n            _context8.next = 26;\n            break;\n\n          case 22:\n            _context8.prev = 22;\n            _context8.t0 = _context8[\"catch\"](4);\n            _didIteratorError2 = true;\n            _iteratorError2 = _context8.t0;\n\n          case 26:\n            _context8.prev = 26;\n            _context8.prev = 27;\n\n            if (!(!_iteratorNormalCompletion2 && _iterator2.return != null)) {\n              _context8.next = 31;\n              break;\n            }\n\n            _context8.next = 31;\n            return _iterator2.return();\n\n          case 31:\n            _context8.prev = 31;\n\n            if (!_didIteratorError2) {\n              _context8.next = 34;\n              break;\n            }\n\n            throw _iteratorError2;\n\n          case 34:\n            return _context8.finish(31);\n\n          case 35:\n            return _context8.finish(26);\n\n          case 36:\n            return _context8.abrupt(\"return\", providers);\n\n          case 37:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _callee8, null, [[4, 22, 26, 36], [27,, 31, 35]]);\n  }));\n  return _loadProviders.apply(this, arguments);\n}\n\nfunction readTime(buf) {\n  return varint.decode(buf);\n}\n\nmodule.exports = Providers;","map":null,"metadata":{},"sourceType":"script"}