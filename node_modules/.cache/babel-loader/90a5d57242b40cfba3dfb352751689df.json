{"ast":null,"code":"'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst errCode = require('err-code');\n\nconst CID = require('cids');\n\nconst resolve = require('./resolvers');\n\nconst last = require('it-last');\n\nconst toPathComponents = (path = '') => {\n  // split on / unless escaped with \\\n  return (path.trim().match(/([^\\\\^/]|\\\\\\/)+/g) || []).filter(Boolean);\n};\n\nconst cidAndRest = path => {\n  if (Buffer.isBuffer(path)) {\n    return {\n      cid: new CID(path),\n      toResolve: []\n    };\n  }\n\n  if (CID.isCID(path)) {\n    return {\n      cid: path,\n      toResolve: []\n    };\n  }\n\n  if (typeof path === 'string') {\n    if (path.indexOf('/ipfs/') === 0) {\n      path = path.substring(6);\n    }\n\n    const output = toPathComponents(path);\n    return {\n      cid: new CID(output[0]),\n      toResolve: output.slice(1)\n    };\n  }\n\n  throw errCode(new Error(`Unknown path type ${path}`), 'ERR_BAD_PATH');\n};\n\nconst walkPath = async function* (path, ipld, options) {\n  let {\n    cid,\n    toResolve\n  } = cidAndRest(path);\n  let name = cid.toBaseEncodedString();\n  let entryPath = name;\n  const startingDepth = toResolve.length;\n\n  while (true) {\n    const result = await resolve(cid, name, entryPath, toResolve, startingDepth, ipld, options);\n\n    if (!result.entry && !result.next) {\n      throw errCode(new Error(`Could not resolve ${path}`), 'ERR_NOT_FOUND');\n    }\n\n    if (result.entry) {\n      yield result.entry;\n    }\n\n    if (!result.next) {\n      return;\n    } // resolve further parts\n\n\n    toResolve = result.next.toResolve;\n    cid = result.next.cid;\n    name = result.next.name;\n    entryPath = result.next.path;\n  }\n};\n\nconst exporter = (path, ipld, options) => {\n  return last(walkPath(path, ipld, options));\n};\n\nconst recursive = async function* (path, ipld, options) {\n  const node = await exporter(path, ipld, options);\n  yield node;\n\n  if (node.unixfs && node.unixfs.type.includes('dir')) {\n    for await (const child of recurse(node, options)) {\n      yield child;\n    }\n  }\n\n  async function* recurse(node, options) {\n    for await (const file of node.content(options)) {\n      yield file;\n\n      if (file.unixfs.type.includes('dir')) {\n        for await (const subFile of recurse(file, options)) {\n          yield subFile;\n        }\n      }\n    }\n  }\n};\n\nmodule.exports = exporter;\nmodule.exports.path = walkPath;\nmodule.exports.recursive = recursive;","map":null,"metadata":{},"sourceType":"script"}