{"ast":null,"code":"import { utils as EthersUtils, BigNumber } from 'ethers';\nexport function bigNum(value) {\n  return BigNumber.from(value);\n}\nexport function max(a, b) {\n  return a.gt(b) ? a : b;\n}\nexport function min(a, b) {\n  return a.lt(b) ? a : b;\n}\nexport function formatTokenAmount(amount, isIncoming, decimals = 0, displaySign = false) {\n  return (displaySign ? isIncoming ? '+' : '-' : '') + formatUnits(amount, {\n    digits: decimals\n  });\n}\n/**\r\n * Format a decimal-based number back to a normal number\r\n *\r\n * @param {string} value the number\r\n * @param {number} digits number of decimal places\r\n * @returns {BN} value converted to it's normal representation\r\n */\n\nexport function parseUnits(value, digits) {\n  return EthersUtils.parseUnits(value, digits);\n}\n/**\r\n * Format an amount of units to be displayed.\r\n *\r\n * @param {BigNumber} value Amount of units to format.\r\n * @param {Number} options.digits Amount of digits on the token.\r\n * @param {Boolean} options.commas Use comma-separated groups.\r\n * @param {Boolean} options.replaceZeroBy The string to be returned when value is zero.\r\n * @param {Boolean} options.precision The precision of the resulting number\r\n * @returns {String} value formatted\r\n */\n\nexport function formatUnits(value, {\n  digits = 18,\n  commas = true,\n  replaceZeroBy = '0',\n  precision = 2\n} = {}) {\n  if (value.lt(0) || digits < 0) {\n    return '';\n  }\n\n  let valueBeforeCommas = EthersUtils.formatUnits(value.toString(), digits); // Replace 0 by an empty value\n\n  if (valueBeforeCommas === '0.0') {\n    return replaceZeroBy;\n  } // EthersUtils.formatUnits() adds a decimal even when 0, this removes it.\n\n\n  valueBeforeCommas = valueBeforeCommas.replace(/\\.0$/, '');\n  const roundedValue = round(valueBeforeCommas, precision);\n  return commas ? EthersUtils.commify(roundedValue) : roundedValue;\n}\n/**\r\n * Format an amount of units to be displayed.\r\n *\r\n * @param {String} value Value to round\r\n * @param {Number} precision Rounding precision\r\n * @returns {String} Value rounded to `precision` decimals\r\n */\n\nexport function round(value, precision = 2) {\n  let [whole, decimal] = value.split('.');\n  if (!decimal || decimal.length <= precision) return value; // Round and keep the last `precision` digits\n\n  decimal = Math.round(parseInt((decimal || '0').slice(0, precision + 2)) / 100);\n  return `${whole}${decimal ? `.${decimal}` : ''}`;\n}\nconst wordNumbers = ['one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'];\nexport function numberToWord(number) {\n  return wordNumbers[number];\n}\nconst ordinalNumbers = ['first', 'second', 'third', 'fourth', 'fifth', 'sixth', 'seventh', 'eighth', 'ninth'];\nexport function numberToOrdinal(number) {\n  return ordinalNumbers[number - 1];\n}\nexport function getPercentage(value, totalValue) {\n  if (!totalValue > 0) return 0;\n  return Math.round(value * 100 / totalValue, 2);\n}\nexport function getPercentageBN(value, totalValue) {\n  const valueAsNumber = Number(EthersUtils.formatUnits(value, 18));\n  const totalValueAsNumber = Number(EthersUtils.formatUnits(totalValue, 18));\n  const PERCENT_BN = 100;\n  if (totalValue.lte(0)) return 0;\n  return valueAsNumber * PERCENT_BN / totalValueAsNumber;\n}\nexport function generateRandomNumber() {\n  const code = BigNumber.from(EthersUtils.randomBytes(32));\n  return code.toHexString().slice(2);\n}\n/**\r\n * Normalizes a number from another range into a value between 0 and 1.\r\n *\r\n * Identical to map(value, low, high, 0, 1)\r\n * Numbers outside the range are not clamped to 0 and 1, because out-of-range\r\n * values are often intentional and useful.\r\n *\r\n * From Processing.js\r\n *\r\n * @param {Number} aNumber The incoming value to be converted\r\n * @param {Number} low Lower bound of the value's current range\r\n * @param {Number} high Upper bound of the value's current range\r\n * @returns {Number} Normalized number\r\n */\n\nexport function norm(aNumber, low, high) {\n  return (aNumber - low) / (high - low);\n}\n/**\r\n * Calculates a number between two numbers at a specific increment. The\r\n * progress parameter is the amount to interpolate between the two values where\r\n * 0.0 equal to the first point, 0.1 is very near the first point, 0.5 is\r\n * half-way in between, etc. The lerp function is convenient for creating\r\n * motion along a straight path and for drawing dotted lines.\r\n *\r\n * From Processing.js\r\n *\r\n * @param {Number} progress Between 0.0 and 1.0\r\n * @param {Number} value1 First value\r\n * @param {Number} value2 Second value\r\n * @returns {Number} Increment value\r\n */\n\nexport function lerp(progress, value1, value2) {\n  return (value2 - value1) * progress + value1;\n}","map":{"version":3,"sources":["/Users/fabianmolina/Documents/1hive/tulip-frontend/src/lib/math-utils.js"],"names":["utils","EthersUtils","BigNumber","bigNum","value","from","max","a","b","gt","min","lt","formatTokenAmount","amount","isIncoming","decimals","displaySign","formatUnits","digits","parseUnits","commas","replaceZeroBy","precision","valueBeforeCommas","toString","replace","roundedValue","round","commify","whole","decimal","split","length","Math","parseInt","slice","wordNumbers","numberToWord","number","ordinalNumbers","numberToOrdinal","getPercentage","totalValue","getPercentageBN","valueAsNumber","Number","totalValueAsNumber","PERCENT_BN","lte","generateRandomNumber","code","randomBytes","toHexString","norm","aNumber","low","high","lerp","progress","value1","value2"],"mappings":"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","sourcesContent":["import { utils as EthersUtils, BigNumber } from 'ethers'\r\n\r\nexport function bigNum(value) {\r\n  return BigNumber.from(value)\r\n}\r\n\r\nexport function max(a, b) {\r\n  return a.gt(b) ? a : b\r\n}\r\n\r\nexport function min(a, b) {\r\n  return a.lt(b) ? a : b\r\n}\r\n\r\nexport function formatTokenAmount(\r\n  amount,\r\n  isIncoming,\r\n  decimals = 0,\r\n  displaySign = false\r\n) {\r\n  return (\r\n    (displaySign ? (isIncoming ? '+' : '-') : '') +\r\n    formatUnits(amount, { digits: decimals })\r\n  )\r\n}\r\n\r\n/**\r\n * Format a decimal-based number back to a normal number\r\n *\r\n * @param {string} value the number\r\n * @param {number} digits number of decimal places\r\n * @returns {BN} value converted to it's normal representation\r\n */\r\nexport function parseUnits(value, digits) {\r\n  return EthersUtils.parseUnits(value, digits)\r\n}\r\n\r\n/**\r\n * Format an amount of units to be displayed.\r\n *\r\n * @param {BigNumber} value Amount of units to format.\r\n * @param {Number} options.digits Amount of digits on the token.\r\n * @param {Boolean} options.commas Use comma-separated groups.\r\n * @param {Boolean} options.replaceZeroBy The string to be returned when value is zero.\r\n * @param {Boolean} options.precision The precision of the resulting number\r\n * @returns {String} value formatted\r\n */\r\nexport function formatUnits(\r\n  value,\r\n  { digits = 18, commas = true, replaceZeroBy = '0', precision = 2 } = {}\r\n) {\r\n  if (value.lt(0) || digits < 0) {\r\n    return ''\r\n  }\r\n\r\n  let valueBeforeCommas = EthersUtils.formatUnits(value.toString(), digits)\r\n\r\n  // Replace 0 by an empty value\r\n  if (valueBeforeCommas === '0.0') {\r\n    return replaceZeroBy\r\n  }\r\n\r\n  // EthersUtils.formatUnits() adds a decimal even when 0, this removes it.\r\n  valueBeforeCommas = valueBeforeCommas.replace(/\\.0$/, '')\r\n\r\n  const roundedValue = round(valueBeforeCommas, precision)\r\n\r\n  return commas ? EthersUtils.commify(roundedValue) : roundedValue\r\n}\r\n\r\n/**\r\n * Format an amount of units to be displayed.\r\n *\r\n * @param {String} value Value to round\r\n * @param {Number} precision Rounding precision\r\n * @returns {String} Value rounded to `precision` decimals\r\n */\r\nexport function round(value, precision = 2) {\r\n  let [whole, decimal] = value.split('.')\r\n\r\n  if (!decimal || decimal.length <= precision) return value\r\n\r\n  // Round and keep the last `precision` digits\r\n  decimal = Math.round(parseInt((decimal || '0').slice(0, precision + 2)) / 100)\r\n\r\n  return `${whole}${decimal ? `.${decimal}` : ''}`\r\n}\r\n\r\nconst wordNumbers = [\r\n  'one',\r\n  'two',\r\n  'three',\r\n  'four',\r\n  'five',\r\n  'six',\r\n  'seven',\r\n  'eight',\r\n  'nine',\r\n]\r\n\r\nexport function numberToWord(number) {\r\n  return wordNumbers[number]\r\n}\r\n\r\nconst ordinalNumbers = [\r\n  'first',\r\n  'second',\r\n  'third',\r\n  'fourth',\r\n  'fifth',\r\n  'sixth',\r\n  'seventh',\r\n  'eighth',\r\n  'ninth',\r\n]\r\n\r\nexport function numberToOrdinal(number) {\r\n  return ordinalNumbers[number - 1]\r\n}\r\n\r\nexport function getPercentage(value, totalValue) {\r\n  if (!totalValue > 0) return 0\r\n\r\n  return Math.round((value * 100) / totalValue, 2)\r\n}\r\n\r\nexport function getPercentageBN(value, totalValue) {\r\n  const valueAsNumber = Number(EthersUtils.formatUnits(value, 18))\r\n  const totalValueAsNumber = Number(EthersUtils.formatUnits(totalValue, 18))\r\n\r\n  const PERCENT_BN = 100\r\n\r\n  if (totalValue.lte(0)) return 0\r\n\r\n  return (valueAsNumber * PERCENT_BN) / totalValueAsNumber\r\n}\r\n\r\nexport function generateRandomNumber() {\r\n  const code = BigNumber.from(EthersUtils.randomBytes(32))\r\n  return code.toHexString().slice(2)\r\n}\r\n\r\n/**\r\n * Normalizes a number from another range into a value between 0 and 1.\r\n *\r\n * Identical to map(value, low, high, 0, 1)\r\n * Numbers outside the range are not clamped to 0 and 1, because out-of-range\r\n * values are often intentional and useful.\r\n *\r\n * From Processing.js\r\n *\r\n * @param {Number} aNumber The incoming value to be converted\r\n * @param {Number} low Lower bound of the value's current range\r\n * @param {Number} high Upper bound of the value's current range\r\n * @returns {Number} Normalized number\r\n */\r\nexport function norm(aNumber, low, high) {\r\n  return (aNumber - low) / (high - low)\r\n}\r\n\r\n/**\r\n * Calculates a number between two numbers at a specific increment. The\r\n * progress parameter is the amount to interpolate between the two values where\r\n * 0.0 equal to the first point, 0.1 is very near the first point, 0.5 is\r\n * half-way in between, etc. The lerp function is convenient for creating\r\n * motion along a straight path and for drawing dotted lines.\r\n *\r\n * From Processing.js\r\n *\r\n * @param {Number} progress Between 0.0 and 1.0\r\n * @param {Number} value1 First value\r\n * @param {Number} value2 Second value\r\n * @returns {Number} Increment value\r\n */\r\nexport function lerp(progress, value1, value2) {\r\n  return (value2 - value1) * progress + value1\r\n}\r\n"]},"metadata":{},"sourceType":"module"}