{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar isIPFS = require('is-ipfs');\n\nvar API = require('./api');\n\nvar config = require('./config');\n\nvar _require = require('./3id/utils'),\n    symEncryptBase = _require.symEncryptBase,\n    symDecryptBase = _require.symDecryptBase,\n    newSymKey = _require.newSymKey;\n\nvar utils = require('./utils/index');\n\nvar orbitAddress = require('orbit-db/src/orbit-db-address');\n\nvar ORBITDB_OPTS = config.orbitdb_options;\nvar MODERATOR = 'MODERATOR';\nvar MEMBER = 'MEMBER';\n\nvar isValid3ID = function isValid3ID(did) {\n  var parts = did.split(':');\n  if (!parts[0] === 'did' || !parts[1] === '3') return false;\n  return isIPFS.cid(parts[2]);\n};\n\nvar Thread = /*#__PURE__*/function () {\n  /**\n   * Please use **space.joinThread** to get the instance of this class\n   */\n  function Thread(name, replicator, members, firstModerator, confidential, user, subscribe) {\n    (0, _classCallCheck2[\"default\"])(this, Thread);\n    this._name = name;\n    this._replicator = replicator;\n    this._spaceName = name ? name.split('.')[2] : undefined;\n    this._subscribe = subscribe;\n    this._queuedNewPosts = [];\n    this._members = Boolean(members);\n    this._firstModerator = firstModerator;\n    this._user = user;\n\n    if (confidential) {\n      this._confidential = true;\n      this._members = true;\n\n      if (typeof confidential === 'string') {\n        this._encKeyId = confidential;\n      } else {\n        this._symKey = newSymKey();\n        this._encKeyId = utils.sha256(this._symKey);\n      }\n    }\n  }\n  /**\n   * Post a message to the thread\n   *\n   * @param     {Object}    message                 The message\n   * @return    {String}                            The postId of the new post\n   */\n\n\n  (0, _createClass2[\"default\"])(Thread, [{\n    key: \"post\",\n    value: function () {\n      var _post = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee(message) {\n        var timestamp;\n        return _regenerator[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this._requireLoad();\n\n                this._requireAuth();\n\n                this._subscribe(this._address, {\n                  firstModerator: this._firstModerator,\n                  members: this._members,\n                  name: this._name\n                });\n\n                this._replicator.ensureConnected(this._address, true);\n\n                timestamp = Math.floor(new Date().getTime() / 1000); // seconds\n\n                if (this._confidential) message = this._symEncrypt(message);\n                return _context.abrupt(\"return\", this._db.add({\n                  message: message,\n                  timestamp: timestamp\n                }));\n\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function post(_x) {\n        return _post.apply(this, arguments);\n      }\n\n      return post;\n    }()\n  }, {\n    key: \"_getThreadAddress\",\n    value: function () {\n      var _getThreadAddress2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee2() {\n        var address;\n        return _regenerator[\"default\"].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!this._address) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", this._address);\n\n              case 2:\n                _context2.next = 4;\n                return this._initAcConfigs();\n\n              case 4:\n                _context2.next = 6;\n                return this._replicator._orbitdb._determineAddress(this._name, 'feed', {\n                  accessController: this._accessController\n                }, false);\n\n              case 6:\n                address = _context2.sent.toString();\n                this._address = address;\n                return _context2.abrupt(\"return\", this._address);\n\n              case 9:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _getThreadAddress() {\n        return _getThreadAddress2.apply(this, arguments);\n      }\n\n      return _getThreadAddress;\n    }()\n    /**\n     * Add a moderator to this thread, throws error is user can not add a moderator\n     *\n     * @param     {String}    id                      Moderator Id\n     */\n\n  }, {\n    key: \"addModerator\",\n    value: function () {\n      var _addModerator = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee3(id) {\n        return _regenerator[\"default\"].wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                this._requireLoad();\n\n                this._requireAuth();\n\n                if (!id.startsWith('0x')) {\n                  _context3.next = 6;\n                  break;\n                }\n\n                _context3.next = 5;\n                return API.getSpaceDID(id, this._spaceName);\n\n              case 5:\n                id = _context3.sent;\n\n              case 6:\n                if (isValid3ID(id)) {\n                  _context3.next = 8;\n                  break;\n                }\n\n                throw new Error('addModerator: must provide valid 3ID');\n\n              case 8:\n                _context3.t0 = this._db.access;\n                _context3.t1 = MODERATOR;\n                _context3.t2 = id;\n                _context3.next = 13;\n                return this._encryptSymKey(id);\n\n              case 13:\n                _context3.t3 = _context3.sent;\n                return _context3.abrupt(\"return\", _context3.t0.grant.call(_context3.t0, _context3.t1, _context3.t2, _context3.t3));\n\n              case 15:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function addModerator(_x2) {\n        return _addModerator.apply(this, arguments);\n      }\n\n      return addModerator;\n    }()\n    /**\n     * List moderators\n     *\n     * @return    {Array<String>}      Array of moderator DIDs\n     */\n\n  }, {\n    key: \"listModerators\",\n    value: function () {\n      var _listModerators = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee4() {\n        return _regenerator[\"default\"].wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                this._requireLoad();\n\n                return _context4.abrupt(\"return\", this._db.access.capabilities.moderators);\n\n              case 2:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function listModerators() {\n        return _listModerators.apply(this, arguments);\n      }\n\n      return listModerators;\n    }()\n    /**\n     * Add a member to this thread, throws if user can not add member, throw is not member thread\n     *\n     * @param     {String}    id                      Member Id\n     */\n\n  }, {\n    key: \"addMember\",\n    value: function () {\n      var _addMember = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee5(id) {\n        return _regenerator[\"default\"].wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                this._requireLoad();\n\n                this._requireAuth();\n\n                this._throwIfNotMembers();\n\n                if (!id.startsWith('0x')) {\n                  _context5.next = 7;\n                  break;\n                }\n\n                _context5.next = 6;\n                return API.getSpaceDID(id, this._spaceName);\n\n              case 6:\n                id = _context5.sent;\n\n              case 7:\n                if (isValid3ID(id)) {\n                  _context5.next = 9;\n                  break;\n                }\n\n                throw new Error('addMember: must provide valid 3ID');\n\n              case 9:\n                _context5.t0 = this._db.access;\n                _context5.t1 = MEMBER;\n                _context5.t2 = id;\n                _context5.next = 14;\n                return this._encryptSymKey(id);\n\n              case 14:\n                _context5.t3 = _context5.sent;\n                return _context5.abrupt(\"return\", _context5.t0.grant.call(_context5.t0, _context5.t1, _context5.t2, _context5.t3));\n\n              case 16:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function addMember(_x3) {\n        return _addMember.apply(this, arguments);\n      }\n\n      return addMember;\n    }()\n    /**\n     * List members, throws if not member thread\n     *\n     * @return    {Array<String>}      Array of member DIDs\n     */\n\n  }, {\n    key: \"listMembers\",\n    value: function () {\n      var _listMembers = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee6() {\n        return _regenerator[\"default\"].wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                this._throwIfNotMembers();\n\n                this._requireLoad();\n\n                return _context6.abrupt(\"return\", this._db.access.capabilities.members);\n\n              case 3:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function listMembers() {\n        return _listMembers.apply(this, arguments);\n      }\n\n      return listMembers;\n    }()\n  }, {\n    key: \"_throwIfNotMembers\",\n    value: function _throwIfNotMembers() {\n      if (!this._members) throw new Error('Thread: Not a members only thread, function not available');\n    }\n    /**\n     * Delete post\n     *\n     * @param     {String}    id                      Moderator Id\n     */\n\n  }, {\n    key: \"deletePost\",\n    value: function () {\n      var _deletePost = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee7(hash) {\n        return _regenerator[\"default\"].wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                this._requireLoad();\n\n                this._requireAuth();\n\n                return _context7.abrupt(\"return\", this._db.remove(hash));\n\n              case 3:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function deletePost(_x4) {\n        return _deletePost.apply(this, arguments);\n      }\n\n      return deletePost;\n    }()\n    /**\n     * Returns an array of posts, based on the options.\n     * If hash not found when passing gt, gte, lt, or lte,\n     * the iterator will return all items (respecting limit and reverse).\n     *\n     * @param     {Object}    opts                    Optional parameters\n     * @param     {String}    opts.gt                 Greater than, takes an postId\n     * @param     {String}    opts.gte                Greater than or equal to, takes an postId\n     * @param     {String}    opts.lt                 Less than, takes an postId\n     * @param     {String}    opts.lte                Less than or equal to, takes an postId\n     * @param     {Integer}   opts.limit              Limiting the number of entries in result, defaults to -1 (no limit)\n     * @param     {Boolean}   opts.reverse            If set to true will result in reversing the result\n     *\n     * @return    {Array<Object>}                           true if successful\n     */\n\n  }, {\n    key: \"getPosts\",\n    value: function () {\n      var _getPosts = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee8() {\n        var _this = this;\n\n        var opts,\n            decrypt,\n            _args8 = arguments;\n        return _regenerator[\"default\"].wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                opts = _args8.length > 0 && _args8[0] !== undefined ? _args8[0] : {};\n\n                decrypt = function decrypt(entry) {\n                  if (!_this._confidential) return entry;\n\n                  var message = _this._symDecrypt(entry.message);\n\n                  return {\n                    message: message,\n                    timestamp: entry.timestamp\n                  };\n                };\n\n                this._requireLoad();\n\n                if (!opts.limit) opts.limit = -1;\n                return _context8.abrupt(\"return\", this._db.iterator(opts).collect().map(function (entry) {\n                  var post = decrypt(entry.payload.value);\n                  var metaData = {\n                    postId: entry.hash,\n                    author: entry.identity.id\n                  };\n                  return Object.assign(metaData, post);\n                }));\n\n              case 5:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function getPosts() {\n        return _getPosts.apply(this, arguments);\n      }\n\n      return getPosts;\n    }()\n    /**\n     * Register a function to be called after new updates\n     * have been received from the network or locally.\n     *\n     * @param     {Function}  updateFn               The function that will get called\n     */\n\n  }, {\n    key: \"onUpdate\",\n    value: function () {\n      var _onUpdate = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee9(updateFn) {\n        return _regenerator[\"default\"].wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                this._requireLoad();\n\n                this._db.events.on('replicated', function (address, hash, entry, prog, tot) {\n                  updateFn();\n                });\n\n                this._db.events.on('write', function (dbname, entry) {\n                  updateFn();\n                });\n\n              case 3:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function onUpdate(_x5) {\n        return _onUpdate.apply(this, arguments);\n      }\n\n      return onUpdate;\n    }()\n    /**\n     * Register a function to be called for every new\n     * capability that is added to the thread access controller.\n     * This inlcudes when a moderator or member is added.\n     * The function takes one parameter, which is the capabilities obj, or\n     * you can call listModerator / listMembers again instead.\n     *\n     * @param     {Function}  updateFn     The function that will get called\n     */\n\n  }, {\n    key: \"onNewCapabilities\",\n    value: function () {\n      var _onNewCapabilities = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee10(updateFn) {\n        var _this2 = this;\n\n        return _regenerator[\"default\"].wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                this._db.access.on('updated', function (event) {\n                  updateFn(_this2._db.access.capabilities);\n                });\n\n              case 1:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function onNewCapabilities(_x6) {\n        return _onNewCapabilities.apply(this, arguments);\n      }\n\n      return onNewCapabilities;\n    }() // Loads by orbitdb address or db name\n\n  }, {\n    key: \"_load\",\n    value: function () {\n      var _load2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee11(dbString) {\n        var loadByAddress;\n        return _regenerator[\"default\"].wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                loadByAddress = dbString && orbitAddress.isValid(dbString);\n\n                if (loadByAddress) {\n                  _context11.next = 4;\n                  break;\n                }\n\n                _context11.next = 4;\n                return this._initAcConfigs();\n\n              case 4:\n                _context11.next = 6;\n                return this._replicator._orbitdb.feed(dbString || this._name, _objectSpread(_objectSpread({}, ORBITDB_OPTS), {}, {\n                  accessController: this._accessController\n                }));\n\n              case 6:\n                this._db = _context11.sent;\n                _context11.next = 9;\n                return this._db.load();\n\n              case 9:\n                if (loadByAddress) {\n                  this._firstModerator = this._db.access._firstModerator;\n                  this._members = this._db.access._members;\n                  this._encKeyId = this._db.access._encKeyId;\n                  this._confidential = Boolean(this._db.access._encKeyId);\n                  this._name = this._db.address.path;\n                  this._spaceName = this._name.split('.')[2];\n                }\n\n                this._address = this._db.address.toString();\n\n                this._replicator.ensureConnected(this._address, true);\n\n                return _context11.abrupt(\"return\", this._address);\n\n              case 13:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function _load(_x7) {\n        return _load2.apply(this, arguments);\n      }\n\n      return _load;\n    }()\n  }, {\n    key: \"_initConfidential\",\n    value: function () {\n      var _initConfidential2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee12() {\n        var _this3 = this;\n\n        var encryptedKey;\n        return _regenerator[\"default\"].wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                if (!this._symKey) {\n                  _context12.next = 13;\n                  break;\n                }\n\n                if (!(this._user.DID !== this._firstModerator)) {\n                  _context12.next = 3;\n                  break;\n                }\n\n                throw new Error('_initConfidential: firstModerator must initialize a confidential thread');\n\n              case 3:\n                _context12.t0 = this._db.access;\n                _context12.t1 = MODERATOR;\n                _context12.t2 = this._firstModerator;\n                _context12.next = 8;\n                return this._encryptSymKey();\n\n              case 8:\n                _context12.t3 = _context12.sent;\n                _context12.next = 11;\n                return _context12.t0.grant.call(_context12.t0, _context12.t1, _context12.t2, _context12.t3);\n\n              case 11:\n                _context12.next = 28;\n                break;\n\n              case 13:\n                encryptedKey = null;\n                _context12.prev = 14;\n                encryptedKey = this._db.access.getEncryptedKey(this._user.DID);\n                _context12.next = 23;\n                break;\n\n              case 18:\n                _context12.prev = 18;\n                _context12.t4 = _context12[\"catch\"](14);\n                _context12.next = 22;\n                return new Promise(function (resolve, reject) {\n                  _this3.onNewCapabilities(function (val) {\n                    var key = null;\n\n                    try {\n                      key = _this3._db.access.getEncryptedKey(_this3._user.DID);\n                    } catch (e) {}\n\n                    if (key !== null) resolve(key);\n                  });\n\n                  setTimeout(function () {\n                    return resolve(null);\n                  }, 10000);\n                });\n\n              case 22:\n                encryptedKey = _context12.sent;\n\n              case 23:\n                if (encryptedKey) {\n                  _context12.next = 25;\n                  break;\n                }\n\n                throw new Error(\"_initConfidential:  no access for \".concat(this._user.DID));\n\n              case 25:\n                _context12.next = 27;\n                return this._decryptSymKey(encryptedKey);\n\n              case 27:\n                this._symKey = _context12.sent;\n\n              case 28:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this, [[14, 18]]);\n      }));\n\n      function _initConfidential() {\n        return _initConfidential2.apply(this, arguments);\n      }\n\n      return _initConfidential;\n    }()\n  }, {\n    key: \"_requireLoad\",\n    value: function _requireLoad() {\n      if (!this._db) throw new Error('_load must be called before interacting with the store');\n    }\n  }, {\n    key: \"_requireAuth\",\n    value: function _requireAuth() {\n      if (!this._authenticated) throw new Error('You must authenticate before performing this action');\n    }\n  }, {\n    key: \"close\",\n    value: function () {\n      var _close = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee13() {\n        return _regenerator[\"default\"].wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                this._requireLoad();\n\n                _context13.next = 3;\n                return this._db.close();\n\n              case 3:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function close() {\n        return _close.apply(this, arguments);\n      }\n\n      return close;\n    }()\n  }, {\n    key: \"_setIdentity\",\n    value: function () {\n      var _setIdentity2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee14(odbId) {\n        return _regenerator[\"default\"].wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                this._db.setIdentity(odbId);\n\n                this._db.access._db.setIdentity(odbId);\n\n                this._authenticated = true; // TODO not too clear hear, but does require auth, and to be after load\n\n                if (!this._confidential) {\n                  _context14.next = 6;\n                  break;\n                }\n\n                _context14.next = 6;\n                return this._initConfidential();\n\n              case 6:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function _setIdentity(_x8) {\n        return _setIdentity2.apply(this, arguments);\n      }\n\n      return _setIdentity;\n    }()\n  }, {\n    key: \"_initAcConfigs\",\n    value: function () {\n      var _initAcConfigs2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee15() {\n        return _regenerator[\"default\"].wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                if (!this._accessController) {\n                  _context15.next = 2;\n                  break;\n                }\n\n                return _context15.abrupt(\"return\");\n\n              case 2:\n                if (!this._firstModerator.startsWith('0x')) {\n                  _context15.next = 6;\n                  break;\n                }\n\n                _context15.next = 5;\n                return API.getSpaceDID(this._firstModerator, this._spaceName);\n\n              case 5:\n                this._firstModerator = _context15.sent;\n\n              case 6:\n                this._accessController = {\n                  type: 'thread-access',\n                  threadName: this._name,\n                  members: this._members,\n                  firstModerator: this._firstModerator\n                };\n\n                if (this._encKeyId) {\n                  this._accessController.encKeyId = this._encKeyId;\n                }\n\n              case 8:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      function _initAcConfigs() {\n        return _initAcConfigs2.apply(this, arguments);\n      }\n\n      return _initAcConfigs;\n    }()\n  }, {\n    key: \"_symEncrypt\",\n    value: function _symEncrypt(message) {\n      var msg = utils.pad(JSON.stringify(message));\n      return symEncryptBase(msg, this._symKey);\n    }\n  }, {\n    key: \"_symDecrypt\",\n    value: function _symDecrypt(payload) {\n      var paddedMsg = symDecryptBase(payload.ciphertext, this._symKey, payload.nonce);\n      return JSON.parse(utils.unpad(paddedMsg));\n    }\n  }, {\n    key: \"_encryptSymKey\",\n    value: function () {\n      var _encryptSymKey2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee16(to) {\n        return _regenerator[\"default\"].wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                if (this._confidential) {\n                  _context16.next = 2;\n                  break;\n                }\n\n                return _context16.abrupt(\"return\", null);\n\n              case 2:\n                return _context16.abrupt(\"return\", this._user.encrypt(this._symKey, {\n                  to: to\n                }));\n\n              case 3:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      function _encryptSymKey(_x9) {\n        return _encryptSymKey2.apply(this, arguments);\n      }\n\n      return _encryptSymKey;\n    }()\n  }, {\n    key: \"_decryptSymKey\",\n    value: function () {\n      var _decryptSymKey2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee17(encKey) {\n        var key;\n        return _regenerator[\"default\"].wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                _context17.next = 2;\n                return this._user.decrypt(encKey, true);\n\n              case 2:\n                key = _context17.sent;\n                return _context17.abrupt(\"return\", new Uint8Array(key));\n\n              case 4:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      function _decryptSymKey(_x10) {\n        return _decryptSymKey2.apply(this, arguments);\n      }\n\n      return _decryptSymKey;\n    }()\n  }, {\n    key: \"address\",\n    get: function get() {\n      return this._db ? this._address : null;\n    }\n  }]);\n  return Thread;\n}();\n\nmodule.exports = Thread;","map":null,"metadata":{},"sourceType":"script"}