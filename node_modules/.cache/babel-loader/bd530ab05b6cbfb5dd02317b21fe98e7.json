{"ast":null,"code":"'use strict';\n\nconst diff = require('hyperdiff');\n\nconst EventEmitter = require('events');\n\nconst clone = require('lodash.clonedeep');\n\nconst PROTOCOL = require('./protocol');\n\nconst Connection = require('./connection');\n\nconst encoding = require('./encoding');\n\nconst directConnection = require('./direct-connection-handler');\n\nconst DEFAULT_OPTIONS = {\n  pollInterval: 1000\n};\nlet index = 0;\n\nclass PubSubRoom extends EventEmitter {\n  constructor(libp2p, topic, options) {\n    super();\n    this._libp2p = libp2p.libp2p || libp2p;\n    this._topic = topic;\n    this._options = Object.assign({}, clone(DEFAULT_OPTIONS), clone(options));\n    this._peers = [];\n    this._connections = {};\n    this._handleDirectMessage = this._handleDirectMessage.bind(this);\n    this._handleMessage = this._onMessage.bind(this);\n\n    if (!this._libp2p.pubsub) {\n      throw new Error('pubsub has not been configured');\n    }\n\n    this._interval = setInterval(this._pollPeers.bind(this), this._options.pollInterval);\n\n    this._libp2p.handle(PROTOCOL, directConnection.handler);\n\n    directConnection.emitter.on(this._topic, this._handleDirectMessage);\n\n    this._libp2p.pubsub.subscribe(this._topic, this._handleMessage);\n\n    this._idx = index++;\n  }\n\n  getPeers() {\n    return this._peers.slice(0);\n  }\n\n  hasPeer(peer) {\n    return Boolean(this._peers.find(p => p.toString() === peer.toString()));\n  }\n\n  async leave() {\n    clearInterval(this._interval);\n    Object.keys(this._connections).forEach(peer => {\n      this._connections[peer].stop();\n    });\n    directConnection.emitter.removeListener(this._topic, this._handleDirectMessage);\n\n    this._libp2p.unhandle(PROTOCOL, directConnection.handler);\n\n    await this._libp2p.pubsub.unsubscribe(this._topic, this._handleMessage);\n  }\n\n  async broadcast(_message) {\n    const message = encoding(_message);\n    await this._libp2p.pubsub.publish(this._topic, message);\n  }\n\n  sendTo(peer, message) {\n    let conn = this._connections[peer];\n\n    if (!conn) {\n      conn = new Connection(peer, this._libp2p, this);\n      conn.on('error', err => this.emit('error', err));\n      this._connections[peer] = conn;\n      conn.once('disconnect', () => {\n        delete this._connections[peer];\n        this._peers = this._peers.filter(p => p.toString() !== peer.toString());\n        this.emit('peer left', peer);\n      });\n    } // We should use the same sequence number generation as js-libp2p-floosub does:\n    // const seqno = Buffer.from(utils.randomSeqno())\n    // Until we figure out a good way to bring in the js-libp2p-floosub's randomSeqno\n    // generator, let's use 0 as the sequence number for all private messages\n    // const seqno = Buffer.from([0])\n\n\n    const seqno = Buffer.from([0]);\n    const msg = {\n      to: peer,\n      from: this._libp2p.peerInfo.id.toB58String(),\n      data: Buffer.from(message).toString('hex'),\n      seqno: seqno.toString('hex'),\n      topicIDs: [this._topic],\n      topicCIDs: [this._topic]\n    };\n    conn.push(Buffer.from(JSON.stringify(msg)));\n  }\n\n  async _pollPeers() {\n    const newPeers = (await this._libp2p.pubsub.getSubscribers(this._topic)).sort();\n\n    if (this._emitChanges(newPeers)) {\n      this._peers = newPeers;\n    }\n  }\n\n  _emitChanges(newPeers) {\n    const differences = diff(this._peers, newPeers);\n    differences.added.forEach(peer => this.emit('peer joined', peer));\n    differences.removed.forEach(peer => this.emit('peer left', peer));\n    return differences.added.length > 0 || differences.removed.length > 0;\n  }\n\n  _onMessage(message) {\n    this.emit('message', message);\n  }\n\n  _handleDirectMessage(message) {\n    if (message.to.toString() === this._libp2p.peerInfo.id.toB58String()) {\n      const m = Object.assign({}, message);\n      delete m.to;\n      this.emit('message', m);\n    }\n  }\n\n}\n\nmodule.exports = PubSubRoom;","map":null,"metadata":{},"sourceType":"script"}