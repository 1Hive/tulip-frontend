{"ast":null,"code":"'use strict';\n\nconst isIpfs = require('is-ipfs');\n\nconst CID = require('cids');\n\nconst {\n  cidToString\n} = require('../../utils/cid');\n\nconst {\n  withTimeoutOption\n} = require('../utils');\n/**\n * @typedef {Object} ResolveOptions\n * @prop {string} cidBase - Multibase codec name the CID in the resolved path will be encoded with\n * @prop {boolean} [recursive=true] - Resolve until the result is an IPFS name\n *\n */\n\n/** @typedef {(path: string, options?: ResolveOptions) => Promise<string>} Resolve */\n\n/**\n * IPFS Resolve factory\n *\n * @param {Object} config\n * @param {IPLD} config.ipld - An instance of IPLD\n * @param {NameApi} [config.name] - An IPFS core interface name API\n * @returns {Resolve}\n */\n\n\nmodule.exports = ({\n  ipld,\n  name\n}) => {\n  return withTimeoutOption(async function resolve(path, opts) {\n    opts = opts || {};\n\n    if (!isIpfs.path(path)) {\n      throw new Error('invalid argument ' + path);\n    }\n\n    if (isIpfs.ipnsPath(path)) {\n      if (!name) {\n        throw new Error('failed to resolve IPNS path: name API unavailable');\n      }\n\n      for await (const resolvedPath of name.resolve(path, opts)) {\n        path = resolvedPath;\n      }\n    }\n\n    const [,, hash, ...rest] = path.split('/'); // ['', 'ipfs', 'hash', ...path]\n\n    const cid = new CID(hash); // nothing to resolve return the input\n\n    if (rest.length === 0) {\n      return `/ipfs/${cidToString(cid, {\n        base: opts.cidBase\n      })}`;\n    }\n\n    path = rest.join('/');\n    const results = ipld.resolve(cid, path);\n    let value = cid;\n    let remainderPath = path;\n\n    for await (const result of results) {\n      if (CID.isCID(result.value)) {\n        value = result.value;\n        remainderPath = result.remainderPath;\n      }\n    }\n\n    return `/ipfs/${cidToString(value, {\n      base: opts.cidBase\n    })}${remainderPath ? '/' + remainderPath : ''}`;\n  });\n};","map":null,"metadata":{},"sourceType":"script"}