{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar Identity = require('./identity');\n\nvar IdentityProvider = require('./identity-provider-interface.js');\n\nvar OrbitDBIdentityProvider = require('./orbit-db-identity-provider');\n\nvar Keystore = require('orbit-db-keystore');\n\nvar LRU = require('lru');\n\nvar path = require('path');\n\nvar defaultType = 'orbitdb';\nvar identityKeysPath = path.join('./orbitdb', 'identity', 'identitykeys');\nvar supportedTypes = {\n  orbitdb: OrbitDBIdentityProvider\n};\n\nvar getHandlerFor = function getHandlerFor(type) {\n  if (!Identities.isSupported(type)) {\n    throw new Error(\"IdentityProvider type '\".concat(type, \"' is not supported\"));\n  }\n\n  return supportedTypes[type];\n};\n\nvar Identities = /*#__PURE__*/function () {\n  function Identities(options) {\n    _classCallCheck(this, Identities);\n\n    this._keystore = options.keystore;\n    this._signingKeystore = options.signingKeystore || this._keystore;\n    this._knownIdentities = options.cache || new LRU(options.cacheSize || 100);\n  }\n\n  _createClass(Identities, [{\n    key: \"keystore\",\n    get: function get() {\n      return this._keystore;\n    }\n  }, {\n    key: \"signingKeystore\",\n    get: function get() {\n      return this._signingKeystore;\n    }\n  }, {\n    key: \"sign\",\n    value: function () {\n      var _sign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(identity, data) {\n        var signingKey, sig;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.keystore.getKey(identity.id);\n\n              case 2:\n                signingKey = _context.sent;\n\n                if (signingKey) {\n                  _context.next = 5;\n                  break;\n                }\n\n                throw new Error(\"Private signing key not found from Keystore\");\n\n              case 5:\n                _context.next = 7;\n                return this.keystore.sign(signingKey, data);\n\n              case 7:\n                sig = _context.sent;\n                return _context.abrupt(\"return\", sig);\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function sign(_x, _x2) {\n        return _sign.apply(this, arguments);\n      }\n\n      return sign;\n    }()\n  }, {\n    key: \"verify\",\n    value: function () {\n      var _verify = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(signature, publicKey, data) {\n        var verifier,\n            _args2 = arguments;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                verifier = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : 'v1';\n                return _context2.abrupt(\"return\", this.keystore.verify(signature, publicKey, data, verifier));\n\n              case 2:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function verify(_x3, _x4, _x5) {\n        return _verify.apply(this, arguments);\n      }\n\n      return verify;\n    }()\n  }, {\n    key: \"createIdentity\",\n    value: function () {\n      var _createIdentity = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var options,\n            keystore,\n            type,\n            identityProvider,\n            id,\n            _yield$this$signId,\n            publicKey,\n            idSignature,\n            pubKeyIdSignature,\n            _args3 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                options = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : {};\n                keystore = options.keystore || this.keystore;\n                type = options.type || defaultType;\n                identityProvider = type === defaultType ? new OrbitDBIdentityProvider(options.signingKeystore || keystore) : new (getHandlerFor(type))(options);\n                _context3.next = 6;\n                return identityProvider.getId(options);\n\n              case 6:\n                id = _context3.sent;\n\n                if (!options.migrate) {\n                  _context3.next = 10;\n                  break;\n                }\n\n                _context3.next = 10;\n                return options.migrate({\n                  targetStore: keystore._store,\n                  targetId: id\n                });\n\n              case 10:\n                _context3.next = 12;\n                return this.signId(id);\n\n              case 12:\n                _yield$this$signId = _context3.sent;\n                publicKey = _yield$this$signId.publicKey;\n                idSignature = _yield$this$signId.idSignature;\n                _context3.next = 17;\n                return identityProvider.signIdentity(publicKey + idSignature, options);\n\n              case 17:\n                pubKeyIdSignature = _context3.sent;\n                return _context3.abrupt(\"return\", new Identity(id, publicKey, idSignature, pubKeyIdSignature, type, this));\n\n              case 19:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function createIdentity() {\n        return _createIdentity.apply(this, arguments);\n      }\n\n      return createIdentity;\n    }()\n  }, {\n    key: \"signId\",\n    value: function () {\n      var _signId = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(id) {\n        var keystore, key, publicKey, idSignature;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                keystore = this.keystore;\n                _context4.next = 3;\n                return keystore.getKey(id);\n\n              case 3:\n                _context4.t0 = _context4.sent;\n\n                if (_context4.t0) {\n                  _context4.next = 8;\n                  break;\n                }\n\n                _context4.next = 7;\n                return keystore.createKey(id);\n\n              case 7:\n                _context4.t0 = _context4.sent;\n\n              case 8:\n                key = _context4.t0;\n                publicKey = keystore.getPublic(key);\n                _context4.next = 12;\n                return keystore.sign(key, id);\n\n              case 12:\n                idSignature = _context4.sent;\n                return _context4.abrupt(\"return\", {\n                  publicKey: publicKey,\n                  idSignature: idSignature\n                });\n\n              case 14:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function signId(_x6) {\n        return _signId.apply(this, arguments);\n      }\n\n      return signId;\n    }()\n  }, {\n    key: \"verifyIdentity\",\n    value: function () {\n      var _verifyIdentity = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(identity) {\n        var knownID, verifyIdSig, IdentityProvider, verified;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (Identity.isIdentity(identity)) {\n                  _context5.next = 2;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", false);\n\n              case 2:\n                knownID = this._knownIdentities.get(identity.signatures.id);\n\n                if (!knownID) {\n                  _context5.next = 5;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", identity.id === knownID.id && identity.publicKey === knownID.publicKey && identity.signatures.id === knownID.signatures.id && identity.signatures.publicKey === knownID.signatures.publicKey);\n\n              case 5:\n                _context5.next = 7;\n                return this.keystore.verify(identity.signatures.id, identity.publicKey, identity.id);\n\n              case 7:\n                verifyIdSig = _context5.sent;\n\n                if (verifyIdSig) {\n                  _context5.next = 10;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", false);\n\n              case 10:\n                IdentityProvider = getHandlerFor(identity.type);\n                _context5.next = 13;\n                return IdentityProvider.verifyIdentity(identity);\n\n              case 13:\n                verified = _context5.sent;\n\n                if (verified) {\n                  this._knownIdentities.set(identity.signatures.id, Identity.toJSON(identity));\n                }\n\n                return _context5.abrupt(\"return\", verified);\n\n              case 16:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function verifyIdentity(_x7) {\n        return _verifyIdentity.apply(this, arguments);\n      }\n\n      return verifyIdentity;\n    }()\n  }], [{\n    key: \"IdentityProvider\",\n    get: function get() {\n      return IdentityProvider;\n    }\n  }, {\n    key: \"verifyIdentity\",\n    value: function () {\n      var _verifyIdentity2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(identity) {\n        var verifyIdSig, IdentityProvider;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (Identity.isIdentity(identity)) {\n                  _context6.next = 2;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\", false);\n\n              case 2:\n                _context6.next = 4;\n                return Keystore.verify(identity.signatures.id, identity.publicKey, identity.id);\n\n              case 4:\n                verifyIdSig = _context6.sent;\n\n                if (verifyIdSig) {\n                  _context6.next = 7;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\", false);\n\n              case 7:\n                IdentityProvider = getHandlerFor(identity.type);\n                return _context6.abrupt(\"return\", IdentityProvider.verifyIdentity(identity));\n\n              case 9:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6);\n      }));\n\n      function verifyIdentity(_x8) {\n        return _verifyIdentity2.apply(this, arguments);\n      }\n\n      return verifyIdentity;\n    }()\n  }, {\n    key: \"createIdentity\",\n    value: function () {\n      var _createIdentity2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n        var options,\n            identities,\n            _args7 = arguments;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                options = _args7.length > 0 && _args7[0] !== undefined ? _args7[0] : {};\n\n                if (!options.keystore) {\n                  options.keystore = new Keystore(options.identityKeysPath || identityKeysPath);\n                }\n\n                if (!options.signingKeystore) {\n                  if (options.signingKeysPath) {\n                    options.signingKeystore = new Keystore(options.signingKeysPath);\n                  } else {\n                    options.signingKeystore = options.keystore;\n                  }\n                }\n\n                options = Object.assign({}, {\n                  type: defaultType\n                }, options);\n                identities = new Identities(options);\n                return _context7.abrupt(\"return\", identities.createIdentity(options));\n\n              case 6:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7);\n      }));\n\n      function createIdentity() {\n        return _createIdentity2.apply(this, arguments);\n      }\n\n      return createIdentity;\n    }()\n  }, {\n    key: \"isSupported\",\n    value: function isSupported(type) {\n      return Object.keys(supportedTypes).includes(type);\n    }\n  }, {\n    key: \"addIdentityProvider\",\n    value: function addIdentityProvider(IdentityProvider) {\n      if (!IdentityProvider) {\n        throw new Error('IdentityProvider class needs to be given as an option');\n      }\n\n      if (!IdentityProvider.type || typeof IdentityProvider.type !== 'string') {\n        throw new Error('Given IdentityProvider class needs to implement: static get type() { /* return a string */}.');\n      }\n\n      supportedTypes[IdentityProvider.type] = IdentityProvider;\n    }\n  }, {\n    key: \"removeIdentityProvider\",\n    value: function removeIdentityProvider(type) {\n      delete supportedTypes[type];\n    }\n  }]);\n\n  return Identities;\n}();\n\nmodule.exports = Identities;","map":null,"metadata":{},"sourceType":"script"}