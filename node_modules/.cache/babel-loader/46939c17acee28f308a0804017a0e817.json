{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nclass EventQueue {\n  constructor() {\n    this.pullQueue = [];\n    this.pushQueue = [];\n    this.eventHandlers = {};\n    this.isPaused = false;\n    this.isStopped = false;\n  }\n\n  push(value) {\n    if (this.isStopped) return;\n    const resolution = {\n      value,\n      done: false\n    };\n\n    if (this.pullQueue.length) {\n      const placeholder = this.pullQueue.shift();\n      if (placeholder) placeholder.resolve(resolution);\n    } else {\n      this.pushQueue.push(Promise.resolve(resolution));\n\n      if (this.highWaterMark !== undefined && this.pushQueue.length >= this.highWaterMark && !this.isPaused) {\n        this.isPaused = true;\n\n        if (this.eventHandlers.highWater) {\n          this.eventHandlers.highWater();\n        } else if (console) {\n          console.warn(`EventIterator queue reached ${this.pushQueue.length} items`);\n        }\n      }\n    }\n  }\n\n  stop() {\n    if (this.isStopped) return;\n    this.isStopped = true;\n    this.remove();\n\n    for (const placeholder of this.pullQueue) {\n      placeholder.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n\n    this.pullQueue.length = 0;\n  }\n\n  fail(error) {\n    if (this.isStopped) return;\n    this.isStopped = true;\n    this.remove();\n\n    if (this.pullQueue.length) {\n      for (const placeholder of this.pullQueue) {\n        placeholder.reject(error);\n      }\n\n      this.pullQueue.length = 0;\n    } else {\n      const rejection = Promise.reject(error);\n      /* Attach error handler to avoid leaking an unhandled promise rejection. */\n\n      rejection.catch(() => {});\n      this.pushQueue.push(rejection);\n    }\n  }\n\n  remove() {\n    Promise.resolve().then(() => {\n      if (this.removeCallback) this.removeCallback();\n    });\n  }\n\n  [Symbol.asyncIterator]() {\n    return {\n      next: value => {\n        const result = this.pushQueue.shift();\n\n        if (result) {\n          if (this.lowWaterMark !== undefined && this.pushQueue.length <= this.lowWaterMark && this.isPaused) {\n            this.isPaused = false;\n\n            if (this.eventHandlers.lowWater) {\n              this.eventHandlers.lowWater();\n            }\n          }\n\n          return result;\n        } else if (this.isStopped) {\n          return Promise.resolve({\n            value: undefined,\n            done: true\n          });\n        } else {\n          return new Promise((resolve, reject) => {\n            this.pullQueue.push({\n              resolve,\n              reject\n            });\n          });\n        }\n      },\n      return: () => {\n        this.isStopped = true;\n        this.pushQueue.length = 0;\n        this.remove();\n        return Promise.resolve({\n          value: undefined,\n          done: true\n        });\n      }\n    };\n  }\n\n}\n\nclass EventIterator {\n  constructor(listen, {\n    highWaterMark = 100,\n    lowWaterMark = 1\n  } = {}) {\n    const queue = new EventQueue();\n    queue.highWaterMark = highWaterMark;\n    queue.lowWaterMark = lowWaterMark;\n\n    queue.removeCallback = listen({\n      push: value => queue.push(value),\n      stop: () => queue.stop(),\n      fail: error => queue.fail(error),\n      on: (event, fn) => {\n        queue.eventHandlers[event] = fn;\n      }\n    }) || (() => {});\n\n    this[Symbol.asyncIterator] = () => queue[Symbol.asyncIterator]();\n\n    Object.freeze(this);\n  }\n\n}\n\nexports.EventIterator = EventIterator;\nexports.default = EventIterator;","map":null,"metadata":{},"sourceType":"script"}