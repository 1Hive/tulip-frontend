{"ast":null,"code":"'use strict';\n\nconst Store = require('orbit-db-store');\n\nconst EventIndex = require('./EventIndex'); // TODO: generalize the Iterator functions and spin to its own module\n\n\nclass EventStore extends Store {\n  constructor(ipfs, id, dbname, options = {}) {\n    if (options.Index === undefined) Object.assign(options, {\n      Index: EventIndex\n    });\n    super(ipfs, id, dbname, options);\n    this._type = 'eventlog';\n    this.events.on(\"log.op.ADD\", (address, hash, payload) => {\n      this.events.emit(\"db.append\", payload.value);\n    });\n  }\n\n  add(data, options = {}) {\n    return this._addOperation({\n      op: 'ADD',\n      key: null,\n      value: data\n    }, options);\n  }\n\n  get(hash) {\n    return this.iterator({\n      gte: hash,\n      limit: 1\n    }).collect()[0];\n  }\n\n  iterator(options) {\n    const messages = this._query(options);\n\n    let currentIndex = 0;\n    let iterator = {\n      [Symbol.iterator]() {\n        return this;\n      },\n\n      next() {\n        let item = {\n          value: null,\n          done: true\n        };\n\n        if (currentIndex < messages.length) {\n          item = {\n            value: messages[currentIndex],\n            done: false\n          };\n          currentIndex++;\n        }\n\n        return item;\n      },\n\n      collect: () => messages\n    };\n    return iterator;\n  }\n\n  _query(opts) {\n    if (!opts) opts = {};\n    const amount = opts.limit ? opts.limit > -1 ? opts.limit : this._index.get().length : 1; // Return 1 if no limit is provided\n\n    const events = this._index.get().slice();\n\n    let result = [];\n\n    if (opts.gt || opts.gte) {\n      // Greater than case\n      result = this._read(events, opts.gt ? opts.gt : opts.gte, amount, !!opts.gte);\n    } else {\n      // Lower than and lastN case, search latest first by reversing the sequence\n      result = this._read(events.reverse(), opts.lt ? opts.lt : opts.lte, amount, opts.lte || !opts.lt).reverse();\n    }\n\n    if (opts.reverse) {\n      result.reverse();\n    }\n\n    return result;\n  }\n\n  _read(ops, hash, amount, inclusive) {\n    // Find the index of the gt/lt hash, or start from the beginning of the array if not found\n    const index = ops.map(e => e.hash).indexOf(hash);\n    let startIndex = Math.max(index, 0); // If gte/lte is set, we include the given hash, if not, start from the next element\n\n    startIndex += inclusive ? 0 : 1; // Slice the array to its requested size\n\n    const res = ops.slice(startIndex).slice(0, amount);\n    return res;\n  }\n\n}\n\nmodule.exports = EventStore;","map":null,"metadata":{},"sourceType":"script"}