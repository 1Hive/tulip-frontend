{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst log = debug('libp2p:secio');\nlog.error = debug('libp2p:secio:error');\n\nconst DuplexPair = require('it-pair/duplex');\n\nconst pipe = require('it-pipe');\n\nconst lp = require('it-length-prefixed');\n\nconst Wrap = require('it-pb-rpc');\n\nconst {\n  int32BEEncode,\n  int32BEDecode\n} = lp; // Maximum length of the data section of the message\n// 8MB, https://github.com/libp2p/specs/blob/94ad1bd/secio/README.md#message-framing\n\nconst MAX_DATA_LENGTH = 0x800000;\n\nconst etm = require('../etm');\n\nconst crypto = require('./crypto'); // step 3. Finish\n// -- send expected message to verify encryption works (send local nonce)\n\n\nmodule.exports = async function finish(state, wrapped) {\n  log('3. finish - start');\n  const proto = state.protocols;\n  const [secure, user] = DuplexPair();\n  const network = wrapped.unwrap();\n  pipe(secure, // this is FROM the user\n  etm.createBoxStream(proto.local.cipher, proto.local.mac), lp.encode({\n    lengthEncoder: int32BEEncode\n  }), network, // and gets piped INTO and FROM the network\n  lp.decode({\n    lengthDecoder: int32BEDecode,\n    maxDataLength: MAX_DATA_LENGTH\n  }), etm.createUnboxStream(proto.remote.cipher, proto.remote.mac), secure // and gets piped TO the user\n  ).catch(err => {\n    log.error('an error occurred in the crypto stream', err);\n  }); // Exchange nonces over the encrypted stream for final verification\n\n  const shake = Wrap(user);\n  shake.write(state.proposal.in.rand);\n  const nonceBack = await shake.read(state.proposal.in.rand.length);\n  crypto.verifyNonce(state, nonceBack.slice());\n  log('3. finish - finish'); // Awesome that's all folks.\n\n  state.secure = shake.unwrap();\n};","map":null,"metadata":{},"sourceType":"script"}