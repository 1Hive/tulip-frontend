{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _objectSpread = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _awaitAsyncGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _wrapAsyncGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar _asyncIterator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar createLock = require('./utils/create-lock');\n\nvar isIpfs = require('is-ipfs'); // These operations are read-locked at the function level and will execute simultaneously\n\n\nvar readOperations = {\n  stat: require('./stat')\n}; // These operations are locked at the function level and will execute in series\n\nvar writeOperations = {\n  chmod: require('./chmod'),\n  cp: require('./cp'),\n  flush: require('./flush'),\n  mkdir: require('./mkdir'),\n  mv: require('./mv'),\n  rm: require('./rm'),\n  touch: require('./touch')\n}; // These operations are asynchronous and manage their own locking\n\nvar unwrappedOperations = {\n  write: require('./write'),\n  read: require('./read'),\n  ls: require('./ls')\n};\n\nvar wrap = function wrap(_ref2) {\n  var options = _ref2.options,\n      mfs = _ref2.mfs,\n      operations = _ref2.operations,\n      lock = _ref2.lock;\n  Object.keys(operations).forEach(function (key) {\n    mfs[key] = lock(operations[key](options));\n  });\n};\n\nvar defaultOptions = {\n  repoOwner: true,\n  ipld: null,\n  repo: null\n};\n\nfunction createMfs(options) {\n  var _Object$assign = Object.assign({}, defaultOptions || {}, options),\n      repoOwner = _Object$assign.repoOwner;\n\n  options.repo = {\n    blocks: options.blocks,\n    datastore: options.datastore\n  };\n  var lock = createLock(repoOwner);\n\n  var readLock = function readLock(operation) {\n    return lock.readLock(operation);\n  };\n\n  var writeLock = function writeLock(operation) {\n    return lock.writeLock(operation);\n  };\n\n  var mfs = {};\n  wrap({\n    options: options,\n    mfs: mfs,\n    operations: readOperations,\n    lock: readLock\n  });\n  wrap({\n    options: options,\n    mfs: mfs,\n    operations: writeOperations,\n    lock: writeLock\n  });\n  Object.keys(unwrappedOperations).forEach(function (key) {\n    mfs[key] = unwrappedOperations[key](options);\n  });\n  return mfs;\n}\n\nmodule.exports = function (_ref3) {\n  var ipld = _ref3.ipld,\n      block = _ref3.block,\n      blockService = _ref3.blockService,\n      repo = _ref3.repo,\n      preload = _ref3.preload,\n      constructorOptions = _ref3.options;\n  var methods = createMfs({\n    ipld: ipld,\n    block: block,\n    blocks: blockService,\n    datastore: repo.root,\n    repoOwner: constructorOptions.repoOwner\n  });\n\n  var withPreload = function withPreload(fn) {\n    return function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      var paths = args.filter(function (arg) {\n        return isIpfs.ipfsPath(arg) || isIpfs.cid(arg);\n      });\n\n      if (paths.length) {\n        var options = args[args.length - 1];\n\n        if (options && options.preload !== false) {\n          paths.forEach(function (path) {\n            return preload(path);\n          });\n        }\n      }\n\n      return fn.apply(void 0, args);\n    };\n  };\n\n  return _objectSpread(_objectSpread({}, methods), {}, {\n    /**\n     * Change file mode\n     *\n     * @param {String} path - The path of the source to modify.\n     * @param {Object} mode - The mode to set the path\n     * @param {Object} [opts] - Options for modification.\n     * @param {boolean} [opts.recursive=false] - Whether to change modes recursively. (default: false)\n     * @param {boolean} [opts.flush=true] - Whether or not to immediately flush MFS changes to disk (default: true).\n     * @param {number} [opts.shardSplitThreshold] - If the modified path has more than this many links it will be turned into a HAMT shard\n     * @returns {Promise<string>}\n     */\n    chmod: methods.chmod,\n\n    /**\n     * Copy files\n     *\n     * @param {String | Array<String>} from - The path(s) of the source to copy.\n     * @param {String} to - The path of the destination to copy to.\n     * @param {Object} [opts] - Options for copy.\n     * @param {boolean} [opts.parents=false] - Whether or not to make the parent directories if they don't exist. (default: false)\n     * @param {String} [opts.format=dag-pb] - Format of nodes to write any newly created directories as. (default: dag-pb)\n     * @param {String} [opts.hashAlg=sha2-256] - Algorithm to use when creating CIDs for newly created directories. (default: sha2-256) {@link https://github.com/multiformats/js-multihash/blob/master/src/constants.js#L5-L343 The list of all possible values}\n     * @param {boolean} [opts.flush=true] - Whether or not to immediately flush MFS changes to disk (default: true).\n     * @returns {Promise<string>}\n     */\n    cp: withPreload(methods.cp),\n\n    /**\n     * Make a directory\n     *\n     * @param {String} path - The path to the directory to make.\n     * @param {Object} [opts] - Options for mkdir.\n     * @param {boolean} [opts.parents=false] - Value to decide whether or not to make the parent directories if they don't exist. (default: false)\n     * @param {String} [opts.format=dag-pb] - Format of nodes to write any newly created directories as. (default: dag-pb).\n     * @param {String} [opts.hashAlg] - Algorithm to use when creating CIDs for newly created directories. (default: sha2-256) {@link https://github.com/multiformats/js-multihash/blob/master/src/constants.js#L5-L343 The list of all possible values}\n     * @param {boolean} [opts.flush=true] - Whether or not to immediately flush MFS changes to disk (default: true).\n     * @returns {Promise<void>}\n     */\n    mkdir: methods.mkdir,\n\n    /**\n     * @typedef {Object} StatOutput\n     * @prop {String} hash - Output hash.\n     * @prop {number} size - File size in bytes.\n     * @prop {number} cumulativeSize - Integer with the size of the DAGNodes making up the file in Bytes.\n     * @prop {string} type - Output type either 'directory' or 'file'.\n     * @prop {number} blocks - If type is directory, this is the number of files in the directory. If it is file it is the number of blocks that make up the file.\n     * @prop {boolean} withLocality - Indicate if locality information is present.\n     * @prop {boolean} local - Indicate if the queried dag is fully present locally.\n     * @prop {number} sizeLocal - Integer indicating the cumulative size of the data present locally.\n     */\n\n    /**\n     * Get file or directory status.\n     *\n     * @param {String} path - Path to the file or directory to stat.\n     * @param {Object} [opts] - Options for stat.\n     * @param {boolean} [opts.hash=false] - Return only the hash. (default: false)\n     * @param {boolean} [opts.size=false] - Return only the size. (default: false)\n     * @param {boolean} [opts.withLocal=false] - Compute the amount of the dag that is local, and if possible the total size. (default: false)\n     * @returns {Promise<StatOutput>}\n     */\n    stat: withPreload(methods.stat),\n\n    /**\n     * Remove a file or directory.\n     *\n     * @param {String | Array<String>} paths - One or more paths to remove.\n     * @param {Object} [opts] - Options for remove.\n     * @param {boolean} [opts.recursive=false] - Whether or not to remove directories recursively. (default: false)\n     * @returns {Promise<void>}\n     */\n    rm: methods.rm,\n\n    /**\n     * @typedef {Object} ReadOptions\n     * @prop {number} [opts.offset=0] - Integer with the byte offset to begin reading from (default: 0).\n     * @prop {number} [opts.length] - Integer with the maximum number of bytes to read (default: Read to the end of stream).\n     */\n\n    /**\n     * Read a file into a Buffer.\n     *\n     * @param {string} path - Path of the file to read and must point to a file (and not a directory).\n     * @param {ReadOptions} [opts] - Object for read.\n     * @returns {AsyncIterable<Buffer>}\n     */\n    read: withPreload(methods.read),\n\n    /**\n     * Update modification time\n     *\n     * @param {String} path - The path of the source to modify.\n     * @param {number} mtime - Time to use as the new modification time in seconds since (+ve) or before (-ve) the Unix Epoch\n     * @param {Object} [opts] - Options for touch.\n     * @param {boolean} [opts.parents=false] - Whether or not to make the parent directories if they don't exist. (default: false)\n     * @param {number} [opts.cidVersion=0] - CID version to use with the newly updated node\n     * @param {number} [opts.shardSplitThreshold] - If the modified path has more than this many links it will be turned into a HAMT shard\n     * @returns {Promise<string>}\n     */\n    touch: methods.touch,\n\n    /**\n     * Write to a file.\n     *\n     * @param {string} path - Path of the file to write.\n     * @param {Buffer | PullStream | ReadableStream | Blob | string} content - Content to write.\n     * @param {Object} opts - Options for write.\n     * @param {number} [opts.offset=0] - Integer with the byte offset to begin writing at. (default: 0)\n     * @param {boolean} [opts.create=false] - Indicate to create the file if it doesn't exist. (default: false)\n     * @param {boolean} [opts.truncate=false] - Indicate if the file should be truncated after writing all the bytes from content. (default: false)\n     * @param {boolena} [opts.parents=false] - Value to decide whether or not to make the parent directories if they don't exist. (default: false)\n     * @param {number} [opts.length] - Maximum number of bytes to read. (default: Read all bytes from content)\n     * @param {boolean} [opts.rawLeaves=false] - If true, DAG leaves will contain raw file data and not be wrapped in a protobuf. (default: false)\n     * @param {number} [opts.cidVersion=0] - The CID version to use when storing the data (storage keys are based on the CID, including its version). (default: 0)\n     * @returns {Promise<void>}\n     */\n    write: methods.write,\n\n    /**\n     * Move files.\n     *\n     * @param {string | Array<string>} from - Path(s) of the source to move.\n     * @param {string} to - Path of the destination to move to.\n     * @param {Object} opts - Options for mv.\n     * @param {boolean} [opts.parents=false] - Value to decide whether or not to make the parent directories if they don't exist. (default: false)\n     * @param {String} [opts.format=dag-pb] - Format of nodes to write any newly created directories as. (default: dag-pb).\n     * @param {String} [opts.hashAlg] - Algorithm to use when creating CIDs for newly created directories. (default: sha2-256) {@link https://github.com/multiformats/js-multihash/blob/master/src/constants.js#L5-L343 The list of all possible values}\n     * @param {boolean} [opts.flush=true] - Value to decide whether or not to immediately flush MFS changes to disk. (default: true)\n     * @returns {Promise<void>}\n     * @description\n     * If from has multiple values then to must be a directory.\n     *\n     * If from has a single value and to exists and is a directory, from will be moved into to.\n     *\n     * If from has a single value and to exists and is a file, from must be a file and the contents of to will be replaced with the contents of from otherwise an error will be returned.\n     *\n     * If from is an IPFS path, and an MFS path exists with the same name, the IPFS path will be chosen.\n     *\n     * All values of from will be removed after the operation is complete unless they are an IPFS path.\n     */\n    mv: withPreload(methods.mv),\n\n    /**\n     * Flush a given path's data to the disk.\n     *\n     * @param {string | Array<string>} [paths] - String paths to flush. (default: /)\n     * @returns {Promise<void>}\n     */\n    flush: methods.flush,\n\n    /**\n     * @typedef {Object} ListOutputFile\n     * @prop {string} name - Which is the file's name.\n     * @prop {string} type - Which is the object's type (directory or file).\n     * @prop {number} size - The size of the file in bytes.\n     * @prop {string} hash - The hash of the file.\n     */\n\n    /**\n     * @typedef {Object} ListOptions\n     * @prop {boolean} [long=false] - Value to decide whether or not to populate type, size and hash. (default: false)\n     * @prop {boolean} [sort=false] - If true entries will be sorted by filename. (default: false)\n     */\n\n    /**\n     * List directories in the local mutable namespace.\n     *\n     * @param {string} [path=\"/\"] - String to show listing for. (default: /)\n     * @param {ListOptions} [opts] - Options for list.\n     * @returns {AsyncIterable<ListOutputFile>}\n     */\n    ls: withPreload( /*#__PURE__*/function () {\n      var _ref = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _iteratorNormalCompletion,\n            _didIteratorError,\n            _iteratorError,\n            _iterator,\n            _step,\n            _value,\n            file,\n            _args = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _iteratorNormalCompletion = true;\n                _didIteratorError = false;\n                _context.prev = 2;\n                _iterator = _asyncIterator(methods.ls.apply(methods, _args));\n\n              case 4:\n                _context.next = 6;\n                return _awaitAsyncGenerator(_iterator.next());\n\n              case 6:\n                _step = _context.sent;\n                _iteratorNormalCompletion = _step.done;\n                _context.next = 10;\n                return _awaitAsyncGenerator(_step.value);\n\n              case 10:\n                _value = _context.sent;\n\n                if (_iteratorNormalCompletion) {\n                  _context.next = 18;\n                  break;\n                }\n\n                file = _value;\n                _context.next = 15;\n                return _objectSpread(_objectSpread({}, file), {}, {\n                  size: file.size || 0\n                });\n\n              case 15:\n                _iteratorNormalCompletion = true;\n                _context.next = 4;\n                break;\n\n              case 18:\n                _context.next = 24;\n                break;\n\n              case 20:\n                _context.prev = 20;\n                _context.t0 = _context[\"catch\"](2);\n                _didIteratorError = true;\n                _iteratorError = _context.t0;\n\n              case 24:\n                _context.prev = 24;\n                _context.prev = 25;\n\n                if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                  _context.next = 29;\n                  break;\n                }\n\n                _context.next = 29;\n                return _awaitAsyncGenerator(_iterator.return());\n\n              case 29:\n                _context.prev = 29;\n\n                if (!_didIteratorError) {\n                  _context.next = 32;\n                  break;\n                }\n\n                throw _iteratorError;\n\n              case 32:\n                return _context.finish(29);\n\n              case 33:\n                return _context.finish(24);\n\n              case 34:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[2, 20, 24, 34], [25,, 29, 33]]);\n      }));\n\n      return function () {\n        return _ref.apply(this, arguments);\n      };\n    }())\n  });\n};","map":null,"metadata":{},"sourceType":"script"}