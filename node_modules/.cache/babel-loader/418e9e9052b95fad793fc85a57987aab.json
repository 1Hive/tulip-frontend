{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar mortice = require('mortice');\n\nvar lock;\n\nmodule.exports = function (repoOwner) {\n  if (lock) {\n    return lock;\n  }\n\n  var mutex = mortice({\n    // ordinarily the main thread would store the read/write lock but\n    // if we are the thread that owns the repo, we can store the lock\n    // on this process even if we are a worker thread\n    singleProcess: repoOwner\n  });\n  lock = {\n    readLock: function readLock(func) {\n      return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var releaseLock,\n            _len,\n            args,\n            _key,\n            _args = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return mutex.readLock();\n\n              case 2:\n                releaseLock = _context.sent;\n                _context.prev = 3;\n\n                for (_len = _args.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                  args[_key] = _args[_key];\n                }\n\n                _context.next = 7;\n                return func.apply(null, args);\n\n              case 7:\n                return _context.abrupt(\"return\", _context.sent);\n\n              case 8:\n                _context.prev = 8;\n                releaseLock();\n                return _context.finish(8);\n\n              case 11:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[3,, 8, 11]]);\n      }));\n    },\n    writeLock: function writeLock(func) {\n      return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var releaseLock,\n            _len2,\n            args,\n            _key2,\n            _args2 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return mutex.writeLock();\n\n              case 2:\n                releaseLock = _context2.sent;\n                _context2.prev = 3;\n\n                for (_len2 = _args2.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n                  args[_key2] = _args2[_key2];\n                }\n\n                _context2.next = 7;\n                return func.apply(null, args);\n\n              case 7:\n                return _context2.abrupt(\"return\", _context2.sent);\n\n              case 8:\n                _context2.prev = 8;\n                releaseLock();\n                return _context2.finish(8);\n\n              case 11:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, null, [[3,, 8, 11]]);\n      }));\n    }\n  };\n  return lock;\n};","map":null,"metadata":{},"sourceType":"script"}