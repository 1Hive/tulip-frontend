{"ast":null,"code":"const fetch = require('node-fetch');\n\nconst pageResults = require('graph-results-pager');\n\nconst {\n  multicallAddresses,\n  graphAPIEndpoints,\n  tokenLists,\n  rpcEndpoints\n} = require('./../constants');\n\nconst Multicall = require('@makerdao/multicall');\n\nmodule.exports = {\n  //fetches the honeyswap token list\n  async tokens() {\n    const data = await fetch(tokenLists.honeyswap, {\n      methods: 'GET',\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    }).then(response => {\n      return response.json();\n    });\n    return data.tokens;\n  },\n\n  async simplyTokenBalances({\n    user_address = undefined,\n    network = 'xdai',\n    tokens = undefined,\n    rpc_endpoint = undefined\n  } = {}) {\n    if (!user_address) {\n      throw new Error('tulip-data: User address undefined');\n    } //const tokens = await module.exports.tokens();\n\n\n    const multicallQuery = [];\n    tokens.forEach(token => {\n      multicallQuery.push({\n        target: token,\n        call: ['balanceOf(address)(uint256)', user_address],\n        returns: [[token]]\n      });\n    });\n    const config = {\n      rpcUrl: rpc_endpoint ? rpc_endpoint : rpcEndpoints[network],\n      multicallAddress: multicallAddresses[network]\n    };\n    return await Multicall.aggregate(multicallQuery, config).then(result => {\n      return result.results.transformed;\n    });\n  },\n\n  //gets a list of all non zero token balances in an wallet address\n  async tokenBalances({\n    user_address = undefined,\n    network = 'xdai'\n  } = {}) {\n    if (!user_address) {\n      throw new Error('tulip-data: User address undefined');\n    }\n\n    const tokens = await module.exports.tokens();\n    const multicallQuery = [];\n    tokens.forEach(token => {\n      multicallQuery.push({\n        target: token.address,\n        call: ['balanceOf(address)(uint256)', user_address],\n        returns: [[token.address, val => val / 10 ** token.decimals]]\n      });\n    });\n    const config = {\n      rpcUrl: rpcEndpoints[network],\n      multicallAddress: multicallAddresses[network]\n    };\n    const nonzeroBalances = {};\n    let gqlIdQuery = '';\n    await Multicall.aggregate(multicallQuery, config).then(resultObject => {\n      const gqlIds = [];\n      Object.entries(resultObject.results.transformed).forEach(([key, value]) => {\n        if (value !== 0) {\n          nonzeroBalances[key] = value;\n          gqlIds.push('\\\\\"' + key + '\\\\\"');\n        }\n      });\n      gqlIdQuery = '[' + gqlIds.join(',') + ']';\n    }); //get data from honeyswap\n\n    const properties = ['id', 'symbol', 'derivedETH'];\n    const tokenData = await pageResults({\n      api: graphAPIEndpoints.honeyswap_v2,\n      query: {\n        entity: 'tokens',\n        selection: {\n          where: {\n            id_in: gqlIdQuery\n          },\n          block: undefined\n        },\n        properties: properties\n      }\n    }).then(results => {\n      return results;\n    }).catch(err => console.log(err));\n    const tokensById = {};\n    tokens.forEach(entry => {\n      tokensById[entry.address.toLowerCase()] = {\n        address: entry.address.toLowerCase(),\n        ...entry\n      };\n    });\n    const results = [];\n    tokenData.forEach(token => {\n      results.push({\n        balance: nonzeroBalances[token.id],\n        priceUSD: token.derivedETH,\n        valueUSD: token.derivedETH * nonzeroBalances[token.id],\n        ...tokensById[token.id]\n      });\n    });\n    return tokenBalances.callback(results);\n  },\n\n  //TODO: add more exchanges/only works with honeyswap subgraph and tokenlist for now\n  async poolBalances({\n    block = undefined,\n    user_address = undefined\n  } = {}) {\n    if (!user_address) {\n      throw new Error('tulip-data: User address undefined');\n    }\n\n    const properties = ['id', 'liquidityPositions { liquidityTokenBalance, pair { token0 { id, symbol, name, derivedETH }, token1 { id, symbol, name, derivedETH }, reserve0, reserve1, reserveUSD, totalSupply} }'];\n    const poolData = await pageResults({\n      api: graphAPIEndpoints.honeyswap_v2,\n      query: {\n        entity: 'users',\n        selection: {\n          where: {\n            id: `\\\\\"${user_address.toLowerCase()}\\\\\"`\n          },\n          block: block ? block : undefined\n        },\n        properties: properties\n      }\n    }).then(results => {\n      return results;\n    }).catch(err => console.log(err));\n    const tokens = await module.exports.tokens();\n    const tokensById = [];\n    tokens.forEach(token => {\n      tokensById[token.address.toLowerCase()] = token;\n    });\n    const results = [];\n\n    if (poolData && poolData[0] && poolData[0].liquidityPositions) {\n      poolData[0].liquidityPositions.forEach(position => {\n        let token0 = tokensById[position.pair.token0.id];\n\n        if (!token0) {\n          token0 = {\n            name: position.pair.token0.name,\n            symbol: position.pair.token0.symbol,\n            address: position.pair.token0.id,\n            logoURI: null\n          };\n        }\n\n        let token1 = tokensById[position.pair.token1.id];\n\n        if (!token1) {\n          token1 = {\n            name: position.pair.token1.name,\n            symbol: position.pair.token1.symbol,\n            address: position.pair.token1.id,\n            logoURI: null\n          };\n        }\n        /*\n        \tget liquidity value of single token\n        \t\tgetLiquidityValue()\n        \tfrom: https://github.com/Uniswap/uniswap-v2-sdk/blob/main/src/entities/pair.ts\n        \tJSBI.divide(JSBI.multiply(liquidity.raw, this.reserveOf(token).raw), totalSupplyAdjusted.raw)\n        \t\tlet liquidityValueUSD = position.liquidityTokenBalance * position.pair.reserve0 / position.pair.totalSupply;\n        \tliquidityValueUSD = liquidityValueUSD * position.pair.token0.derivedETH * 2;\n        */\n\n\n        token0.balance = position.liquidityTokenBalance * position.pair.reserve0 / position.pair.totalSupply;\n        token1.balance = position.liquidityTokenBalance * position.pair.reserve1 / position.pair.totalSupply; //in this case eth == dai == usd\n\n        token0.priceUSD = position.pair.token0.derivedETH;\n        token1.priceUSD = position.pair.token1.derivedETH;\n        token0.valueUSD = token0.balance * position.pair.token0.derivedETH;\n        token1.valueUSD = token1.balance * position.pair.token1.derivedETH;\n        /* get usd value of owned pool tokens */\n\n        const liquidityValueUSD = position.pair.reserveUSD / position.pair.totalSupply * position.liquidityTokenBalance;\n        if (position.liquidityTokenBalance <= 0) return;\n        results.push({\n          tokens: [token0, token1],\n          balance: position.liquidityTokenBalance,\n          valueUSD: liquidityValueUSD\n        });\n      });\n      return poolBalances.callback(results);\n    }\n  }\n\n};\nconst tokenBalance = {\n  /*\n  properties: [\n  \t'balance',\n  \t'name',\n  \t'address',\n  \t'symbol',\n  \t'logoURI',\n  \t'priceUsd',\n  \t'valueUsd'\n  ],\n   */\n  callback(entry) {\n    return {\n      balance: Number(entry.balance),\n      name: entry.name,\n      address: entry.address,\n      symbol: entry.symbol,\n      logoURI: entry.logoURI,\n      priceUSD: Number(entry.priceUSD),\n      valueUSD: Number(entry.valueUSD)\n    };\n  }\n\n};\nconst tokenBalances = {\n  callback(results) {\n    return results.map(entry => tokenBalance.callback(entry));\n  }\n\n};\nconst poolBalances = {\n  callback(results) {\n    results.map(entry => {\n      const result = {\n        balance: Number(entry.balance),\n        valueUSD: Number(entry.valueUSD)\n      };\n      result.tokens = entry.tokens.map(token => tokenBalance.callback(token));\n    });\n    return results;\n  }\n\n};","map":null,"metadata":{},"sourceType":"script"}