{"ast":null,"code":"'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst errcode = require('err-code');\n\nconst multihash = require('multihashes');\n\nconst crypto = require('./crypto');\n/**\n * Hash the given `buf` using the algorithm specified by `alg`.\n * @param {Buffer} buf - The value to hash.\n * @param {number|string} alg - The algorithm to use eg 'sha1'\n * @param {number} [length] - Optionally trim the result to this length.\n * @returns {Promise<Buffer>}\n */\n\n\nasync function Multihashing(buf, alg, length) {\n  const digest = await Multihashing.digest(buf, alg, length);\n  return multihash.encode(digest, alg, length);\n}\n/**\n * The `buffer` module for easy use in the browser.\n *\n * @type {Buffer}\n */\n\n\nMultihashing.Buffer = Buffer; // for browser things\n\n/**\n * Expose multihash itself, to avoid silly double requires.\n */\n\nMultihashing.multihash = multihash;\n/**\n * @param {Buffer} buf - The value to hash.\n * @param {number|string} alg - The algorithm to use eg 'sha1'\n * @param {number} [length] - Optionally trim the result to this length.\n * @returns {Promise<Buffer>}\n */\n\nMultihashing.digest = async (buf, alg, length) => {\n  const hash = Multihashing.createHash(alg);\n  const digest = await hash(buf);\n  return length ? digest.slice(0, length) : digest;\n};\n/**\n * Creates a function that hashes with the given algorithm\n *\n * @param {string|number} alg - The algorithm to use eg 'sha1'\n *\n * @returns {function} - The hash function corresponding to `alg`\n */\n\n\nMultihashing.createHash = function (alg) {\n  if (!alg) {\n    throw errcode(new Error('hash algorithm must be specified'), 'ERR_HASH_ALGORITHM_NOT_SPECIFIED');\n  }\n\n  alg = multihash.coerceCode(alg);\n\n  if (!Multihashing.functions[alg]) {\n    throw errcode(new Error(`multihash function '${alg}' not yet supported`), 'ERR_HASH_ALGORITHM_NOT_SUPPORTED');\n  }\n\n  return Multihashing.functions[alg];\n};\n/**\n * Mapping of multihash codes to their hashing functions.\n * @type {Object}\n */\n\n\nMultihashing.functions = {\n  // identity\n  0x00: crypto.identity,\n  // sha1\n  0x11: crypto.sha1,\n  // sha2-256\n  0x12: crypto.sha2256,\n  // sha2-512\n  0x13: crypto.sha2512,\n  // sha3-512\n  0x14: crypto.sha3512,\n  // sha3-384\n  0x15: crypto.sha3384,\n  // sha3-256\n  0x16: crypto.sha3256,\n  // sha3-224\n  0x17: crypto.sha3224,\n  // shake-128\n  0x18: crypto.shake128,\n  // shake-256\n  0x19: crypto.shake256,\n  // keccak-224\n  0x1A: crypto.keccak224,\n  // keccak-256\n  0x1B: crypto.keccak256,\n  // keccak-384\n  0x1C: crypto.keccak384,\n  // keccak-512\n  0x1D: crypto.keccak512,\n  // murmur3-128\n  0x22: crypto.murmur3128,\n  // murmur3-32\n  0x23: crypto.murmur332,\n  // dbl-sha2-256\n  0x56: crypto.dblSha2256\n}; // add blake functions\n\ncrypto.addBlake(Multihashing.functions);\n\nMultihashing.validate = async (buf, hash) => {\n  const newHash = await Multihashing(buf, multihash.decode(hash).name);\n  return Buffer.compare(hash, newHash) === 0;\n};\n\nmodule.exports = Multihashing;","map":null,"metadata":{},"sourceType":"script"}