{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _createForOfIteratorHelper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _objectSpread = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _asyncIterator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar pipe = require('it-pipe');\n\nvar pushable = require('it-pushable');\n\nvar log = require('debug')('libp2p:mplex');\n\nvar abortable = require('abortable-iterator');\n\nvar Coder = require('./coder');\n\nvar restrictSize = require('./restrict-size');\n\nvar _require = require('./message-types'),\n    MessageTypes = _require.MessageTypes,\n    MessageTypeNames = _require.MessageTypeNames;\n\nvar createStream = require('./stream');\n\nvar Mplex = /*#__PURE__*/function () {\n  /**\n   * @constructor\n   * @param {object} options\n   * @param {function(*)} options.onStream Called whenever an inbound stream is created\n   * @param {function(*)} options.onStreamEnd Called whenever a stream ends\n   * @param {AbortSignal} options.signal An AbortController signal\n   */\n  function Mplex(options) {\n    _classCallCheck(this, Mplex);\n\n    options = options || {};\n    options = typeof options === 'function' ? {\n      onStream: options\n    } : options;\n    this._streamId = 0;\n    this._streams = {\n      /**\n       * @type {Map<number, *>} Stream to ids map\n       */\n      initiators: new Map(),\n\n      /**\n       * @type {Map<number, *>} Stream to ids map\n       */\n      receivers: new Map()\n    };\n    this._options = options;\n    /**\n     * An iterable sink\n     */\n\n    this.sink = this._createSink();\n    /**\n     * An iterable source\n     */\n\n    this.source = this._createSource();\n    /**\n     * @property {function} onStream\n     */\n\n    this.onStream = options.onStream;\n    /**\n     * @property {function} onStreamEnd\n     */\n\n    this.onStreamEnd = options.onStreamEnd;\n  }\n  /**\n   * Returns a Map of streams and their ids\n   * @returns {Map<number,*>}\n   */\n\n\n  _createClass(Mplex, [{\n    key: \"streams\",\n    get: function get() {\n      // Inbound and Outbound streams may have the same ids, so we need to make those unique\n      var streams = [];\n\n      this._streams.initiators.forEach(function (stream) {\n        streams.push(stream);\n      });\n\n      this._streams.receivers.forEach(function (stream) {\n        streams.push(stream);\n      });\n\n      return streams;\n    }\n    /**\n     * Initiate a new stream with the given name. If no name is\n     * provided, the id of th stream will be used.\n     * @param {string} [name] If name is not a string it will be cast to one\n     * @returns {Stream}\n     */\n\n  }, {\n    key: \"newStream\",\n    value: function newStream(name) {\n      var id = this._streamId++;\n      name = name == null ? id.toString() : String(name);\n      var registry = this._streams.initiators;\n      return this._newStream({\n        id: id,\n        name: name,\n        type: 'initiator',\n        registry: registry\n      });\n    }\n    /**\n     * Called whenever an inbound stream is created\n     * @private\n     * @param {*} options\n     * @param {number} options.id\n     * @param {string} options.name\n     * @returns {*} A muxed stream\n     */\n\n  }, {\n    key: \"_newReceiverStream\",\n    value: function _newReceiverStream(_ref) {\n      var id = _ref.id,\n          name = _ref.name;\n      var registry = this._streams.receivers;\n      return this._newStream({\n        id: id,\n        name: name,\n        type: 'receiver',\n        registry: registry\n      });\n    }\n    /**\n     * Creates a new stream\n     * @private\n     * @param {object} options\n     * @param {number} options.id\n     * @param {string} options.name\n     * @param {string} options.type\n     * @param {Map<number, *>} options.registry A map of streams to their ids\n     * @returns {*} A muxed stream\n     */\n\n  }, {\n    key: \"_newStream\",\n    value: function _newStream(_ref2) {\n      var _this = this;\n\n      var id = _ref2.id,\n          name = _ref2.name,\n          type = _ref2.type,\n          registry = _ref2.registry;\n\n      if (registry.has(id)) {\n        throw new Error(\"\".concat(type, \" stream \").concat(id, \" already exists!\"));\n      }\n\n      log('new %s stream %s %s', type, id, name);\n\n      var send = function send(msg) {\n        if (log.enabled) {\n          log('%s stream %s %s send', type, id, name, _objectSpread(_objectSpread({}, msg), {}, {\n            type: MessageTypeNames[msg.type],\n            data: msg.data && msg.data.slice()\n          }));\n        }\n\n        return _this.source.push(msg);\n      };\n\n      var onEnd = function onEnd() {\n        log('%s stream %s %s ended', type, id, name);\n        registry.delete(id);\n        _this.onStreamEnd && _this.onStreamEnd(stream);\n      };\n\n      var stream = createStream({\n        id: id,\n        name: name,\n        send: send,\n        type: type,\n        onEnd: onEnd,\n        maxMsgSize: this._options.maxMsgSize\n      });\n      registry.set(id, stream);\n      return stream;\n    }\n    /**\n     * Creates a sink with an abortable source. Incoming messages will\n     * also have their size restricted. All messages will be varint decoded.\n     * @private\n     * @returns {*} Returns an iterable sink\n     */\n\n  }, {\n    key: \"_createSink\",\n    value: function _createSink() {\n      var _this2 = this;\n\n      return /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(source) {\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  if (_this2._options.signal) {\n                    source = abortable(source, _this2._options.signal);\n                  }\n\n                  _context2.prev = 1;\n                  _context2.next = 4;\n                  return pipe(source, Coder.decode, restrictSize(_this2._options.maxMsgSize), /*#__PURE__*/function () {\n                    var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(source) {\n                      var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, msgs, _iterator2, _step2, msg;\n\n                      return _regeneratorRuntime.wrap(function _callee$(_context) {\n                        while (1) {\n                          switch (_context.prev = _context.next) {\n                            case 0:\n                              _iteratorNormalCompletion = true;\n                              _didIteratorError = false;\n                              _context.prev = 2;\n                              _iterator = _asyncIterator(source);\n\n                            case 4:\n                              _context.next = 6;\n                              return _iterator.next();\n\n                            case 6:\n                              _step = _context.sent;\n                              _iteratorNormalCompletion = _step.done;\n                              _context.next = 10;\n                              return _step.value;\n\n                            case 10:\n                              _value = _context.sent;\n\n                              if (_iteratorNormalCompletion) {\n                                _context.next = 18;\n                                break;\n                              }\n\n                              msgs = _value;\n                              _iterator2 = _createForOfIteratorHelper(msgs);\n\n                              try {\n                                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                                  msg = _step2.value;\n\n                                  _this2._handleIncoming(msg);\n                                }\n                              } catch (err) {\n                                _iterator2.e(err);\n                              } finally {\n                                _iterator2.f();\n                              }\n\n                            case 15:\n                              _iteratorNormalCompletion = true;\n                              _context.next = 4;\n                              break;\n\n                            case 18:\n                              _context.next = 24;\n                              break;\n\n                            case 20:\n                              _context.prev = 20;\n                              _context.t0 = _context[\"catch\"](2);\n                              _didIteratorError = true;\n                              _iteratorError = _context.t0;\n\n                            case 24:\n                              _context.prev = 24;\n                              _context.prev = 25;\n\n                              if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                                _context.next = 29;\n                                break;\n                              }\n\n                              _context.next = 29;\n                              return _iterator.return();\n\n                            case 29:\n                              _context.prev = 29;\n\n                              if (!_didIteratorError) {\n                                _context.next = 32;\n                                break;\n                              }\n\n                              throw _iteratorError;\n\n                            case 32:\n                              return _context.finish(29);\n\n                            case 33:\n                              return _context.finish(24);\n\n                            case 34:\n                            case \"end\":\n                              return _context.stop();\n                          }\n                        }\n                      }, _callee, null, [[2, 20, 24, 34], [25,, 29, 33]]);\n                    }));\n\n                    return function (_x2) {\n                      return _ref4.apply(this, arguments);\n                    };\n                  }());\n\n                case 4:\n                  _context2.next = 10;\n                  break;\n\n                case 6:\n                  _context2.prev = 6;\n                  _context2.t0 = _context2[\"catch\"](1);\n                  log('error in sink', _context2.t0);\n                  return _context2.abrupt(\"return\", _this2.source.end(_context2.t0));\n\n                case 10:\n                  _this2.source.end();\n\n                case 11:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, null, [[1, 6]]);\n        }));\n\n        return function (_x) {\n          return _ref3.apply(this, arguments);\n        };\n      }();\n    }\n    /**\n     * Creates a source that restricts outgoing message sizes\n     * and varint encodes them.\n     * @private\n     * @returns {*} An iterable source\n     */\n\n  }, {\n    key: \"_createSource\",\n    value: function _createSource() {\n      var _this3 = this;\n\n      var onEnd = function onEnd(err) {\n        var _this3$_streams = _this3._streams,\n            initiators = _this3$_streams.initiators,\n            receivers = _this3$_streams.receivers; // Abort all the things!\n\n        var _iterator3 = _createForOfIteratorHelper(initiators.values()),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var s = _step3.value;\n            s.abort(err);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n\n        var _iterator4 = _createForOfIteratorHelper(receivers.values()),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var _s = _step4.value;\n\n            _s.abort(err);\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      };\n\n      var source = pushable({\n        onEnd: onEnd,\n        writev: true\n      });\n      return Object.assign(Coder.encode(source), {\n        push: source.push,\n        end: source.end,\n        return: source.return\n      });\n    }\n    /**\n     * @private\n     * @param {object} options\n     * @param {number} options.id\n     * @param {string} options.type\n     * @param {Buffer|BufferList} options.data\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_handleIncoming\",\n    value: function _handleIncoming(_ref5) {\n      var id = _ref5.id,\n          type = _ref5.type,\n          data = _ref5.data;\n\n      if (log.enabled) {\n        log('incoming message', {\n          id: id,\n          type: MessageTypeNames[type],\n          data: data.slice()\n        });\n      } // Create a new stream?\n\n\n      if (type === MessageTypes.NEW_STREAM && this.onStream) {\n        var _stream = this._newReceiverStream({\n          id: id,\n          name: data.toString()\n        });\n\n        return this.onStream(_stream);\n      }\n\n      var list = type & 1 ? this._streams.initiators : this._streams.receivers;\n      var stream = list.get(id);\n      if (!stream) return log('missing stream %s', id);\n\n      switch (type) {\n        case MessageTypes.MESSAGE_INITIATOR:\n        case MessageTypes.MESSAGE_RECEIVER:\n          stream.source.push(data);\n          break;\n\n        case MessageTypes.CLOSE_INITIATOR:\n        case MessageTypes.CLOSE_RECEIVER:\n          stream.close();\n          break;\n\n        case MessageTypes.RESET_INITIATOR:\n        case MessageTypes.RESET_RECEIVER:\n          stream.reset();\n          break;\n\n        default:\n          log('unknown message type %s', type);\n      }\n    }\n  }]);\n\n  return Mplex;\n}();\n\nMplex.multicodec = '/mplex/6.7.0';\nmodule.exports = Mplex;","map":null,"metadata":{},"sourceType":"script"}