{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport { Buffer } from \"buffer\";\nimport { XXHandshake } from \"./handshake-xx\";\nimport { decodePayload, getPeerIdFromPayload, verifySignedPayload } from \"./utils\";\nimport { logger, logLocalEphemeralKeys, logRemoteEphemeralKey, logRemoteStaticKey } from \"./logger\";\nimport { decode0, decode1 } from \"./encoder\";\nexport class XXFallbackHandshake extends XXHandshake {\n  constructor(isInitiator, payload, prologue, staticKeypair, connection, initialMsg, remotePeer, ephemeralKeys, handshake) {\n    super(isInitiator, payload, prologue, staticKeypair, connection, remotePeer, handshake);\n\n    _defineProperty(this, \"ephemeralKeys\", void 0);\n\n    _defineProperty(this, \"initialMsg\", void 0);\n\n    if (ephemeralKeys) {\n      this.ephemeralKeys = ephemeralKeys;\n    }\n\n    this.initialMsg = initialMsg;\n  } // stage 0\n\n\n  async propose() {\n    if (this.isInitiator) {\n      this.xx.sendMessage(this.session, Buffer.alloc(0), this.ephemeralKeys);\n      logger(\"XX Fallback Stage 0 - Initialized state as the first message was sent by initiator.\");\n      logLocalEphemeralKeys(this.session.hs.e);\n    } else {\n      logger(\"XX Fallback Stage 0 - Responder decoding initial msg from IK.\");\n      const receivedMessageBuffer = decode0(this.initialMsg);\n      const {\n        valid\n      } = this.xx.recvMessage(this.session, {\n        ne: receivedMessageBuffer.ne,\n        ns: Buffer.alloc(0),\n        ciphertext: Buffer.alloc(0)\n      });\n\n      if (!valid) {\n        throw new Error(\"xx fallback stage 0 decryption validation fail\");\n      }\n\n      logger(\"XX Fallback Stage 0 - Responder used received message from IK.\");\n      logRemoteEphemeralKey(this.session.hs.re);\n    }\n  } // stage 1\n\n\n  async exchange() {\n    if (this.isInitiator) {\n      const receivedMessageBuffer = decode1(this.initialMsg);\n      const {\n        plaintext,\n        valid\n      } = this.xx.recvMessage(this.session, receivedMessageBuffer);\n\n      if (!valid) {\n        throw new Error(\"xx fallback stage 1 decryption validation fail\");\n      }\n\n      logger('XX Fallback Stage 1 - Initiator used received message from IK.');\n      logRemoteEphemeralKey(this.session.hs.re);\n      logRemoteStaticKey(this.session.hs.rs);\n      logger(\"Initiator going to check remote's signature...\");\n\n      try {\n        const decodedPayload = await decodePayload(plaintext);\n        this.remotePeer = this.remotePeer || (await getPeerIdFromPayload(decodedPayload));\n        await verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);\n        this.setRemoteEarlyData(decodedPayload.data);\n      } catch (e) {\n        throw new Error(\"Error occurred while verifying signed payload from responder: \".concat(e.message));\n      }\n\n      logger(\"All good with the signature!\");\n    } else {\n      logger(\"XX Fallback Stage 1 - Responder start\");\n      await super.exchange();\n      logger(\"XX Fallback Stage 1 - Responder end\");\n    }\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}