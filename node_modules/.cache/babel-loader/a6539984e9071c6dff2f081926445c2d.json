{"ast":null,"code":"'use strict';\n\nconst errcode = require('err-code');\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst TimeCache = require('time-cache');\n\nconst pipe = require('it-pipe');\n\nconst lp = require('it-length-prefixed');\n\nconst pMap = require('p-map');\n\nconst {\n  GossipSubID\n} = require('../src/constants');\n\nconst floodsubMulticodec = '/floodsub/1.0.0';\n\nconst Pubsub = require('libp2p-pubsub');\n\nconst {\n  utils\n} = require('libp2p-pubsub');\n\nconst {\n  rpc\n} = require('./message');\n\nclass BasicPubSub extends Pubsub {\n  /**\n   * @param {Object} props\n   * @param {String} props.debugName log namespace\n   * @param {string} props.multicodec protocol identificer to connect\n   * @param {PeerInfo} props.peerInfo peer's peerInfo\n   * @param {Object} props.registrar registrar for libp2p protocols\n   * @param {function} props.registrar.handle\n   * @param {function} props.registrar.register\n   * @param {function} props.registrar.unregister\n   * @param {Object} [props.options]\n   * @param {bool} [props.options.emitSelf] if publish should emit to self, if subscribed, defaults to false\n   * @param {bool} [props.options.gossipIncoming] if incoming messages on a subscribed topic should be automatically gossiped, defaults to true\n   * @param {bool} [props.options.fallbackToFloodsub] if dial should fallback to floodsub, defaults to true\n   * @constructor\n   */\n  constructor({\n    debugName,\n    multicodec,\n    peerInfo,\n    registrar,\n    options = {}\n  }) {\n    const multicodecs = [multicodec];\n    const _options = {\n      emitSelf: false,\n      gossipIncoming: true,\n      fallbackToFloodsub: true,\n      ...options\n    }; // Also wants to get notified of peers connected using floodsub\n\n    if (_options.fallbackToFloodsub) {\n      multicodecs.push(floodsubMulticodec);\n    }\n\n    super({\n      debugName,\n      multicodecs,\n      peerInfo,\n      registrar,\n      ..._options\n    });\n    /**\n     * A set of subscriptions\n     */\n\n    this.subscriptions = new Set();\n    /**\n     * Cache of seen messages\n     *\n     * @type {TimeCache}\n     */\n\n    this.seenCache = new TimeCache();\n    /**\n     * Pubsub options\n     */\n\n    this._options = _options;\n    this._onRpc = this._onRpc.bind(this);\n    /**\n     * The default msgID implementation\n     * @param {rpc.RPC.Message} msg the message object\n     * @returns {string} message id as string\n     */\n\n    this.defaultMsgIdFn = msg => utils.msgId(msg.from, msg.seqno);\n  }\n  /**\n   * Peer connected successfully with pubsub protocol.\n   * @override\n   * @param {PeerInfo} peerInfo peer info\n   * @param {Connection} conn connection to the peer\n   * @returns {Promise<void>}\n   */\n\n\n  async _onPeerConnected(peerInfo, conn) {\n    await super._onPeerConnected(peerInfo, conn);\n    const idB58Str = peerInfo.id.toB58String();\n    const peer = this.peers.get(idB58Str);\n\n    if (peer && peer.isWritable) {\n      // Immediately send my own subscriptions to the newly established conn\n      peer.sendSubscriptions(this.subscriptions);\n    }\n  }\n  /**\n   * Overriding the implementation of _processConnection should keep the connection and is\n   * responsible for processing each RPC message received by other peers.\n   * @override\n   * @param {string} idB58Str peer id string in base58\n   * @param {Connection} conn connection\n   * @param {Peer} peer PubSub peer\n   * @returns {void}\n   *\n   */\n\n\n  async _processMessages(idB58Str, conn, peer) {\n    const onRpcFunc = this._onRpc;\n\n    try {\n      await pipe(conn, lp.decode(), async function (source) {\n        for await (const data of source) {\n          const rpcMsg = Buffer.isBuffer(data) ? data : data.slice();\n          onRpcFunc(idB58Str, rpc.RPC.decode(rpcMsg));\n        }\n      });\n    } catch (err) {\n      this._onPeerDisconnected(peer.info, err);\n    }\n  }\n  /**\n   * Handles an rpc request from a peer\n   *\n   * @param {String} idB58Str\n   * @param {Object} rpc\n   * @returns {void}\n   */\n\n\n  _onRpc(idB58Str, rpc) {\n    if (!rpc) {\n      return;\n    }\n\n    const peer = this.peers.get(idB58Str);\n\n    if (!peer) {\n      return;\n    }\n\n    this.log('rpc from', idB58Str);\n    const subs = rpc.subscriptions;\n    const msgs = rpc.msgs;\n\n    if (subs.length) {\n      // update peer subscriptions\n      peer.updateSubscriptions(subs);\n      subs.forEach(subOptMsg => {\n        const t = subOptMsg.topicID;\n\n        if (!this.topics.has(t)) {\n          this.topics.set(t, new Set());\n        }\n\n        const topicSet = this.topics.get(t);\n\n        if (subOptMsg.subscribe) {\n          // subscribe peer to new topic\n          topicSet.add(peer);\n        } else {\n          // unsubscribe from existing topic\n          topicSet.delete(peer);\n        }\n      });\n      this.emit('pubsub:subscription-change', peer.info, peer.topics, subs);\n    }\n\n    if (msgs.length) {\n      msgs.forEach(async message => {\n        const msg = utils.normalizeInRpcMessage(message);\n        const msgID = this.getMsgId(msg); // Ignore if we've already seen the message\n\n        if (this.seenCache.has(msgID)) {\n          return;\n        }\n\n        this.seenCache.put(msgID); // Ensure the message is valid before processing it\n\n        let isValid;\n        let error;\n\n        try {\n          isValid = await this.validate(message);\n        } catch (err) {\n          error = err;\n        }\n\n        if (error || !isValid) {\n          this.log('Message could not be validated, dropping it. isValid=%s', isValid, error);\n          return;\n        }\n\n        this._processRpcMessage(msg);\n      });\n    }\n\n    this._handleRpcControl(peer, rpc);\n  }\n  /**\n   * @param {rpc.RPC.Message} msg\n   */\n\n\n  _processRpcMessage(msg) {\n    if (this.peerInfo.id.toB58String() === msg.from && !this._options.emitSelf) {\n      return;\n    } // Emit to self\n\n\n    this._emitMessage(msg.topicIDs, msg);\n  }\n\n  _emitMessage(topics, message) {\n    topics.forEach(topic => {\n      if (this.subscriptions.has(topic)) {\n        this.emit(topic, message);\n      }\n    });\n  }\n\n  _handleRpcControl(peer, rpc) {\n    throw errcode(new Error('_handleRpcControl must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED');\n  }\n  /**\n   * Returns a buffer of a RPC message that contains a control message\n   * @param {Array<rpc.RPC.Message>} msgs\n   * @param {Array<rpc.RPC.ControlIHave>} ihave\n   * @param {Array<rpc.RPC.ControlIWant>} iwant\n   * @param {Array<rpc.RPC.ControlGraft>} graft\n   * @param {Array<rpc.RPC.Prune>} prune\n   * @returns {rpc.RPC}\n   */\n\n\n  _rpcWithControl(msgs = [], ihave = [], iwant = [], graft = [], prune = []) {\n    return {\n      subscriptions: [],\n      msgs: msgs,\n      control: {\n        ihave: ihave,\n        iwant: iwant,\n        graft: graft,\n        prune: prune\n      }\n    };\n  }\n  /**\n   * Unmounts the protocol and shuts down every connection\n   * @override\n   * @returns {void}\n   */\n\n\n  async stop() {\n    await super.stop();\n    this.subscriptions = new Set();\n  }\n  /**\n   * Subscribes to topics\n   * @override\n   * @param {Array<string>|string} topics\n   * @returns {void}\n   */\n\n\n  subscribe(topics) {\n    if (!this.started) {\n      throw new Error('Pubsub has not started');\n    }\n\n    topics = utils.ensureArray(topics);\n    const newTopics = topics.filter(topic => !this.subscriptions.has(topic));\n\n    if (newTopics.length === 0) {\n      return;\n    } // set subscriptions\n\n\n    newTopics.forEach(topic => {\n      this.subscriptions.add(topic);\n    }); // Broadcast SUBSCRIBE to all peers\n\n    this.peers.forEach(peer => sendSubscriptionsOnceReady(peer)); // make sure that Gossipsub is already mounted\n\n    function sendSubscriptionsOnceReady(peer) {\n      if (peer && peer.isWritable) {\n        return peer.sendSubscriptions(topics);\n      }\n\n      const onConnection = () => {\n        peer.removeListener('connection', onConnection);\n        sendSubscriptionsOnceReady(peer);\n      };\n\n      peer.on('connection', onConnection);\n      peer.once('close', () => peer.removeListener('connection', onConnection));\n    }\n\n    this.join(newTopics);\n  }\n\n  join(topics) {\n    throw errcode(new Error('join must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED');\n  }\n  /**\n   * Leaves a topic\n   * @override\n   * @param {Array<string>|string} topics\n   * @returns {void}\n   */\n\n\n  unsubscribe(topics) {\n    if (!this.started) {\n      throw new Error('Pubsub has not started');\n    }\n\n    topics = utils.ensureArray(topics);\n    const unTopics = topics.filter(topic => this.subscriptions.has(topic));\n\n    if (!unTopics.length) {\n      return;\n    } // delete subscriptions\n\n\n    unTopics.forEach(topic => {\n      this.subscriptions.delete(topic);\n    }); // Broadcast UNSUBSCRIBE to all peers ready\n\n    this.peers.forEach(peer => sendUnsubscriptionsOnceReady(peer)); // make sure that Gossipsub is already mounted\n\n    function sendUnsubscriptionsOnceReady(peer) {\n      if (peer && peer.isWritable) {\n        return peer.sendUnsubscriptions(topics);\n      }\n\n      const onConnection = () => {\n        peer.removeListener('connection', onConnection);\n        sendUnsubscriptionsOnceReady(peer);\n      };\n\n      peer.on('connection', onConnection);\n      peer.once('close', () => peer.removeListener('connection', onConnection));\n    }\n\n    this.leave(unTopics);\n  }\n\n  leave(topics) {\n    throw errcode(new Error('leave must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED');\n  }\n  /**\n   * Publishes messages to all subscribed peers\n   * @override\n   * @param {Array<string>|string} topics\n   * @param {Array<any>|any} messages\n   * @returns {void}\n   */\n\n\n  async publish(topics, messages) {\n    if (!this.started) {\n      throw new Error('Pubsub has not started');\n    }\n\n    this.log('publish', topics, messages);\n    topics = utils.ensureArray(topics);\n    messages = utils.ensureArray(messages);\n    const from = this.peerInfo.id.toB58String();\n\n    const buildMessage = (msg, cb) => {\n      const seqno = utils.randomSeqno();\n      const msgObj = {\n        from: from,\n        data: msg,\n        seqno: seqno,\n        topicIDs: topics\n      }; // put in seen cache\n\n      this.seenCache.put(msgObj.seqno); // Emit to self if I'm interested and emitSelf enabled\n\n      this._options.emitSelf && this._emitMessages(topics, [msgObj]);\n      return this._buildMessage(msgObj);\n    };\n\n    const msgObjects = await pMap(messages, buildMessage); // send to all the other peers\n\n    this._publish(utils.normalizeOutRpcMessages(msgObjects));\n  }\n  /**\n   * Get the list of topics which the peer is subscribed to.\n   * @override\n   * @returns {Array<String>}\n   */\n\n\n  getTopics() {\n    if (!this.started) {\n      throw new Error('Pubsub is not started');\n    }\n\n    return Array.from(this.subscriptions);\n  }\n  /**\n   * Child class can override this.\n   * @param {rpc.RPC.Message} msg the message object\n   * @returns {string} message id as string\n   */\n\n\n  getMsgId(msg) {\n    return this.defaultMsgIdFn(msg);\n  }\n\n  _emitMessages(topics, messages) {\n    topics.forEach(topic => {\n      if (!this.subscriptions.has(topic)) {\n        return;\n      }\n\n      messages.forEach(message => {\n        this.emit(topic, message);\n      });\n    });\n  }\n\n  _publish(rpcs) {\n    throw errcode(new Error('_publish must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED');\n  }\n  /**\n   * Given a topic, returns up to count peers subscribed to that topic\n   *\n   * @param {String} topic\n   * @param {Number} count\n   * @returns {Set<Peer>}\n   *\n   */\n\n\n  _getPeers(topic, count) {\n    const peersInTopic = this.topics.get(topic);\n\n    if (!peersInTopic) {\n      return new Set();\n    } // Adds all peers using our protocol\n\n\n    let peers = [];\n    peersInTopic.forEach(peer => {\n      if (peer.info.protocols.has(GossipSubID)) {\n        peers.push(peer);\n      }\n    }); // Pseudo-randomly shuffles peers\n\n    peers = this._shufflePeers(peers);\n\n    if (count > 0 && peers.length > count) {\n      peers = peers.slice(0, count);\n    }\n\n    return new Set(peers);\n  }\n  /**\n   * Pseudo-randomly shuffles peers\n   *\n   * @param {Array<Peers>} peers\n   * @returns {Array<Peers>}\n   */\n\n\n  _shufflePeers(peers) {\n    if (peers.length <= 1) {\n      return peers;\n    }\n\n    for (let i = 0; i < peers.length; i++) {\n      const randInt = () => {\n        return Math.floor(Math.random() * Math.floor(peers.length));\n      };\n\n      const j = randInt();\n      const tmp = peers[i];\n      peers[i] = peers[j];\n      peers[j] = tmp;\n      return peers;\n    }\n  }\n\n}\n\nmodule.exports = BasicPubSub;","map":null,"metadata":{},"sourceType":"script"}