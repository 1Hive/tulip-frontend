{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar fs = typeof window === 'object' || typeof self === 'object' ? null : eval('require(\"fs\")'); // eslint-disable-line\n\nvar level = require('level');\n\nvar crypto = require('libp2p-crypto');\n\nvar secp256k1 = require('secp256k1');\n\nvar LRU = require('lru');\n\nvar Buffer = require('safe-buffer/').Buffer;\n\nvar _require = require('./verifiers'),\n    verifier = _require.verifier;\n\nfunction createStore() {\n  var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : './keystore';\n\n  if (fs && fs.mkdirSync) {\n    fs.mkdirSync(path, {\n      recursive: true\n    });\n  }\n\n  return level(path);\n}\n\nvar verifiedCache = new LRU(1000);\n\nvar Keystore = /*#__PURE__*/function () {\n  function Keystore() {\n    var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Keystore);\n\n    if (typeof input === 'string') {\n      this._store = createStore(input);\n    } else if (typeof input.open === 'function') {\n      this._store = input;\n    } else if (typeof input.store === 'string') {\n      this._store = createStore(input.store);\n    } else {\n      this._store = input.store || createStore();\n    }\n\n    this._cache = input.cache || new LRU(100);\n  }\n\n  _createClass(Keystore, [{\n    key: \"open\",\n    value: function () {\n      var _open = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this._store) {\n                  _context.next = 4;\n                  break;\n                }\n\n                _context.next = 3;\n                return this._store.open();\n\n              case 3:\n                return _context.abrupt(\"return\", Promise.resolve());\n\n              case 4:\n                return _context.abrupt(\"return\", Promise.reject(new Error('Keystore: No store found to open')));\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function open() {\n        return _open.apply(this, arguments);\n      }\n\n      return open;\n    }()\n  }, {\n    key: \"close\",\n    value: function () {\n      var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (this._store) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 2:\n                _context2.next = 4;\n                return this._store.close();\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function close() {\n        return _close.apply(this, arguments);\n      }\n\n      return close;\n    }()\n  }, {\n    key: \"hasKey\",\n    value: function () {\n      var _hasKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(id) {\n        var hasKey, storedKey;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (id) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                throw new Error('id needed to check a key');\n\n              case 2:\n                if (!(this._store.status && this._store.status !== 'open')) {\n                  _context3.next = 4;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", Promise.resolve(null));\n\n              case 4:\n                hasKey = false;\n                _context3.prev = 5;\n                _context3.t0 = this._cache.get(id);\n\n                if (_context3.t0) {\n                  _context3.next = 11;\n                  break;\n                }\n\n                _context3.next = 10;\n                return this._store.get(id);\n\n              case 10:\n                _context3.t0 = _context3.sent;\n\n              case 11:\n                storedKey = _context3.t0;\n                hasKey = storedKey !== undefined && storedKey !== null;\n                _context3.next = 18;\n                break;\n\n              case 15:\n                _context3.prev = 15;\n                _context3.t1 = _context3[\"catch\"](5);\n                // Catches 'Error: ENOENT: no such file or directory, open <path>'\n                console.error('Error: ENOENT: no such file or directory');\n\n              case 18:\n                return _context3.abrupt(\"return\", hasKey);\n\n              case 19:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[5, 15]]);\n      }));\n\n      function hasKey(_x) {\n        return _hasKey.apply(this, arguments);\n      }\n\n      return hasKey;\n    }()\n  }, {\n    key: \"createKey\",\n    value: function () {\n      var _createKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(id) {\n        var genKeyPair, keys, decompressedKey, key;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (id) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                throw new Error('id needed to create a key');\n\n              case 2:\n                if (!(this._store.status && this._store.status !== 'open')) {\n                  _context4.next = 4;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", Promise.resolve(null));\n\n              case 4:\n                genKeyPair = function genKeyPair() {\n                  return new Promise(function (resolve, reject) {\n                    crypto.keys.generateKeyPair('secp256k1', 256, function (err, key) {\n                      if (!err) {\n                        resolve(key);\n                      }\n\n                      reject(err);\n                    });\n                  });\n                };\n\n                _context4.next = 7;\n                return genKeyPair();\n\n              case 7:\n                keys = _context4.sent;\n                decompressedKey = Buffer.from(secp256k1.publicKeyConvert(keys.public.marshal(), false));\n                key = {\n                  publicKey: decompressedKey.toString('hex'),\n                  privateKey: keys.marshal().toString('hex')\n                };\n                _context4.prev = 10;\n                _context4.next = 13;\n                return this._store.put(id, JSON.stringify(key));\n\n              case 13:\n                _context4.next = 18;\n                break;\n\n              case 15:\n                _context4.prev = 15;\n                _context4.t0 = _context4[\"catch\"](10);\n                console.log(_context4.t0);\n\n              case 18:\n                this._cache.set(id, key);\n\n                return _context4.abrupt(\"return\", keys);\n\n              case 20:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[10, 15]]);\n      }));\n\n      function createKey(_x2) {\n        return _createKey.apply(this, arguments);\n      }\n\n      return createKey;\n    }()\n  }, {\n    key: \"getKey\",\n    value: function () {\n      var _getKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(id) {\n        var cachedKey, storedKey, deserializedKey, genPrivKey;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (id) {\n                  _context5.next = 2;\n                  break;\n                }\n\n                throw new Error('id needed to get a key');\n\n              case 2:\n                if (this._store) {\n                  _context5.next = 5;\n                  break;\n                }\n\n                _context5.next = 5;\n                return this.open();\n\n              case 5:\n                if (!(this._store.status && this._store.status !== 'open')) {\n                  _context5.next = 7;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", Promise.resolve(null));\n\n              case 7:\n                cachedKey = this._cache.get(id);\n                _context5.prev = 8;\n                _context5.t0 = cachedKey;\n\n                if (_context5.t0) {\n                  _context5.next = 14;\n                  break;\n                }\n\n                _context5.next = 13;\n                return this._store.get(id);\n\n              case 13:\n                _context5.t0 = _context5.sent;\n\n              case 14:\n                storedKey = _context5.t0;\n                _context5.next = 19;\n                break;\n\n              case 17:\n                _context5.prev = 17;\n                _context5.t1 = _context5[\"catch\"](8);\n\n              case 19:\n                if (storedKey) {\n                  _context5.next = 21;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\");\n\n              case 21:\n                deserializedKey = cachedKey || JSON.parse(storedKey);\n\n                if (deserializedKey) {\n                  _context5.next = 24;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\");\n\n              case 24:\n                if (!cachedKey) {\n                  this._cache.set(id, deserializedKey);\n                }\n\n                genPrivKey = function genPrivKey(pk) {\n                  return new Promise(function (resolve, reject) {\n                    crypto.keys.supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(pk, function (err, key) {\n                      if (!err) {\n                        resolve(key);\n                      }\n\n                      reject(err);\n                    });\n                  });\n                };\n\n                return _context5.abrupt(\"return\", genPrivKey(Buffer.from(deserializedKey.privateKey, 'hex')));\n\n              case 27:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[8, 17]]);\n      }));\n\n      function getKey(_x3) {\n        return _getKey.apply(this, arguments);\n      }\n\n      return getKey;\n    }()\n  }, {\n    key: \"sign\",\n    value: function () {\n      var _sign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(key, data) {\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (key) {\n                  _context6.next = 2;\n                  break;\n                }\n\n                throw new Error('No signing key given');\n\n              case 2:\n                if (data) {\n                  _context6.next = 4;\n                  break;\n                }\n\n                throw new Error('Given input data was undefined');\n\n              case 4:\n                if (!Buffer.isBuffer(data)) {\n                  data = Buffer.from(data);\n                }\n\n                return _context6.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  key.sign(data, function (err, signature) {\n                    if (!err) {\n                      resolve(signature.toString('hex'));\n                    }\n\n                    reject(err);\n                  });\n                }));\n\n              case 6:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6);\n      }));\n\n      function sign(_x4, _x5) {\n        return _sign.apply(this, arguments);\n      }\n\n      return sign;\n    }()\n  }, {\n    key: \"getPublic\",\n    value: function getPublic(keys) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var formats = ['hex', 'buffer'];\n      var decompress = typeof options.decompress === 'undefined' ? true : options.decompress;\n      var format = options.format || 'hex';\n\n      if (formats.indexOf(format) === -1) {\n        throw new Error('Supported formats are `hex` and `buffer`');\n      }\n\n      var pubKey = keys.public.marshal();\n\n      if (decompress) {\n        pubKey = Buffer.from(secp256k1.publicKeyConvert(pubKey, false));\n      }\n\n      return format === 'buffer' ? pubKey : pubKey.toString('hex');\n    }\n  }, {\n    key: \"verify\",\n    value: function () {\n      var _verify = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(signature, publicKey, data) {\n        var v,\n            _args7 = arguments;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                v = _args7.length > 3 && _args7[3] !== undefined ? _args7[3] : 'v1';\n                return _context7.abrupt(\"return\", Keystore.verify(signature, publicKey, data, v));\n\n              case 2:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7);\n      }));\n\n      function verify(_x6, _x7, _x8) {\n        return _verify.apply(this, arguments);\n      }\n\n      return verify;\n    }()\n  }], [{\n    key: \"verify\",\n    value: function () {\n      var _verify2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(signature, publicKey, data) {\n        var v,\n            cached,\n            res,\n            verified,\n            compare,\n            _args8 = arguments;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                v = _args8.length > 3 && _args8[3] !== undefined ? _args8[3] : 'v1';\n                cached = verifiedCache.get(signature);\n                res = false;\n\n                if (cached) {\n                  _context8.next = 11;\n                  break;\n                }\n\n                _context8.next = 6;\n                return verifier(v).verify(signature, publicKey, data);\n\n              case 6:\n                verified = _context8.sent;\n                res = verified;\n\n                if (verified) {\n                  verifiedCache.set(signature, {\n                    publicKey: publicKey,\n                    data: data\n                  });\n                }\n\n                _context8.next = 13;\n                break;\n\n              case 11:\n                compare = function compare(cached, data, v) {\n                  var match;\n\n                  if (v === 'v0') {\n                    match = Buffer.compare(Buffer.alloc(30, cached), Buffer.alloc(30, data)) === 0;\n                  } else {\n                    match = Buffer.isBuffer(data) ? Buffer.compare(cached, data) === 0 : cached === data;\n                  }\n\n                  return match;\n                };\n\n                res = cached.publicKey === publicKey && compare(cached.data, data, v);\n\n              case 13:\n                return _context8.abrupt(\"return\", res);\n\n              case 14:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8);\n      }));\n\n      function verify(_x9, _x10, _x11) {\n        return _verify2.apply(this, arguments);\n      }\n\n      return verify;\n    }()\n  }]);\n\n  return Keystore;\n}();\n\nmodule.exports = Keystore;","map":null,"metadata":{},"sourceType":"script"}