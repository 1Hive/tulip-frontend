{"ast":null,"code":"'use strict';\n\nconst errcode = require('err-code');\n\nconst mergeOptions = require('merge-options');\n\nconst LatencyMonitor = require('./latency-monitor');\n\nconst debug = require('debug')('libp2p:connection-manager');\n\nconst retimer = require('retimer');\n\nconst {\n  ERR_INVALID_PARAMETERS\n} = require('../errors');\n\nconst defaultOptions = {\n  maxConnections: Infinity,\n  minConnections: 0,\n  maxData: Infinity,\n  maxSentData: Infinity,\n  maxReceivedData: Infinity,\n  maxEventLoopDelay: Infinity,\n  pollInterval: 2000,\n  movingAverageInterval: 60000,\n  defaultPeerValue: 1\n};\n\nclass ConnectionManager {\n  /**\n   * @constructor\n   * @param {Libp2p} libp2p\n   * @param {object} options\n   * @param {Number} options.maxConnections The maximum number of connections allowed. Default=Infinity\n   * @param {Number} options.minConnections The minimum number of connections to avoid pruning. Default=0\n   * @param {Number} options.maxData The max data (in and out), per average interval to allow. Default=Infinity\n   * @param {Number} options.maxSentData The max outgoing data, per average interval to allow. Default=Infinity\n   * @param {Number} options.maxReceivedData The max incoming data, per average interval to allow.. Default=Infinity\n   * @param {Number} options.maxEventLoopDelay The upper limit the event loop can take to run. Default=Infinity\n   * @param {Number} options.pollInterval How often, in milliseconds, metrics and latency should be checked. Default=2000\n   * @param {Number} options.movingAverageInterval How often, in milliseconds, to compute averages. Default=60000\n   * @param {Number} options.defaultPeerValue The value of the peer. Default=1\n   */\n  constructor(libp2p, options) {\n    this._libp2p = libp2p;\n    this._registrar = libp2p.registrar;\n    this._peerId = libp2p.peerInfo.id.toB58String();\n    this._options = mergeOptions.call({\n      ignoreUndefined: true\n    }, defaultOptions, options);\n\n    if (this._options.maxConnections < this._options.minConnections) {\n      throw errcode(new Error('Connection Manager maxConnections must be greater than minConnections'), ERR_INVALID_PARAMETERS);\n    }\n\n    debug('options: %j', this._options);\n    this._metrics = libp2p.metrics;\n    this._peerValues = new Map();\n    this._connections = new Map();\n    this._timer = null;\n    this._checkMetrics = this._checkMetrics.bind(this);\n  }\n  /**\n   * Starts the Connection Manager. If Metrics are not enabled on libp2p\n   * only event loop and connection limits will be monitored.\n   */\n\n\n  start() {\n    if (this._metrics) {\n      this._timer = this._timer || retimer(this._checkMetrics, this._options.pollInterval);\n    } // latency monitor\n\n\n    this._latencyMonitor = new LatencyMonitor({\n      latencyCheckIntervalMs: this._options.pollInterval,\n      dataEmitIntervalMs: this._options.pollInterval\n    });\n    this._onLatencyMeasure = this._onLatencyMeasure.bind(this);\n\n    this._latencyMonitor.on('data', this._onLatencyMeasure);\n\n    debug('started');\n  }\n  /**\n   * Stops the Connection Manager\n   */\n\n\n  stop() {\n    this._timer && this._timer.clear();\n    this._latencyMonitor && this._latencyMonitor.removeListener('data', this._onLatencyMeasure);\n    debug('stopped');\n  }\n  /**\n   * Sets the value of the given peer. Peers with lower values\n   * will be disconnected first.\n   * @param {PeerId} peerId\n   * @param {number} value A number between 0 and 1\n   */\n\n\n  setPeerValue(peerId, value) {\n    if (value < 0 || value > 1) {\n      throw new Error('value should be a number between 0 and 1');\n    }\n\n    if (peerId.toB58String) {\n      peerId = peerId.toB58String();\n    }\n\n    this._peerValues.set(peerId, value);\n  }\n  /**\n   * Checks the libp2p metrics to determine if any values have exceeded\n   * the configured maximums.\n   * @private\n   */\n\n\n  _checkMetrics() {\n    const movingAverages = this._metrics.global.movingAverages;\n\n    const received = movingAverages.dataReceived[this._options.movingAverageInterval].movingAverage();\n\n    this._checkLimit('maxReceivedData', received);\n\n    const sent = movingAverages.dataSent[this._options.movingAverageInterval].movingAverage();\n\n    this._checkLimit('maxSentData', sent);\n\n    const total = received + sent;\n\n    this._checkLimit('maxData', total);\n\n    debug('metrics update', total);\n\n    this._timer.reschedule(this._options.pollInterval);\n  }\n  /**\n   * Tracks the incoming connection and check the connection limit\n   * @param {Connection} connection\n   */\n\n\n  onConnect(connection) {\n    const peerId = connection.remotePeer.toB58String();\n\n    this._connections.set(connection.id, connection);\n\n    if (!this._peerValues.has(peerId)) {\n      this._peerValues.set(peerId, this._options.defaultPeerValue);\n    }\n\n    this._checkLimit('maxConnections', this._connections.size);\n  }\n  /**\n   * Removes the connection from tracking\n   * @param {Connection} connection\n   */\n\n\n  onDisconnect(connection) {\n    this._connections.delete(connection.id);\n\n    this._peerValues.delete(connection.remotePeer.toB58String());\n  }\n  /**\n   * If the event loop is slow, maybe close a connection\n   * @private\n   * @param {*} summary The LatencyMonitor summary\n   */\n\n\n  _onLatencyMeasure(summary) {\n    this._checkLimit('maxEventLoopDelay', summary.avgMs);\n  }\n  /**\n   * If the `value` of `name` has exceeded its limit, maybe close a connection\n   * @private\n   * @param {string} name The name of the field to check limits for\n   * @param {number} value The current value of the field\n   */\n\n\n  _checkLimit(name, value) {\n    const limit = this._options[name];\n    debug('checking limit of %s. current value: %d of %d', name, value, limit);\n\n    if (value > limit) {\n      debug('%s: limit exceeded: %s, %d', this._peerId, name, value);\n\n      this._maybeDisconnectOne();\n    }\n  }\n  /**\n   * If we have more connections than our maximum, close a connection\n   * to the lowest valued peer.\n   * @private\n   */\n\n\n  _maybeDisconnectOne() {\n    if (this._options.minConnections < this._connections.size) {\n      const peerValues = Array.from(this._peerValues).sort(byPeerValue);\n      debug('%s: sorted peer values: %j', this._peerId, peerValues);\n      const disconnectPeer = peerValues[0];\n\n      if (disconnectPeer) {\n        const peerId = disconnectPeer[0];\n        debug('%s: lowest value peer is %s', this._peerId, peerId);\n        debug('%s: closing a connection to %j', this._peerId, peerId);\n\n        for (const connection of this._connections.values()) {\n          if (connection.remotePeer.toB58String() === peerId) {\n            connection.close();\n            break;\n          }\n        }\n      }\n    }\n  }\n\n}\n\nmodule.exports = ConnectionManager;\n\nfunction byPeerValue(peerValueEntryA, peerValueEntryB) {\n  return peerValueEntryA[1] - peerValueEntryB[1];\n}","map":null,"metadata":{},"sourceType":"script"}