{"ast":null,"code":"import _slicedToArray from \"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _regeneratorRuntime from \"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport x25519 from 'bcrypto/lib/js/x25519';\nimport { Buffer } from \"buffer\";\nimport Wrap from 'it-pb-rpc';\nimport DuplexPair from 'it-pair/duplex';\nimport ensureBuffer from 'it-buffer';\nimport pipe from 'it-pipe';\nimport { encode, decode } from 'it-length-prefixed';\nimport { XXHandshake } from \"./handshake-xx\";\nimport { IKHandshake } from \"./handshake-ik\";\nimport { XXFallbackHandshake } from \"./handshake-xx-fallback\";\nimport { generateKeypair, getPayload } from \"./utils\";\nimport { uint16BEDecode, uint16BEEncode } from \"./encoder\";\nimport { decryptStream, encryptStream } from \"./crypto\";\nimport { KeyCache } from \"./keycache\";\nimport { logger } from \"./logger\";\nimport { NOISE_MSG_MAX_LENGTH_BYTES } from \"./constants\";\nexport var Noise = /*#__PURE__*/function () {\n  /**\n   *\n   * @param staticNoiseKey x25519 private key, reuse for faster handshakes\n   * @param earlyData\n   */\n  function Noise(staticNoiseKey, earlyData) {\n    _classCallCheck(this, Noise);\n\n    _defineProperty(this, \"protocol\", \"/noise\");\n\n    _defineProperty(this, \"prologue\", Buffer.alloc(0));\n\n    _defineProperty(this, \"staticKeys\", void 0);\n\n    _defineProperty(this, \"earlyData\", void 0);\n\n    _defineProperty(this, \"useNoisePipes\", void 0);\n\n    this.earlyData = earlyData || Buffer.alloc(0); //disabled until properly specked\n\n    this.useNoisePipes = false;\n\n    if (staticNoiseKey) {\n      var publicKey = x25519.publicKeyCreate(staticNoiseKey);\n      this.staticKeys = {\n        privateKey: staticNoiseKey,\n        publicKey: publicKey\n      };\n    } else {\n      this.staticKeys = generateKeypair();\n    }\n  }\n  /**\n   * Encrypt outgoing data to the remote party (handshake as initiator)\n   * @param {PeerId} localPeer - PeerId of the receiving peer\n   * @param connection - streaming iterable duplex that will be encrypted\n   * @param {PeerId} remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer.\n   * @returns {Promise<SecureOutbound>}\n   */\n\n\n  _createClass(Noise, [{\n    key: \"secureOutbound\",\n    value: function () {\n      var _secureOutbound = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(localPeer, connection, remotePeer) {\n        var wrappedConnection, handshake, conn;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                wrappedConnection = Wrap(connection, {\n                  lengthEncoder: uint16BEEncode,\n                  lengthDecoder: uint16BEDecode,\n                  maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES\n                });\n                _context.next = 3;\n                return this.performHandshake({\n                  connection: wrappedConnection,\n                  isInitiator: true,\n                  localPeer: localPeer,\n                  remotePeer: remotePeer\n                });\n\n              case 3:\n                handshake = _context.sent;\n                _context.next = 6;\n                return this.createSecureConnection(wrappedConnection, handshake);\n\n              case 6:\n                conn = _context.sent;\n                return _context.abrupt(\"return\", {\n                  conn: conn,\n                  remoteEarlyData: handshake.remoteEarlyData,\n                  remotePeer: handshake.remotePeer\n                });\n\n              case 8:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function secureOutbound(_x, _x2, _x3) {\n        return _secureOutbound.apply(this, arguments);\n      }\n\n      return secureOutbound;\n    }()\n    /**\n     * Decrypt incoming data (handshake as responder).\n     * @param {PeerId} localPeer - PeerId of the receiving peer.\n     * @param connection - streaming iterable duplex that will be encryption.\n     * @param {PeerId} remotePeer - optional PeerId of the initiating peer, if known. This may only exist during transport upgrades.\n     * @returns {Promise<SecureOutbound>}\n     */\n\n  }, {\n    key: \"secureInbound\",\n    value: function () {\n      var _secureInbound = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(localPeer, connection, remotePeer) {\n        var wrappedConnection, handshake, conn;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                wrappedConnection = Wrap(connection, {\n                  lengthEncoder: uint16BEEncode,\n                  lengthDecoder: uint16BEDecode,\n                  maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES\n                });\n                _context2.next = 3;\n                return this.performHandshake({\n                  connection: wrappedConnection,\n                  isInitiator: false,\n                  localPeer: localPeer,\n                  remotePeer: remotePeer\n                });\n\n              case 3:\n                handshake = _context2.sent;\n                _context2.next = 6;\n                return this.createSecureConnection(wrappedConnection, handshake);\n\n              case 6:\n                conn = _context2.sent;\n                return _context2.abrupt(\"return\", {\n                  conn: conn,\n                  remoteEarlyData: handshake.remoteEarlyData,\n                  remotePeer: handshake.remotePeer\n                });\n\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function secureInbound(_x4, _x5, _x6) {\n        return _secureInbound.apply(this, arguments);\n      }\n\n      return secureInbound;\n    }()\n    /**\n     * If Noise pipes supported, tries IK handshake first with XX as fallback if it fails.\n     * If noise pipes disabled or remote peer static key is unknown, use XX.\n     * @param params\n     */\n\n  }, {\n    key: \"performHandshake\",\n    value: function () {\n      var _performHandshake = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(params) {\n        var payload, tryIK, remotePeer, connection, isInitiator, ikHandshake, ephemeralKeys;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return getPayload(params.localPeer, this.staticKeys.publicKey, this.earlyData);\n\n              case 2:\n                payload = _context3.sent;\n                tryIK = this.useNoisePipes;\n\n                if (params.isInitiator && KeyCache.load(params.remotePeer) === null) {\n                  //if we are initiator and remote static key is unknown, don't try IK\n                  tryIK = false;\n                } // Try IK if acting as responder or initiator that has remote's static key.\n\n\n                if (!tryIK) {\n                  _context3.next = 22;\n                  break;\n                }\n\n                // Try IK first\n                remotePeer = params.remotePeer, connection = params.connection, isInitiator = params.isInitiator;\n                ikHandshake = new IKHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, //safe to cast as we did checks\n                KeyCache.load(params.remotePeer) || Buffer.alloc(32), remotePeer);\n                _context3.prev = 8;\n                _context3.next = 11;\n                return this.performIKHandshake(ikHandshake);\n\n              case 11:\n                return _context3.abrupt(\"return\", _context3.sent);\n\n              case 14:\n                _context3.prev = 14;\n                _context3.t0 = _context3[\"catch\"](8);\n\n                // IK failed, go to XX fallback\n                if (params.isInitiator) {\n                  ephemeralKeys = ikHandshake.getLocalEphemeralKeys();\n                }\n\n                _context3.next = 19;\n                return this.performXXFallbackHandshake(params, payload, _context3.t0.initialMsg, ephemeralKeys);\n\n              case 19:\n                return _context3.abrupt(\"return\", _context3.sent);\n\n              case 20:\n                _context3.next = 25;\n                break;\n\n              case 22:\n                _context3.next = 24;\n                return this.performXXHandshake(params, payload);\n\n              case 24:\n                return _context3.abrupt(\"return\", _context3.sent);\n\n              case 25:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[8, 14]]);\n      }));\n\n      function performHandshake(_x7) {\n        return _performHandshake.apply(this, arguments);\n      }\n\n      return performHandshake;\n    }()\n  }, {\n    key: \"performXXFallbackHandshake\",\n    value: function () {\n      var _performXXFallbackHandshake = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(params, payload, initialMsg, ephemeralKeys) {\n        var isInitiator, remotePeer, connection, handshake;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                isInitiator = params.isInitiator, remotePeer = params.remotePeer, connection = params.connection;\n                handshake = new XXFallbackHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, initialMsg, remotePeer, ephemeralKeys);\n                _context4.prev = 2;\n                _context4.next = 5;\n                return handshake.propose();\n\n              case 5:\n                _context4.next = 7;\n                return handshake.exchange();\n\n              case 7:\n                _context4.next = 9;\n                return handshake.finish();\n\n              case 9:\n                _context4.next = 15;\n                break;\n\n              case 11:\n                _context4.prev = 11;\n                _context4.t0 = _context4[\"catch\"](2);\n                logger(_context4.t0);\n                throw new Error(\"Error occurred during XX Fallback handshake: \".concat(_context4.t0.message));\n\n              case 15:\n                return _context4.abrupt(\"return\", handshake);\n\n              case 16:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[2, 11]]);\n      }));\n\n      function performXXFallbackHandshake(_x8, _x9, _x10, _x11) {\n        return _performXXFallbackHandshake.apply(this, arguments);\n      }\n\n      return performXXFallbackHandshake;\n    }()\n  }, {\n    key: \"performXXHandshake\",\n    value: function () {\n      var _performXXHandshake = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(params, payload) {\n        var isInitiator, remotePeer, connection, handshake;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                isInitiator = params.isInitiator, remotePeer = params.remotePeer, connection = params.connection;\n                handshake = new XXHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, remotePeer);\n                _context5.prev = 2;\n                _context5.next = 5;\n                return handshake.propose();\n\n              case 5:\n                _context5.next = 7;\n                return handshake.exchange();\n\n              case 7:\n                _context5.next = 9;\n                return handshake.finish();\n\n              case 9:\n                if (this.useNoisePipes && handshake.remotePeer) {\n                  KeyCache.store(handshake.remotePeer, handshake.getRemoteStaticKey());\n                }\n\n                _context5.next = 15;\n                break;\n\n              case 12:\n                _context5.prev = 12;\n                _context5.t0 = _context5[\"catch\"](2);\n                throw new Error(\"Error occurred during XX handshake: \".concat(_context5.t0.message));\n\n              case 15:\n                return _context5.abrupt(\"return\", handshake);\n\n              case 16:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[2, 12]]);\n      }));\n\n      function performXXHandshake(_x12, _x13) {\n        return _performXXHandshake.apply(this, arguments);\n      }\n\n      return performXXHandshake;\n    }()\n  }, {\n    key: \"performIKHandshake\",\n    value: function () {\n      var _performIKHandshake = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(handshake) {\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return handshake.stage0();\n\n              case 2:\n                _context6.next = 4;\n                return handshake.stage1();\n\n              case 4:\n                return _context6.abrupt(\"return\", handshake);\n\n              case 5:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6);\n      }));\n\n      function performIKHandshake(_x14) {\n        return _performIKHandshake.apply(this, arguments);\n      }\n\n      return performIKHandshake;\n    }()\n  }, {\n    key: \"createSecureConnection\",\n    value: function () {\n      var _createSecureConnection = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(connection, handshake) {\n        var _DuplexPair, _DuplexPair2, secure, user, network;\n\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                // Create encryption box/unbox wrapper\n                _DuplexPair = DuplexPair(), _DuplexPair2 = _slicedToArray(_DuplexPair, 2), secure = _DuplexPair2[0], user = _DuplexPair2[1];\n                network = connection.unwrap();\n                pipe(secure, // write to wrapper\n                ensureBuffer, // ensure any type of data is converted to buffer\n                encryptStream(handshake), // data is encrypted\n                encode({\n                  lengthEncoder: uint16BEEncode\n                }), // prefix with message length\n                network, // send to the remote peer\n                decode({\n                  lengthDecoder: uint16BEDecode\n                }), // read message length prefix\n                ensureBuffer, // ensure any type of data is converted to buffer\n                decryptStream(handshake), // decrypt the incoming data\n                secure // pipe to the wrapper\n                );\n                return _context7.abrupt(\"return\", user);\n\n              case 4:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7);\n      }));\n\n      function createSecureConnection(_x15, _x16) {\n        return _createSecureConnection.apply(this, arguments);\n      }\n\n      return createSecureConnection;\n    }()\n  }]);\n\n  return Noise;\n}();","map":null,"metadata":{},"sourceType":"module"}