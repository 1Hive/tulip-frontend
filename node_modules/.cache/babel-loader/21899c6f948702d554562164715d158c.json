{"ast":null,"code":"import _regeneratorRuntime from\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _objectSpread from\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _asyncToGenerator from\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import env from'../environment';import{providers as Providers,utils}from'ethers';import{InvalidURI,InvalidNetworkType,NoConnection}from'../errors';import{validHttpFormat}from'./uri-utils';var keccak256=utils.id,soliditySha3=utils.solidityKeccak256,toUtf8String=utils.toUtf8String;export var DEFAULT_LOCAL_CHAIN='private';export var ZERO_ADDRESS=\"0x\".concat(''.padEnd(40,'0'));export var ETH_FAKE_ADDRESS=ZERO_ADDRESS;var ETH_ADDRESS_SPLIT_REGEX=/(0x[a-fA-F0-9]{40}(?:\\b|\\.|,|\\?|!|;))/g;var ETH_ADDRESS_TEST_REGEX=/(0x[a-fA-F0-9]{40}(?:\\b|\\.|,|\\?|!|;))/g;export function getFunctionSignature(func){return keccak256(func).slice(0,10);}export function encodeFunctionData(contract,functionName,params){return contract.interface.encodeFunctionData(functionName,params);}export function getUseWalletProviders(){var providers=[{id:'injected'}];if(env('FORTMATIC_API_KEY')){providers.push({id:'fortmatic',useWalletConf:{apiKey:env('FORTMATIC_API_KEY')}});}if(env('PORTIS_DAPP_ID')){providers.push({id:'portis',useWalletConf:{dAppId:env('PORTIS_DAPP_ID')}});}return providers;}export function getUseWalletConnectors(){return getUseWalletProviders().reduce(function(connectors,provider){if(provider.useWalletConf){connectors[provider.id]=provider.useWalletConf;}return connectors;},{});}function toChecksumAddress(address){if(!/^(0x)?[0-9a-f]{40}$/i.test(address)){throw new Error('Given address \"'+address+'\" is not a valid Ethereum address.');}address=address.toLowerCase().replace(/^0x/i,'');var addressHash=keccak256(address).replace(/^0x/i,'');var checksumAddress='0x';for(var i=0;i<address.length;i++){// If ith character is 9 to f then make it uppercase\nif(parseInt(addressHash[i],16)>7){checksumAddress+=address[i].toUpperCase();}else{checksumAddress+=address[i];}}return checksumAddress;}// Check address equality with checksums\nexport function addressesEqual(first,second){first=first&&toChecksumAddress(first);second=second&&toChecksumAddress(second);return first===second;}export var addressPattern='(0x)?[0-9a-fA-F]{40}';/**\r\n * Shorten an Ethereum address. `charsLength` allows to change the number of\r\n * characters on both sides of the ellipsis.\r\n *\r\n * Examples:\r\n *   shortenAddress('0x19731977931271')    // 0x1973…1271\r\n *   shortenAddress('0x19731977931271', 2) // 0x19…71\r\n *   shortenAddress('0x197319')            // 0x197319 (already short enough)\r\n *\r\n * @param {string} address The address to shorten\r\n * @param {number} [charsLength=4] The number of characters to change on both sides of the ellipsis\r\n * @returns {string} The shortened address\r\n */export function shortenAddress(address){var charsLength=arguments.length>1&&arguments[1]!==undefined?arguments[1]:4;var prefixLength=2;// \"0x\"\nif(!address){return'';}if(address.length<charsLength*2+prefixLength){return address;}return address.slice(0,charsLength+prefixLength)+'…'+address.slice(-charsLength);}export function getNetworkType(){var chainId=arguments.length>0&&arguments[0]!==undefined?arguments[0]:env('CHAIN_ID');chainId=String(chainId);if(chainId==='1')return'main';if(chainId==='3')return'ropsten';if(chainId==='4')return'rinkeby';if(chainId==='100')return'xdai';return DEFAULT_LOCAL_CHAIN;}export function getNetworkName(){var chainId=arguments.length>0&&arguments[0]!==undefined?arguments[0]:env('CHAIN_ID');chainId=String(chainId);if(chainId==='1')return'Mainnet';if(chainId==='3')return'Ropsten';if(chainId==='4')return'Rinkeby';if(chainId==='100')return'xDai';return'unknown';}export function sanitizeNetworkType(networkType){if(networkType==='private'){return'localhost';}else if(networkType==='main'){return'mainnet';}return networkType;}export function isLocalOrUnknownNetwork(){var chainId=arguments.length>0&&arguments[0]!==undefined?arguments[0]:env('CHAIN_ID');return getNetworkType(chainId)===DEFAULT_LOCAL_CHAIN;}// Detect Ethereum addresses in a string and transform each part.\n//\n// `callback` is called on every part with two params:\n//   - The string of the current part.\n//   - A boolean indicating if it is an address.\n//\nexport function transformAddresses(str,callback){return str.split(ETH_ADDRESS_SPLIT_REGEX).map(function(part,index){return callback(part,ETH_ADDRESS_TEST_REGEX.test(part),index);});}/**\r\n * Check if the ETH node at the given URI is compatible for the current environment\r\n * @param {string} uri URI of the ETH node.\r\n * @param {string} expectedNetworkType The expected network type of the ETH node.\r\n * @returns {Promise} Resolves if the ETH node is compatible, otherwise throws:\r\n *    - InvalidURI: URI given is not compatible (e.g. must be WebSockets)\r\n *    - InvalidNetworkType: ETH node connected to wrong network\r\n *    - NoConnection: Couldn't connect to URI\r\n */export function checkValidEthNode(_x){return _checkValidEthNode.apply(this,arguments);}function _checkValidEthNode(){_checkValidEthNode=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(uri){var isLocalOrUnknown,expectedNetworkType,provider,networkType,networkTypeName;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:isLocalOrUnknown=isLocalOrUnknownNetwork(env('CHAIN_ID'));if(validHttpFormat(uri)){_context.next=3;break;}throw new InvalidURI('The URI must use the HTTP protocol');case 3:_context.prev=3;expectedNetworkType=getNetworkType();_context.next=7;return new Providers.JsonRpcProvider(uri);case 7:provider=_context.sent;_context.next=10;return provider.getNetwork();case 10:networkType=_context.sent;networkTypeName=networkType.name==='homestead'?'main':networkType.name;if(isLocalOrUnknown){_context.next=15;break;}if(!(networkTypeName!==expectedNetworkType)){_context.next=15;break;}throw new InvalidNetworkType();case 15:_context.next=22;break;case 17:_context.prev=17;_context.t0=_context[\"catch\"](3);if(!(_context.t0 instanceof InvalidNetworkType)){_context.next=21;break;}throw _context.t0;case 21:throw new NoConnection();case 22:return _context.abrupt(\"return\",true);case 23:case\"end\":return _context.stop();}}},_callee,null,[[3,17]]);}));return _checkValidEthNode.apply(this,arguments);}export function signMessage(_x2,_x3){return _signMessage.apply(this,arguments);}function _signMessage(){_signMessage=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(wallet,message){var signHash,error;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:error=false;_context2.prev=1;_context2.next=4;return wallet.ethers.getSigner().signMessage(message);case 4:signHash=_context2.sent;_context2.next=10;break;case 7:_context2.prev=7;_context2.t0=_context2[\"catch\"](1);error=_context2.t0;case 10:return _context2.abrupt(\"return\",{signHash:signHash,error:error});case 11:case\"end\":return _context2.stop();}}},_callee2,null,[[1,7]]);}));return _signMessage.apply(this,arguments);}export function sanitizeSignature(signature){return _objectSpread(_objectSpread({},signature),{},{r:\"0x\".concat(signature.r),s:\"0x\".concat(signature.s)});}// ethers utils exports\nexport{keccak256,soliditySha3,toUtf8String};","map":{"version":3,"sources":["/Users/fabianmolina/Documents/1hive/tulip-frontend/src/lib/web3-utils.js"],"names":["env","providers","Providers","utils","InvalidURI","InvalidNetworkType","NoConnection","validHttpFormat","keccak256","id","soliditySha3","solidityKeccak256","toUtf8String","DEFAULT_LOCAL_CHAIN","ZERO_ADDRESS","padEnd","ETH_FAKE_ADDRESS","ETH_ADDRESS_SPLIT_REGEX","ETH_ADDRESS_TEST_REGEX","getFunctionSignature","func","slice","encodeFunctionData","contract","functionName","params","interface","getUseWalletProviders","push","useWalletConf","apiKey","dAppId","getUseWalletConnectors","reduce","connectors","provider","toChecksumAddress","address","test","Error","toLowerCase","replace","addressHash","checksumAddress","i","length","parseInt","toUpperCase","addressesEqual","first","second","addressPattern","shortenAddress","charsLength","prefixLength","getNetworkType","chainId","String","getNetworkName","sanitizeNetworkType","networkType","isLocalOrUnknownNetwork","transformAddresses","str","callback","split","map","part","index","checkValidEthNode","uri","isLocalOrUnknown","expectedNetworkType","JsonRpcProvider","getNetwork","networkTypeName","name","signMessage","wallet","message","error","ethers","getSigner","signHash","sanitizeSignature","signature","r","s"],"mappings":"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","sourcesContent":["import env from '../environment'\r\nimport { providers as Providers, utils } from 'ethers'\r\nimport { InvalidURI, InvalidNetworkType, NoConnection } from '../errors'\r\nimport { validHttpFormat } from './uri-utils'\r\n\r\nconst { id: keccak256, solidityKeccak256: soliditySha3, toUtf8String } = utils\r\n\r\nexport const DEFAULT_LOCAL_CHAIN = 'private'\r\nexport const ZERO_ADDRESS = `0x${''.padEnd(40, '0')}`\r\nexport const ETH_FAKE_ADDRESS = ZERO_ADDRESS\r\n\r\nconst ETH_ADDRESS_SPLIT_REGEX = /(0x[a-fA-F0-9]{40}(?:\\b|\\.|,|\\?|!|;))/g\r\nconst ETH_ADDRESS_TEST_REGEX = /(0x[a-fA-F0-9]{40}(?:\\b|\\.|,|\\?|!|;))/g\r\n\r\nexport function getFunctionSignature(func) {\r\n  return keccak256(func).slice(0, 10)\r\n}\r\n\r\nexport function encodeFunctionData(contract, functionName, params) {\r\n  return contract.interface.encodeFunctionData(functionName, params)\r\n}\r\n\r\nexport function getUseWalletProviders() {\r\n  const providers = [{ id: 'injected' }]\r\n\r\n  if (env('FORTMATIC_API_KEY')) {\r\n    providers.push({\r\n      id: 'fortmatic',\r\n      useWalletConf: { apiKey: env('FORTMATIC_API_KEY') },\r\n    })\r\n  }\r\n\r\n  if (env('PORTIS_DAPP_ID')) {\r\n    providers.push({\r\n      id: 'portis',\r\n      useWalletConf: { dAppId: env('PORTIS_DAPP_ID') },\r\n    })\r\n  }\r\n\r\n  return providers\r\n}\r\n\r\nexport function getUseWalletConnectors() {\r\n  return getUseWalletProviders().reduce((connectors, provider) => {\r\n    if (provider.useWalletConf) {\r\n      connectors[provider.id] = provider.useWalletConf\r\n    }\r\n    return connectors\r\n  }, {})\r\n}\r\n\r\nfunction toChecksumAddress(address) {\r\n  if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {\r\n    throw new Error(\r\n      'Given address \"' + address + '\" is not a valid Ethereum address.'\r\n    )\r\n  }\r\n\r\n  address = address.toLowerCase().replace(/^0x/i, '')\r\n\r\n  const addressHash = keccak256(address).replace(/^0x/i, '')\r\n  let checksumAddress = '0x'\r\n\r\n  for (let i = 0; i < address.length; i++) {\r\n    // If ith character is 9 to f then make it uppercase\r\n    if (parseInt(addressHash[i], 16) > 7) {\r\n      checksumAddress += address[i].toUpperCase()\r\n    } else {\r\n      checksumAddress += address[i]\r\n    }\r\n  }\r\n\r\n  return checksumAddress\r\n}\r\n\r\n// Check address equality with checksums\r\nexport function addressesEqual(first, second) {\r\n  first = first && toChecksumAddress(first)\r\n  second = second && toChecksumAddress(second)\r\n  return first === second\r\n}\r\n\r\nexport const addressPattern = '(0x)?[0-9a-fA-F]{40}'\r\n\r\n/**\r\n * Shorten an Ethereum address. `charsLength` allows to change the number of\r\n * characters on both sides of the ellipsis.\r\n *\r\n * Examples:\r\n *   shortenAddress('0x19731977931271')    // 0x1973…1271\r\n *   shortenAddress('0x19731977931271', 2) // 0x19…71\r\n *   shortenAddress('0x197319')            // 0x197319 (already short enough)\r\n *\r\n * @param {string} address The address to shorten\r\n * @param {number} [charsLength=4] The number of characters to change on both sides of the ellipsis\r\n * @returns {string} The shortened address\r\n */\r\nexport function shortenAddress(address, charsLength = 4) {\r\n  const prefixLength = 2 // \"0x\"\r\n  if (!address) {\r\n    return ''\r\n  }\r\n  if (address.length < charsLength * 2 + prefixLength) {\r\n    return address\r\n  }\r\n  return (\r\n    address.slice(0, charsLength + prefixLength) +\r\n    '…' +\r\n    address.slice(-charsLength)\r\n  )\r\n}\r\n\r\nexport function getNetworkType(chainId = env('CHAIN_ID')) {\r\n  chainId = String(chainId)\r\n\r\n  if (chainId === '1') return 'main'\r\n  if (chainId === '3') return 'ropsten'\r\n  if (chainId === '4') return 'rinkeby'\r\n  if (chainId === '100') return 'xdai'\r\n\r\n  return DEFAULT_LOCAL_CHAIN\r\n}\r\n\r\nexport function getNetworkName(chainId = env('CHAIN_ID')) {\r\n  chainId = String(chainId)\r\n\r\n  if (chainId === '1') return 'Mainnet'\r\n  if (chainId === '3') return 'Ropsten'\r\n  if (chainId === '4') return 'Rinkeby'\r\n  if (chainId === '100') return 'xDai'\r\n\r\n  return 'unknown'\r\n}\r\n\r\nexport function sanitizeNetworkType(networkType) {\r\n  if (networkType === 'private') {\r\n    return 'localhost'\r\n  } else if (networkType === 'main') {\r\n    return 'mainnet'\r\n  }\r\n  return networkType\r\n}\r\n\r\nexport function isLocalOrUnknownNetwork(chainId = env('CHAIN_ID')) {\r\n  return getNetworkType(chainId) === DEFAULT_LOCAL_CHAIN\r\n}\r\n\r\n// Detect Ethereum addresses in a string and transform each part.\r\n//\r\n// `callback` is called on every part with two params:\r\n//   - The string of the current part.\r\n//   - A boolean indicating if it is an address.\r\n//\r\nexport function transformAddresses(str, callback) {\r\n  return str\r\n    .split(ETH_ADDRESS_SPLIT_REGEX)\r\n    .map((part, index) =>\r\n      callback(part, ETH_ADDRESS_TEST_REGEX.test(part), index)\r\n    )\r\n}\r\n\r\n/**\r\n * Check if the ETH node at the given URI is compatible for the current environment\r\n * @param {string} uri URI of the ETH node.\r\n * @param {string} expectedNetworkType The expected network type of the ETH node.\r\n * @returns {Promise} Resolves if the ETH node is compatible, otherwise throws:\r\n *    - InvalidURI: URI given is not compatible (e.g. must be WebSockets)\r\n *    - InvalidNetworkType: ETH node connected to wrong network\r\n *    - NoConnection: Couldn't connect to URI\r\n */\r\nexport async function checkValidEthNode(uri) {\r\n  const isLocalOrUnknown = isLocalOrUnknownNetwork(env('CHAIN_ID'))\r\n\r\n  if (!validHttpFormat(uri)) {\r\n    throw new InvalidURI('The URI must use the HTTP protocol')\r\n  }\r\n\r\n  try {\r\n    const expectedNetworkType = getNetworkType()\r\n    const provider = await new Providers.JsonRpcProvider(uri)\r\n    const networkType = await provider.getNetwork()\r\n    const networkTypeName =\r\n      networkType.name === 'homestead' ? 'main' : networkType.name\r\n\r\n    if (!isLocalOrUnknown) {\r\n      if (networkTypeName !== expectedNetworkType) {\r\n        throw new InvalidNetworkType()\r\n      }\r\n    }\r\n  } catch (err) {\r\n    if (err instanceof InvalidNetworkType) {\r\n      throw err\r\n    }\r\n    throw new NoConnection()\r\n  }\r\n\r\n  return true\r\n}\r\n\r\nexport async function signMessage(wallet, message) {\r\n  let signHash\r\n  let error = false\r\n\r\n  try {\r\n    signHash = await wallet.ethers.getSigner().signMessage(message)\r\n  } catch (err) {\r\n    error = err\r\n  }\r\n\r\n  return { signHash, error }\r\n}\r\n\r\nexport function sanitizeSignature(signature) {\r\n  return {\r\n    ...signature,\r\n    r: `0x${signature.r}`,\r\n    s: `0x${signature.s}`,\r\n  }\r\n}\r\n\r\n// ethers utils exports\r\nexport { keccak256, soliditySha3, toUtf8String }\r\n"]},"metadata":{},"sourceType":"module"}