{"ast":null,"code":"var _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _asyncIterator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar getIterator = require('get-iterator');\n\nmodule.exports = function (writable) {\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(source) {\n      var maybeEndSource, error, errCb, errorHandler, closeCb, closed, closeHandler, finishCb, finished, finishHandler, drainCb, drainHandler, waitForDrainOrClose, waitForDone, cleanup, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, value;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              source = getIterator(source);\n\n              maybeEndSource = function maybeEndSource(source) {\n                if (typeof source.return === 'function') source.return();\n              };\n\n              error = null;\n              errCb = null;\n\n              errorHandler = function errorHandler(err) {\n                error = err;\n                if (errCb) errCb(err); // When the writable errors, try to end the source to exit iteration early\n\n                maybeEndSource(source);\n              };\n\n              closeCb = null;\n              closed = false;\n\n              closeHandler = function closeHandler() {\n                closed = true;\n                if (closeCb) closeCb();\n              };\n\n              finishCb = null;\n              finished = false;\n\n              finishHandler = function finishHandler() {\n                finished = true;\n                if (finishCb) finishCb();\n              };\n\n              drainCb = null;\n\n              drainHandler = function drainHandler() {\n                if (drainCb) drainCb();\n              };\n\n              waitForDrainOrClose = function waitForDrainOrClose() {\n                return new Promise(function (resolve, reject) {\n                  closeCb = drainCb = resolve;\n                  errCb = reject;\n                  writable.once('drain', drainHandler);\n                });\n              };\n\n              waitForDone = function waitForDone() {\n                // Immediately try to end the source\n                maybeEndSource(source);\n                return new Promise(function (resolve, reject) {\n                  if (closed || finished || error) return resolve();\n                  finishCb = closeCb = resolve;\n                  errCb = reject;\n                });\n              };\n\n              cleanup = function cleanup() {\n                writable.removeListener('error', errorHandler);\n                writable.removeListener('close', closeHandler);\n                writable.removeListener('finish', finishHandler);\n                writable.removeListener('drain', drainHandler);\n              };\n\n              writable.once('error', errorHandler);\n              writable.once('close', closeHandler);\n              writable.once('finish', finishHandler);\n              _context.prev = 19;\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _context.prev = 22;\n              _iterator = _asyncIterator(source);\n\n            case 24:\n              _context.next = 26;\n              return _iterator.next();\n\n            case 26:\n              _step = _context.sent;\n              _iteratorNormalCompletion = _step.done;\n              _context.next = 30;\n              return _step.value;\n\n            case 30:\n              _value = _context.sent;\n\n              if (_iteratorNormalCompletion) {\n                _context.next = 41;\n                break;\n              }\n\n              value = _value;\n\n              if (!(!writable.writable || writable.destroyed || error)) {\n                _context.next = 35;\n                break;\n              }\n\n              return _context.abrupt(\"break\", 41);\n\n            case 35:\n              if (!(writable.write(value) === false)) {\n                _context.next = 38;\n                break;\n              }\n\n              _context.next = 38;\n              return waitForDrainOrClose();\n\n            case 38:\n              _iteratorNormalCompletion = true;\n              _context.next = 24;\n              break;\n\n            case 41:\n              _context.next = 47;\n              break;\n\n            case 43:\n              _context.prev = 43;\n              _context.t0 = _context[\"catch\"](22);\n              _didIteratorError = true;\n              _iteratorError = _context.t0;\n\n            case 47:\n              _context.prev = 47;\n              _context.prev = 48;\n\n              if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                _context.next = 52;\n                break;\n              }\n\n              _context.next = 52;\n              return _iterator.return();\n\n            case 52:\n              _context.prev = 52;\n\n              if (!_didIteratorError) {\n                _context.next = 55;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 55:\n              return _context.finish(52);\n\n            case 56:\n              return _context.finish(47);\n\n            case 57:\n              _context.next = 63;\n              break;\n\n            case 59:\n              _context.prev = 59;\n              _context.t1 = _context[\"catch\"](19);\n\n              // error is set by stream error handler so only destroy stream if source threw\n              if (!error) {\n                writable.destroy();\n              } // could we be obscuring an error here?\n\n\n              error = _context.t1;\n\n            case 63:\n              _context.prev = 63;\n\n              // We're done writing, end everything (n.b. stream may be destroyed at this point but then this is a no-op)\n              if (writable.writable) {\n                writable.end();\n              } // Wait until we close or finish. This supports halfClosed streams\n\n\n              _context.next = 67;\n              return waitForDone();\n\n            case 67:\n              if (!error) {\n                _context.next = 69;\n                break;\n              }\n\n              throw error;\n\n            case 69:\n              _context.prev = 69;\n              // Clean up listeners\n              cleanup();\n              return _context.finish(69);\n\n            case 72:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[19, 59], [22, 43, 47, 57], [48,, 52, 56], [63,, 69, 72]]);\n    }));\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n};","map":null,"metadata":{},"sourceType":"script"}