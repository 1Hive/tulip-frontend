{"ast":null,"code":"const DID_PLACEHOLDER = 'GENESIS';\n/**\n * A class for creating ipfs based DID Documents.\n * Based on the DID spec: https://w3c-ccg.github.io/did-spec/\n */\n\nclass DidDocument {\n  /**\n   * Create a new DID Document.\n   *\n   * @param     {Object}        ipfs            An js-ipfs instance\n   * @param     {String}        method          The name of the DID Method\n   * @return    {DidDocument}                   self\n   */\n  constructor(ipfs, method) {\n    this._ipfs = ipfs;\n    this._content = {\n      id: `did:${method}:${DID_PLACEHOLDER}`\n    };\n  }\n\n  get DID() {\n    if (this._content.id.includes(DID_PLACEHOLDER)) {\n      throw new Error('DID is not available before commit');\n    }\n\n    return this._content.id;\n  }\n  /**\n   * Load an already existing DID Document.\n   *\n   * @param     {Object}        ipfs            An js-ipfs instance\n   * @param     {String}        documentCid     The CID of the document\n   * @return    {Promise<DidDocument>}                   self\n   */\n\n\n  static async load(ipfs, documentCid) {\n    const doc = new DidDocument(ipfs);\n    doc._content = await DidDocument.cidToDocument(ipfs, documentCid);\n    doc._content.previousDocument = {\n      '/': documentCid.toString()\n    };\n    return doc;\n  }\n  /**\n   * Add a new public key\n   *\n   * @param     {String}        id              The id of the key, e.g. \"key1\"\n   * @param     {String}        type            The type of the key\n   * @param     {String}        encoding        The encoding of the key\n   * @param     {String}        key             The encoded public key\n   * @param     {String}        owner           The owner of the key (optional)\n   */\n\n\n  addPublicKey(id, type, encoding, key, owner) {\n    if (!this._content.publicKey) {\n      this._content.publicKey = [];\n    }\n\n    let entry = {\n      id: `${this._content.id}#${id}`,\n      type\n    };\n    entry[encoding] = key;\n\n    if (owner) {\n      entry.owner = owner;\n    }\n\n    this._content.publicKey.push(entry);\n  }\n  /**\n   * Remove a public key\n   *\n   * @param     {String}        id              The id of the key, e.g. \"key1\"\n   */\n\n\n  removePublicKey(id) {\n    const idx = this._content.publicKey.findIndex(e => e.id.endsWith(id));\n\n    this._content.publicKey.splice(idx, 1);\n\n    if (!this._content.publicKey.length) {\n      delete this._content.publicKey;\n    }\n  }\n  /**\n   * Add a new authentication\n   *\n   * @param     {String}        type            The type of the authentication\n   * @param     {String}        id              The id of the key to be used, e.g. \"key1\"\n   */\n\n\n  addAuthentication(type, id) {\n    if (!this._content.authentication) {\n      this._content.authentication = [];\n    }\n\n    this._content.authentication.push({\n      type,\n      publicKey: `${this._content.id}#${id}`\n    });\n  }\n  /**\n   * Remove an authentication\n   *\n   * @param     {String}        id              The id of the key, e.g. \"key1\"\n   */\n\n\n  removeAuthentication(id) {\n    const idx = this._content.authentication.findIndex(e => e.publicKey.endsWith(id));\n\n    this._content.authentication.splice(idx, 1);\n\n    if (!this._content.authentication.length) {\n      delete this._content.authentication;\n    }\n  }\n  /**\n   * Add a new service\n   *\n   * @param     {String}        id                  The id of the key to be used, e.g. \"key1\"\n   * @param     {String}        type                The type of the service\n   * @param     {String}        serviceEndpoint     The endpoint of the service\n   * @param     {Object}        additionalFields    Any additional fields (optional)\n   */\n\n\n  addService(id, type, serviceEndpoint, additionalFields) {\n    if (!this._content.service) {\n      this._content.service = [];\n    }\n\n    this._content.service.push(Object.assign({\n      id: `${this._content.id};${id}`,\n      type,\n      serviceEndpoint\n    }, additionalFields));\n  }\n  /**\n   * Remove a service\n   *\n   * @param     {String}        id              The id of the key, e.g. \"key1\"\n   */\n\n\n  removeService(id) {\n    const idx = this._content.service.findIndex(e => e.id.endsWith(id));\n\n    this._content.service.splice(idx, 1);\n\n    if (!this._content.service.length) {\n      delete this._content.service;\n    }\n  }\n  /**\n   * Set the revocationMethod. This can be of any js object\n   * and is determined by the implementer of a revocation module.\n   *\n   * @param     {Object}        methodDescriptor    the object that defines the revocation method\n   */\n\n\n  setRevocationMethod(methodDescriptor) {\n    this._content.revocationMethod = methodDescriptor;\n  }\n  /**\n   * Add a new property\n   *\n   * @param     {String}        propName            The name of the property\n   * @param     {Object}        propValue           The value of the property\n   */\n\n\n  addCustomProperty(propName, propValue) {\n    this._content[propName] = propValue;\n  }\n  /**\n   * Remove a property\n   *\n   * @param     {String}        propName            The name of the property\n   */\n\n\n  removeCustomProperty(propName) {\n    delete this._content[propName];\n  }\n  /**\n   * Commit all changes and create a new ipfs dag object.\n   *\n   * @param     {Object}        opts                Optional parameters\n   * @param     {Boolean}       noTimestamp         Don't use timestamps if true\n   *\n   * @return    {Promise<CID>}                   The CID of the object\n   */\n\n\n  async commit(opts = {}) {\n    if (!this._content.created) {\n      this._content['@context'] = 'https://w3id.org/did/v1';\n\n      if (!opts.noTimestamp) {\n        this._content.created = new Date(Date.now()).toISOString();\n      }\n    } else if (!opts.noTimestamp) {\n      this._content.updated = new Date(Date.now()).toISOString();\n    }\n\n    const cid = await this._ipfs.dag.put(this._content, {\n      format: 'dag-cbor',\n      hashAlg: 'sha2-256'\n    }); // set up for further changes:\n\n    this._content = await DidDocument.cidToDocument(this._ipfs, cid);\n    this._content.previousDocument = {\n      '/': cid.toString()\n    };\n    return cid;\n  }\n  /**\n   * Returns the DID document of a document CID\n   *\n   * @param     {Object}        ipfs            An js-ipfs instance\n   * @param     {String}        documentCid     The CID of the document\n   * @return    {Promise<Object>}                        The DID document as a js object\n   */\n\n\n  static async cidToDocument(ipfs, documentCid) {\n    let doc = (await ipfs.dag.get(documentCid)).value; // If genesis document replace placeholder identifier with cid\n\n    if (doc.id.includes(DID_PLACEHOLDER)) {\n      const re = new RegExp(DID_PLACEHOLDER, 'gi');\n      doc.id = doc.id.replace(re, documentCid);\n\n      if (doc.publicKey) {\n        doc.publicKey = JSON.parse(JSON.stringify(doc.publicKey).replace(re, documentCid));\n      }\n\n      if (doc.authentication) {\n        doc.authentication = JSON.parse(JSON.stringify(doc.authentication).replace(re, documentCid));\n      }\n\n      if (doc.service) {\n        doc.service = JSON.parse(JSON.stringify(doc.service).replace(re, documentCid));\n      }\n    }\n\n    if (doc.previousDocument) {\n      // make CID human readable\n      doc.previousDocument = {\n        '/': doc.previousDocument.toString()\n      };\n    }\n\n    return doc;\n  }\n\n}\n\nmodule.exports = DidDocument;","map":null,"metadata":{},"sourceType":"script"}