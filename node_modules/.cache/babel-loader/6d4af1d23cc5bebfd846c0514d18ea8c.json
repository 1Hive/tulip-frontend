{"ast":null,"code":"var events = require('events');\n\nvar inherits = require('inherits');\n\nmodule.exports = LRU;\n\nfunction LRU(opts) {\n  if (!(this instanceof LRU)) return new LRU(opts);\n  if (typeof opts === 'number') opts = {\n    max: opts\n  };\n  if (!opts) opts = {};\n  events.EventEmitter.call(this);\n  this.cache = {};\n  this.head = this.tail = null;\n  this.length = 0;\n  this.max = opts.max || 1000;\n  this.maxAge = opts.maxAge || 0;\n}\n\ninherits(LRU, events.EventEmitter);\nObject.defineProperty(LRU.prototype, 'keys', {\n  get: function () {\n    return Object.keys(this.cache);\n  }\n});\n\nLRU.prototype.clear = function () {\n  this.cache = {};\n  this.head = this.tail = null;\n  this.length = 0;\n};\n\nLRU.prototype.remove = function (key) {\n  if (typeof key !== 'string') key = '' + key;\n  if (!this.cache.hasOwnProperty(key)) return;\n  var element = this.cache[key];\n  delete this.cache[key];\n\n  this._unlink(key, element.prev, element.next);\n\n  return element.value;\n};\n\nLRU.prototype._unlink = function (key, prev, next) {\n  this.length--;\n\n  if (this.length === 0) {\n    this.head = this.tail = null;\n  } else {\n    if (this.head === key) {\n      this.head = prev;\n      this.cache[this.head].next = null;\n    } else if (this.tail === key) {\n      this.tail = next;\n      this.cache[this.tail].prev = null;\n    } else {\n      this.cache[prev].next = next;\n      this.cache[next].prev = prev;\n    }\n  }\n};\n\nLRU.prototype.peek = function (key) {\n  if (!this.cache.hasOwnProperty(key)) return;\n  var element = this.cache[key];\n  if (!this._checkAge(key, element)) return;\n  return element.value;\n};\n\nLRU.prototype.set = function (key, value) {\n  if (typeof key !== 'string') key = '' + key;\n  var element;\n\n  if (this.cache.hasOwnProperty(key)) {\n    element = this.cache[key];\n    element.value = value;\n    if (this.maxAge) element.modified = Date.now(); // If it's already the head, there's nothing more to do:\n\n    if (key === this.head) return value;\n\n    this._unlink(key, element.prev, element.next);\n  } else {\n    element = {\n      value: value,\n      modified: 0,\n      next: null,\n      prev: null\n    };\n    if (this.maxAge) element.modified = Date.now();\n    this.cache[key] = element; // Eviction is only possible if the key didn't already exist:\n\n    if (this.length === this.max) this.evict();\n  }\n\n  this.length++;\n  element.next = null;\n  element.prev = this.head;\n  if (this.head) this.cache[this.head].next = key;\n  this.head = key;\n  if (!this.tail) this.tail = key;\n  return value;\n};\n\nLRU.prototype._checkAge = function (key, element) {\n  if (this.maxAge && Date.now() - element.modified > this.maxAge) {\n    this.remove(key);\n    this.emit('evict', {\n      key: key,\n      value: element.value\n    });\n    return false;\n  }\n\n  return true;\n};\n\nLRU.prototype.get = function (key) {\n  if (typeof key !== 'string') key = '' + key;\n  if (!this.cache.hasOwnProperty(key)) return;\n  var element = this.cache[key];\n  if (!this._checkAge(key, element)) return;\n\n  if (this.head !== key) {\n    if (key === this.tail) {\n      this.tail = element.next;\n      this.cache[this.tail].prev = null;\n    } else {\n      // Set prev.next -> element.next:\n      this.cache[element.prev].next = element.next;\n    } // Set element.next.prev -> element.prev:\n\n\n    this.cache[element.next].prev = element.prev; // Element is the new head\n\n    this.cache[this.head].next = key;\n    element.prev = this.head;\n    element.next = null;\n    this.head = key;\n  }\n\n  return element.value;\n};\n\nLRU.prototype.evict = function () {\n  if (!this.tail) return;\n  var key = this.tail;\n  var value = this.remove(this.tail);\n  this.emit('evict', {\n    key: key,\n    value: value\n  });\n};","map":null,"metadata":{},"sourceType":"script"}