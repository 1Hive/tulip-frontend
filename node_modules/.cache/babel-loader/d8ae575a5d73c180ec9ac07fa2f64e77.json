{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _createForOfIteratorHelper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _wrapAsyncGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar _awaitAsyncGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _asyncIterator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar _asyncGeneratorDelegate = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate\");\n\nvar isIpfs = require('is-ipfs');\n\nvar CID = require('cids');\n\nvar _require = require('ipld-dag-pb'),\n    DAGNode = _require.DAGNode;\n\nvar _require2 = require('../../utils'),\n    normalizeCidPath = _require2.normalizeCidPath;\n\nvar _require3 = require('interface-datastore'),\n    Errors = _require3.Errors;\n\nvar ERR_NOT_FOUND = Errors.notFoundError().code;\n\nvar _require4 = require('../../utils'),\n    withTimeoutOption = _require4.withTimeoutOption;\n\nvar Format = {\n  default: '<dst>',\n  edges: '<src> -> <dst>'\n};\n\nmodule.exports = function (_ref) {\n  var ipld = _ref.ipld,\n      resolve = _ref.resolve,\n      preload = _ref.preload;\n  return withTimeoutOption( /*#__PURE__*/function () {\n    var _refs = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(ipfsPath, options) {\n      var rawPaths, paths, _iterator2, _step2, path;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              // eslint-disable-line require-await\n              options = options || {};\n\n              if (!(options.maxDepth === 0)) {\n                _context.next = 3;\n                break;\n              }\n\n              return _context.abrupt(\"return\");\n\n            case 3:\n              if (!(options.edges && options.format && options.format !== Format.default)) {\n                _context.next = 5;\n                break;\n              }\n\n              throw new Error('Cannot set edges to true and also specify format');\n\n            case 5:\n              options.format = options.edges ? Format.edges : options.format || Format.default;\n\n              if (typeof options.maxDepth !== 'number') {\n                options.maxDepth = options.recursive ? Infinity : 1;\n              }\n\n              rawPaths = Array.isArray(ipfsPath) ? ipfsPath : [ipfsPath];\n              paths = rawPaths.map(function (p) {\n                return getFullPath(preload, p, options);\n              });\n              _iterator2 = _createForOfIteratorHelper(paths);\n              _context.prev = 10;\n\n              _iterator2.s();\n\n            case 12:\n              if ((_step2 = _iterator2.n()).done) {\n                _context.next = 17;\n                break;\n              }\n\n              path = _step2.value;\n              return _context.delegateYield(_asyncGeneratorDelegate(_asyncIterator(refsStream(resolve, ipld, path, options)), _awaitAsyncGenerator), \"t0\", 15);\n\n            case 15:\n              _context.next = 12;\n              break;\n\n            case 17:\n              _context.next = 22;\n              break;\n\n            case 19:\n              _context.prev = 19;\n              _context.t1 = _context[\"catch\"](10);\n\n              _iterator2.e(_context.t1);\n\n            case 22:\n              _context.prev = 22;\n\n              _iterator2.f();\n\n              return _context.finish(22);\n\n            case 25:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[10, 19, 22, 25]]);\n    }));\n\n    function refs(_x, _x2) {\n      return _refs.apply(this, arguments);\n    }\n\n    return refs;\n  }());\n};\n\nmodule.exports.Format = Format;\n\nfunction getFullPath(preload, ipfsPath, options) {\n  // normalizeCidPath() strips /ipfs/ off the front of the path so the CID will\n  // be at the front of the path\n  var path = normalizeCidPath(ipfsPath);\n  var pathComponents = path.split('/');\n  var cid = pathComponents[0];\n\n  if (!isIpfs.cid(cid)) {\n    throw new Error(\"Error resolving path '\".concat(path, \"': '\").concat(cid, \"' is not a valid CID\"));\n  }\n\n  if (options.preload !== false) {\n    preload(cid);\n  }\n\n  return '/ipfs/' + path;\n} // Get a stream of refs at the given path\n\n\nfunction refsStream(_x3, _x4, _x5, _x6) {\n  return _refsStream.apply(this, arguments);\n} // Get formatted link\n\n\nfunction _refsStream() {\n  _refsStream = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(resolve, ipld, path, options) {\n    var resPath, parts, cid, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, obj;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return _awaitAsyncGenerator(resolve(path));\n\n          case 2:\n            resPath = _context2.sent;\n            // path is /ipfs/<cid>\n            parts = resPath.split('/');\n            cid = parts[2]; // Traverse the DAG, converting it into a stream\n\n            _iteratorNormalCompletion = true;\n            _didIteratorError = false;\n            _context2.prev = 7;\n            _iterator = _asyncIterator(objectStream(ipld, cid, options.maxDepth, options.unique));\n\n          case 9:\n            _context2.next = 11;\n            return _awaitAsyncGenerator(_iterator.next());\n\n          case 11:\n            _step = _context2.sent;\n            _iteratorNormalCompletion = _step.done;\n            _context2.next = 15;\n            return _awaitAsyncGenerator(_step.value);\n\n          case 15:\n            _value = _context2.sent;\n\n            if (_iteratorNormalCompletion) {\n              _context2.next = 27;\n              break;\n            }\n\n            obj = _value;\n\n            if (obj.parent) {\n              _context2.next = 20;\n              break;\n            }\n\n            return _context2.abrupt(\"continue\", 24);\n\n          case 20:\n            if (!obj.isDuplicate) {\n              _context2.next = 22;\n              break;\n            }\n\n            return _context2.abrupt(\"continue\", 24);\n\n          case 22:\n            _context2.next = 24;\n            return {\n              ref: formatLink(obj.parent.cid, obj.node.cid, obj.node.name, options.format)\n            };\n\n          case 24:\n            _iteratorNormalCompletion = true;\n            _context2.next = 9;\n            break;\n\n          case 27:\n            _context2.next = 33;\n            break;\n\n          case 29:\n            _context2.prev = 29;\n            _context2.t0 = _context2[\"catch\"](7);\n            _didIteratorError = true;\n            _iteratorError = _context2.t0;\n\n          case 33:\n            _context2.prev = 33;\n            _context2.prev = 34;\n\n            if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n              _context2.next = 38;\n              break;\n            }\n\n            _context2.next = 38;\n            return _awaitAsyncGenerator(_iterator.return());\n\n          case 38:\n            _context2.prev = 38;\n\n            if (!_didIteratorError) {\n              _context2.next = 41;\n              break;\n            }\n\n            throw _iteratorError;\n\n          case 41:\n            return _context2.finish(38);\n\n          case 42:\n            return _context2.finish(33);\n\n          case 43:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[7, 29, 33, 43], [34,, 38, 42]]);\n  }));\n  return _refsStream.apply(this, arguments);\n}\n\nfunction formatLink(srcCid, dstCid, linkName, format) {\n  var out = format.replace(/<src>/g, srcCid.toString());\n  out = out.replace(/<dst>/g, dstCid.toString());\n  out = out.replace(/<linkname>/g, linkName);\n  return out;\n} // Do a depth first search of the DAG, starting from the given root cid\n\n\nfunction objectStream(_x7, _x8, _x9, _x10) {\n  return _objectStream.apply(this, arguments);\n} // Fetch a node from IPLD then get all its links\n\n\nfunction _objectStream() {\n  _objectStream = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(ipld, rootCid, maxDepth, uniqueOnly) {\n    var seen, traverseLevel, _traverseLevel;\n\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _traverseLevel = function _traverseLevel3() {\n              _traverseLevel = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(parent, depth) {\n                var nextLevelDepth, _iterator3, _step3, link;\n\n                return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                  while (1) {\n                    switch (_context3.prev = _context3.next) {\n                      case 0:\n                        nextLevelDepth = depth + 1; // Check the depth\n\n                        if (!(nextLevelDepth > maxDepth)) {\n                          _context3.next = 3;\n                          break;\n                        }\n\n                        return _context3.abrupt(\"return\");\n\n                      case 3:\n                        _context3.prev = 3;\n                        _context3.t0 = _createForOfIteratorHelper;\n                        _context3.next = 7;\n                        return _awaitAsyncGenerator(getLinks(ipld, parent.cid));\n\n                      case 7:\n                        _context3.t1 = _context3.sent;\n                        _iterator3 = (0, _context3.t0)(_context3.t1);\n                        _context3.prev = 9;\n\n                        _iterator3.s();\n\n                      case 11:\n                        if ((_step3 = _iterator3.n()).done) {\n                          _context3.next = 19;\n                          break;\n                        }\n\n                        link = _step3.value;\n                        _context3.next = 15;\n                        return {\n                          parent: parent,\n                          node: link,\n                          isDuplicate: uniqueOnly && seen.has(link.cid.toString())\n                        };\n\n                      case 15:\n                        if (uniqueOnly) {\n                          seen.add(link.cid.toString());\n                        }\n\n                        return _context3.delegateYield(_asyncGeneratorDelegate(_asyncIterator(traverseLevel(link, nextLevelDepth)), _awaitAsyncGenerator), \"t2\", 17);\n\n                      case 17:\n                        _context3.next = 11;\n                        break;\n\n                      case 19:\n                        _context3.next = 24;\n                        break;\n\n                      case 21:\n                        _context3.prev = 21;\n                        _context3.t3 = _context3[\"catch\"](9);\n\n                        _iterator3.e(_context3.t3);\n\n                      case 24:\n                        _context3.prev = 24;\n\n                        _iterator3.f();\n\n                        return _context3.finish(24);\n\n                      case 27:\n                        _context3.next = 33;\n                        break;\n\n                      case 29:\n                        _context3.prev = 29;\n                        _context3.t4 = _context3[\"catch\"](3);\n\n                        if (_context3.t4.code === ERR_NOT_FOUND) {\n                          _context3.t4.message = \"Could not find object with CID: \".concat(parent.cid);\n                        }\n\n                        throw _context3.t4;\n\n                      case 33:\n                      case \"end\":\n                        return _context3.stop();\n                    }\n                  }\n                }, _callee3, null, [[3, 29], [9, 21, 24, 27]]);\n              }));\n              return _traverseLevel.apply(this, arguments);\n            };\n\n            traverseLevel = function _traverseLevel2(_x11, _x12) {\n              return _traverseLevel.apply(this, arguments);\n            };\n\n            // eslint-disable-line require-await\n            seen = new Set();\n            return _context4.delegateYield(_asyncGeneratorDelegate(_asyncIterator(traverseLevel({\n              cid: rootCid\n            }, 0)), _awaitAsyncGenerator), \"t0\", 4);\n\n          case 4:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _objectStream.apply(this, arguments);\n}\n\nfunction getLinks(_x13, _x14) {\n  return _getLinks.apply(this, arguments);\n} // Recursively search the node for CIDs\n\n\nfunction _getLinks() {\n  _getLinks = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(ipld, cid) {\n    var node;\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            _context5.next = 2;\n            return ipld.get(new CID(cid));\n\n          case 2:\n            node = _context5.sent;\n\n            if (!DAGNode.isDAGNode(node)) {\n              _context5.next = 5;\n              break;\n            }\n\n            return _context5.abrupt(\"return\", node.Links.map(function (_ref2) {\n              var Name = _ref2.Name,\n                  Hash = _ref2.Hash;\n              return {\n                name: Name,\n                cid: new CID(Hash)\n              };\n            }));\n\n          case 5:\n            return _context5.abrupt(\"return\", getNodeLinks(node));\n\n          case 6:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n  return _getLinks.apply(this, arguments);\n}\n\nfunction getNodeLinks(node) {\n  var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var links = [];\n\n  for (var _i = 0, _Object$entries = Object.entries(node); _i < _Object$entries.length; _i++) {\n    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n        name = _Object$entries$_i[0],\n        value = _Object$entries$_i[1];\n\n    if (CID.isCID(value)) {\n      links.push({\n        name: path + name,\n        cid: value\n      });\n    } else if (typeof value === 'object') {\n      links = links.concat(getNodeLinks(value, path + name + '/'));\n    }\n  }\n\n  return links;\n}","map":null,"metadata":{},"sourceType":"script"}