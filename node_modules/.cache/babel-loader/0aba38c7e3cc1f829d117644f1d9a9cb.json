{"ast":null,"code":"\"use strict\";\n/**\n * Generate a character map.\n * @param {string} alphabet e.g. \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\"\n * @param {object} mappings map overrides from key to value\n * @method\n */\n\nvar charmap = function charmap(alphabet, mappings) {\n  mappings || (mappings = {});\n  alphabet.split(\"\").forEach(function (c, i) {\n    if (!(c in mappings)) mappings[c] = i;\n  });\n  return mappings;\n};\n/**\n * The RFC 4648 base 32 alphabet and character map.\n * @see {@link https://tools.ietf.org/html/rfc4648}\n */\n\n\nvar rfc4648 = {\n  alphabet: \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\",\n  charmap: {\n    0: 14,\n    1: 8\n  }\n};\nrfc4648.charmap = charmap(rfc4648.alphabet, rfc4648.charmap);\n/**\n * The Crockford base 32 alphabet and character map.\n * @see {@link http://www.crockford.com/wrmg/base32.html}\n */\n\nvar crockford = {\n  alphabet: \"0123456789ABCDEFGHJKMNPQRSTVWXYZ\",\n  charmap: {\n    O: 0,\n    I: 1,\n    L: 1\n  }\n};\ncrockford.charmap = charmap(crockford.alphabet, crockford.charmap);\n/**\n * base32hex\n * @see {@link https://en.wikipedia.org/wiki/Base32#base32hex}\n */\n\nvar base32hex = {\n  alphabet: \"0123456789ABCDEFGHIJKLMNOPQRSTUV\",\n  charmap: {}\n};\nbase32hex.charmap = charmap(base32hex.alphabet, base32hex.charmap);\n/**\n * Create a new `Decoder` with the given options.\n *\n * @param {object} [options]\n *   @param {string} [type] Supported Base-32 variants are \"rfc4648\" and\n *     \"crockford\".\n *   @param {object} [charmap] Override the character map used in decoding.\n * @constructor\n */\n\nfunction Decoder(options) {\n  this.buf = [];\n  this.shift = 8;\n  this.carry = 0;\n\n  if (options) {\n    switch (options.type) {\n      case \"rfc4648\":\n        this.charmap = exports.rfc4648.charmap;\n        break;\n\n      case \"crockford\":\n        this.charmap = exports.crockford.charmap;\n        break;\n\n      case \"base32hex\":\n        this.charmap = exports.base32hex.charmap;\n        break;\n\n      default:\n        throw new Error(\"invalid type\");\n    }\n\n    if (options.charmap) this.charmap = options.charmap;\n  }\n}\n/**\n * The default character map coresponds to RFC4648.\n */\n\n\nDecoder.prototype.charmap = rfc4648.charmap;\n/**\n * Decode a string, continuing from the previous state.\n *\n * @param {string} str\n * @return {Decoder} this\n */\n\nDecoder.prototype.write = function (str) {\n  var charmap = this.charmap;\n  var buf = this.buf;\n  var shift = this.shift;\n  var carry = this.carry; // decode string\n\n  str.toUpperCase().split(\"\").forEach(function (char) {\n    // ignore padding\n    if (char == \"=\") return; // lookup symbol\n\n    var symbol = charmap[char] & 0xff; // 1: 00000 000\n    // 2:          00 00000 0\n    // 3:                    0000 0000\n    // 4:                             0 00000 00\n    // 5:                                       000 00000\n    // 6:                                                00000 000\n    // 7:                                                         00 00000 0\n\n    shift -= 5;\n\n    if (shift > 0) {\n      carry |= symbol << shift;\n    } else if (shift < 0) {\n      buf.push(carry | symbol >> -shift);\n      shift += 8;\n      carry = symbol << shift & 0xff;\n    } else {\n      buf.push(carry | symbol);\n      shift = 8;\n      carry = 0;\n    }\n  }); // save state\n\n  this.shift = shift;\n  this.carry = carry; // for chaining\n\n  return this;\n};\n/**\n * Finish decoding.\n *\n * @param {string} [str] The final string to decode.\n * @return {Array} Decoded byte array.\n */\n\n\nDecoder.prototype.finalize = function (str) {\n  if (str) {\n    this.write(str);\n  }\n\n  if (this.shift !== 8 && this.carry !== 0) {\n    this.buf.push(this.carry);\n    this.shift = 8;\n    this.carry = 0;\n  }\n\n  return this.buf;\n};\n/**\n * Create a new `Encoder` with the given options.\n *\n * @param {object} [options]\n *   @param {string} [type] Supported Base-32 variants are \"rfc4648\" and\n *     \"crockford\".\n *   @param {object} [alphabet] Override the alphabet used in encoding.\n * @constructor\n */\n\n\nfunction Encoder(options) {\n  this.buf = \"\";\n  this.shift = 3;\n  this.carry = 0;\n\n  if (options) {\n    switch (options.type) {\n      case \"rfc4648\":\n        this.alphabet = exports.rfc4648.alphabet;\n        break;\n\n      case \"crockford\":\n        this.alphabet = exports.crockford.alphabet;\n        break;\n\n      case \"base32hex\":\n        this.alphabet = exports.base32hex.alphabet;\n        break;\n\n      default:\n        throw new Error(\"invalid type\");\n    }\n\n    if (options.alphabet) this.alphabet = options.alphabet;else if (options.lc) this.alphabet = this.alphabet.toLowerCase();\n  }\n}\n/**\n * The default alphabet coresponds to RFC4648.\n */\n\n\nEncoder.prototype.alphabet = rfc4648.alphabet;\n/**\n * Encode a byte array, continuing from the previous state.\n *\n * @param {byte[]} buf The byte array to encode.\n * @return {Encoder} this\n */\n\nEncoder.prototype.write = function (buf) {\n  var shift = this.shift;\n  var carry = this.carry;\n  var symbol;\n  var byte;\n  var i; // encode each byte in buf\n\n  for (i = 0; i < buf.length; i++) {\n    byte = buf[i]; // 1: 00000 000\n    // 2:          00 00000 0\n    // 3:                    0000 0000\n    // 4:                             0 00000 00\n    // 5:                                       000 00000\n    // 6:                                                00000 000\n    // 7:                                                         00 00000 0\n\n    symbol = carry | byte >> shift;\n    this.buf += this.alphabet[symbol & 0x1f];\n\n    if (shift > 5) {\n      shift -= 5;\n      symbol = byte >> shift;\n      this.buf += this.alphabet[symbol & 0x1f];\n    }\n\n    shift = 5 - shift;\n    carry = byte << shift;\n    shift = 8 - shift;\n  } // save state\n\n\n  this.shift = shift;\n  this.carry = carry; // for chaining\n\n  return this;\n};\n/**\n * Finish encoding.\n *\n * @param {byte[]} [buf] The final byte array to encode.\n * @return {string} The encoded byte array.\n */\n\n\nEncoder.prototype.finalize = function (buf) {\n  if (buf) {\n    this.write(buf);\n  }\n\n  if (this.shift !== 3) {\n    this.buf += this.alphabet[this.carry & 0x1f];\n    this.shift = 3;\n    this.carry = 0;\n  }\n\n  return this.buf;\n};\n/**\n * Convenience encoder.\n *\n * @param {byte[]} buf The byte array to encode.\n * @param {object} [options] Options to pass to the encoder.\n * @return {string} The encoded string.\n */\n\n\nexports.encode = function (buf, options) {\n  return new Encoder(options).finalize(buf);\n};\n/**\n * Convenience decoder.\n *\n * @param {string} str The string to decode.\n * @param {object} [options] Options to pass to the decoder.\n * @return {byte[]} The decoded byte array.\n */\n\n\nexports.decode = function (str, options) {\n  return new Decoder(options).finalize(str);\n}; // Exports.\n\n\nexports.Decoder = Decoder;\nexports.Encoder = Encoder;\nexports.charmap = charmap;\nexports.crockford = crockford;\nexports.rfc4648 = rfc4648;\nexports.base32hex = base32hex;","map":null,"metadata":{},"sourceType":"script"}