{"ast":null,"code":"'use strict';\n\nvar slicedToArray = require('./slicedToArray-a8a77f0e.js');\n\nvar React = require('react');\n\nvar index = require('./index-46d0e707.js');\n\nvar _extends = require('./extends-023d783e.js');\n\nvar objectWithoutProperties = require('./objectWithoutProperties-c6d3675c.js');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nvar React__default = /*#__PURE__*/_interopDefaultLegacy(React);\n\nvar RootContext = /*#__PURE__*/React__default['default'].createContext(null);\n\nfunction RootProvider(_ref) {\n  var children = _ref.children,\n      props = objectWithoutProperties.objectWithoutProperties(_ref, [\"children\"]);\n\n  var _useState = React.useState(null),\n      _useState2 = slicedToArray.slicedToArray(_useState, 2),\n      element = _useState2[0],\n      setElement = _useState2[1];\n\n  var handleRef = React.useCallback(function (element) {\n    if (element !== null) {\n      setElement(element);\n    }\n  }, []);\n  return /*#__PURE__*/React__default['default'].createElement(RootContext.Provider, {\n    value: element\n  }, /*#__PURE__*/React__default['default'].createElement(\"div\", _extends._extends_1({\n    ref: handleRef\n  }, props),\n  /*\n     We don’t render the children tree until the element is present, at\n     the second rendering.\n      The reason why it is needed is because element references are\n     assigned after the first rendering, and we don’t want to let\n     `<Root />` consumers having to deal with the reference being `null`\n     at the first rendering.\n      This way, we can guarantee that if a consumer gets `null` rather\n     than the element, it’s because <Root.Provider /> has to be defined\n     at an upper level.\n   */\n  element ? children : null));\n}\n\nRootProvider.propTypes = {\n  children: index.propTypes.node\n};\n\nfunction Root(props) {\n  return /*#__PURE__*/React__default['default'].createElement(RootContext.Consumer, props);\n}\n\nRoot.Provider = RootProvider;\n\nvar useRoot = function useRoot() {\n  return React.useContext(RootContext);\n};\n\nexports.Root = Root;\nexports.useRoot = useRoot;","map":{"version":3,"sources":["../src/providers/Root/Root.js"],"names":["RootContext","React","children","props","element","setElement","useState","handleRef","useCallback","RootProvider","PropTypes","node","Root","useRoot","useContext"],"mappings":";;;;;;;;;;;;;;;;;;;;AAGA,IAAMA,WAAW,GAAA,aAAGC,cAAAA,CAAAA,SAAAA,CAAAA,CAAAA,aAAAA,CAApB,IAAoBA,CAApB;;AAEA,SAAA,YAAA,CAAA,IAAA,EAA8C;AAAA,MAAtBC,QAAsB,GAAA,IAAA,CAAtBA,QAAsB;AAAA,MAATC,KAAS,GAAA,uBAAA,CAAA,uBAAA,CAAA,IAAA,EAAA,CAAA,UAAA,CAAA,CAAA;;AAAA,MAAA,SAAA,GACdG,KAAAA,CAAAA,QAAAA,CADc,IACdA,CADc;AAAA,MAAA,UAAA,GAAA,aAAA,CAAA,aAAA,CAAA,SAAA,EAAA,CAAA,CAAA;AAAA,MACrCF,OADqC,GAAA,UAAA,CAAA,CAAA,CAAA;AAAA,MAC5BC,UAD4B,GAAA,UAAA,CAAA,CAAA,CAAA;;AAG5C,MAAME,SAAS,GAAGC,KAAAA,CAAAA,WAAAA,CAAY,UAAA,OAAA,EAAW;AACvC,QAAIJ,OAAO,KAAX,IAAA,EAAsB;AACpBC,MAAAA,UAAU,CAAVA,OAAU,CAAVA;AACD;AAH0B,GAAXG,EAAlB,EAAkBA,CAAlB;AAMA,SAAA,aACE,cAAA,CAAA,SAAA,CAAA,CAAA,aAAA,CAAC,WAAD,CAAA,QAAA,EAAA;AAAsB,IAAA,KAAK,EAAEJ;AAA7B,GAAA,EAAA,aACE,cAAA,CAAA,SAAA,CAAA,CAAA,aAAA,CAAA,KAAA,EAAA,QAAA,CAAA,UAAA,CAAA;AAAK,IAAA,GAAG,EAAEG;AAAV,GAAA,EAAA,KAAA,CAAA;AACG;;;;;;;;;;;AAaDH,EAAAA,OAAO,GAAA,QAAA,GAhBb,IAEI,CADF,CADF;AAoBD;;AAEDK,YAAY,CAAZA,SAAAA,GAAyB;AACvBP,EAAAA,QAAQ,EAAEQ,KAAAA,CAAAA,SAAAA,CAAUC;AADG,CAAzBF;;AAIA,SAAA,IAAA,CAAA,KAAA,EAAqB;AACnB,SAAA,aAAOR,cAAAA,CAAAA,SAAAA,CAAAA,CAAAA,aAAAA,CAAC,WAADA,CAAAA,QAAAA,EAAP,KAAOA,CAAP;AACD;;AACDW,IAAI,CAAJA,QAAAA,GAAAA,YAAAA;;IAEMC,OAAO,GAAG,SAAVA,OAAU,GAAA;AAAA,SAAMC,KAAAA,CAAAA,UAAAA,CAAN,WAAMA,CAAN;AAAA,C","sourcesContent":["import React, { useCallback, useContext, useState } from 'react'\nimport PropTypes from 'prop-types'\n\nconst RootContext = React.createContext(null)\n\nfunction RootProvider({ children, ...props }) {\n  const [element, setElement] = useState(null)\n\n  const handleRef = useCallback(element => {\n    if (element !== null) {\n      setElement(element)\n    }\n  }, [])\n\n  return (\n    <RootContext.Provider value={element}>\n      <div ref={handleRef} {...props}>\n        {/*\n            We don’t render the children tree until the element is present, at\n            the second rendering.\n\n            The reason why it is needed is because element references are\n            assigned after the first rendering, and we don’t want to let\n            `<Root />` consumers having to deal with the reference being `null`\n            at the first rendering.\n\n            This way, we can guarantee that if a consumer gets `null` rather\n            than the element, it’s because <Root.Provider /> has to be defined\n            at an upper level.\n          */\n        element ? children : null}\n      </div>\n    </RootContext.Provider>\n  )\n}\n\nRootProvider.propTypes = {\n  children: PropTypes.node,\n}\n\nfunction Root(props) {\n  return <RootContext.Consumer {...props} />\n}\nRoot.Provider = RootProvider\n\nconst useRoot = () => useContext(RootContext)\n\nexport { Root, useRoot }\nexport default Root\n"]},"metadata":{},"sourceType":"script"}