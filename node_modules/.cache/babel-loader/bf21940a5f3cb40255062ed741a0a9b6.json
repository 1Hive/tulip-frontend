{"ast":null,"code":"'use strict'; // JS treats subjects of bitwise operators as SIGNED 32 bit numbers,\n// which means the maximum amount of bits we can store inside each byte\n// is 7..\n\nconst BITS_PER_BYTE = 7;\nmodule.exports = class SparseArray {\n  constructor() {\n    this._bitArrays = [];\n    this._data = [];\n    this._length = 0;\n    this._changedLength = false;\n    this._changedData = false;\n  }\n\n  set(index, value) {\n    let pos = this._internalPositionFor(index, false);\n\n    if (value === undefined) {\n      // unsetting\n      if (pos !== -1) {\n        // remove item from bit array and array itself\n        this._unsetInternalPos(pos);\n\n        this._unsetBit(index);\n\n        this._changedLength = true;\n        this._changedData = true;\n      }\n    } else {\n      let needsSort = false;\n\n      if (pos === -1) {\n        pos = this._data.length;\n\n        this._setBit(index);\n\n        this._changedData = true;\n      } else {\n        needsSort = true;\n      }\n\n      this._setInternalPos(pos, index, value, needsSort);\n\n      this._changedLength = true;\n    }\n  }\n\n  unset(index) {\n    this.set(index, undefined);\n  }\n\n  get(index) {\n    this._sortData();\n\n    const pos = this._internalPositionFor(index, true);\n\n    if (pos === -1) {\n      return undefined;\n    }\n\n    return this._data[pos][1];\n  }\n\n  push(value) {\n    this.set(this.length, value);\n    return this.length;\n  }\n\n  get length() {\n    this._sortData();\n\n    if (this._changedLength) {\n      const last = this._data[this._data.length - 1];\n      this._length = last ? last[0] + 1 : 0;\n      this._changedLength = false;\n    }\n\n    return this._length;\n  }\n\n  forEach(iterator) {\n    let i = 0;\n\n    while (i < this.length) {\n      iterator(this.get(i), i, this);\n      i++;\n    }\n  }\n\n  map(iterator) {\n    let i = 0;\n    let mapped = new Array(this.length);\n\n    while (i < this.length) {\n      mapped[i] = iterator(this.get(i), i, this);\n      i++;\n    }\n\n    return mapped;\n  }\n\n  reduce(reducer, initialValue) {\n    let i = 0;\n    let acc = initialValue;\n\n    while (i < this.length) {\n      const value = this.get(i);\n      acc = reducer(acc, value, i);\n      i++;\n    }\n\n    return acc;\n  }\n\n  find(finder) {\n    let i = 0,\n        found,\n        last;\n\n    while (i < this.length && !found) {\n      last = this.get(i);\n      found = finder(last);\n      i++;\n    }\n\n    return found ? last : undefined;\n  }\n\n  _internalPositionFor(index, noCreate) {\n    const bytePos = this._bytePosFor(index, noCreate);\n\n    if (bytePos >= this._bitArrays.length) {\n      return -1;\n    }\n\n    const byte = this._bitArrays[bytePos];\n    const bitPos = index - bytePos * BITS_PER_BYTE;\n    const exists = (byte & 1 << bitPos) > 0;\n\n    if (!exists) {\n      return -1;\n    }\n\n    const previousPopCount = this._bitArrays.slice(0, bytePos).reduce(popCountReduce, 0);\n\n    const mask = ~(0xffffffff << bitPos + 1);\n    const bytePopCount = popCount(byte & mask);\n    const arrayPos = previousPopCount + bytePopCount - 1;\n    return arrayPos;\n  }\n\n  _bytePosFor(index, noCreate) {\n    const bytePos = Math.floor(index / BITS_PER_BYTE);\n    const targetLength = bytePos + 1;\n\n    while (!noCreate && this._bitArrays.length < targetLength) {\n      this._bitArrays.push(0);\n    }\n\n    return bytePos;\n  }\n\n  _setBit(index) {\n    const bytePos = this._bytePosFor(index, false);\n\n    this._bitArrays[bytePos] |= 1 << index - bytePos * BITS_PER_BYTE;\n  }\n\n  _unsetBit(index) {\n    const bytePos = this._bytePosFor(index, false);\n\n    this._bitArrays[bytePos] &= ~(1 << index - bytePos * BITS_PER_BYTE);\n  }\n\n  _setInternalPos(pos, index, value, needsSort) {\n    const data = this._data;\n    const elem = [index, value];\n\n    if (needsSort) {\n      this._sortData();\n\n      data[pos] = elem;\n    } else {\n      // new element. just shove it into the array\n      // but be nice about where we shove it\n      // in order to make sorting it later easier\n      if (data.length) {\n        if (data[data.length - 1][0] >= index) {\n          data.push(elem);\n        } else if (data[0][0] <= index) {\n          data.unshift(elem);\n        } else {\n          const randomIndex = Math.round(data.length / 2);\n          this._data = data.slice(0, randomIndex).concat(elem).concat(data.slice(randomIndex));\n        }\n      } else {\n        this._data.push(elem);\n      }\n\n      this._changedData = true;\n      this._changedLength = true;\n    }\n  }\n\n  _unsetInternalPos(pos) {\n    this._data.splice(pos, 1);\n  }\n\n  _sortData() {\n    if (this._changedData) {\n      this._data.sort(sortInternal);\n    }\n\n    this._changedData = false;\n  }\n\n  bitField() {\n    const bytes = [];\n    let pendingBitsForResultingByte = 8;\n    let pendingBitsForNewByte = 0;\n    let resultingByte = 0;\n    let newByte;\n\n    const pending = this._bitArrays.slice();\n\n    while (pending.length || pendingBitsForNewByte) {\n      if (pendingBitsForNewByte === 0) {\n        newByte = pending.shift();\n        pendingBitsForNewByte = 7;\n      }\n\n      const usingBits = Math.min(pendingBitsForNewByte, pendingBitsForResultingByte);\n      const mask = ~(0b11111111 << usingBits);\n      const masked = newByte & mask;\n      resultingByte |= masked << 8 - pendingBitsForResultingByte;\n      newByte = newByte >>> usingBits;\n      pendingBitsForNewByte -= usingBits;\n      pendingBitsForResultingByte -= usingBits;\n\n      if (!pendingBitsForResultingByte || !pendingBitsForNewByte && !pending.length) {\n        bytes.push(resultingByte);\n        resultingByte = 0;\n        pendingBitsForResultingByte = 8;\n      }\n    } // remove trailing zeroes\n\n\n    for (var i = bytes.length - 1; i > 0; i--) {\n      const value = bytes[i];\n\n      if (value === 0) {\n        bytes.pop();\n      } else {\n        break;\n      }\n    }\n\n    return bytes;\n  }\n\n  compactArray() {\n    this._sortData();\n\n    return this._data.map(valueOnly);\n  }\n\n};\n\nfunction popCountReduce(count, byte) {\n  return count + popCount(byte);\n}\n\nfunction popCount(_v) {\n  let v = _v;\n  v = v - (v >> 1 & 0x55555555); // reuse input as temporary\n\n  v = (v & 0x33333333) + (v >> 2 & 0x33333333); // temp\n\n  return (v + (v >> 4) & 0xF0F0F0F) * 0x1010101 >> 24;\n}\n\nfunction sortInternal(a, b) {\n  return a[0] - b[0];\n}\n\nfunction valueOnly(elem) {\n  return elem[1];\n}","map":null,"metadata":{},"sourceType":"script"}