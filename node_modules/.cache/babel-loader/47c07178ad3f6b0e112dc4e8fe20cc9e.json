{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst EventEmitter = require('events');\n\nconst errcode = require('err-code');\n\nconst PeerInfo = require('peer-info');\n\nconst MulticodecTopology = require('libp2p-interfaces/src/topology/multicodec-topology');\n\nconst message = require('./message');\n\nconst Peer = require('./peer');\n\nconst utils = require('./utils');\n\nconst {\n  signMessage,\n  verifySignature\n} = require('./message/sign');\n\nfunction validateRegistrar(registrar) {\n  // registrar handling\n  if (typeof registrar !== 'object') {\n    throw new Error('a registrar object is required');\n  }\n\n  if (typeof registrar.handle !== 'function') {\n    throw new Error('a handle function must be provided in registrar');\n  }\n\n  if (typeof registrar.register !== 'function') {\n    throw new Error('a register function must be provided in registrar');\n  }\n\n  if (typeof registrar.unregister !== 'function') {\n    throw new Error('a unregister function must be provided in registrar');\n  }\n}\n/**\n * PubsubBaseProtocol handles the peers and connections logic for pubsub routers\n */\n\n\nclass PubsubBaseProtocol extends EventEmitter {\n  /**\n   * @param {Object} props\n   * @param {String} props.debugName log namespace\n   * @param {Array<string>|string} props.multicodecs protocol identificers to connect\n   * @param {PeerInfo} props.peerInfo peer's peerInfo\n   * @param {Object} props.registrar registrar for libp2p protocols\n   * @param {function} props.registrar.handle\n   * @param {function} props.registrar.register\n   * @param {function} props.registrar.unregister\n   * @param {boolean} [props.signMessages] if messages should be signed, defaults to true\n   * @param {boolean} [props.strictSigning] if message signing should be required, defaults to true\n   * @abstract\n   */\n  constructor({\n    debugName,\n    multicodecs,\n    peerInfo,\n    registrar,\n    signMessages = true,\n    strictSigning = true\n  }) {\n    if (typeof debugName !== 'string') {\n      throw new Error('a debugname `string` is required');\n    }\n\n    if (!multicodecs) {\n      throw new Error('multicodecs are required');\n    }\n\n    if (!PeerInfo.isPeerInfo(peerInfo)) {\n      throw new Error('peer info must be an instance of `peer-info`');\n    }\n\n    validateRegistrar(registrar);\n    super();\n    this.log = debug(debugName);\n    this.log.err = debug(`${debugName}:error`);\n    this.multicodecs = utils.ensureArray(multicodecs);\n    this.peerInfo = peerInfo;\n    this.registrar = registrar;\n    this.started = false;\n    /**\n     * Map of topics to which peers are subscribed to\n     *\n     * @type {Map<string, Peer>}\n     */\n\n    this.topics = new Map();\n    /**\n     * Map of peers.\n     *\n     * @type {Map<string, Peer>}\n     */\n\n    this.peers = new Map(); // Message signing\n\n    if (signMessages) {\n      this.peerId = this.peerInfo.id;\n    }\n    /**\n     * If message signing should be required for incoming messages\n     * @type {boolean}\n     */\n\n\n    this.strictSigning = strictSigning;\n    this._registrarId = undefined;\n    this._onIncomingStream = this._onIncomingStream.bind(this);\n    this._onPeerConnected = this._onPeerConnected.bind(this);\n    this._onPeerDisconnected = this._onPeerDisconnected.bind(this);\n  }\n  /**\n   * Register the pubsub protocol onto the libp2p node.\n   * @returns {Promise<void>}\n   */\n\n\n  async start() {\n    if (this.started) {\n      return;\n    }\n\n    this.log('starting'); // Incoming streams\n\n    this.registrar.handle(this.multicodecs, this._onIncomingStream); // register protocol with topology\n\n    const topology = new MulticodecTopology({\n      multicodecs: this.multicodecs,\n      handlers: {\n        onConnect: this._onPeerConnected,\n        onDisconnect: this._onPeerDisconnected\n      }\n    });\n    this._registrarId = await this.registrar.register(topology);\n    this.log('started');\n    this.started = true;\n  }\n  /**\n   * Unregister the pubsub protocol and the streams with other peers will be closed.\n   * @returns {Promise}\n   */\n\n\n  async stop() {\n    if (!this.started) {\n      return;\n    } // unregister protocol and handlers\n\n\n    await this.registrar.unregister(this._registrarId);\n    this.log('stopping');\n    this.peers.forEach(peer => peer.close());\n    this.peers = new Map();\n    this.started = false;\n    this.log('stopped');\n  }\n  /**\n   * On an incoming stream event.\n   * @private\n   * @param {Object} props\n   * @param {string} props.protocol\n   * @param {DuplexStream} props.strean\n   * @param {Connection} props.connection connection\n   */\n\n\n  async _onIncomingStream({\n    protocol,\n    stream,\n    connection\n  }) {\n    const peerInfo = await PeerInfo.create(connection.remotePeer);\n    peerInfo.protocols.add(protocol);\n    const idB58Str = peerInfo.id.toB58String();\n\n    const peer = this._addPeer(peerInfo);\n\n    this._processMessages(idB58Str, stream, peer);\n  }\n  /**\n   * Registrar notifies a connection successfully with pubsub protocol.\n   * @private\n   * @param {PeerInfo} peerInfo remote peer info\n   * @param {Connection} conn connection to the peer\n   */\n\n\n  async _onPeerConnected(peerInfo, conn) {\n    const idB58Str = peerInfo.id.toB58String();\n    this.log('connected', idB58Str);\n\n    const peer = this._addPeer(peerInfo);\n\n    try {\n      const {\n        stream\n      } = await conn.newStream(this.multicodecs);\n      peer.attachConnection(stream);\n    } catch (err) {\n      this.log.err(err);\n    }\n  }\n  /**\n   * Registrar notifies a closing connection with pubsub protocol.\n   * @private\n   * @param {PeerInfo} peerInfo peer info\n   * @param {Error} err error for connection end\n   */\n\n\n  _onPeerDisconnected(peerInfo, err) {\n    const idB58Str = peerInfo.id.toB58String();\n    const peer = this.peers.get(idB58Str);\n    this.log('connection ended', idB58Str, err ? err.message : '');\n\n    this._removePeer(peer);\n  }\n  /**\n   * Add a new connected peer to the peers map.\n   * @private\n   * @param {PeerInfo} peerInfo peer info\n   * @returns {PeerInfo}\n   */\n\n\n  _addPeer(peerInfo) {\n    const id = peerInfo.id.toB58String();\n    let existing = this.peers.get(id);\n\n    if (!existing) {\n      this.log('new peer', id);\n      const peer = new Peer(peerInfo);\n      this.peers.set(id, peer);\n      existing = peer;\n      peer.once('close', () => this._removePeer(peer));\n    }\n\n    return existing;\n  }\n  /**\n   * Remove a peer from the peers map.\n   * @private\n   * @param {Peer} peer peer state\n   * @returns {PeerInfo}\n   */\n\n\n  _removePeer(peer) {\n    if (!peer) return;\n    const id = peer.info.id.toB58String();\n    this.log('delete peer', id);\n    this.peers.delete(id);\n    return peer;\n  }\n  /**\n   * Validates the given message. The signature will be checked for authenticity.\n   * @param {rpc.RPC.Message} message\n   * @returns {Promise<Boolean>}\n   */\n\n\n  async validate(message) {\n    // eslint-disable-line require-await\n    // If strict signing is on and we have no signature, abort\n    if (this.strictSigning && !message.signature) {\n      this.log('Signing required and no signature was present, dropping message:', message);\n      return false;\n    } // Check the message signature if present\n\n\n    if (message.signature) {\n      return verifySignature(message);\n    } else {\n      return true;\n    }\n  }\n  /**\n   * Normalizes the message and signs it, if signing is enabled\n   * @private\n   * @param {Message} message\n   * @returns {Promise<Message>}\n   */\n\n\n  _buildMessage(message) {\n    const msg = utils.normalizeOutRpcMessage(message);\n\n    if (this.peerId) {\n      return signMessage(this.peerId, msg);\n    } else {\n      return message;\n    }\n  }\n  /**\n   * Get a list of the peer-ids that are subscribed to one topic.\n   * @param {string} topic\n   * @returns {Array<string>}\n   */\n\n\n  getSubscribers(topic) {\n    if (!this.started) {\n      throw errcode(new Error('not started yet'), 'ERR_NOT_STARTED_YET');\n    }\n\n    if (!topic || typeof topic !== 'string') {\n      throw errcode(new Error('a string topic must be provided'), 'ERR_NOT_VALID_TOPIC');\n    }\n\n    return Array.from(this.peers.values()).filter(peer => peer.topics.has(topic)).map(peer => peer.info.id.toB58String());\n  }\n  /**\n   * Overriding the implementation of publish should handle the appropriate algorithms for the publish/subscriber implementation.\n   * For example, a Floodsub implementation might simply publish each message to each topic for every peer\n   * @abstract\n   * @param {Array<string>|string} topics\n   * @param {Array<any>|any} messages\n   * @returns {Promise}\n   *\n   */\n\n\n  publish(topics, messages) {\n    throw errcode(new Error('publish must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED');\n  }\n  /**\n   * Overriding the implementation of subscribe should handle the appropriate algorithms for the publish/subscriber implementation.\n   * For example, a Floodsub implementation might simply send a message for every peer showing interest in the topics\n   * @abstract\n   * @param {Array<string>|string} topics\n   * @returns {void}\n   */\n\n\n  subscribe(topics) {\n    throw errcode(new Error('subscribe must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED');\n  }\n  /**\n   * Overriding the implementation of unsubscribe should handle the appropriate algorithms for the publish/subscriber implementation.\n   * For example, a Floodsub implementation might simply send a message for every peer revoking interest in the topics\n   * @abstract\n   * @param {Array<string>|string} topics\n   * @returns {void}\n   */\n\n\n  unsubscribe(topics) {\n    throw errcode(new Error('unsubscribe must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED');\n  }\n  /**\n   * Overriding the implementation of getTopics should handle the appropriate algorithms for the publish/subscriber implementation.\n   * Get the list of subscriptions the peer is subscribed to.\n   * @abstract\n   * @returns {Array<string>}\n   */\n\n\n  getTopics() {\n    throw errcode(new Error('getTopics must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED');\n  }\n  /**\n   * Overriding the implementation of _processMessages should keep the connection and is\n   * responsible for processing each RPC message received by other peers.\n   * @abstract\n   * @param {string} idB58Str peer id string in base58\n   * @param {Connection} conn connection\n   * @param {Peer} peer A Pubsub Peer\n   * @returns {void}\n   *\n   */\n\n\n  _processMessages(idB58Str, conn, peer) {\n    throw errcode(new Error('_processMessages must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED');\n  }\n\n}\n\nmodule.exports = PubsubBaseProtocol;\nmodule.exports.message = message;\nmodule.exports.utils = utils;","map":null,"metadata":{},"sourceType":"script"}