{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar _require2 = require('interface-datastore'),\n    Key = _require2.Key,\n    Adapter = _require2.Adapter;\n\nvar _require3 = require('./utils'),\n    encodeBase32 = _require3.encodeBase32,\n    keyToTopic = _require3.keyToTopic,\n    topicToKey = _require3.topicToKey;\n\nvar errcode = require('err-code');\n\nvar debug = require('debug');\n\nvar log = debug('datastore-pubsub:publisher');\nlog.error = debug('datastore-pubsub:publisher:error'); // DatastorePubsub is responsible for providing an api for pubsub to be used as a datastore with\n// [TieredDatastore]{@link https://github.com/ipfs/js-datastore-core/blob/master/src/tiered.js}\n\nvar DatastorePubsub = /*#__PURE__*/function (_Adapter) {\n  _inherits(DatastorePubsub, _Adapter);\n\n  var _super = _createSuper(DatastorePubsub);\n\n  /**\n   * Creates an instance of DatastorePubsub.\n   * @param {*} pubsub - pubsub implementation.\n   * @param {*} datastore - datastore instance.\n   * @param {*} peerId - peer-id instance.\n   * @param {Object} validator - validator functions.\n   * @param {function(record, peerId, callback)} validator.validate - function to validate a record.\n   * @param {function(received, current, callback)} validator.select - function to select the newest between two records.\n   * @param {function(key, callback)} subscriptionKeyFn - optional function to manipulate the key topic received before processing it.\n   * @memberof DatastorePubsub\n   */\n  function DatastorePubsub(pubsub, datastore, peerId, validator, subscriptionKeyFn) {\n    var _this;\n\n    _classCallCheck(this, DatastorePubsub);\n\n    _this = _super.call(this);\n\n    if (!validator) {\n      throw errcode(new TypeError('missing validator'), 'ERR_INVALID_PARAMETERS');\n    }\n\n    if (typeof validator.validate !== 'function') {\n      throw errcode(new TypeError('missing validate function'), 'ERR_INVALID_PARAMETERS');\n    }\n\n    if (typeof validator.select !== 'function') {\n      throw errcode(new TypeError('missing select function'), 'ERR_INVALID_PARAMETERS');\n    }\n\n    if (subscriptionKeyFn && typeof subscriptionKeyFn !== 'function') {\n      throw errcode(new TypeError('invalid subscriptionKeyFn received'), 'ERR_INVALID_PARAMETERS');\n    }\n\n    _this._pubsub = pubsub;\n    _this._datastore = datastore;\n    _this._peerId = peerId;\n    _this._validator = validator;\n    _this._handleSubscriptionKeyFn = subscriptionKeyFn; // Bind _onMessage function, which is called by pubsub.\n\n    _this._onMessage = _this._onMessage.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n  /**\n   * Publishes a value through pubsub.\n   * @param {Buffer} key identifier of the value to be published.\n   * @param {Buffer} val value to be propagated.\n   * @returns {Promise}\n   */\n\n\n  _createClass(DatastorePubsub, [{\n    key: \"put\",\n    value: function () {\n      var _put = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(key, val) {\n        var errMsg, _errMsg, stringifiedTopic;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (Buffer.isBuffer(key)) {\n                  _context.next = 4;\n                  break;\n                }\n\n                errMsg = 'datastore key does not have a valid format';\n                log.error(errMsg);\n                throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY');\n\n              case 4:\n                if (Buffer.isBuffer(val)) {\n                  _context.next = 8;\n                  break;\n                }\n\n                _errMsg = 'received value is not a buffer';\n                log.error(_errMsg);\n                throw errcode(new Error(_errMsg), 'ERR_INVALID_VALUE_RECEIVED');\n\n              case 8:\n                stringifiedTopic = keyToTopic(key);\n                log(\"publish value for topic \".concat(stringifiedTopic)); // Publish record to pubsub\n\n                return _context.abrupt(\"return\", this._pubsub.publish(stringifiedTopic, val));\n\n              case 11:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function put(_x, _x2) {\n        return _put.apply(this, arguments);\n      }\n\n      return put;\n    }()\n    /**\n     * Try to subscribe a topic with Pubsub and returns the local value if available.\n     * @param {Buffer} key identifier of the value to be subscribed.\n     * @returns {Promise<Buffer>}\n     */\n\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(key) {\n        var errMsg, stringifiedTopic, subscriptions, _errMsg2;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (Buffer.isBuffer(key)) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                errMsg = 'datastore key does not have a valid format';\n                log.error(errMsg);\n                throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY');\n\n              case 4:\n                stringifiedTopic = keyToTopic(key);\n                _context2.next = 7;\n                return this._pubsub.getTopics();\n\n              case 7:\n                subscriptions = _context2.sent;\n\n                if (!(subscriptions && Array.isArray(subscriptions) && subscriptions.indexOf(stringifiedTopic) > -1)) {\n                  _context2.next = 10;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", this._getLocal(key));\n\n              case 10:\n                _context2.prev = 10;\n                _context2.next = 13;\n                return this._pubsub.subscribe(stringifiedTopic, this._onMessage);\n\n              case 13:\n                _context2.next = 20;\n                break;\n\n              case 15:\n                _context2.prev = 15;\n                _context2.t0 = _context2[\"catch\"](10);\n                _errMsg2 = \"cannot subscribe topic \".concat(stringifiedTopic);\n                log.error(_errMsg2);\n                throw errcode(new Error(_errMsg2), 'ERR_SUBSCRIBING_TOPIC');\n\n              case 20:\n                log(\"subscribed values for key \".concat(stringifiedTopic));\n                return _context2.abrupt(\"return\", this._getLocal(key));\n\n              case 22:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[10, 15]]);\n      }));\n\n      function get(_x3) {\n        return _get.apply(this, arguments);\n      }\n\n      return get;\n    }()\n    /**\n     * Unsubscribe topic.\n     * @param {Buffer} key identifier of the value to unsubscribe.\n     * @returns {void}\n     */\n\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(key) {\n      var stringifiedTopic = keyToTopic(key);\n      return this._pubsub.unsubscribe(stringifiedTopic, this._onMessage);\n    } // Get record from local datastore\n\n  }, {\n    key: \"_getLocal\",\n    value: function () {\n      var _getLocal2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(key) {\n        var routingKey, dsVal, _errMsg3, errMsg, _errMsg4;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                // encode key - base32(/ipns/{cid})\n                routingKey = new Key('/' + encodeBase32(key), false);\n                _context3.prev = 1;\n                _context3.next = 4;\n                return this._datastore.get(routingKey);\n\n              case 4:\n                dsVal = _context3.sent;\n                _context3.next = 16;\n                break;\n\n              case 7:\n                _context3.prev = 7;\n                _context3.t0 = _context3[\"catch\"](1);\n\n                if (!(_context3.t0.code !== 'ERR_NOT_FOUND')) {\n                  _context3.next = 13;\n                  break;\n                }\n\n                _errMsg3 = \"unexpected error getting the ipns record for \".concat(routingKey.toString());\n                log.error(_errMsg3);\n                throw errcode(new Error(_errMsg3), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD');\n\n              case 13:\n                errMsg = \"local record requested was not found for \".concat(routingKey.toString());\n                log.error(errMsg);\n                throw errcode(new Error(errMsg), 'ERR_NOT_FOUND');\n\n              case 16:\n                if (Buffer.isBuffer(dsVal)) {\n                  _context3.next = 20;\n                  break;\n                }\n\n                _errMsg4 = 'found record that we couldn\\'t convert to a value';\n                log.error(_errMsg4);\n                throw errcode(new Error(_errMsg4), 'ERR_INVALID_RECORD_RECEIVED');\n\n              case 20:\n                return _context3.abrupt(\"return\", dsVal);\n\n              case 21:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[1, 7]]);\n      }));\n\n      function _getLocal(_x4) {\n        return _getLocal2.apply(this, arguments);\n      }\n\n      return _getLocal;\n    }() // handles pubsub subscription messages\n\n  }, {\n    key: \"_onMessage\",\n    value: function () {\n      var _onMessage2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(msg) {\n        var data, from, topicIDs, key, res;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                data = msg.data, from = msg.from, topicIDs = msg.topicIDs;\n                _context4.prev = 1;\n                key = topicToKey(topicIDs[0]);\n                _context4.next = 9;\n                break;\n\n              case 5:\n                _context4.prev = 5;\n                _context4.t0 = _context4[\"catch\"](1);\n                log.error(_context4.t0);\n                return _context4.abrupt(\"return\");\n\n              case 9:\n                log(\"message received for topic \".concat(topicIDs[0])); // Stop if the message is from the peer (it already stored it while publishing to pubsub)\n\n                if (!(from === this._peerId.toB58String())) {\n                  _context4.next = 13;\n                  break;\n                }\n\n                log('message discarded as it is from the same peer');\n                return _context4.abrupt(\"return\");\n\n              case 13:\n                if (!this._handleSubscriptionKeyFn) {\n                  _context4.next = 25;\n                  break;\n                }\n\n                _context4.prev = 14;\n                _context4.next = 17;\n                return this._handleSubscriptionKeyFn(key);\n\n              case 17:\n                res = _context4.sent;\n                _context4.next = 24;\n                break;\n\n              case 20:\n                _context4.prev = 20;\n                _context4.t1 = _context4[\"catch\"](14);\n                log.error('message discarded by the subscriptionKeyFn');\n                return _context4.abrupt(\"return\");\n\n              case 24:\n                key = res;\n\n              case 25:\n                _context4.prev = 25;\n                _context4.next = 28;\n                return this._storeIfSubscriptionIsBetter(key, data);\n\n              case 28:\n                _context4.next = 33;\n                break;\n\n              case 30:\n                _context4.prev = 30;\n                _context4.t2 = _context4[\"catch\"](25);\n                log.error(_context4.t2);\n\n              case 33:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[1, 5], [14, 20], [25, 30]]);\n      }));\n\n      function _onMessage(_x5) {\n        return _onMessage2.apply(this, arguments);\n      }\n\n      return _onMessage;\n    }() // Store the received record if it is better than the current stored\n\n  }, {\n    key: \"_storeIfSubscriptionIsBetter\",\n    value: function () {\n      var _storeIfSubscriptionIsBetter2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(key, data) {\n        var isBetter;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                isBetter = false;\n                _context5.prev = 1;\n                _context5.next = 4;\n                return this._isBetter(key, data);\n\n              case 4:\n                isBetter = _context5.sent;\n                _context5.next = 11;\n                break;\n\n              case 7:\n                _context5.prev = 7;\n                _context5.t0 = _context5[\"catch\"](1);\n\n                if (!(_context5.t0.code !== 'ERR_NOT_VALID_RECORD')) {\n                  _context5.next = 11;\n                  break;\n                }\n\n                throw _context5.t0;\n\n              case 11:\n                if (!isBetter) {\n                  _context5.next = 14;\n                  break;\n                }\n\n                _context5.next = 14;\n                return this._storeRecord(Buffer.from(key), data);\n\n              case 14:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[1, 7]]);\n      }));\n\n      function _storeIfSubscriptionIsBetter(_x6, _x7) {\n        return _storeIfSubscriptionIsBetter2.apply(this, arguments);\n      }\n\n      return _storeIfSubscriptionIsBetter;\n    }() // Validate record according to the received validation function\n\n  }, {\n    key: \"_validateRecord\",\n    value: function () {\n      var _validateRecord2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(value, peerId) {\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                return _context6.abrupt(\"return\", this._validator.validate(value, peerId));\n\n              case 1:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function _validateRecord(_x8, _x9) {\n        return _validateRecord2.apply(this, arguments);\n      }\n\n      return _validateRecord;\n    }() // Select the best record according to the received select function.\n\n  }, {\n    key: \"_selectRecord\",\n    value: function () {\n      var _selectRecord2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(receivedRecord, currentRecord) {\n        var res;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.next = 2;\n                return this._validator.select(receivedRecord, currentRecord);\n\n              case 2:\n                res = _context7.sent;\n                return _context7.abrupt(\"return\", res === 0);\n\n              case 4:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function _selectRecord(_x10, _x11) {\n        return _selectRecord2.apply(this, arguments);\n      }\n\n      return _selectRecord;\n    }() // Verify if the record received through pubsub is valid and better than the one currently stored\n\n  }, {\n    key: \"_isBetter\",\n    value: function () {\n      var _isBetter2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(key, val) {\n        var error, valid, errMsg, dsKey, currentRecord;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.prev = 0;\n                _context8.next = 3;\n                return this._validateRecord(val, key);\n\n              case 3:\n                valid = _context8.sent;\n                _context8.next = 9;\n                break;\n\n              case 6:\n                _context8.prev = 6;\n                _context8.t0 = _context8[\"catch\"](0);\n                error = _context8.t0;\n\n              case 9:\n                if (!(error || !valid)) {\n                  _context8.next = 13;\n                  break;\n                }\n\n                errMsg = 'record received through pubsub is not valid';\n                log.error(errMsg);\n                throw errcode(new Error(errMsg), 'ERR_NOT_VALID_RECORD');\n\n              case 13:\n                // Get Local record\n                dsKey = new Key(key);\n                _context8.prev = 14;\n                _context8.next = 17;\n                return this._getLocal(dsKey.toBuffer());\n\n              case 17:\n                currentRecord = _context8.sent;\n                _context8.next = 23;\n                break;\n\n              case 20:\n                _context8.prev = 20;\n                _context8.t1 = _context8[\"catch\"](14);\n                return _context8.abrupt(\"return\", true);\n\n              case 23:\n                if (!currentRecord.equals(val)) {\n                  _context8.next = 25;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\", false);\n\n              case 25:\n                return _context8.abrupt(\"return\", this._selectRecord(val, currentRecord));\n\n              case 26:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this, [[0, 6], [14, 20]]);\n      }));\n\n      function _isBetter(_x12, _x13) {\n        return _isBetter2.apply(this, arguments);\n      }\n\n      return _isBetter;\n    }() // add record to datastore\n\n  }, {\n    key: \"_storeRecord\",\n    value: function () {\n      var _storeRecord2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(key, data) {\n        var routingKey;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                // encode key - base32(/ipns/{cid})\n                routingKey = new Key('/' + encodeBase32(key), false);\n                _context9.next = 3;\n                return this._datastore.put(routingKey, data);\n\n              case 3:\n                log(\"record for \".concat(keyToTopic(key), \" was stored in the datastore\"));\n\n              case 4:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function _storeRecord(_x14, _x15) {\n        return _storeRecord2.apply(this, arguments);\n      }\n\n      return _storeRecord;\n    }()\n  }, {\n    key: \"open\",\n    value: function open() {\n      var errMsg = 'open function was not implemented yet';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET');\n    }\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      var errMsg = 'has function was not implemented yet';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET');\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key) {\n      var errMsg = 'delete function was not implemented yet';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET');\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      var errMsg = 'close function was not implemented yet';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET');\n    }\n  }, {\n    key: \"batch\",\n    value: function batch() {\n      var errMsg = 'batch function was not implemented yet';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET');\n    }\n  }, {\n    key: \"query\",\n    value: function query() {\n      var errMsg = 'query function was not implemented yet';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET');\n    }\n  }]);\n\n  return DatastorePubsub;\n}(Adapter);\n\nexports = module.exports = DatastorePubsub;","map":null,"metadata":{},"sourceType":"script"}