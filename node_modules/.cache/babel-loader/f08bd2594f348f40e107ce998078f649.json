{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _slicedToArray = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _require = require('../../utils'),\n    withTimeoutOption = _require.withTimeoutOption;\n\nmodule.exports = function (_ref) {\n  var libp2p = _ref.libp2p;\n  return withTimeoutOption( /*#__PURE__*/function () {\n    var _peers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(options) {\n      var verbose, peers, _iterator, _step, _step$value, peerId, connections, _iterator2, _step2, connection, tupple;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              // eslint-disable-line require-await\n              options = options || {};\n              verbose = options.v || options.verbose;\n              peers = [];\n              _iterator = _createForOfIteratorHelper(libp2p.connections);\n\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  _step$value = _slicedToArray(_step.value, 2), peerId = _step$value[0], connections = _step$value[1];\n                  _iterator2 = _createForOfIteratorHelper(connections);\n\n                  try {\n                    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                      connection = _step2.value;\n                      tupple = {\n                        addr: connection.remoteAddr,\n                        peer: peerId\n                      };\n\n                      if (verbose || options.direction) {\n                        tupple.direction = connection.stat.direction;\n                      }\n\n                      if (verbose) {\n                        tupple.muxer = connection.stat.multiplexer;\n                        tupple.latency = 'n/a';\n                      }\n\n                      peers.push(tupple);\n                    }\n                  } catch (err) {\n                    _iterator2.e(err);\n                  } finally {\n                    _iterator2.f();\n                  }\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n\n              return _context.abrupt(\"return\", peers);\n\n            case 6:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    function peers(_x) {\n      return _peers.apply(this, arguments);\n    }\n\n    return peers;\n  }());\n};","map":null,"metadata":{},"sourceType":"script"}