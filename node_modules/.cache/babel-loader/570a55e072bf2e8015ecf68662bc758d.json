{"ast":null,"code":"import env from '../environment';\nimport { providers as Providers, utils } from 'ethers';\nimport { InvalidURI, InvalidNetworkType, NoConnection } from '../errors';\nimport { validHttpFormat } from './uri-utils';\nconst {\n  id: keccak256,\n  solidityKeccak256: soliditySha3,\n  toUtf8String\n} = utils;\nexport const DEFAULT_LOCAL_CHAIN = 'private';\nexport const ZERO_ADDRESS = `0x${''.padEnd(40, '0')}`;\nexport const ETH_FAKE_ADDRESS = ZERO_ADDRESS;\nconst ETH_ADDRESS_SPLIT_REGEX = /(0x[a-fA-F0-9]{40}(?:\\b|\\.|,|\\?|!|;))/g;\nconst ETH_ADDRESS_TEST_REGEX = /(0x[a-fA-F0-9]{40}(?:\\b|\\.|,|\\?|!|;))/g;\nexport function getFunctionSignature(func) {\n  return keccak256(func).slice(0, 10);\n}\nexport function encodeFunctionData(contract, functionName, params) {\n  return contract.interface.encodeFunctionData(functionName, params);\n}\nexport function getUseWalletProviders() {\n  const providers = [{\n    id: 'injected'\n  }];\n\n  if (env('FORTMATIC_API_KEY')) {\n    providers.push({\n      id: 'fortmatic',\n      useWalletConf: {\n        apiKey: env('FORTMATIC_API_KEY')\n      }\n    });\n  }\n\n  if (env('PORTIS_DAPP_ID')) {\n    providers.push({\n      id: 'portis',\n      useWalletConf: {\n        dAppId: env('PORTIS_DAPP_ID')\n      }\n    });\n  }\n\n  return providers;\n}\nexport function getUseWalletConnectors() {\n  return getUseWalletProviders().reduce((connectors, provider) => {\n    if (provider.useWalletConf) {\n      connectors[provider.id] = provider.useWalletConf;\n    }\n\n    return connectors;\n  }, {});\n}\n\nfunction toChecksumAddress(address) {\n  if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {\n    throw new Error('Given address \"' + address + '\" is not a valid Ethereum address.');\n  }\n\n  address = address.toLowerCase().replace(/^0x/i, '');\n  const addressHash = keccak256(address).replace(/^0x/i, '');\n  let checksumAddress = '0x';\n\n  for (let i = 0; i < address.length; i++) {\n    // If ith character is 9 to f then make it uppercase\n    if (parseInt(addressHash[i], 16) > 7) {\n      checksumAddress += address[i].toUpperCase();\n    } else {\n      checksumAddress += address[i];\n    }\n  }\n\n  return checksumAddress;\n} // Check address equality with checksums\n\n\nexport function addressesEqual(first, second) {\n  first = first && toChecksumAddress(first);\n  second = second && toChecksumAddress(second);\n  return first === second;\n}\nexport const addressPattern = '(0x)?[0-9a-fA-F]{40}';\n/**\r\n * Shorten an Ethereum address. `charsLength` allows to change the number of\r\n * characters on both sides of the ellipsis.\r\n *\r\n * Examples:\r\n *   shortenAddress('0x19731977931271')    // 0x1973…1271\r\n *   shortenAddress('0x19731977931271', 2) // 0x19…71\r\n *   shortenAddress('0x197319')            // 0x197319 (already short enough)\r\n *\r\n * @param {string} address The address to shorten\r\n * @param {number} [charsLength=4] The number of characters to change on both sides of the ellipsis\r\n * @returns {string} The shortened address\r\n */\n\nexport function shortenAddress(address, charsLength = 4) {\n  const prefixLength = 2; // \"0x\"\n\n  if (!address) {\n    return '';\n  }\n\n  if (address.length < charsLength * 2 + prefixLength) {\n    return address;\n  }\n\n  return address.slice(0, charsLength + prefixLength) + '…' + address.slice(-charsLength);\n}\nexport function getNetworkType(chainId = env('CHAIN_ID')) {\n  chainId = String(chainId);\n  if (chainId === '1') return 'main';\n  if (chainId === '3') return 'ropsten';\n  if (chainId === '4') return 'rinkeby';\n  if (chainId === '100') return 'xdai';\n  return DEFAULT_LOCAL_CHAIN;\n}\nexport function getNetworkName(chainId = env('CHAIN_ID')) {\n  chainId = String(chainId);\n  if (chainId === '1') return 'Mainnet';\n  if (chainId === '3') return 'Ropsten';\n  if (chainId === '4') return 'Rinkeby';\n  if (chainId === '100') return 'xDai';\n  return 'unknown';\n}\nexport function sanitizeNetworkType(networkType) {\n  if (networkType === 'private') {\n    return 'localhost';\n  } else if (networkType === 'main') {\n    return 'mainnet';\n  }\n\n  return networkType;\n}\nexport function isLocalOrUnknownNetwork(chainId = env('CHAIN_ID')) {\n  return getNetworkType(chainId) === DEFAULT_LOCAL_CHAIN;\n} // Detect Ethereum addresses in a string and transform each part.\n//\n// `callback` is called on every part with two params:\n//   - The string of the current part.\n//   - A boolean indicating if it is an address.\n//\n\nexport function transformAddresses(str, callback) {\n  return str.split(ETH_ADDRESS_SPLIT_REGEX).map((part, index) => callback(part, ETH_ADDRESS_TEST_REGEX.test(part), index));\n}\n/**\r\n * Check if the ETH node at the given URI is compatible for the current environment\r\n * @param {string} uri URI of the ETH node.\r\n * @param {string} expectedNetworkType The expected network type of the ETH node.\r\n * @returns {Promise} Resolves if the ETH node is compatible, otherwise throws:\r\n *    - InvalidURI: URI given is not compatible (e.g. must be WebSockets)\r\n *    - InvalidNetworkType: ETH node connected to wrong network\r\n *    - NoConnection: Couldn't connect to URI\r\n */\n\nexport async function checkValidEthNode(uri) {\n  const isLocalOrUnknown = isLocalOrUnknownNetwork(env('CHAIN_ID'));\n\n  if (!validHttpFormat(uri)) {\n    throw new InvalidURI('The URI must use the HTTP protocol');\n  }\n\n  try {\n    const expectedNetworkType = getNetworkType();\n    const provider = await new Providers.JsonRpcProvider(uri);\n    const networkType = await provider.getNetwork();\n    const networkTypeName = networkType.name === 'homestead' ? 'main' : networkType.name;\n\n    if (!isLocalOrUnknown) {\n      if (networkTypeName !== expectedNetworkType) {\n        throw new InvalidNetworkType();\n      }\n    }\n  } catch (err) {\n    if (err instanceof InvalidNetworkType) {\n      throw err;\n    }\n\n    throw new NoConnection();\n  }\n\n  return true;\n}\nexport async function signMessage(wallet, message) {\n  let signHash;\n  let error = false;\n\n  try {\n    signHash = await wallet.ethers.getSigner().signMessage(message);\n  } catch (err) {\n    error = err;\n  }\n\n  return {\n    signHash,\n    error\n  };\n}\nexport function sanitizeSignature(signature) {\n  return { ...signature,\n    r: `0x${signature.r}`,\n    s: `0x${signature.s}`\n  };\n} // ethers utils exports\n\nexport { keccak256, soliditySha3, toUtf8String };","map":{"version":3,"sources":["/Users/fabianmolina/Documents/1hive/tulip-frontend/src/lib/web3-utils.js"],"names":["env","providers","Providers","utils","InvalidURI","InvalidNetworkType","NoConnection","validHttpFormat","id","keccak256","solidityKeccak256","soliditySha3","toUtf8String","DEFAULT_LOCAL_CHAIN","ZERO_ADDRESS","padEnd","ETH_FAKE_ADDRESS","ETH_ADDRESS_SPLIT_REGEX","ETH_ADDRESS_TEST_REGEX","getFunctionSignature","func","slice","encodeFunctionData","contract","functionName","params","interface","getUseWalletProviders","push","useWalletConf","apiKey","dAppId","getUseWalletConnectors","reduce","connectors","provider","toChecksumAddress","address","test","Error","toLowerCase","replace","addressHash","checksumAddress","i","length","parseInt","toUpperCase","addressesEqual","first","second","addressPattern","shortenAddress","charsLength","prefixLength","getNetworkType","chainId","String","getNetworkName","sanitizeNetworkType","networkType","isLocalOrUnknownNetwork","transformAddresses","str","callback","split","map","part","index","checkValidEthNode","uri","isLocalOrUnknown","expectedNetworkType","JsonRpcProvider","getNetwork","networkTypeName","name","err","signMessage","wallet","message","signHash","error","ethers","getSigner","sanitizeSignature","signature","r","s"],"mappings":"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","sourcesContent":["import env from '../environment'\r\nimport { providers as Providers, utils } from 'ethers'\r\nimport { InvalidURI, InvalidNetworkType, NoConnection } from '../errors'\r\nimport { validHttpFormat } from './uri-utils'\r\n\r\nconst { id: keccak256, solidityKeccak256: soliditySha3, toUtf8String } = utils\r\n\r\nexport const DEFAULT_LOCAL_CHAIN = 'private'\r\nexport const ZERO_ADDRESS = `0x${''.padEnd(40, '0')}`\r\nexport const ETH_FAKE_ADDRESS = ZERO_ADDRESS\r\n\r\nconst ETH_ADDRESS_SPLIT_REGEX = /(0x[a-fA-F0-9]{40}(?:\\b|\\.|,|\\?|!|;))/g\r\nconst ETH_ADDRESS_TEST_REGEX = /(0x[a-fA-F0-9]{40}(?:\\b|\\.|,|\\?|!|;))/g\r\n\r\nexport function getFunctionSignature(func) {\r\n  return keccak256(func).slice(0, 10)\r\n}\r\n\r\nexport function encodeFunctionData(contract, functionName, params) {\r\n  return contract.interface.encodeFunctionData(functionName, params)\r\n}\r\n\r\nexport function getUseWalletProviders() {\r\n  const providers = [{ id: 'injected' }]\r\n\r\n  if (env('FORTMATIC_API_KEY')) {\r\n    providers.push({\r\n      id: 'fortmatic',\r\n      useWalletConf: { apiKey: env('FORTMATIC_API_KEY') },\r\n    })\r\n  }\r\n\r\n  if (env('PORTIS_DAPP_ID')) {\r\n    providers.push({\r\n      id: 'portis',\r\n      useWalletConf: { dAppId: env('PORTIS_DAPP_ID') },\r\n    })\r\n  }\r\n\r\n  return providers\r\n}\r\n\r\nexport function getUseWalletConnectors() {\r\n  return getUseWalletProviders().reduce((connectors, provider) => {\r\n    if (provider.useWalletConf) {\r\n      connectors[provider.id] = provider.useWalletConf\r\n    }\r\n    return connectors\r\n  }, {})\r\n}\r\n\r\nfunction toChecksumAddress(address) {\r\n  if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {\r\n    throw new Error(\r\n      'Given address \"' + address + '\" is not a valid Ethereum address.'\r\n    )\r\n  }\r\n\r\n  address = address.toLowerCase().replace(/^0x/i, '')\r\n\r\n  const addressHash = keccak256(address).replace(/^0x/i, '')\r\n  let checksumAddress = '0x'\r\n\r\n  for (let i = 0; i < address.length; i++) {\r\n    // If ith character is 9 to f then make it uppercase\r\n    if (parseInt(addressHash[i], 16) > 7) {\r\n      checksumAddress += address[i].toUpperCase()\r\n    } else {\r\n      checksumAddress += address[i]\r\n    }\r\n  }\r\n\r\n  return checksumAddress\r\n}\r\n\r\n// Check address equality with checksums\r\nexport function addressesEqual(first, second) {\r\n  first = first && toChecksumAddress(first)\r\n  second = second && toChecksumAddress(second)\r\n  return first === second\r\n}\r\n\r\nexport const addressPattern = '(0x)?[0-9a-fA-F]{40}'\r\n\r\n/**\r\n * Shorten an Ethereum address. `charsLength` allows to change the number of\r\n * characters on both sides of the ellipsis.\r\n *\r\n * Examples:\r\n *   shortenAddress('0x19731977931271')    // 0x1973…1271\r\n *   shortenAddress('0x19731977931271', 2) // 0x19…71\r\n *   shortenAddress('0x197319')            // 0x197319 (already short enough)\r\n *\r\n * @param {string} address The address to shorten\r\n * @param {number} [charsLength=4] The number of characters to change on both sides of the ellipsis\r\n * @returns {string} The shortened address\r\n */\r\nexport function shortenAddress(address, charsLength = 4) {\r\n  const prefixLength = 2 // \"0x\"\r\n  if (!address) {\r\n    return ''\r\n  }\r\n  if (address.length < charsLength * 2 + prefixLength) {\r\n    return address\r\n  }\r\n  return (\r\n    address.slice(0, charsLength + prefixLength) +\r\n    '…' +\r\n    address.slice(-charsLength)\r\n  )\r\n}\r\n\r\nexport function getNetworkType(chainId = env('CHAIN_ID')) {\r\n  chainId = String(chainId)\r\n\r\n  if (chainId === '1') return 'main'\r\n  if (chainId === '3') return 'ropsten'\r\n  if (chainId === '4') return 'rinkeby'\r\n  if (chainId === '100') return 'xdai'\r\n\r\n  return DEFAULT_LOCAL_CHAIN\r\n}\r\n\r\nexport function getNetworkName(chainId = env('CHAIN_ID')) {\r\n  chainId = String(chainId)\r\n\r\n  if (chainId === '1') return 'Mainnet'\r\n  if (chainId === '3') return 'Ropsten'\r\n  if (chainId === '4') return 'Rinkeby'\r\n  if (chainId === '100') return 'xDai'\r\n\r\n  return 'unknown'\r\n}\r\n\r\nexport function sanitizeNetworkType(networkType) {\r\n  if (networkType === 'private') {\r\n    return 'localhost'\r\n  } else if (networkType === 'main') {\r\n    return 'mainnet'\r\n  }\r\n  return networkType\r\n}\r\n\r\nexport function isLocalOrUnknownNetwork(chainId = env('CHAIN_ID')) {\r\n  return getNetworkType(chainId) === DEFAULT_LOCAL_CHAIN\r\n}\r\n\r\n// Detect Ethereum addresses in a string and transform each part.\r\n//\r\n// `callback` is called on every part with two params:\r\n//   - The string of the current part.\r\n//   - A boolean indicating if it is an address.\r\n//\r\nexport function transformAddresses(str, callback) {\r\n  return str\r\n    .split(ETH_ADDRESS_SPLIT_REGEX)\r\n    .map((part, index) =>\r\n      callback(part, ETH_ADDRESS_TEST_REGEX.test(part), index)\r\n    )\r\n}\r\n\r\n/**\r\n * Check if the ETH node at the given URI is compatible for the current environment\r\n * @param {string} uri URI of the ETH node.\r\n * @param {string} expectedNetworkType The expected network type of the ETH node.\r\n * @returns {Promise} Resolves if the ETH node is compatible, otherwise throws:\r\n *    - InvalidURI: URI given is not compatible (e.g. must be WebSockets)\r\n *    - InvalidNetworkType: ETH node connected to wrong network\r\n *    - NoConnection: Couldn't connect to URI\r\n */\r\nexport async function checkValidEthNode(uri) {\r\n  const isLocalOrUnknown = isLocalOrUnknownNetwork(env('CHAIN_ID'))\r\n\r\n  if (!validHttpFormat(uri)) {\r\n    throw new InvalidURI('The URI must use the HTTP protocol')\r\n  }\r\n\r\n  try {\r\n    const expectedNetworkType = getNetworkType()\r\n    const provider = await new Providers.JsonRpcProvider(uri)\r\n    const networkType = await provider.getNetwork()\r\n    const networkTypeName =\r\n      networkType.name === 'homestead' ? 'main' : networkType.name\r\n\r\n    if (!isLocalOrUnknown) {\r\n      if (networkTypeName !== expectedNetworkType) {\r\n        throw new InvalidNetworkType()\r\n      }\r\n    }\r\n  } catch (err) {\r\n    if (err instanceof InvalidNetworkType) {\r\n      throw err\r\n    }\r\n    throw new NoConnection()\r\n  }\r\n\r\n  return true\r\n}\r\n\r\nexport async function signMessage(wallet, message) {\r\n  let signHash\r\n  let error = false\r\n\r\n  try {\r\n    signHash = await wallet.ethers.getSigner().signMessage(message)\r\n  } catch (err) {\r\n    error = err\r\n  }\r\n\r\n  return { signHash, error }\r\n}\r\n\r\nexport function sanitizeSignature(signature) {\r\n  return {\r\n    ...signature,\r\n    r: `0x${signature.r}`,\r\n    s: `0x${signature.s}`,\r\n  }\r\n}\r\n\r\n// ethers utils exports\r\nexport { keccak256, soliditySha3, toUtf8String }\r\n"]},"metadata":{},"sourceType":"module"}