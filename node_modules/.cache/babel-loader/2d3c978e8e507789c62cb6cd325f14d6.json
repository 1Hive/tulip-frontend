{"ast":null,"code":"'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst webcrypto = require('../webcrypto');\n\nconst randomBytes = require('../random-bytes');\n\nexports.utils = require('./rsa-utils');\n\nexports.generateKey = async function (bits) {\n  const pair = await webcrypto.get().subtle.generateKey({\n    name: 'RSASSA-PKCS1-v1_5',\n    modulusLength: bits,\n    publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n    hash: {\n      name: 'SHA-256'\n    }\n  }, true, ['sign', 'verify']);\n  const keys = await exportKey(pair);\n  return {\n    privateKey: keys[0],\n    publicKey: keys[1]\n  };\n}; // Takes a jwk key\n\n\nexports.unmarshalPrivateKey = async function (key) {\n  const privateKey = await webcrypto.get().subtle.importKey('jwk', key, {\n    name: 'RSASSA-PKCS1-v1_5',\n    hash: {\n      name: 'SHA-256'\n    }\n  }, true, ['sign']);\n  const pair = [privateKey, await derivePublicFromPrivate(key)];\n  const keys = await exportKey({\n    privateKey: pair[0],\n    publicKey: pair[1]\n  });\n  return {\n    privateKey: keys[0],\n    publicKey: keys[1]\n  };\n};\n\nexports.getRandomValues = randomBytes;\n\nexports.hashAndSign = async function (key, msg) {\n  const privateKey = await webcrypto.get().subtle.importKey('jwk', key, {\n    name: 'RSASSA-PKCS1-v1_5',\n    hash: {\n      name: 'SHA-256'\n    }\n  }, false, ['sign']);\n  const sig = await webcrypto.get().subtle.sign({\n    name: 'RSASSA-PKCS1-v1_5'\n  }, privateKey, Uint8Array.from(msg));\n  return Buffer.from(sig);\n};\n\nexports.hashAndVerify = async function (key, sig, msg) {\n  const publicKey = await webcrypto.get().subtle.importKey('jwk', key, {\n    name: 'RSASSA-PKCS1-v1_5',\n    hash: {\n      name: 'SHA-256'\n    }\n  }, false, ['verify']);\n  return webcrypto.get().subtle.verify({\n    name: 'RSASSA-PKCS1-v1_5'\n  }, publicKey, sig, msg);\n};\n\nfunction exportKey(pair) {\n  return Promise.all([webcrypto.get().subtle.exportKey('jwk', pair.privateKey), webcrypto.get().subtle.exportKey('jwk', pair.publicKey)]);\n}\n\nfunction derivePublicFromPrivate(jwKey) {\n  return webcrypto.get().subtle.importKey('jwk', {\n    kty: jwKey.kty,\n    n: jwKey.n,\n    e: jwKey.e\n  }, {\n    name: 'RSASSA-PKCS1-v1_5',\n    hash: {\n      name: 'SHA-256'\n    }\n  }, true, ['verify']);\n}\n/*\n\nRSA encryption/decryption for the browser with webcrypto workarround\n\"bloody dark magic. webcrypto's why.\"\n\nExplanation:\n  - Convert JWK to nodeForge\n  - Convert msg buffer to nodeForge buffer: ByteBuffer is a \"binary-string backed buffer\", so let's make our buffer a binary string\n  - Convert resulting nodeForge buffer to buffer: it returns a binary string, turn that into a uint8array(buffer)\n\n*/\n\n\nconst {\n  jwk2pub,\n  jwk2priv\n} = require('./jwk2pem');\n\nfunction convertKey(key, pub, msg, handle) {\n  const fkey = pub ? jwk2pub(key) : jwk2priv(key);\n  const fmsg = Buffer.from(msg).toString('binary');\n  const fomsg = handle(fmsg, fkey);\n  return Buffer.from(fomsg, 'binary');\n}\n\nexports.encrypt = function (key, msg) {\n  return convertKey(key, true, msg, (msg, key) => key.encrypt(msg));\n};\n\nexports.decrypt = function (key, msg) {\n  return convertKey(key, false, msg, (msg, key) => key.decrypt(msg));\n};","map":null,"metadata":{},"sourceType":"script"}