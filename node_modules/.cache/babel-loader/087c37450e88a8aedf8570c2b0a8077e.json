{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst errcode = require('err-code');\n\nconst log = debug('libp2p:peer-store');\nlog.error = debug('libp2p:peer-store:error');\n\nconst {\n  ERR_INVALID_PARAMETERS\n} = require('./errors');\n\nconst Topology = require('libp2p-interfaces/src/topology');\n\nconst {\n  Connection\n} = require('libp2p-interfaces/src/connection');\n\nconst PeerInfo = require('peer-info');\n/**\n * Responsible for notifying registered protocols of events in the network.\n */\n\n\nclass Registrar {\n  /**\n   * @param {Object} props\n   * @param {PeerStore} props.peerStore\n   * @constructor\n   */\n  constructor({\n    peerStore\n  }) {\n    this.peerStore = peerStore;\n    /**\n     * Map of connections per peer\n     * TODO: this should be handled by connectionManager\n     * @type {Map<string, Array<conn>>}\n     */\n\n    this.connections = new Map();\n    /**\n     * Map of topologies\n     *\n     * @type {Map<string, object>}\n     */\n\n    this.topologies = new Map();\n    this._handle = undefined;\n  }\n\n  get handle() {\n    return this._handle;\n  }\n\n  set handle(handle) {\n    this._handle = handle;\n  }\n  /**\n   * Cleans up the registrar\n   * @async\n   */\n\n\n  async close() {\n    // Close all connections we're tracking\n    const tasks = [];\n\n    for (const connectionList of this.connections.values()) {\n      for (const connection of connectionList) {\n        tasks.push(connection.close());\n      }\n    }\n\n    await tasks;\n    this.connections.clear();\n  }\n  /**\n   * Add a new connected peer to the record\n   * TODO: this should live in the ConnectionManager\n   * @param {PeerInfo} peerInfo\n   * @param {Connection} conn\n   * @returns {void}\n   */\n\n\n  onConnect(peerInfo, conn) {\n    if (!PeerInfo.isPeerInfo(peerInfo)) {\n      throw errcode(new Error('peerInfo must be an instance of peer-info'), ERR_INVALID_PARAMETERS);\n    }\n\n    if (!Connection.isConnection(conn)) {\n      throw errcode(new Error('conn must be an instance of interface-connection'), ERR_INVALID_PARAMETERS);\n    }\n\n    const id = peerInfo.id.toB58String();\n    const storedConn = this.connections.get(id);\n\n    if (storedConn) {\n      storedConn.push(conn);\n    } else {\n      this.connections.set(id, [conn]);\n    }\n  }\n  /**\n   * Remove a disconnected peer from the record\n   * TODO: this should live in the ConnectionManager\n   * @param {PeerInfo} peerInfo\n   * @param {Connection} connection\n   * @param {Error} [error]\n   * @returns {void}\n   */\n\n\n  onDisconnect(peerInfo, connection, error) {\n    if (!PeerInfo.isPeerInfo(peerInfo)) {\n      throw errcode(new Error('peerInfo must be an instance of peer-info'), ERR_INVALID_PARAMETERS);\n    }\n\n    const id = peerInfo.id.toB58String();\n    let storedConn = this.connections.get(id);\n\n    if (storedConn && storedConn.length > 1) {\n      storedConn = storedConn.filter(conn => conn.id !== connection.id);\n      this.connections.set(id, storedConn);\n    } else if (storedConn) {\n      for (const [, topology] of this.topologies) {\n        topology.disconnect(peerInfo, error);\n      }\n\n      this.connections.delete(peerInfo.id.toB58String());\n    }\n  }\n  /**\n   * Get a connection with a peer.\n   * @param {PeerInfo} peerInfo\n   * @returns {Connection}\n   */\n\n\n  getConnection(peerInfo) {\n    if (!PeerInfo.isPeerInfo(peerInfo)) {\n      throw errcode(new Error('peerInfo must be an instance of peer-info'), ERR_INVALID_PARAMETERS);\n    }\n\n    const connections = this.connections.get(peerInfo.id.toB58String()); // Return the first, open connection\n\n    if (connections) {\n      return connections.find(connection => connection.stat.status === 'open');\n    }\n\n    return null;\n  }\n  /**\n   * Register handlers for a set of multicodecs given\n   * @param {Topology} topology protocol topology\n   * @return {string} registrar identifier\n   */\n\n\n  register(topology) {\n    if (!Topology.isTopology(topology)) {\n      throw errcode(new Error('topology must be an instance of interfaces/topology'), ERR_INVALID_PARAMETERS);\n    } // Create topology\n\n\n    const id = parseInt(Math.random() * 1e9).toString(36) + Date.now();\n    this.topologies.set(id, topology); // Set registrar\n\n    topology.registrar = this;\n    return id;\n  }\n  /**\n   * Unregister topology.\n   * @param {string} id registrar identifier\n   * @return {boolean} unregistered successfully\n   */\n\n\n  unregister(id) {\n    return this.topologies.delete(id);\n  }\n\n}\n\nmodule.exports = Registrar;","map":null,"metadata":{},"sourceType":"script"}