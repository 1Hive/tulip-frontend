{"ast":null,"code":"/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict';\n\nconst {\n  resolvePath,\n  withTimeoutOption\n} = require('../../utils');\n\nmodule.exports = ({\n  pinManager,\n  gcLock,\n  dag\n}) => {\n  return withTimeoutOption(async function add(paths, options) {\n    options = options || {};\n    const recursive = options.recursive !== false;\n    const cids = await resolvePath(dag, paths, {\n      signal: options.signal\n    });\n\n    const pinAdd = async () => {\n      const results = []; // verify that each hash can be pinned\n\n      for (const cid of cids) {\n        const key = cid.toBaseEncodedString();\n\n        if (recursive) {\n          if (pinManager.recursivePins.has(key)) {\n            // it's already pinned recursively\n            results.push(cid);\n            continue;\n          } // entire graph of nested links should be pinned,\n          // so make sure we have all the objects\n\n\n          await pinManager.fetchCompleteDag(key, {\n            preload: options.preload,\n            signal: options.signal\n          }); // found all objects, we can add the pin\n\n          results.push(cid);\n        } else {\n          if (pinManager.recursivePins.has(key)) {\n            // recursive supersedes direct, can't have both\n            throw new Error(`${key} already pinned recursively`);\n          }\n\n          if (!pinManager.directPins.has(key)) {\n            // make sure we have the object\n            await dag.get(cid, {\n              preload: options.preload\n            });\n          }\n\n          results.push(cid);\n        }\n      } // update the pin sets in memory\n\n\n      const pinset = recursive ? pinManager.recursivePins : pinManager.directPins;\n      results.forEach(cid => pinset.add(cid.toString())); // persist updated pin sets to datastore\n\n      await pinManager.flushPins();\n      return results.map(cid => ({\n        cid\n      }));\n    }; // When adding a file, we take a lock that gets released after pinning\n    // is complete, so don't take a second lock here\n\n\n    const lock = Boolean(options.lock);\n\n    if (!lock) {\n      return pinAdd();\n    }\n\n    const release = await gcLock.readLock();\n\n    try {\n      await pinAdd();\n    } finally {\n      release();\n    }\n  });\n};","map":null,"metadata":{},"sourceType":"script"}