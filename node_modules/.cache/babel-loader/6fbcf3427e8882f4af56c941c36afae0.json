{"ast":null,"code":"'use strict';\n\nconst pSeries = require('p-series');\n\nconst PeerMonitor = require('ipfs-pubsub-peer-monitor');\n\nconst Logger = require('logplease');\n\nconst logger = Logger.create(\"pubsub\", {\n  color: Logger.Colors.Yellow\n});\nLogger.setLogLevel('ERROR');\nconst maxTopicsOpen = 256;\nlet topicsOpenCount = 0;\n\nclass IPFSPubsub {\n  constructor(ipfs, id) {\n    this._ipfs = ipfs;\n    this._id = id;\n    this._subscriptions = {};\n    if (this._ipfs.pubsub === null) logger.error(\"The provided version of ipfs doesn't have pubsub support. Messages will not be exchanged.\");\n    this._handleMessage = this._handleMessage.bind(this); // Bump up the number of listeners we can have open,\n    // ie. number of databases replicating\n\n    if (this._ipfs.setMaxListeners) this._ipfs.setMaxListeners(maxTopicsOpen);\n  }\n\n  async subscribe(topic, onMessageCallback, onNewPeerCallback, options = {}) {\n    if (!this._subscriptions[topic] && this._ipfs.pubsub) {\n      await this._ipfs.pubsub.subscribe(topic, this._handleMessage, options);\n      const topicMonitor = new PeerMonitor(this._ipfs.pubsub, topic);\n      topicMonitor.on('join', peer => {\n        logger.debug(`Peer joined ${topic}:`);\n        logger.debug(peer);\n\n        if (this._subscriptions[topic]) {\n          onNewPeerCallback(topic, peer);\n        } else {\n          logger.warn('Peer joined a room we don\\'t have a subscription for');\n          logger.warn(topic, peer);\n        }\n      });\n      topicMonitor.on('leave', peer => logger.debug(`Peer ${peer} left ${topic}`));\n      topicMonitor.on('error', e => logger.error(e));\n      this._subscriptions[topic] = {\n        topicMonitor: topicMonitor,\n        onMessage: onMessageCallback,\n        onNewPeer: onNewPeerCallback\n      };\n      topicsOpenCount++;\n      logger.debug(\"Topics open:\", topicsOpenCount);\n    }\n  }\n\n  async unsubscribe(hash) {\n    if (this._subscriptions[hash]) {\n      await this._ipfs.pubsub.unsubscribe(hash, this._handleMessage);\n\n      this._subscriptions[hash].topicMonitor.stop();\n\n      delete this._subscriptions[hash];\n      logger.debug(`Unsubscribed from '${hash}'`);\n      topicsOpenCount--;\n      logger.debug(\"Topics open:\", topicsOpenCount);\n    }\n  }\n\n  publish(topic, message, options = {}) {\n    if (this._subscriptions[topic] && this._ipfs.pubsub) {\n      this._ipfs.pubsub.publish(topic, Buffer.from(JSON.stringify(message)), options);\n    }\n  }\n\n  async disconnect() {\n    const topics = Object.keys(this._subscriptions);\n    await pSeries(topics.map(t => this.unsubscribe.bind(this, t)));\n    this._subscriptions = {};\n  }\n\n  async _handleMessage(message) {\n    // Don't process our own messages\n    if (message.from === this._id) return; // Get the message content and a subscription\n\n    let content, subscription, topicId;\n\n    try {\n      // Get the topic\n      topicId = message.topicIDs[0];\n      content = JSON.parse(message.data);\n      subscription = this._subscriptions[topicId];\n    } catch (e) {\n      logger.error(e);\n      logger.error('Couldn\\'t parse pubsub message:', message);\n    }\n\n    if (subscription && subscription.onMessage && content) {\n      await subscription.onMessage(topicId, content, message.from);\n    }\n  }\n\n}\n\nmodule.exports = IPFSPubsub;","map":null,"metadata":{},"sourceType":"script"}