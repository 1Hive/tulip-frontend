{"ast":null,"code":"'use strict';\n\nconst applyDefaultOptions = require('./utils/apply-default-options');\n\nconst toMfsPath = require('./utils/to-mfs-path');\n\nconst log = require('debug')('ipfs:mfs:touch');\n\nconst errCode = require('err-code');\n\nconst UnixFS = require('ipfs-unixfs');\n\nconst toTrail = require('./utils/to-trail');\n\nconst addLink = require('./utils/add-link');\n\nconst updateTree = require('./utils/update-tree');\n\nconst updateMfsRoot = require('./utils/update-mfs-root');\n\nconst {\n  DAGNode\n} = require('ipld-dag-pb');\n\nconst mc = require('multicodec');\n\nconst mh = require('multihashes');\n\nconst {\n  withTimeoutOption\n} = require('../../utils');\n\nconst defaultOptions = {\n  mtime: undefined,\n  flush: true,\n  shardSplitThreshold: 1000,\n  cidVersion: 0,\n  hashAlg: 'sha2-256'\n};\n\nmodule.exports = context => {\n  return withTimeoutOption(async function mfsTouch(path, options) {\n    options = options || {};\n    options = applyDefaultOptions(options, defaultOptions);\n    options.mtime = options.mtime || new Date();\n    log(`Touching ${path} mtime: ${options.mtime}`);\n    const {\n      cid,\n      mfsDirectory,\n      name,\n      exists\n    } = await toMfsPath(context, path);\n    let node;\n    let updatedCid;\n    let cidVersion = options.cidVersion;\n\n    if (!exists) {\n      const metadata = new UnixFS({\n        type: 'file',\n        mtime: options.mtime\n      });\n      node = new DAGNode(metadata.marshal());\n      updatedCid = await context.ipld.put(node, mc.DAG_PB, {\n        cidVersion: options.cidVersion,\n        hashAlg: mh.names['sha2-256'],\n        onlyHash: !options.flush\n      });\n    } else {\n      if (cid.codec !== 'dag-pb') {\n        throw errCode(new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS');\n      }\n\n      cidVersion = cid.version;\n      node = await context.ipld.get(cid);\n      const metadata = UnixFS.unmarshal(node.Data);\n      metadata.mtime = options.mtime;\n      node = new DAGNode(metadata.marshal(), node.Links);\n      updatedCid = await context.ipld.put(node, mc.DAG_PB, {\n        cidVersion: cid.version,\n        hashAlg: mh.names['sha2-256'],\n        onlyHash: !options.flush\n      });\n    }\n\n    const trail = await toTrail(context, mfsDirectory, options);\n    const parent = trail[trail.length - 1];\n    const parentNode = await context.ipld.get(parent.cid);\n    const result = await addLink(context, {\n      parent: parentNode,\n      name: name,\n      cid: updatedCid,\n      size: node.serialize().length,\n      flush: options.flush,\n      shardSplitThreshold: options.shardSplitThreshold,\n      hashAlg: 'sha2-256',\n      cidVersion\n    });\n    parent.cid = result.cid; // update the tree with the new child\n\n    const newRootCid = await updateTree(context, trail, options); // Update the MFS record with the new CID for the root of the tree\n\n    await updateMfsRoot(context, newRootCid);\n  });\n};","map":null,"metadata":{},"sourceType":"script"}