{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport { Buffer } from \"buffer\";\nimport { XX } from \"./handshakes/xx\";\nimport { decodePayload, getPeerIdFromPayload, verifySignedPayload } from \"./utils\";\nimport { logger, logLocalStaticKeys, logLocalEphemeralKeys, logRemoteEphemeralKey, logRemoteStaticKey, logCipherState } from \"./logger\";\nimport { decode0, decode1, decode2, encode0, encode1, encode2 } from \"./encoder\";\nexport class XXHandshake {\n  constructor(isInitiator, payload, prologue, staticKeypair, connection, remotePeer, handshake) {\n    _defineProperty(this, \"isInitiator\", void 0);\n\n    _defineProperty(this, \"session\", void 0);\n\n    _defineProperty(this, \"remotePeer\", void 0);\n\n    _defineProperty(this, \"remoteEarlyData\", void 0);\n\n    _defineProperty(this, \"payload\", void 0);\n\n    _defineProperty(this, \"connection\", void 0);\n\n    _defineProperty(this, \"xx\", void 0);\n\n    _defineProperty(this, \"staticKeypair\", void 0);\n\n    _defineProperty(this, \"prologue\", void 0);\n\n    this.isInitiator = isInitiator;\n    this.payload = payload;\n    this.prologue = prologue;\n    this.staticKeypair = staticKeypair;\n    this.connection = connection;\n\n    if (remotePeer) {\n      this.remotePeer = remotePeer;\n    }\n\n    this.xx = handshake || new XX();\n    this.session = this.xx.initSession(this.isInitiator, this.prologue, this.staticKeypair);\n    this.remoteEarlyData = Buffer.alloc(0);\n  } // stage 0\n\n\n  async propose() {\n    logLocalStaticKeys(this.session.hs.s);\n\n    if (this.isInitiator) {\n      logger(\"Stage 0 - Initiator starting to send first message.\");\n      const messageBuffer = this.xx.sendMessage(this.session, Buffer.alloc(0));\n      this.connection.writeLP(encode0(messageBuffer));\n      logger(\"Stage 0 - Initiator finished sending first message.\");\n      logLocalEphemeralKeys(this.session.hs.e);\n    } else {\n      logger(\"Stage 0 - Responder waiting to receive first message...\");\n      const receivedMessageBuffer = decode0((await this.connection.readLP()).slice());\n      const {\n        valid\n      } = this.xx.recvMessage(this.session, receivedMessageBuffer);\n\n      if (!valid) {\n        throw new Error(\"xx handshake stage 0 validation fail\");\n      }\n\n      logger(\"Stage 0 - Responder received first message.\");\n      logRemoteEphemeralKey(this.session.hs.re);\n    }\n  } // stage 1\n\n\n  async exchange() {\n    if (this.isInitiator) {\n      logger('Stage 1 - Initiator waiting to receive first message from responder...');\n      const receivedMessageBuffer = decode1((await this.connection.readLP()).slice());\n      const {\n        plaintext,\n        valid\n      } = this.xx.recvMessage(this.session, receivedMessageBuffer);\n\n      if (!valid) {\n        throw new Error(\"xx handshake stage 1 validation fail\");\n      }\n\n      logger('Stage 1 - Initiator received the message.');\n      logRemoteEphemeralKey(this.session.hs.re);\n      logRemoteStaticKey(this.session.hs.rs);\n      logger(\"Initiator going to check remote's signature...\");\n\n      try {\n        const decodedPayload = await decodePayload(plaintext);\n        this.remotePeer = this.remotePeer || (await getPeerIdFromPayload(decodedPayload));\n        this.remotePeer = await verifySignedPayload(receivedMessageBuffer.ns, decodedPayload, this.remotePeer);\n        this.setRemoteEarlyData(decodedPayload.data);\n      } catch (e) {\n        throw new Error(\"Error occurred while verifying signed payload: \".concat(e.message));\n      }\n\n      logger(\"All good with the signature!\");\n    } else {\n      logger('Stage 1 - Responder sending out first message with signed payload and static key.');\n      const messageBuffer = this.xx.sendMessage(this.session, this.payload);\n      this.connection.writeLP(encode1(messageBuffer));\n      logger('Stage 1 - Responder sent the second handshake message with signed payload.');\n      logLocalEphemeralKeys(this.session.hs.e);\n    }\n  } // stage 2\n\n\n  async finish() {\n    if (this.isInitiator) {\n      logger('Stage 2 - Initiator sending third handshake message.');\n      const messageBuffer = this.xx.sendMessage(this.session, this.payload);\n      this.connection.writeLP(encode2(messageBuffer));\n      logger('Stage 2 - Initiator sent message with signed payload.');\n    } else {\n      logger('Stage 2 - Responder waiting for third handshake message...');\n      const receivedMessageBuffer = decode2((await this.connection.readLP()).slice());\n      const {\n        plaintext,\n        valid\n      } = this.xx.recvMessage(this.session, receivedMessageBuffer);\n\n      if (!valid) {\n        throw new Error(\"xx handshake stage 2 validation fail\");\n      }\n\n      logger('Stage 2 - Responder received the message, finished handshake.');\n\n      try {\n        const decodedPayload = await decodePayload(plaintext);\n        this.remotePeer = this.remotePeer || (await getPeerIdFromPayload(decodedPayload));\n        await verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);\n        this.setRemoteEarlyData(decodedPayload.data);\n      } catch (e) {\n        throw new Error(\"Error occurred while verifying signed payload: \".concat(e.message));\n      }\n    }\n\n    logCipherState(this.session);\n  }\n\n  encrypt(plaintext, session) {\n    const cs = this.getCS(session);\n    return this.xx.encryptWithAd(cs, Buffer.alloc(0), plaintext);\n  }\n\n  decrypt(ciphertext, session) {\n    const cs = this.getCS(session, false);\n    return this.xx.decryptWithAd(cs, Buffer.alloc(0), ciphertext);\n  }\n\n  getRemoteStaticKey() {\n    return this.session.hs.rs;\n  }\n\n  getCS(session, encryption = true) {\n    if (!session.cs1 || !session.cs2) {\n      throw new Error(\"Handshake not completed properly, cipher state does not exist.\");\n    }\n\n    if (this.isInitiator) {\n      return encryption ? session.cs1 : session.cs2;\n    } else {\n      return encryption ? session.cs2 : session.cs1;\n    }\n  }\n\n  setRemoteEarlyData(data) {\n    if (data) {\n      this.remoteEarlyData = Buffer.from(data.buffer, data.byteOffset, data.length);\n    }\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}