{"ast":null,"code":"var r = require(\"uint8arrays\"),\n    e = require(\"@stablelib/sha256\"),\n    t = require(\"js-sha3\"),\n    n = require(\"elliptic\"),\n    i = require(\"@stablelib/ed25519\"),\n    o = require(\"@stablelib/xchacha20poly1305\"),\n    a = require(\"@stablelib/x25519\"),\n    u = require(\"@stablelib/random\");\n\nfunction c(e) {\n  return r.toString(e, \"base64url\");\n}\n\nfunction f(e) {\n  var t = e.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=/g, \"\");\n  return r.fromString(t, \"base64url\");\n}\n\nfunction s(e) {\n  return r.fromString(e, \"base58btc\");\n}\n\nfunction l(e) {\n  var t = e.startsWith(\"0x\") ? e.substring(2) : e;\n  return r.fromString(t.toLowerCase(), \"base16\");\n}\n\nfunction h(e) {\n  return c(r.fromString(e));\n}\n\nfunction v(e) {\n  return r.toString(f(e));\n}\n\nfunction d(e) {\n  return r.toString(e, \"base16\");\n}\n\nfunction p(e) {\n  return r.fromString(e);\n}\n\nfunction y(e, t) {\n  var n = e.r,\n      i = e.s,\n      o = e.recoveryParam,\n      a = new Uint8Array(t ? 65 : 64);\n\n  if (a.set(r.fromString(n, \"base16\"), 0), a.set(r.fromString(i, \"base16\"), 32), t) {\n    if (void 0 === o) throw new Error(\"Signer did not return a recoveryParam\");\n    a[64] = o;\n  }\n\n  return c(a);\n}\n\nfunction g(r) {\n  var e = f(r);\n  if (e.length < 64 || e.length > 65) throw new TypeError(\"Wrong size for signature. Expected 64 or 65 bytes, but got \" + e.length);\n  return {\n    r: d(e.slice(0, 32)),\n    s: d(e.slice(32, 64)),\n    recoveryParam: 65 === e.length ? e[64] : void 0\n  };\n}\n\nfunction w(e, t) {\n  return r.concat([f(e), f(t)]);\n}\n\nvar m = /^(0x)?([a-fA-F0-9]{64}|[a-fA-F0-9]{128})$/,\n    b = /^([1-9A-HJ-NP-Za-km-z]{44}|[1-9A-HJ-NP-Za-km-z]{88})$/,\n    E = /^([0-9a-zA-Z=\\-_\\+\\/]{43}|[0-9a-zA-Z=\\-_\\+\\/]{86})(={0,2})$/;\n\nfunction P(r) {\n  if (\"string\" == typeof r) {\n    if (m.test(r)) return l(r);\n    if (b.test(r)) return s(r);\n    if (E.test(r)) return f(r);\n    throw TypeError(\"Invalid private key format\");\n  }\n\n  if (r instanceof Uint8Array) return r;\n  throw TypeError(\"Invalid private key format\");\n}\n\nfunction S(r, e) {\n  return void 0 === e && (e = 64), r.length === e ? r : \"0\".repeat(e - r.length) + r;\n}\n\nfunction x(t) {\n  var n = \"string\" == typeof t ? r.fromString(t) : t;\n  return e.hash(n);\n}\n\nfunction k(e) {\n  var n,\n      i = r.fromString(e.slice(2), \"base16\");\n  return \"0x\" + r.toString((n = i, new Uint8Array(t.keccak_256.arrayBuffer(n))).slice(-20), \"base16\");\n}\n\nfunction K(e, t) {\n  void 0 === t && (t = new Uint8Array(4));\n  var n = r.fromString(e.toString(), \"base10\");\n  return t.set(n, 4 - n.length), t;\n}\n\nvar A = function (e) {\n  return r.concat([K(e.length), e]);\n};\n\nfunction j(t, n, i) {\n  if (256 !== n) throw new Error(\"Unsupported key length: \" + n);\n  var o = r.concat([A(r.fromString(i)), A(new Uint8Array(0)), A(new Uint8Array(0)), K(n)]);\n  return e.hash(r.concat([K(1), t, o]));\n}\n\nvar J = new n.ec(\"secp256k1\");\n\nfunction W(r, e) {\n  void 0 === e && (e = !1);\n  var t = P(r);\n  if (32 !== t.length) throw new Error(\"Invalid private key format. Expecting 32 bytes, but got \" + t.length);\n  var n = J.keyFromPrivate(t);\n  return function (r) {\n    try {\n      var t = n.sign(x(r)),\n          i = t.s,\n          o = t.recoveryParam;\n      return Promise.resolve(y({\n        r: S(t.r.toString(\"hex\")),\n        s: S(i.toString(\"hex\")),\n        recoveryParam: o\n      }, e));\n    } catch (r) {\n      return Promise.reject(r);\n    }\n  };\n}\n\nfunction D(r) {\n  var e = P(r);\n  if (64 !== e.length) throw new Error(\"Invalid private key format. Expecting 64 bytes, but got \" + e.length);\n  return function (r) {\n    try {\n      var t = \"string\" == typeof r ? p(r) : r,\n          n = i.sign(e, t);\n      return Promise.resolve(c(n));\n    } catch (r) {\n      return Promise.reject(r);\n    }\n  };\n}\n\nfunction T() {\n  return (T = Object.assign || function (r) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n\n      for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (r[n] = t[n]);\n    }\n\n    return r;\n  }).apply(this, arguments);\n}\n\nvar I = new n.ec(\"secp256k1\");\n\nfunction C(r, e) {\n  void 0 === e && (e = !1);\n  var t = f(r);\n  if (t.length !== (e ? 65 : 64)) throw new Error(\"wrong signature length\");\n  var n = {\n    r: d(t.slice(0, 32)),\n    s: d(t.slice(32, 64))\n  };\n  return e && (n.recoveryParam = t[64]), n;\n}\n\nfunction U(r) {\n  return r.publicKeyBase58 ? s(r.publicKeyBase58) : r.publicKeyBase64 ? f(r.publicKeyBase64) : r.publicKeyHex ? l(r.publicKeyHex) : new Uint8Array();\n}\n\nfunction O(r, e, t) {\n  var n;\n  if (e.length > 86) n = [C(e, !0)];else {\n    var i = C(e, !1);\n    n = [T({}, i, {\n      recoveryParam: 0\n    }), T({}, i, {\n      recoveryParam: 1\n    })];\n  }\n  var o = n.map(function (e) {\n    var n = x(r),\n        i = I.recoverPubKey(n, e, e.recoveryParam),\n        o = i.encode(\"hex\"),\n        a = i.encode(\"hex\", !0),\n        u = k(o);\n    return t.find(function (r) {\n      var e = r.publicKeyHex;\n      return e === o || e === a || r.ethereumAddress === u;\n    });\n  }).filter(function (r) {\n    return null != r;\n  });\n  if (0 === o.length) throw new Error(\"Signature invalid for JWT\");\n  return o[0];\n}\n\nfunction B(r, e, t) {\n  var n = p(r),\n      o = f(e),\n      a = t.find(function (r) {\n    return i.verify(U(r), n, o);\n  });\n  if (!a) throw new Error(\"Signature invalid for JWT\");\n  return a;\n}\n\nvar N = {\n  ES256K: function (r, e, t) {\n    var n = x(r),\n        i = C(e),\n        o = t.filter(function (r) {\n      return void 0 === r.ethereumAddress;\n    }),\n        a = t.filter(function (r) {\n      return void 0 !== r.ethereumAddress;\n    }),\n        u = o.find(function (r) {\n      try {\n        var e = U(r);\n        return I.keyFromPublic(e).verify(n, i);\n      } catch (r) {\n        return !1;\n      }\n    });\n    if (!u && a.length > 0 && (u = O(r, e, a)), !u) throw new Error(\"Signature invalid for JWT\");\n    return u;\n  },\n  \"ES256K-R\": O,\n  Ed25519: B,\n  EdDSA: B\n};\n\nfunction X(r) {\n  var e = N[r];\n  if (!e) throw new Error(\"Unsupported algorithm \" + r);\n  return e;\n}\n\nfunction V(r) {\n  return \"object\" == typeof r && \"r\" in r && \"s\" in r;\n}\n\nfunction _(r) {\n  return function (e, t) {\n    try {\n      return Promise.resolve(t(e)).then(function (e) {\n        if (V(e)) return y(e, r);\n        if (r && void 0 === g(e).recoveryParam) throw new Error(\"ES256K-R not supported when signer doesn't provide a recovery param\");\n        return e;\n      });\n    } catch (r) {\n      return Promise.reject(r);\n    }\n  };\n}\n\nfunction q() {\n  return function (r, e) {\n    try {\n      return Promise.resolve(e(r)).then(function (r) {\n        if (V(r)) throw new Error(\"expected a signer function that returns a string instead of signature object\");\n        return r;\n      });\n    } catch (r) {\n      return Promise.reject(r);\n    }\n  };\n}\n\nX.toSignatureObject = C;\n\nvar H = {\n  ES256K: _(),\n  \"ES256K-R\": _(!0),\n  Ed25519: q(),\n  EdDSA: q()\n},\n    z = function (r, e, t) {\n  void 0 === t && (t = {});\n\n  try {\n    t.alg || (t.alg = F);\n\n    var n = \"string\" == typeof r ? r : L(r),\n        i = [L(t), n].join(\".\"),\n        o = function (r) {\n      var e = H[r];\n      if (!e) throw new Error(\"Unsupported algorithm \" + r);\n      return e;\n    }(t.alg);\n\n    return Promise.resolve(o(i, e)).then(function (r) {\n      return [i, r].join(\".\");\n    });\n  } catch (r) {\n    return Promise.reject(r);\n  }\n},\n    Z = {\n  ES256K: [\"Secp256k1VerificationKey2018\", \"Secp256k1SignatureVerificationKey2018\", \"EcdsaPublicKeySecp256k1\", \"EcdsaSecp256k1VerificationKey2019\"],\n  \"ES256K-R\": [\"Secp256k1VerificationKey2018\", \"Secp256k1SignatureVerificationKey2018\", \"EcdsaPublicKeySecp256k1\", \"EcdsaSecp256k1VerificationKey2019\"],\n  Ed25519: [\"ED25519SignatureVerification\", \"Ed25519VerificationKey2018\"],\n  EdDSA: [\"ED25519SignatureVerification\", \"Ed25519VerificationKey2018\"]\n},\n    F = \"ES256K\";\n\nfunction L(r) {\n  return h(JSON.stringify(r));\n}\n\nfunction R(r) {\n  var e = r.match(/^([a-zA-Z0-9_-]+)\\.([a-zA-Z0-9_-]+)\\.([a-zA-Z0-9_-]+)$/);\n  if (e) return {\n    header: JSON.parse(v(e[1])),\n    payload: e[2],\n    signature: e[3],\n    data: e[1] + \".\" + e[2]\n  };\n  throw new Error(\"Incorrect format JWS\");\n}\n\nfunction $(r) {\n  if (!r) throw new Error(\"no JWT passed into decodeJWT\");\n\n  try {\n    var e = R(r);\n    return Object.assign(e, {\n      payload: JSON.parse(v(e.payload))\n    });\n  } catch (r) {\n    throw new Error(\"Incorrect format JWT\");\n  }\n}\n\nfunction M(r, e) {\n  var t = r.header,\n      n = r.data,\n      i = r.signature;\n  return Array.isArray(e) || (e = [e]), X(t.alg)(n, i, e);\n}\n\nvar G = \"undefined\" != typeof Symbol ? Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\")) : \"@@iterator\";\n\nfunction Q(r, e, t) {\n  if (!r.s) {\n    if (t instanceof Y) {\n      if (!t.s) return void (t.o = Q.bind(null, r, e));\n      1 & e && (e = t.s), t = t.v;\n    }\n\n    if (t && t.then) return void t.then(Q.bind(null, r, e), Q.bind(null, r, 2));\n    r.s = e, r.v = t;\n    var n = r.o;\n    n && n(r);\n  }\n}\n\nvar Y = function () {\n  function r() {}\n\n  return r.prototype.then = function (e, t) {\n    var n = new r(),\n        i = this.s;\n\n    if (i) {\n      var o = 1 & i ? e : t;\n\n      if (o) {\n        try {\n          Q(n, 1, o(this.v));\n        } catch (r) {\n          Q(n, 2, r);\n        }\n\n        return n;\n      }\n\n      return this;\n    }\n\n    return this.o = function (r) {\n      try {\n        var i = r.v;\n        1 & r.s ? Q(n, 1, e ? e(i) : i) : t ? Q(n, 1, t(i)) : Q(n, 2, i);\n      } catch (r) {\n        Q(n, 2, r);\n      }\n    }, n;\n  }, r;\n}();\n\nfunction rr(r) {\n  return r instanceof Y && 1 & r.s;\n}\n\nfunction er(r, e) {\n  var t = r.ciphertext,\n      n = r.tag,\n      i = r.recipient,\n      o = {\n    protected: r.protectedHeader,\n    iv: c(r.iv),\n    ciphertext: c(t),\n    tag: c(n)\n  };\n  return e && (o.aad = c(e)), i && (o.recipients = [i]), o;\n}\n\nfunction tr(r) {\n  var e = new o.XChaCha20Poly1305(r);\n  return function (r, t) {\n    var n = u.randomBytes(e.nonceLength),\n        i = e.seal(n, r, t);\n    return {\n      ciphertext: i.subarray(0, i.length - e.tagLength),\n      tag: i.subarray(i.length - e.tagLength),\n      iv: n\n    };\n  };\n}\n\nfunction nr(r) {\n  var e = tr(r),\n      t = \"XC20P\";\n  return {\n    alg: \"dir\",\n    enc: t,\n    encrypt: function (r, n, i) {\n      void 0 === n && (n = {});\n\n      try {\n        var o = h(JSON.stringify(Object.assign({\n          alg: \"dir\"\n        }, n, {\n          enc: t\n        }))),\n            a = new Uint8Array(Buffer.from(i ? o + \".\" + c(i) : o));\n        return Promise.resolve(T({}, e(r, a), {\n          protectedHeader: o\n        }));\n      } catch (r) {\n        return Promise.reject(r);\n      }\n    }\n  };\n}\n\nfunction ir(r) {\n  var e = new o.XChaCha20Poly1305(r);\n  return {\n    alg: \"dir\",\n    enc: \"XC20P\",\n    decrypt: function (r, t, n) {\n      try {\n        return Promise.resolve(e.open(t, r, n));\n      } catch (r) {\n        return Promise.reject(r);\n      }\n    }\n  };\n}\n\nfunction or(r, e) {\n  var t = function (t) {\n    try {\n      var u = a.generateKeyPair(),\n          f = tr(j(a.sharedKey(u.secretKey, r), i, n))(t),\n          s = {\n        encrypted_key: c(f.ciphertext),\n        header: {\n          alg: n,\n          iv: c(f.iv),\n          tag: c(f.tag),\n          epk: {\n            kty: \"OKP\",\n            crv: o,\n            x: c(u.publicKey)\n          }\n        }\n      };\n      return e && (s.header.kid = e), Promise.resolve(s);\n    } catch (r) {\n      return Promise.reject(r);\n    }\n  },\n      n = \"ECDH-ES+XC20PKW\",\n      i = 256,\n      o = \"X25519\";\n\n  return {\n    alg: n,\n    enc: \"XC20P\",\n    encrypt: function (r, e, n) {\n      void 0 === e && (e = {});\n\n      try {\n        Object.assign(e, {\n          alg: void 0\n        });\n        var i = u.randomBytes(32);\n        return Promise.resolve(nr(i).encrypt(r, e, n)).then(function (r) {\n          return Promise.resolve(t(i)).then(function (e) {\n            return T({}, r, {\n              recipient: e,\n              cek: i\n            });\n          });\n        });\n      } catch (r) {\n        return Promise.reject(r);\n      }\n    },\n    encryptCek: t\n  };\n}\n\nexports.ES256KSigner = W, exports.EdDSASigner = D, exports.EllipticSigner = function (r) {\n  return W(r);\n}, exports.NaclSigner = function (r) {\n  return D(r);\n}, exports.SimpleSigner = function (r) {\n  var e = W(r, !0);\n  return function (r) {\n    try {\n      return Promise.resolve(e(r)).then(g);\n    } catch (r) {\n      return Promise.reject(r);\n    }\n  };\n}, exports.createJWE = function (r, e, t, n) {\n  void 0 === t && (t = {});\n\n  try {\n    if (\"dir\" === e[0].alg) {\n      if (e.length > 1) throw new Error('Can only do \"dir\" encryption to one key.');\n      return Promise.resolve(e[0].encrypt(r, t, n)).then(function (r) {\n        return er(r, n);\n      });\n    }\n\n    var i,\n        o,\n        a = e[0].enc;\n    if (!e.reduce(function (r, e) {\n      return r && e.enc === a;\n    }, !0)) throw new Error(\"Incompatible encrypters passed\");\n\n    var u = function (r, e, t) {\n      if (\"function\" == typeof r[G]) {\n        var n,\n            i,\n            o,\n            a = r[G]();\n\n        if (function r(t) {\n          try {\n            for (; !(n = a.next()).done;) if ((t = e(n.value)) && t.then) {\n              if (!rr(t)) return void t.then(r, o || (o = Q.bind(null, i = new Y(), 2)));\n              t = t.v;\n            }\n\n            i ? Q(i, 1, t) : i = t;\n          } catch (r) {\n            Q(i || (i = new Y()), 2, r);\n          }\n        }(), a.return) {\n          var u = function (r) {\n            try {\n              n.done || a.return();\n            } catch (r) {}\n\n            return r;\n          };\n\n          if (i && i.then) return i.then(u, function (r) {\n            throw u(r);\n          });\n          u();\n        }\n\n        return i;\n      }\n\n      if (!(\"length\" in r)) throw new TypeError(\"Object is not iterable\");\n\n      for (var c = [], f = 0; f < r.length; f++) c.push(r[f]);\n\n      return function (r, e, t) {\n        var n,\n            i,\n            o = -1;\n        return function t(a) {\n          try {\n            for (; ++o < r.length;) if ((a = e(o)) && a.then) {\n              if (!rr(a)) return void a.then(t, i || (i = Q.bind(null, n = new Y(), 2)));\n              a = a.v;\n            }\n\n            n ? Q(n, 1, a) : n = a;\n          } catch (r) {\n            Q(n || (n = new Y()), 2, r);\n          }\n        }(), n;\n      }(c, function (r) {\n        return e(c[r]);\n      });\n    }(e, function (e) {\n      var a = function () {\n        if (i) {\n          var a = o.recipients,\n              u = a.push;\n          return Promise.resolve(e.encryptCek(i)).then(function (r) {\n            u.call(a, r);\n          });\n        }\n\n        return Promise.resolve(e.encrypt(r, t, n)).then(function (r) {\n          i = r.cek, o = er(r, n);\n        });\n      }();\n\n      if (a && a.then) return a.then(function () {});\n    });\n\n    return Promise.resolve(u && u.then ? u.then(function () {\n      return o;\n    }) : o);\n  } catch (r) {\n    return Promise.reject(r);\n  }\n}, exports.createJWS = z, exports.createJWT = function (r, e, t) {\n  var n = e.issuer,\n      i = e.signer,\n      o = e.alg,\n      a = e.expiresIn;\n  void 0 === t && (t = {});\n\n  try {\n    if (!i) throw new Error(\"No Signer functionality has been configured\");\n    if (!n) throw new Error(\"No issuing DID has been configured\");\n    t.typ || (t.typ = \"JWT\"), t.alg || (t.alg = o);\n    var u = {\n      iat: Math.floor(Date.now() / 1e3),\n      exp: void 0\n    };\n\n    if (a) {\n      if (\"number\" != typeof a) throw new Error(\"JWT expiresIn is not a number\");\n      u.exp = (r.nbf || u.iat) + Math.floor(a);\n    }\n\n    var c = T({}, u, r, {\n      iss: n\n    });\n    return z(c, i, t);\n  } catch (r) {\n    return Promise.reject(r);\n  }\n}, exports.decodeJWT = $, exports.decryptJWE = function (r, e) {\n  try {\n    var t = function (r) {\n      if (null === a) throw new Error(\"Failed to decrypt\");\n      return a;\n    };\n\n    !function (r) {\n      if (!(r.protected && r.iv && r.ciphertext && r.tag)) throw new Error(\"Invalid JWE\");\n      r.recipients && r.recipients.map(function (r) {\n        if (!r.header || !r.encrypted_key) throw new Error(\"Invalid JWE\");\n      });\n    }(r);\n    var n = JSON.parse(v(r.protected));\n    if (n.enc !== e.enc) throw new Error(\"Decrypter does not support: '\" + n.enc + \"'\");\n    var i = w(r.ciphertext, r.tag),\n        o = new Uint8Array(Buffer.from(r.aad ? r.protected + \".\" + r.aad : r.protected)),\n        a = null,\n        u = \"dir\" === n.alg && \"dir\" === e.alg ? Promise.resolve(e.decrypt(i, f(r.iv), o)).then(function (r) {\n      a = r;\n    }) : function () {\n      if (r.recipients && 0 !== r.recipients.length) {\n        var t = 0;\n        return function (r, e, t) {\n          for (var n;;) {\n            var i = r();\n            if (rr(i) && (i = i.v), !i) return o;\n\n            if (i.then) {\n              n = 0;\n              break;\n            }\n\n            var o = t();\n\n            if (o && o.then) {\n              if (!rr(o)) {\n                n = 1;\n                break;\n              }\n\n              o = o.s;\n            }\n\n            if (e) {\n              var a = e();\n\n              if (a && a.then && !rr(a)) {\n                n = 2;\n                break;\n              }\n            }\n          }\n\n          var u = new Y(),\n              c = Q.bind(null, u, 2);\n          return (0 === n ? i.then(s) : 1 === n ? o.then(f) : a.then(l)).then(void 0, c), u;\n\n          function f(n) {\n            o = n;\n\n            do {\n              if (e && (a = e()) && a.then && !rr(a)) return void a.then(l).then(void 0, c);\n              if (!(i = r()) || rr(i) && !i.v) return void Q(u, 1, o);\n              if (i.then) return void i.then(s).then(void 0, c);\n              rr(o = t()) && (o = o.v);\n            } while (!o || !o.then);\n\n            o.then(f).then(void 0, c);\n          }\n\n          function s(r) {\n            r ? (o = t()) && o.then ? o.then(f).then(void 0, c) : f(o) : Q(u, 1, o);\n          }\n\n          function l() {\n            (i = r()) ? i.then ? i.then(s).then(void 0, c) : s(i) : Q(u, 1, o);\n          }\n        }(function () {\n          return !a && t < r.recipients.length;\n        }, function () {\n          return t++;\n        }, function () {\n          var u = r.recipients[t];\n          Object.assign(u.header, n);\n\n          var c = function () {\n            if (u.header.alg === e.alg) return Promise.resolve(e.decrypt(i, f(r.iv), o, u)).then(function (r) {\n              a = r;\n            });\n          }();\n\n          if (c && c.then) return c.then(function () {});\n        });\n      }\n\n      throw new Error(\"Invalid JWE\");\n    }();\n    return Promise.resolve(u && u.then ? u.then(t) : t());\n  } catch (r) {\n    return Promise.reject(r);\n  }\n}, exports.resolveX25519Encrypters = function (r, e) {\n  try {\n    return Promise.all(r.map(function (r) {\n      try {\n        return Promise.resolve(e.resolve(r)).then(function (e) {\n          var t;\n          if (!e.keyAgreement) throw new Error(\"Could not find x25519 key for \" + r);\n          var n = (null == (t = e.keyAgreement) ? void 0 : t.map(function (r) {\n            return \"string\" == typeof r ? e.publicKey.find(function (e) {\n              return e.id === r;\n            }) : r;\n          })).find(function (r) {\n            return \"X25519KeyAgreementKey2019\" === r.type && Boolean(r.publicKeyBase58);\n          });\n          if (!n) throw new Error(\"Could not find x25519 key for \" + r);\n          return or(s(n.publicKeyBase58), n.id);\n        });\n      } catch (r) {\n        return Promise.reject(r);\n      }\n    }));\n  } catch (r) {\n    return Promise.reject(r);\n  }\n}, exports.toEthereumAddress = k, exports.verifyJWS = function (r, e) {\n  return M(R(r), e);\n}, exports.verifyJWT = function (r, e) {\n  void 0 === e && (e = {\n    resolver: null,\n    auth: null,\n    audience: null,\n    callbackUrl: null,\n    skewTime: null\n  });\n\n  try {\n    if (!e.resolver) throw new Error(\"No DID resolver has been configured\");\n    var t = $(r),\n        n = t.payload,\n        i = t.header,\n        o = t.signature,\n        a = t.data;\n    return Promise.resolve(function (r, e, t, n) {\n      try {\n        var i = Z[e];\n        if (!i || 0 === i.length) throw new Error(\"No supported signature types for algorithm \" + e);\n        return Promise.resolve(r.resolve(t)).then(function (r) {\n          if (!r) throw new Error(\"Unable to resolve DID document for \" + t);\n\n          var o = function (r, e) {\n            var t = r.publicKey.filter(function (r) {\n              return e === r.id;\n            });\n            return t.length > 0 ? t[0] : null;\n          },\n              a = r.publicKey || [];\n\n          n && (a = (r.authentication || []).map(function (e) {\n            return \"string\" == typeof e ? o(r, e) : \"string\" == typeof e.publicKey ? o(r, e.publicKey) : e;\n          }).filter(function (r) {\n            return null != r;\n          }));\n          var u = a.filter(function (r) {\n            var e = r.type;\n            return i.find(function (r) {\n              return r === e;\n            });\n          });\n          if (n && (!u || 0 === u.length)) throw new Error(\"DID document for \" + t + \" does not have public keys suitable for authenticating user\");\n          if (!u || 0 === u.length) throw new Error(\"DID document for \" + t + \" does not have public keys for \" + e);\n          return {\n            authenticators: u,\n            issuer: t,\n            doc: r\n          };\n        });\n      } catch (r) {\n        return Promise.reject(r);\n      }\n    }(e.resolver, i.alg, n.iss, e.auth)).then(function (t) {\n      var u = t.doc,\n          c = t.issuer;\n      return Promise.resolve(M({\n        header: i,\n        data: a,\n        signature: o\n      }, t.authenticators)).then(function (t) {\n        var i = Math.floor(Date.now() / 1e3),\n            o = e.skewTime >= 0 ? e.skewTime : 300;\n\n        if (t) {\n          var a = i + o;\n\n          if (n.nbf) {\n            if (n.nbf > a) throw new Error(\"JWT not valid before nbf: \" + n.nbf);\n          } else if (n.iat && n.iat > a) throw new Error(\"JWT not valid yet (issued in the future) iat: \" + n.iat);\n\n          if (n.exp && n.exp <= i - o) throw new Error(\"JWT has expired: exp: \" + n.exp + \" < now: \" + i);\n\n          if (n.aud) {\n            if (!e.audience && !e.callbackUrl) throw new Error(\"JWT audience is required but your app address has not been configured\");\n            if (void 0 === (Array.isArray(n.aud) ? n.aud : [n.aud]).find(function (r) {\n              return e.audience === r || e.callbackUrl === r;\n            })) throw new Error(\"JWT audience does not match your DID or callback url\");\n          }\n\n          return {\n            payload: n,\n            doc: u,\n            issuer: c,\n            signer: t,\n            jwt: r\n          };\n        }\n      });\n    });\n  } catch (r) {\n    return Promise.reject(r);\n  }\n}, exports.x25519Decrypter = function (r) {\n  var e = \"ECDH-ES+XC20PKW\";\n  return {\n    alg: e,\n    enc: \"XC20P\",\n    decrypt: function (t, n, i, o) {\n      try {\n        if (function (r) {\n          if (!(r.epk && r.iv && r.tag)) throw new Error(\"Invalid JWE\");\n        }(o.header), \"X25519\" !== o.header.epk.crv) return Promise.resolve(null);\n        var u = f(o.header.epk.x),\n            c = j(a.sharedKey(r, u), 256, e),\n            s = w(o.encrypted_key, o.header.tag);\n        return Promise.resolve(ir(c).decrypt(s, f(o.header.iv))).then(function (r) {\n          return null === r ? null : ir(r).decrypt(t, n, i);\n        });\n      } catch (r) {\n        return Promise.reject(r);\n      }\n    }\n  };\n}, exports.x25519Encrypter = or, exports.xc20pDirDecrypter = ir, exports.xc20pDirEncrypter = nr;","map":null,"metadata":{},"sourceType":"script"}