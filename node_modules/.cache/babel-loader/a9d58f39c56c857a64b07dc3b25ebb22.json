{"ast":null,"code":"/* eslint-disable no-undef */\n'use strict';\n\nconst {\n  fetch,\n  Request,\n  Headers\n} = require('./http/fetch');\n\nconst {\n  TimeoutError,\n  HTTPError\n} = require('./http/error');\n\nconst merge = require('merge-options').bind({\n  ignoreUndefined: true\n});\n\nconst {\n  URL,\n  URLSearchParams\n} = require('iso-url');\n\nconst TextDecoder = require('./text-decoder');\n\nconst AbortController = require('abort-controller');\n\nconst anySignal = require('any-signal');\n\nconst timeout = (promise, ms, abortController) => {\n  if (ms === undefined) {\n    return promise;\n  }\n\n  const start = Date.now();\n\n  const timedOut = () => {\n    const time = Date.now() - start;\n    return time >= ms;\n  };\n\n  return new Promise((resolve, reject) => {\n    const timeoutID = setTimeout(() => {\n      if (timedOut()) {\n        reject(new TimeoutError());\n        abortController.abort();\n      }\n    }, ms);\n\n    const after = next => {\n      return res => {\n        clearTimeout(timeoutID);\n\n        if (timedOut()) {\n          reject(new TimeoutError());\n          return;\n        }\n\n        next(res);\n      };\n    };\n\n    promise.then(after(resolve), after(reject));\n  });\n};\n\nconst defaults = {\n  headers: {},\n  throwHttpErrors: true,\n  credentials: 'same-origin',\n  transformSearchParams: p => p\n};\n/**\n * @typedef {Object} APIOptions - creates a new type named 'SpecialType'\n * @prop {any} [body] - Request body\n * @prop {Object} [json] - JSON shortcut\n * @prop {string} [method] - GET, POST, PUT, DELETE, etc.\n * @prop {string} [base] - The base URL to use in case url is a relative URL\n * @prop {Headers|Record<string, string>} [headers] - Request header.\n * @prop {number} [timeout] - Amount of time until request should timeout in ms.\n * @prop {AbortSignal} [signal] - Signal to abort the request.\n * @prop {URLSearchParams|Object} [searchParams] - URL search param.\n * @prop {string} [credentials]\n * @prop {boolean} [throwHttpErrors]\n * @prop {function(URLSearchParams): URLSearchParams } [transformSearchParams]\n * @prop {function(any): any} [transform] - When iterating the response body, transform each chunk with this function.\n * @prop {function(Response): Promise<void>} [handleError] - Handle errors\n * @prop {function({total:number, loaded:number, lengthComputable:boolean}):void} [onUploadProgress] - Can be passed to track upload progress\n * @prop {function({total:number, loaded:number, lengthComputable:boolean}):void} [onDownloadProgress] - Can be passed to track download progress\n */\n\nclass HTTP {\n  /**\n   *\n   * @param {APIOptions} options\n   */\n  constructor(options = {}) {\n    /** @type {APIOptions} */\n    this.opts = merge(defaults, options);\n  }\n  /**\n   * Fetch\n   *\n   * @param {string | URL | Request} resource\n   * @param {APIOptions} options\n   * @returns {Promise<Response>}\n   */\n\n\n  async fetch(resource, options = {}) {\n    /** @type {APIOptions} */\n    const opts = merge(this.opts, options);\n    opts.headers = new Headers(opts.headers); // validate resource type\n\n    if (typeof resource !== 'string' && !(resource instanceof URL || resource instanceof Request)) {\n      throw new TypeError('`resource` must be a string, URL, or Request');\n    } // validate resource format and normalize with prefixUrl\n\n\n    if (opts.base && typeof opts.base === 'string' && typeof resource === 'string') {\n      if (resource.startsWith('/')) {\n        throw new Error('`resource` must not begin with a slash when using `base`');\n      }\n\n      if (!opts.base.endsWith('/')) {\n        opts.base += '/';\n      }\n\n      resource = opts.base + resource;\n    } // TODO: try to remove the logic above or fix URL instance input without trailing '/'\n\n\n    const url = new URL(resource, opts.base);\n\n    if (opts.searchParams) {\n      url.search = opts.transformSearchParams(new URLSearchParams(opts.searchParams));\n    }\n\n    if (opts.json !== undefined) {\n      opts.body = JSON.stringify(opts.json);\n      opts.headers.set('content-type', 'application/json');\n    }\n\n    const abortController = new AbortController();\n    const signal = anySignal([abortController.signal, opts.signal]);\n    const response = await timeout(fetch(url, { ...opts,\n      signal,\n      timeout: undefined\n    }), opts.timeout, abortController);\n\n    if (!response.ok && opts.throwHttpErrors) {\n      if (opts.handleError) {\n        await opts.handleError(response);\n      }\n\n      throw new HTTPError(response);\n    }\n\n    response.iterator = function () {\n      const it = streamToAsyncIterator(response.body);\n\n      if (!isAsyncIterator(it)) {\n        throw new Error('Can\\'t convert fetch body into a Async Iterator:');\n      }\n\n      return it;\n    };\n\n    response.ndjson = async function* () {\n      for await (const chunk of ndjson(response.iterator())) {\n        if (options.transform) {\n          yield options.transform(chunk);\n        } else {\n          yield chunk;\n        }\n      }\n    };\n\n    return response;\n  }\n  /**\n   * @param {string | URL | Request} resource\n   * @param {APIOptions} options\n   * @returns {Promise<Response>}\n   */\n\n\n  post(resource, options = {}) {\n    return this.fetch(resource, { ...options,\n      method: 'POST'\n    });\n  }\n  /**\n   * @param {string | URL | Request} resource\n   * @param {APIOptions} options\n   * @returns {Promise<Response>}\n   */\n\n\n  get(resource, options = {}) {\n    return this.fetch(resource, { ...options,\n      method: 'GET'\n    });\n  }\n  /**\n   * @param {string | URL | Request} resource\n   * @param {APIOptions} options\n   * @returns {Promise<Response>}\n   */\n\n\n  put(resource, options = {}) {\n    return this.fetch(resource, { ...options,\n      method: 'PUT'\n    });\n  }\n  /**\n   * @param {string | URL | Request} resource\n   * @param {APIOptions} options\n   * @returns {Promise<Response>}\n   */\n\n\n  delete(resource, options = {}) {\n    return this.fetch(resource, { ...options,\n      method: 'DELETE'\n    });\n  }\n  /**\n   * @param {string | URL | Request} resource\n   * @param {APIOptions} options\n   * @returns {Promise<Response>}\n   */\n\n\n  options(resource, options = {}) {\n    return this.fetch(resource, { ...options,\n      method: 'OPTIONS'\n    });\n  }\n\n}\n/**\n * Parses NDJSON chunks from an iterator\n *\n * @param {AsyncGenerator<Uint8Array, void, any>} source\n * @returns {AsyncGenerator<Object, void, any>}\n */\n\n\nconst ndjson = async function* (source) {\n  const decoder = new TextDecoder();\n  let buf = '';\n\n  for await (const chunk of source) {\n    buf += decoder.decode(chunk, {\n      stream: true\n    });\n    const lines = buf.split(/\\r?\\n/);\n\n    for (let i = 0; i < lines.length - 1; i++) {\n      const l = lines[i].trim();\n\n      if (l.length > 0) {\n        yield JSON.parse(l);\n      }\n    }\n\n    buf = lines[lines.length - 1];\n  }\n\n  buf += decoder.decode();\n  buf = buf.trim();\n\n  if (buf.length !== 0) {\n    yield JSON.parse(buf);\n  }\n};\n\nconst streamToAsyncIterator = function (source) {\n  if (isAsyncIterator(source)) {\n    // Workaround for https://github.com/node-fetch/node-fetch/issues/766\n    if (Object.prototype.hasOwnProperty.call(source, 'readable') && Object.prototype.hasOwnProperty.call(source, 'writable')) {\n      const iter = source[Symbol.asyncIterator]();\n      const wrapper = {\n        next: iter.next.bind(iter),\n        return: () => {\n          source.destroy();\n          return iter.return();\n        },\n        [Symbol.asyncIterator]: () => {\n          return wrapper;\n        }\n      };\n      return wrapper;\n    }\n\n    return source;\n  }\n\n  const reader = source.getReader();\n  return {\n    next() {\n      return reader.read();\n    },\n\n    return() {\n      reader.releaseLock();\n      return {};\n    },\n\n    [Symbol.asyncIterator]() {\n      return this;\n    }\n\n  };\n};\n\nconst isAsyncIterator = obj => {\n  return typeof obj === 'object' && obj !== null && // typeof obj.next === 'function' &&\n  typeof obj[Symbol.asyncIterator] === 'function';\n};\n\nHTTP.HTTPError = HTTPError;\nHTTP.TimeoutError = TimeoutError;\nHTTP.streamToAsyncIterator = streamToAsyncIterator;\n/**\n * @param {string | URL | Request} resource\n * @param {APIOptions} options\n * @returns {Promise<Response>}\n */\n\nHTTP.post = (resource, options) => new HTTP(options).post(resource, options);\n/**\n * @param {string | URL | Request} resource\n * @param {APIOptions} options\n * @returns {Promise<Response>}\n */\n\n\nHTTP.get = (resource, options) => new HTTP(options).get(resource, options);\n/**\n * @param {string | URL | Request} resource\n * @param {APIOptions} options\n * @returns {Promise<Response>}\n */\n\n\nHTTP.put = (resource, options) => new HTTP(options).put(resource, options);\n/**\n * @param {string | URL | Request} resource\n * @param {APIOptions} options\n * @returns {Promise<Response>}\n */\n\n\nHTTP.delete = (resource, options) => new HTTP(options).delete(resource, options);\n/**\n * @param {string | URL | Request} resource\n * @param {APIOptions} options\n * @returns {Promise<Response>}\n */\n\n\nHTTP.options = (resource, options) => new HTTP(options).options(resource, options);\n\nmodule.exports = HTTP;","map":null,"metadata":{},"sourceType":"script"}