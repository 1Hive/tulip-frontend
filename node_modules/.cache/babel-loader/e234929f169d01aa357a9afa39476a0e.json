{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _awaitAsyncGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _wrapAsyncGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar errcode = require('err-code');\n\nvar pTimeout = require('p-timeout');\n\nvar PeerId = require('peer-id');\n\nvar PeerInfo = require('peer-info');\n\nvar crypto = require('libp2p-crypto');\n\nvar c = require('../constants');\n\nvar Message = require('../message');\n\nvar Query = require('../query');\n\nvar utils = require('../utils');\n\nmodule.exports = function (dht) {\n  /**\n   * Look if we are connected to a peer with the given id.\n   * Returns the `PeerInfo` for it, if found, otherwise `undefined`.\n   * @param {PeerId} peer\n   * @returns {Promise<PeerInfo>}\n   */\n  var findPeerLocal = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(peer) {\n      var p;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              dht._log('findPeerLocal %s', peer.toB58String());\n\n              _context.next = 3;\n              return dht.routingTable.find(peer);\n\n            case 3:\n              p = _context.sent;\n\n              if (!(!p || !dht.peerStore.has(p))) {\n                _context.next = 6;\n                break;\n              }\n\n              return _context.abrupt(\"return\");\n\n            case 6:\n              return _context.abrupt(\"return\", dht.peerStore.get(p));\n\n            case 7:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function findPeerLocal(_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n  /**\n   * Get a value via rpc call for the given parameters.\n   * @param {PeerId} peer\n   * @param {Buffer} key\n   * @returns {Promise<Message>}\n   * @private\n   */\n\n\n  var getValueSingle = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(peer, key) {\n      var msg;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              // eslint-disable-line require-await\n              msg = new Message(Message.TYPES.GET_VALUE, key, 0);\n              return _context2.abrupt(\"return\", dht.network.sendRequest(peer, msg));\n\n            case 2:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    return function getValueSingle(_x2, _x3) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n  /**\n   * Find close peers for a given peer\n   * @param {Buffer} key\n   * @param {PeerId} peer\n   * @returns {Promise<Array<PeerInfo>>}\n   * @private\n   */\n\n\n  var closerPeersSingle = /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(key, peer) {\n      var msg;\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              dht._log('closerPeersSingle %b from %s', key, peer.toB58String());\n\n              _context3.next = 3;\n              return dht.peerRouting._findPeerSingle(peer, new PeerId(key));\n\n            case 3:\n              msg = _context3.sent;\n              return _context3.abrupt(\"return\", msg.closerPeers.filter(function (pInfo) {\n                return !dht._isSelf(pInfo.id);\n              }).map(function (pInfo) {\n                return dht.peerStore.put(pInfo);\n              }));\n\n            case 5:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n\n    return function closerPeersSingle(_x4, _x5) {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n  /**\n   * Get the public key directly from a node.\n   * @param {PeerId} peer\n   * @returns {Promise<PublicKey>}\n   * @private\n   */\n\n\n  var getPublicKeyFromNode = /*#__PURE__*/function () {\n    var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(peer) {\n      var pkKey, msg, recPeer;\n      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              pkKey = utils.keyForPublicKey(peer);\n              _context4.next = 3;\n              return getValueSingle(peer, pkKey);\n\n            case 3:\n              msg = _context4.sent;\n\n              if (!(!msg.record || !msg.record.value)) {\n                _context4.next = 6;\n                break;\n              }\n\n              throw errcode(\"Node not responding with its public key: \".concat(peer.toB58String()), 'ERR_INVALID_RECORD');\n\n            case 6:\n              recPeer = PeerId.createFromPubKey(msg.record.value); // compare hashes of the pub key\n\n              if (recPeer.isEqual(peer)) {\n                _context4.next = 9;\n                break;\n              }\n\n              throw errcode('public key does not match id', 'ERR_PUBLIC_KEY_DOES_NOT_MATCH_ID');\n\n            case 9:\n              return _context4.abrupt(\"return\", recPeer.pubKey);\n\n            case 10:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n\n    return function getPublicKeyFromNode(_x6) {\n      return _ref4.apply(this, arguments);\n    };\n  }();\n\n  return {\n    /**\n     * Ask peer `peer` if they know where the peer with id `target` is.\n     * @param {PeerId} peer\n     * @param {PeerId} target\n     * @returns {Promise<Message>}\n     * @private\n     */\n    _findPeerSingle: function _findPeerSingle(peer, target) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        var msg;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                // eslint-disable-line require-await\n                dht._log('findPeerSingle %s', peer.toB58String());\n\n                msg = new Message(Message.TYPES.FIND_NODE, target.id, 0);\n                return _context5.abrupt(\"return\", dht.network.sendRequest(peer, msg));\n\n              case 3:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }))();\n    },\n\n    /**\n     * Search for a peer with the given ID.\n     * @param {PeerId} id\n     * @param {Object} options - findPeer options\n     * @param {number} options.timeout - how long the query should maximally run, in milliseconds (default: 60000)\n     * @returns {Promise<PeerInfo>}\n     */\n    findPeer: function findPeer(id) {\n      var _arguments = arguments,\n          _this = this;\n\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n        var options, pi, key, peers, match, query, error, result, success;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                options = _arguments.length > 1 && _arguments[1] !== undefined ? _arguments[1] : {};\n                options.timeout = options.timeout || c.minute;\n\n                dht._log('findPeer %s', id.toB58String()); // Try to find locally\n\n\n                _context7.next = 5;\n                return findPeerLocal(id);\n\n              case 5:\n                pi = _context7.sent;\n\n                if (!(pi != null)) {\n                  _context7.next = 9;\n                  break;\n                }\n\n                dht._log('found local');\n\n                return _context7.abrupt(\"return\", pi);\n\n              case 9:\n                _context7.next = 11;\n                return utils.convertPeerId(id);\n\n              case 11:\n                key = _context7.sent;\n                peers = dht.routingTable.closestPeers(key, dht.kBucketSize);\n\n                if (!(peers.length === 0)) {\n                  _context7.next = 15;\n                  break;\n                }\n\n                throw errcode(new Error('Peer lookup failed'), 'ERR_LOOKUP_FAILED');\n\n              case 15:\n                // sanity check\n                match = peers.find(function (p) {\n                  return p.isEqual(id);\n                });\n\n                if (!(match && dht.peerStore.has(id))) {\n                  _context7.next = 19;\n                  break;\n                }\n\n                dht._log('found in peerStore');\n\n                return _context7.abrupt(\"return\", dht.peerStore.get(id));\n\n              case 19:\n                // query the network\n                query = new Query(dht, id.id, function () {\n                  // There is no distinction between the disjoint paths,\n                  // so there are no per-path variables in dht scope.\n                  // Just return the actual query function.\n                  return /*#__PURE__*/function () {\n                    var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(peer) {\n                      var msg, match;\n                      return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n                        while (1) {\n                          switch (_context6.prev = _context6.next) {\n                            case 0:\n                              _context6.next = 2;\n                              return _this._findPeerSingle(peer, id);\n\n                            case 2:\n                              msg = _context6.sent;\n                              match = msg.closerPeers.find(function (p) {\n                                return p.id.isEqual(id);\n                              }); // found it\n\n                              if (!match) {\n                                _context6.next = 6;\n                                break;\n                              }\n\n                              return _context6.abrupt(\"return\", {\n                                peer: match,\n                                queryComplete: true\n                              });\n\n                            case 6:\n                              return _context6.abrupt(\"return\", {\n                                closerPeers: msg.closerPeers\n                              });\n\n                            case 7:\n                            case \"end\":\n                              return _context6.stop();\n                          }\n                        }\n                      }, _callee6);\n                    }));\n\n                    return function (_x7) {\n                      return _ref5.apply(this, arguments);\n                    };\n                  }();\n                });\n                _context7.prev = 20;\n                _context7.next = 23;\n                return pTimeout(query.run(peers), options.timeout);\n\n              case 23:\n                result = _context7.sent;\n                _context7.next = 29;\n                break;\n\n              case 26:\n                _context7.prev = 26;\n                _context7.t0 = _context7[\"catch\"](20);\n                error = _context7.t0;\n\n              case 29:\n                query.stop();\n\n                if (!error) {\n                  _context7.next = 32;\n                  break;\n                }\n\n                throw error;\n\n              case 32:\n                success = false;\n                result.paths.forEach(function (result) {\n                  if (result.success) {\n                    success = true;\n                    dht.peerStore.put(result.peer);\n                  }\n                });\n\n                dht._log('findPeer %s: %s', id.toB58String(), success);\n\n                if (success) {\n                  _context7.next = 37;\n                  break;\n                }\n\n                throw errcode(new Error('No peer found'), 'ERR_NOT_FOUND');\n\n              case 37:\n                return _context7.abrupt(\"return\", dht.peerStore.get(id));\n\n              case 38:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, null, [[20, 26]]);\n      }))();\n    },\n\n    /**\n     * Kademlia 'node lookup' operation.\n     * @param {Buffer} key\n     * @param {Object} [options]\n     * @param {boolean} [options.shallow] shallow query (default: false)\n     * @returns {AsyncIterable<PeerId>}\n     */\n    getClosestPeers: function getClosestPeers(key) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        shallow: false\n      };\n      return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n        var id, tablePeers, q, res, sorted, _iterator, _step, pId;\n\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                dht._log('getClosestPeers to %b', key);\n\n                _context9.next = 3;\n                return _awaitAsyncGenerator(utils.convertBuffer(key));\n\n              case 3:\n                id = _context9.sent;\n                tablePeers = dht.routingTable.closestPeers(id, dht.kBucketSize);\n                q = new Query(dht, key, function () {\n                  // There is no distinction between the disjoint paths,\n                  // so there are no per-path variables in dht scope.\n                  // Just return the actual query function.\n                  return /*#__PURE__*/function () {\n                    var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(peer) {\n                      var closer;\n                      return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n                        while (1) {\n                          switch (_context8.prev = _context8.next) {\n                            case 0:\n                              _context8.next = 2;\n                              return closerPeersSingle(key, peer);\n\n                            case 2:\n                              closer = _context8.sent;\n                              return _context8.abrupt(\"return\", {\n                                closerPeers: closer,\n                                pathComplete: options.shallow ? true : undefined\n                              });\n\n                            case 4:\n                            case \"end\":\n                              return _context8.stop();\n                          }\n                        }\n                      }, _callee8);\n                    }));\n\n                    return function (_x8) {\n                      return _ref6.apply(this, arguments);\n                    };\n                  }();\n                });\n                _context9.next = 8;\n                return _awaitAsyncGenerator(q.run(tablePeers));\n\n              case 8:\n                res = _context9.sent;\n\n                if (!(!res || !res.finalSet)) {\n                  _context9.next = 11;\n                  break;\n                }\n\n                return _context9.abrupt(\"return\", []);\n\n              case 11:\n                _context9.next = 13;\n                return _awaitAsyncGenerator(utils.sortClosestPeers(Array.from(res.finalSet), id));\n\n              case 13:\n                sorted = _context9.sent;\n                _iterator = _createForOfIteratorHelper(sorted.slice(0, dht.kBucketSize));\n                _context9.prev = 15;\n\n                _iterator.s();\n\n              case 17:\n                if ((_step = _iterator.n()).done) {\n                  _context9.next = 23;\n                  break;\n                }\n\n                pId = _step.value;\n                _context9.next = 21;\n                return pId;\n\n              case 21:\n                _context9.next = 17;\n                break;\n\n              case 23:\n                _context9.next = 28;\n                break;\n\n              case 25:\n                _context9.prev = 25;\n                _context9.t0 = _context9[\"catch\"](15);\n\n                _iterator.e(_context9.t0);\n\n              case 28:\n                _context9.prev = 28;\n\n                _iterator.f();\n\n                return _context9.finish(28);\n\n              case 31:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, null, [[15, 25, 28, 31]]);\n      }))();\n    },\n\n    /**\n     * Get the public key for the given peer id.\n     * @param {PeerId} peer\n     * @returns {Promise<PubKey>}\n     */\n    getPublicKey: function getPublicKey(peer) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {\n        var info, pk, pkKey, value;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                dht._log('getPublicKey %s', peer.toB58String()); // local check\n\n\n                if (!dht.peerStore.has(peer)) {\n                  _context10.next = 8;\n                  break;\n                }\n\n                info = dht.peerStore.get(peer);\n\n                if (!(info && info.id.pubKey)) {\n                  _context10.next = 6;\n                  break;\n                }\n\n                dht._log('getPublicKey: found local copy');\n\n                return _context10.abrupt(\"return\", info.id.pubKey);\n\n              case 6:\n                _context10.next = 9;\n                break;\n\n              case 8:\n                info = dht.peerStore.put(new PeerInfo(peer));\n\n              case 9:\n                _context10.prev = 9;\n                _context10.next = 12;\n                return getPublicKeyFromNode(peer);\n\n              case 12:\n                pk = _context10.sent;\n                _context10.next = 22;\n                break;\n\n              case 15:\n                _context10.prev = 15;\n                _context10.t0 = _context10[\"catch\"](9);\n                // try dht directly\n                pkKey = utils.keyForPublicKey(peer);\n                _context10.next = 20;\n                return dht.get(pkKey);\n\n              case 20:\n                value = _context10.sent;\n                pk = crypto.keys.unmarshalPublicKey(value);\n\n              case 22:\n                info.id = new PeerId(peer.id, null, pk);\n                dht.peerStore.put(info);\n                return _context10.abrupt(\"return\", pk);\n\n              case 25:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, null, [[9, 15]]);\n      }))();\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"script"}