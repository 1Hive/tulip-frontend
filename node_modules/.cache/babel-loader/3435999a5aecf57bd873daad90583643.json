{"ast":null,"code":"'use strict';\n\nconst withIs = require('class-is');\n\nconst Topology = require('./index');\n\nclass MulticodecTopology extends Topology {\n  /**\n   * @param {Object} props\n   * @param {number} props.min minimum needed connections (default: 0)\n   * @param {number} props.max maximum needed connections (default: Infinity)\n   * @param {Array<string>} props.multicodecs protocol multicodecs\n   * @param {Object} props.handlers\n   * @param {function} props.handlers.onConnect protocol \"onConnect\" handler\n   * @param {function} props.handlers.onDisconnect protocol \"onDisconnect\" handler\n   * @constructor\n   */\n  constructor({\n    min,\n    max,\n    multicodecs,\n    handlers\n  }) {\n    super({\n      min,\n      max,\n      handlers\n    });\n\n    if (!multicodecs) {\n      throw new Error('one or more multicodec should be provided');\n    }\n\n    if (!handlers) {\n      throw new Error('the handlers should be provided');\n    }\n\n    if (typeof handlers.onConnect !== 'function') {\n      throw new Error('the \\'onConnect\\' handler must be provided');\n    }\n\n    if (typeof handlers.onDisconnect !== 'function') {\n      throw new Error('the \\'onDisconnect\\' handler must be provided');\n    }\n\n    this.multicodecs = Array.isArray(multicodecs) ? multicodecs : [multicodecs];\n    this._registrar = undefined;\n    this._onProtocolChange = this._onProtocolChange.bind(this);\n  }\n\n  set registrar(registrar) {\n    this._registrar = registrar;\n\n    this._registrar.peerStore.on('change:protocols', this._onProtocolChange); // Update topology peers\n\n\n    this._updatePeers(this._registrar.peerStore.peers.values());\n  }\n  /**\n   * Update topology.\n   * @param {Array<PeerInfo>} peerInfoIterable\n   * @returns {void}\n   */\n\n\n  _updatePeers(peerInfoIterable) {\n    for (const peerInfo of peerInfoIterable) {\n      if (this.multicodecs.filter(multicodec => peerInfo.protocols.has(multicodec)).length) {\n        // Add the peer regardless of whether or not there is currently a connection\n        this.peers.set(peerInfo.id.toB58String(), peerInfo); // If there is a connection, call _onConnect\n\n        const connection = this._registrar.getConnection(peerInfo);\n\n        connection && this._onConnect(peerInfo, connection);\n      } else {\n        // Remove any peers we might be tracking that are no longer of value to us\n        this.peers.delete(peerInfo.id.toB58String());\n      }\n    }\n  }\n  /**\n   * Check if a new peer support the multicodecs for this topology.\n   * @param {Object} props\n   * @param {PeerInfo} props.peerInfo\n   * @param {Array<string>} props.protocols\n   */\n\n\n  _onProtocolChange({\n    peerInfo,\n    protocols\n  }) {\n    const existingPeer = this.peers.get(peerInfo.id.toB58String());\n    const hasProtocol = protocols.filter(protocol => this.multicodecs.includes(protocol)); // Not supporting the protocol anymore?\n\n    if (existingPeer && hasProtocol.length === 0) {\n      this._onDisconnect(peerInfo);\n    } // New to protocol support\n\n\n    for (const protocol of protocols) {\n      if (this.multicodecs.includes(protocol)) {\n        this._updatePeers([peerInfo]);\n\n        return;\n      }\n    }\n  }\n\n}\n\nmodule.exports = withIs(MulticodecTopology, {\n  className: 'MulticodecTopology',\n  symbolName: '@libp2p/js-interfaces/topology/multicodec-topology'\n});","map":null,"metadata":{},"sourceType":"script"}