{"ast":null,"code":"import { id } from 'ethers/utils/hash';\nimport invariant from 'invariant';\nimport fetch from 'cross-fetch';\nimport { defaultAbiCoder } from 'ethers/utils/abi-coder';\nimport debug from 'debug';\nimport memoize from 'lodash/memoize';\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport WebSocket from 'isomorphic-ws';\nvar log = debug('multicall'); // Function signature for: aggregate((address,bytes)[])\n\nvar AGGREGATE_SELECTOR = '0x252dba42';\n\nfunction strip0x(str) {\n  return str.replace(/^0x/, '');\n}\n\nfunction encodeParameters(types, vals) {\n  return defaultAbiCoder.encode(types, vals);\n}\n\nfunction decodeParameters(types, vals) {\n  return defaultAbiCoder.decode(types, '0x' + vals.replace(/0x/i, ''));\n}\n\nfunction isEmpty(obj) {\n  if (Array.isArray(obj)) return obj.length === 0;\n  return !obj || Object.keys(obj).length === 0;\n}\n\nasync function ethCall(rawData, _ref) {\n  var id = _ref.id,\n      web3 = _ref.web3,\n      rpcUrl = _ref.rpcUrl,\n      block = _ref.block,\n      multicallAddress = _ref.multicallAddress,\n      ws = _ref.ws,\n      wsResponseTimeout = _ref.wsResponseTimeout;\n  var abiEncodedData = AGGREGATE_SELECTOR + strip0x(rawData);\n\n  if (ws) {\n    log('Sending via WebSocket');\n    return new Promise(function (resolve, reject) {\n      ws.send(JSON.stringify({\n        jsonrpc: '2.0',\n        method: 'eth_call',\n        params: [{\n          to: multicallAddress,\n          data: abiEncodedData\n        }, block || 'latest'],\n        id: id\n      }));\n\n      function onMessage(data) {\n        if (typeof data !== 'string') data = data.data;\n        var json = JSON.parse(data);\n        if (!json.id || json.id !== id) return;\n        log('Got WebSocket response id #%d', json.id);\n        clearTimeout(timeoutHandle);\n        ws.onmessage = null;\n        resolve(json.result);\n      }\n\n      var timeoutHandle = setTimeout(function () {\n        if (ws.onmessage !== onMessage) return;\n        ws.onmessage = null;\n        reject(new Error('WebSocket response timeout'));\n      }, wsResponseTimeout);\n      ws.onmessage = onMessage;\n    });\n  } else if (web3) {\n    log('Sending via web3 provider');\n    return web3.eth.call({\n      to: multicallAddress,\n      data: abiEncodedData\n    });\n  } else {\n    log('Sending via XHR fetch');\n    var rawResponse = await fetch(rpcUrl, {\n      method: 'POST',\n      headers: {\n        'Accept': 'application/json',\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        jsonrpc: '2.0',\n        method: 'eth_call',\n        params: [{\n          to: multicallAddress,\n          data: abiEncodedData\n        }, block || 'latest'],\n        id: 1\n      })\n    });\n    var content = await rawResponse.json();\n\n    if (!content || !content.result) {\n      throw new Error('Multicall received an empty response. Check your call configuration for errors.');\n    }\n\n    return content.result;\n  }\n}\n\nvar INSIDE_EVERY_PARENTHESES = /\\(.*?\\)/g;\nvar FIRST_CLOSING_PARENTHESES = /^[^)]*\\)/;\n\nfunction _makeMulticallData(calls) {\n  var values = [calls.map(function (_ref) {\n    var target = _ref.target,\n        method = _ref.method,\n        args = _ref.args,\n        returnTypes = _ref.returnTypes;\n    return [target, id(method).substr(0, 10) + (args && args.length > 0 ? strip0x(encodeParameters(args.map(function (a) {\n      return a[1];\n    }), args.map(function (a) {\n      return a[0];\n    }))) : '')];\n  })];\n  var calldata = encodeParameters([{\n    components: [{\n      type: 'address'\n    }, {\n      type: 'bytes'\n    }],\n    name: 'data',\n    type: 'tuple[]'\n  }], values);\n  return calldata;\n}\n\nvar makeMulticallData = memoize(_makeMulticallData, function () {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return JSON.stringify(args);\n});\n\nasync function aggregate(calls, config) {\n  calls = Array.isArray(calls) ? calls : [calls];\n  var keyToArgMap = calls.reduce(function (acc, _ref2) {\n    var call = _ref2.call,\n        returns = _ref2.returns;\n    var args = call.slice(1);\n\n    if (args.length > 0) {\n      for (var _iterator = returns, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref3;\n\n        if (_isArray) {\n          if (_i >= _iterator.length) break;\n          _ref3 = _iterator[_i++];\n        } else {\n          _i = _iterator.next();\n          if (_i.done) break;\n          _ref3 = _i.value;\n        }\n\n        var returnMeta = _ref3;\n        var key = returnMeta[0];\n        acc[key] = args;\n      }\n    }\n\n    return acc;\n  }, {});\n  calls = calls.map(function (_ref4) {\n    var call = _ref4.call,\n        target = _ref4.target,\n        returns = _ref4.returns;\n    if (!target) target = config.multicallAddress;\n    var method = call[0],\n        argValues = call.slice(1);\n\n    var _method$match$map = method.match(INSIDE_EVERY_PARENTHESES).map(function (match) {\n      return match.slice(1, -1);\n    }),\n        argTypesString = _method$match$map[0],\n        returnTypesString = _method$match$map[1];\n\n    var argTypes = argTypesString.split(',').filter(function (e) {\n      return !!e;\n    });\n    invariant(argTypes.length === argValues.length, \"Every method argument must have exactly one type.\\n          Comparing argument types \" + JSON.stringify(argTypes) + \"\\n          to argument values \" + JSON.stringify(argValues) + \".\\n        \");\n    var args = argValues.map(function (argValue, idx) {\n      return [argValue, argTypes[idx]];\n    });\n    var returnTypes = !!returnTypesString ? returnTypesString.split(',') : [];\n    return {\n      method: method.match(FIRST_CLOSING_PARENTHESES)[0],\n      args: args,\n      returnTypes: returnTypes,\n      target: target,\n      returns: returns\n    };\n  });\n  var callDataBytes = makeMulticallData(calls, false);\n  var outerResults = await ethCall(callDataBytes, config);\n  var returnTypeArray = calls.map(function (_ref5) {\n    var returnTypes = _ref5.returnTypes;\n    return returnTypes;\n  }).reduce(function (acc, ele) {\n    return acc.concat(ele);\n  }, []);\n  var returnDataMeta = calls.map(function (_ref6) {\n    var returns = _ref6.returns;\n    return returns;\n  }).reduce(function (acc, ele) {\n    return acc.concat(ele);\n  }, []);\n  invariant(returnTypeArray.length === returnDataMeta.length, 'Missing data needed to parse results');\n  var outerResultsDecoded = decodeParameters(['uint256', 'bytes[]'], outerResults);\n  var blockNumber = outerResultsDecoded.shift();\n  var parsedVals = outerResultsDecoded.reduce(function (acc, r) {\n    r.forEach(function (results, idx) {\n      var types = calls[idx].returnTypes;\n      var resultsDecoded = decodeParameters(types, results);\n      acc.push.apply(acc, resultsDecoded.map(function (r, idx) {\n        if (types[idx] === 'bool') return r.toString() === 'true';\n        return r;\n      }));\n    });\n    return acc;\n  }, []);\n  var retObj = {\n    blockNumber: blockNumber,\n    original: {},\n    transformed: {}\n  };\n\n  for (var i = 0; i < parsedVals.length; i++) {\n    var _returnDataMeta$i = returnDataMeta[i],\n        name = _returnDataMeta$i[0],\n        transform = _returnDataMeta$i[1];\n    retObj.original[name] = parsedVals[i];\n    retObj.transformed[name] = transform !== undefined ? transform(parsedVals[i]) : parsedVals[i];\n  }\n\n  return {\n    results: retObj,\n    keyToArgMap: keyToArgMap\n  };\n}\n\nvar mainnet = {\n  multicall: \"0xeefba1e63905ef1d7acba5a8513c70307c1ce441\",\n  rpcUrl: \"https://mainnet.infura.io\"\n};\nvar kovan = {\n  multicall: \"0x2cc8688c5f75e365aaeeb4ea8d6a480405a48d2a\",\n  rpcUrl: \"https://kovan.infura.io\"\n};\nvar rinkeby = {\n  multicall: \"0x42ad527de7d4e9d9d011ac45b31d8551f8fe9821\",\n  rpcUrl: \"https://rinkeby.infura.io\"\n};\nvar goerli = {\n  multicall: \"0x77dca2c955b15e9de4dbbcf1246b4b85b651e50e\",\n  rpcUrl: \"https://rpc.slock.it/goerli\"\n};\nvar xdai = {\n  multicall: \"0xb5b692a88bdfc81ca69dcb1d924f59f0413a602a\",\n  rpcUrl: \"https://dai.poa.network\"\n};\nvar addresses = {\n  mainnet: mainnet,\n  kovan: kovan,\n  rinkeby: rinkeby,\n  goerli: goerli,\n  xdai: xdai\n};\nvar log$1 = debug('multicall');\nvar reWsEndpoint = /^wss?:\\/\\//i;\n\nfunction isNewState(type, value, store) {\n  return store[type] === undefined || (value !== null && store[type] !== null && typeof value === 'object' && typeof value.toString === 'function' && typeof store[type] === 'object' && typeof store[type].toString === 'function' ? value.toString() !== store[type].toString() : value !== store[type]);\n}\n\nfunction prepareConfig(config) {\n  config = _extends({\n    interval: 1000,\n    staleBlockRetryWait: 3000,\n    errorRetryWait: 5000,\n    wsResponseTimeout: 5000,\n    wsReconnectTimeout: 5000\n  }, config);\n\n  if (config.preset !== undefined) {\n    if (addresses[config.preset] !== undefined) {\n      config.multicallAddress = addresses[config.preset].multicall;\n      config.rpcUrl = addresses[config.preset].rpcUrl;\n    } else throw new Error(\"Unknown preset \" + config.preset);\n  }\n\n  return config;\n}\n\nfunction createWatcher(model, config) {\n  var state = {\n    model: [].concat(model),\n    store: {},\n    storeTransformed: {},\n    keyToArgMap: {},\n    latestPromiseId: 0,\n    latestBlockNumber: null,\n    id: 0,\n    listeners: {\n      subscribe: [],\n      block: [],\n      poll: [],\n      error: []\n    },\n    handler: null,\n    wsReconnectHandler: null,\n    watching: false,\n    config: prepareConfig(config),\n    ws: null\n  };\n\n  function reconnectWebSocket(timeout) {\n    clearTimeout(state.handler);\n    state.handler = null;\n    clearTimeout(state.wsReconnectHandler);\n    state.wsReconnectHandler = setTimeout(function () {\n      destroyWebSocket();\n      setupWebSocket();\n    }, timeout);\n  }\n\n  function setupWebSocket() {\n    if (reWsEndpoint.test(state.config.rpcUrl)) {\n      log$1(\"Connecting to WebSocket \" + state.config.rpcUrl + \"...\");\n      state.ws = new WebSocket(state.config.rpcUrl);\n\n      state.ws.onopen = function () {\n        log$1('WebSocket connected');\n        if (state.handler) throw new Error('Existing poll setTimeout handler set');\n\n        if (state.watching) {\n          _poll.call({\n            state: state,\n            interval: 0,\n            resolveFetchPromise: state.initialFetchResolver\n          });\n        }\n      };\n\n      state.ws.onclose = function (err) {\n        log$1('WebSocket closed: %s', JSON.stringify(err));\n        log$1(\"Reconnecting in \" + state.config.wsReconnectTimeout / 1000 + \" seconds.\");\n        reconnectWebSocket(state.config.wsReconnectTimeout);\n      };\n\n      state.ws.onerror = function (err) {\n        log$1('WebSocket error: %s', JSON.stringify(err));\n        log$1(\"Reconnecting in \" + state.config.wsReconnectTimeout / 1000 + \" seconds.\");\n        reconnectWebSocket(state.config.wsReconnectTimeout);\n      };\n    }\n  }\n\n  function destroyWebSocket() {\n    log$1('destroyWebSocket()');\n    state.ws.onopen = null;\n    state.ws.onclose = null;\n    state.ws.onerror = null;\n    state.ws.onmessage = null;\n    state.ws.close();\n  }\n\n  setupWebSocket();\n  state.initialFetchPromise = new Promise(function (resolve) {\n    state.initialFetchResolver = resolve;\n  });\n\n  function _subscribe(listener, id, batch) {\n    if (batch === void 0) {\n      batch = false;\n    }\n\n    if (!isEmpty(state.storeTransformed)) {\n      var events = Object.entries(state.storeTransformed).map(function (_ref) {\n        var type = _ref[0],\n            value = _ref[1];\n        return {\n          type: type,\n          value: value,\n          args: state.keyToArgMap[type] || []\n        };\n      });\n      batch ? listener(events) : events.forEach(listener);\n    }\n\n    state.listeners.subscribe.push({\n      listener: listener,\n      id: id,\n      batch: batch\n    });\n  }\n\n  function alertListeners(events) {\n    if (!isEmpty(events)) state.listeners.subscribe.forEach(function (_ref2) {\n      var listener = _ref2.listener,\n          batch = _ref2.batch;\n      return batch ? listener(events) : events.forEach(listener);\n    });\n  }\n\n  function _poll() {\n    var _this = this;\n\n    var interval = this.interval !== undefined ? this.interval : this.state.config.interval;\n    log$1('poll() called, %s%s', 'interval: ' + interval, this.retry ? ', retry: ' + this.retry : '');\n    this.state.handler = setTimeout(async function () {\n      try {\n        if (!_this.state.handler) return;\n        _this.state.latestPromiseId++;\n        var promiseId = _this.state.latestPromiseId;\n        state.listeners.poll.forEach(function (_ref3) {\n          var listener = _ref3.listener;\n          return listener(_extends({\n            id: promiseId,\n            latestBlockNumber: _this.state.latestBlockNumber\n          }, _this.retry ? {\n            retry: _this.retry\n          } : {}));\n        });\n\n        var _ref4 = await aggregate(_this.state.model, _extends({}, _this.state.config, {\n          ws: _this.state.ws,\n          id: _this.state.latestPromiseId\n        })),\n            _ref4$results = _ref4.results,\n            blockNumber = _ref4$results.blockNumber,\n            data = _extends({}, _ref4$results.original),\n            dataTransformed = _extends({}, _ref4$results.transformed),\n            keyToArgMap = _ref4.keyToArgMap;\n\n        if (_this.state.cancelPromiseId === promiseId) return;\n        if (typeof _this.resolveFetchPromise === 'function') _this.resolveFetchPromise();\n\n        if (_this.state.latestBlockNumber !== null && blockNumber < _this.state.latestBlockNumber) {\n          // Retry if blockNumber is lower than latestBlockNumber\n          log$1(\"Stale block returned, retrying in \" + _this.state.config.staleBlockRetryWait / 1000 + \" seconds\");\n\n          _poll.call({\n            state: _this.state,\n            interval: _this.state.config.staleBlockRetryWait,\n            retry: _this.retry ? _this.retry + 1 : 1\n          });\n        } else {\n          if (_this.state.latestBlockNumber === null || _this.state.latestBlockNumber !== null && blockNumber > _this.state.latestBlockNumber) {\n            _this.state.latestBlockNumber = parseInt(blockNumber);\n            state.listeners.block.forEach(function (_ref5) {\n              var listener = _ref5.listener;\n              return listener(_this.state.latestBlockNumber);\n            });\n          }\n\n          var events = Object.entries(data).filter(function (_ref6) {\n            var type = _ref6[0],\n                value = _ref6[1];\n            return isNewState(type, value, _this.state.store);\n          }).map(function (_ref7) {\n            var type = _ref7[0];\n            return {\n              type: type,\n              value: dataTransformed[type],\n              args: keyToArgMap[type] || []\n            };\n          });\n          _this.state.store = _extends({}, data);\n          _this.state.storeTransformed = _extends({}, dataTransformed);\n          _this.state.keyToArgMap = _extends({}, keyToArgMap);\n          alertListeners(events);\n\n          _poll.call({\n            state: _this.state\n          });\n        }\n      } catch (err) {\n        log$1('Error: %s', err.message);\n        state.listeners.error.forEach(function (_ref8) {\n          var listener = _ref8.listener;\n          return listener(err, _this.state);\n        });\n        if (!_this.state.handler) return; // Retry on error\n\n        log$1(\"Error occured, retrying in \" + _this.state.config.errorRetryWait / 1000 + \" seconds\");\n\n        _poll.call({\n          state: _this.state,\n          interval: _this.state.config.errorRetryWait,\n          retry: _this.retry ? _this.retry + 1 : 1\n        });\n      }\n    }, interval);\n  }\n\n  var watcher = {\n    tap: function tap(transform) {\n      log$1('watcher.tap() called');\n      var nextModel = transform([].concat(state.model));\n      state.model = [].concat(nextModel);\n      return this.poll();\n    },\n    poll: function poll() {\n      log$1('watcher.poll() called');\n      var resolveFetchPromise;\n      var fetchPromise = new Promise(function (resolve) {\n        resolveFetchPromise = resolve;\n      });\n\n      if (state.watching && (!state.ws || state.ws.readyState === WebSocket.OPEN)) {\n        clearTimeout(state.handler);\n        state.handler = null;\n\n        _poll.call({\n          state: state,\n          interval: 0,\n          resolveFetchPromise: resolveFetchPromise\n        });\n\n        return fetchPromise;\n      }\n\n      return Promise.resolve();\n    },\n    subscribe: function subscribe(listener) {\n      var id = state.id++;\n\n      _subscribe(listener, id, false);\n\n      return {\n        unsub: function unsub() {\n          state.listeners.subscribe = state.listeners.subscribe.filter(function (_ref9) {\n            var _id = _ref9.id;\n            return _id !== id;\n          });\n        }\n      };\n    },\n    batch: function batch() {\n      return {\n        subscribe: function subscribe(listener) {\n          var id = state.id++;\n\n          _subscribe(listener, id, true);\n\n          return {\n            unsub: function unsub() {\n              state.listeners.subscribe = state.listeners.subscribe.filter(function (_ref10) {\n                var _id = _ref10.id;\n                return _id !== id;\n              });\n            }\n          };\n        }\n      };\n    },\n    onNewBlock: function onNewBlock(listener) {\n      var id = state.id++;\n      state.latestBlockNumber && listener(state.latestBlockNumber);\n      state.listeners.block.push({\n        listener: listener,\n        id: id\n      });\n      return {\n        unsub: function unsub() {\n          state.listeners.block = state.listeners.block.filter(function (_ref11) {\n            var _id = _ref11.id;\n            return _id !== id;\n          });\n        }\n      };\n    },\n    onPoll: function onPoll(listener) {\n      var id = state.id++;\n      state.listeners.poll.push({\n        listener: listener,\n        id: id\n      });\n      return {\n        unsub: function unsub() {\n          state.listeners.poll = state.listeners.poll.filter(function (_ref12) {\n            var _id = _ref12.id;\n            return _id !== id;\n          });\n        }\n      };\n    },\n    onError: function onError(listener) {\n      var id = state.id++;\n      state.listeners.error.push({\n        listener: listener,\n        id: id\n      });\n      return {\n        unsub: function unsub() {\n          state.listeners.error = state.listeners.error.filter(function (_ref13) {\n            var _id = _ref13.id;\n            return _id !== id;\n          });\n        }\n      };\n    },\n    start: function start() {\n      log$1('watcher.start() called');\n      state.watching = true;\n\n      if (!state.ws || state.ws.readyState === WebSocket.OPEN) {\n        _poll.call({\n          state: state,\n          interval: 0,\n          resolveFetchPromise: state.initialFetchResolver\n        });\n      }\n\n      return state.initialFetchPromise;\n    },\n    stop: function stop() {\n      log$1('watcher.stop() called');\n      clearTimeout(state.handler);\n      state.handler = null;\n      clearTimeout(state.wsReconnectHandler);\n      state.wsReconnectHandler = null;\n      state.watching = false;\n    },\n    recreate: function recreate(model, config) {\n      log$1('watcher.recreate() called');\n      clearTimeout(state.handler);\n      state.handler = null;\n      clearTimeout(state.wsReconnectHandler);\n      state.wsReconnectHandler = null;\n      if (state.ws) destroyWebSocket();\n      state.ws = null;\n      state.config = prepareConfig(config);\n      state.model = [].concat(model);\n      state.store = {};\n      state.storeTransformed = {};\n      state.latestBlockNumber = null;\n      state.cancelPromiseId = state.latestPromiseId;\n      setupWebSocket();\n\n      if (state.watching && !state.ws) {\n        var resolveFetchPromise;\n        var fetchPromise = new Promise(function (resolve) {\n          resolveFetchPromise = resolve;\n        });\n\n        _poll.call({\n          state: state,\n          interval: 0,\n          resolveFetchPromise: resolveFetchPromise\n        });\n\n        return fetchPromise;\n      }\n\n      return Promise.resolve();\n    },\n    awaitInitialFetch: function awaitInitialFetch() {\n      return state.initialFetchPromise;\n    },\n\n    get initialFetch() {\n      return state.initialFetchPromise;\n    },\n\n    get schemas() {\n      return state.model;\n    }\n\n  };\n  return watcher;\n}\n\nexport { aggregate, createWatcher };","map":null,"metadata":{},"sourceType":"module"}