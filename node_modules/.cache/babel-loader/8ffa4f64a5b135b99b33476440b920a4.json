{"ast":null,"code":"/*!\n * ecdh.js - ECDH for bcrypto\n * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Resources:\n *   https://cr.yp.to/ecdh.html\n *   https://cr.yp.to/ecdh/curve25519-20060209.pdf\n *   https://tools.ietf.org/html/rfc7748\n */\n'use strict';\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar assert = require('../internal/assert');\n\nvar elliptic = require('./elliptic');\n\nvar rng = require('../random');\n\nvar _require = require('../encoding/util'),\n    padRight = _require.padRight;\n/**\n * ECDH\n */\n\n\nvar ECDH = /*#__PURE__*/function () {\n  function ECDH(id, eid, pre) {\n    _classCallCheck(this, ECDH);\n\n    assert(typeof id === 'string');\n    assert(!eid || typeof eid === 'string');\n    this.id = id;\n    this.type = 'ecdh';\n    this.eid = eid || null;\n    this._pre = pre || null;\n    this._curve = null;\n    this._edwards = null;\n    this.native = 0;\n  }\n\n  _createClass(ECDH, [{\n    key: \"curve\",\n    get: function get() {\n      if (!this._curve) this._curve = elliptic.curve(this.id);\n      return this._curve;\n    }\n  }, {\n    key: \"edwards\",\n    get: function get() {\n      if (this.eid && !this._edwards) {\n        this._edwards = elliptic.curve(this.eid, this._pre);\n\n        this._edwards.precompute(rng);\n\n        this._pre = null;\n      }\n\n      return this._edwards;\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this.curve.fieldSize;\n    }\n  }, {\n    key: \"bits\",\n    get: function get() {\n      return this.curve.fieldBits;\n    }\n  }, {\n    key: \"privateKeyGenerate\",\n    value: function privateKeyGenerate() {\n      var key = rng.randomBytes(this.curve.scalarSize);\n      return this.curve.clamp(key);\n    }\n  }, {\n    key: \"privateKeyVerify\",\n    value: function privateKeyVerify(key) {\n      assert(Buffer.isBuffer(key));\n      return key.length === this.curve.scalarSize;\n    }\n  }, {\n    key: \"privateKeyExport\",\n    value: function privateKeyExport(key, sign) {\n      var pub = this.publicKeyCreate(key);\n\n      var _this$publicKeyExport = this.publicKeyExport(pub, sign),\n          x = _this$publicKeyExport.x,\n          y = _this$publicKeyExport.y;\n\n      return {\n        d: Buffer.from(key),\n        x: x,\n        y: y\n      };\n    }\n  }, {\n    key: \"privateKeyImport\",\n    value: function privateKeyImport(json) {\n      assert(json && typeof json === 'object');\n      return padRight(json.d, this.curve.scalarSize);\n    }\n  }, {\n    key: \"publicKeyCreate\",\n    value: function publicKeyCreate(key) {\n      var a = this.curve.decodeScalar(key);\n      var k = this.curve.reduce(a);\n\n      if (this.edwards && this.edwards.g.pre) {\n        var _A = this.edwards.g.mulBlind(k);\n\n        var P = this.curve.pointFromEdwards(_A);\n        return P.encode();\n      }\n\n      var G = this.curve.g.toX();\n      var A = G.mulBlind(k, rng);\n      return A.encode();\n    }\n  }, {\n    key: \"publicKeyConvert\",\n    value: function publicKeyConvert(key, sign) {\n      assert(sign == null || typeof sign === 'boolean');\n      if (!this.edwards) throw new Error('No equivalent edwards curve.');\n      var A = this.curve.decodePoint(key);\n      var P = this.edwards.pointFromMont(A);\n\n      if (sign != null) {\n        if (P.isOdd() !== sign) return P.neg().encode();\n      }\n\n      return P.encode();\n    }\n  }, {\n    key: \"publicKeyFromUniform\",\n    value: function publicKeyFromUniform(bytes) {\n      var u = this.curve.decodeUniform(bytes);\n      var A = this.curve.pointFromUniform(u);\n      return A.encode();\n    }\n  }, {\n    key: \"publicKeyToUniform\",\n    value: function publicKeyToUniform(key) {\n      var hint = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : rng.randomInt();\n      var A = this.curve.decodePoint(key);\n      var u = this.curve.pointToUniform(A, hint);\n      return this.curve.encodeUniform(u, hint >>> 8);\n    }\n  }, {\n    key: \"publicKeyFromHash\",\n    value: function publicKeyFromHash(bytes) {\n      var pake = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var A = this.curve.pointFromHash(bytes, pake);\n      return A.encode();\n    }\n  }, {\n    key: \"publicKeyToHash\",\n    value: function publicKeyToHash(key) {\n      var subgroup = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : rng.randomInt();\n      var A = this.curve.decodePoint(key);\n      return this.curve.pointToHash(A, subgroup, rng);\n    }\n  }, {\n    key: \"publicKeyVerify\",\n    value: function publicKeyVerify(key) {\n      assert(Buffer.isBuffer(key));\n      var A;\n\n      try {\n        A = this.curve.decodeX(key);\n      } catch (e) {\n        return false;\n      }\n\n      return A.validate();\n    }\n  }, {\n    key: \"publicKeyIsSmall\",\n    value: function publicKeyIsSmall(key) {\n      assert(Buffer.isBuffer(key));\n      var A;\n\n      try {\n        A = this.curve.decodeX(key);\n      } catch (e) {\n        return false;\n      }\n\n      if (!A.validate()) return false;\n      return A.isSmall();\n    }\n  }, {\n    key: \"publicKeyHasTorsion\",\n    value: function publicKeyHasTorsion(key) {\n      assert(Buffer.isBuffer(key));\n      var A;\n\n      try {\n        A = this.curve.decodeX(key);\n      } catch (e) {\n        return false;\n      }\n\n      if (!A.validate()) return false;\n      return A.hasTorsion();\n    }\n  }, {\n    key: \"publicKeyExport\",\n    value: function publicKeyExport(key, sign) {\n      var _this$curve$decodePoi = this.curve.decodePoint(key, sign),\n          x = _this$curve$decodePoi.x,\n          y = _this$curve$decodePoi.y;\n\n      return {\n        x: this.curve.encodeField(x.fromRed()),\n        y: this.curve.encodeField(y.fromRed())\n      };\n    }\n  }, {\n    key: \"publicKeyImport\",\n    value: function publicKeyImport(json) {\n      assert(json && typeof json === 'object');\n      var x = padRight(json.x, this.curve.fieldSize);\n      var A = this.curve.decodeX(x);\n      if (!A.validate()) throw new Error('Invalid point.');\n      return A.encode();\n    }\n  }, {\n    key: \"derive\",\n    value: function derive(pub, priv) {\n      var A = this.curve.decodeX(pub);\n      var a = this.curve.decodeScalar(priv);\n      var k = this.curve.reduce(a);\n      var P = A.mulConst(k, rng);\n      return P.encode();\n    }\n  }]);\n\n  return ECDH;\n}();\n/*\n * Expose\n */\n\n\nmodule.exports = ECDH;","map":null,"metadata":{},"sourceType":"script"}