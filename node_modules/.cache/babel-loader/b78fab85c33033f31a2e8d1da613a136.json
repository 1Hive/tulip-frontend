{"ast":null,"code":"'use strict';\n\nconst pipe = require('it-pipe');\n\nconst lp = require('it-length-prefixed');\n\nconst PeerInfo = require('peer-info');\n\nconst Message = require('../message');\n\nconst handlers = require('./handlers');\n\nconst utils = require('../utils');\n\nmodule.exports = dht => {\n  const log = utils.logger(dht.peerInfo.id, 'rpc');\n  const getMessageHandler = handlers(dht);\n  /**\n   * Process incoming DHT messages.\n   * @param {PeerInfo} peer\n   * @param {Message} msg\n   * @returns {Promise<Message>}\n   *\n   * @private\n   */\n\n  async function handleMessage(peer, msg) {\n    // get handler & execute it\n    const handler = getMessageHandler(msg.type);\n\n    try {\n      await dht._add(peer);\n    } catch (err) {\n      log.error('Failed to update the kbucket store', err);\n    }\n\n    if (!handler) {\n      log.error(`no handler found for message type: ${msg.type}`);\n      return;\n    }\n\n    return handler(peer, msg);\n  }\n  /**\n   * Handle incoming streams on the dht protocol.\n   * @param {Object} props\n   * @param {DuplexStream} props.stream\n   * @param {Connection} props.connection connection\n   * @returns {Promise<void>}\n   */\n\n\n  return async function onIncomingStream({\n    stream,\n    connection\n  }) {\n    const peerInfo = await PeerInfo.create(connection.remotePeer);\n\n    try {\n      await dht._add(peerInfo);\n    } catch (err) {\n      log.error(err);\n    }\n\n    const idB58Str = peerInfo.id.toB58String();\n    log('from: %s', idB58Str);\n    await pipe(stream.source, lp.decode(), source => async function* () {\n      for await (const msg of source) {\n        // handle the message\n        const desMessage = Message.deserialize(msg.slice());\n        const res = await handleMessage(peerInfo, desMessage); // Not all handlers will return a response\n\n        if (res) {\n          yield res.serialize();\n        }\n      }\n    }(), lp.encode(), stream.sink);\n  };\n};","map":null,"metadata":{},"sourceType":"script"}