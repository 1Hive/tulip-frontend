{"ast":null,"code":"const pageResults = require('graph-results-pager');\n\nconst ws = require('isomorphic-ws');\n\nconst {\n  SubscriptionClient\n} = require('subscriptions-transport-ws');\n\nconst {\n  request,\n  gql\n} = require('graphql-request');\n\nconst {\n  graphAPIEndpoints,\n  graphWSEndpoints\n} = require('../constants');\n\nconst {\n  timestampToBlock\n} = require('../utils');\n\nmodule.exports = {\n  userHistory({\n    minTimestamp = undefined,\n    maxTimestamp = undefined,\n    minBlock = undefined,\n    maxBlock = undefined,\n    user_address = undefined,\n    max = undefined\n  } = {}) {\n    if (!user_address) {\n      throw new Error(\"sushi-data: User address undefined\");\n    }\n\n    return pageResults({\n      api: graphAPIEndpoints.exchange_v1,\n      query: {\n        entity: 'liquidityPositionSnapshots',\n        selection: {\n          where: {\n            user: `\\\\\"${user_address.toLowerCase()}\\\\\"`,\n            block_gte: minBlock || undefined,\n            block_lte: maxBlock || undefined,\n            timestamp_gte: minTimestamp || undefined,\n            timestamp_lte: maxTimestamp || undefined\n          }\n        },\n        properties: userHistory.properties\n      },\n      max\n    }).then(results => userHistory.callback(results)).catch(err => console.log(err));\n  },\n\n  async userPositions({\n    block = undefined,\n    timestamp = undefined,\n    user_address = undefined\n  } = {}) {\n    if (!user_address) {\n      throw new Error(\"sushi-data: User address undefined\");\n    }\n\n    return pageResults({\n      api: graphAPIEndpoints.exchange_v1,\n      query: {\n        entity: 'liquidityPositions',\n        selection: {\n          where: {\n            user: `\\\\\"${user_address.toLowerCase()}\\\\\"`\n          },\n          block: block ? {\n            number: block\n          } : timestamp ? {\n            number: await timestampToBlock(timestamp)\n          } : undefined\n        },\n        properties: userPositions.properties\n      }\n    }).then(results => userPositions.callback(results)).catch(err => console.log(err));\n  }\n\n};\nconst userHistory = {\n  properties: ['id', 'timestamp', 'block', 'pair { id, reserve0, reserve1, reserveUSD, token0 { id }, token1 { id } }', 'token0PriceUSD', 'token1PriceUSD', 'reserve0', 'reserve1', 'reserveUSD', 'liquidityTokenTotalSupply', 'liquidityTokenBalance'],\n\n  callback(results) {\n    return results.map(entry => ({\n      id: entry.id,\n      timestamp: Number(entry.timestamp),\n      block: Number(entry.block),\n      pair: {\n        id: entry.pair.id,\n        reserve0: Number(entry.pair.reserve0),\n        reserve1: Number(entry.pair.reserve1),\n        reserveUSD: Number(entry.pair.reserveUSD),\n        token0: {\n          id: entry.pair.token0.id\n        },\n        token1: {\n          id: entry.pair.token1.id\n        }\n      },\n      token0PriceUSD: Number(entry.token0PriceUSD),\n      token1PriceUSD: Number(entry.token1PriceUSD),\n      reserve0: Number(entry.reserve0),\n      reserve1: Number(entry.reserve1),\n      reserveUSD: Number(entry.reserveUSD),\n      liquidityTokenTotalSupply: Number(entry.liquidityTokenTotalSupply),\n      liquidityTokenBalance: Number(entry.liquidityTokenBalance)\n    }));\n  }\n\n};\nconst userPositions = {\n  properties: ['id', 'pair { id, reserve0, reserve1, reserveUSD, token0 { id, symbol, derivedETH }, token1 { id, symbol, derivedETH }, totalSupply }', 'liquidityTokenBalance'],\n\n  callback(results) {\n    return results.map(entry => ({\n      id: entry.id,\n      pair: {\n        id: entry.pair.id,\n        reserve0: Number(entry.pair.reserve0),\n        reserve1: Number(entry.pair.reserve1),\n        reserveUSD: Number(entry.pair.reserveUSD),\n        token0: {\n          id: entry.pair.token0.id,\n          symbol: entry.pair.token0.symbol,\n          derivedETH: Number(entry.pair.token0.derivedETH)\n        },\n        token1: {\n          id: entry.pair.token1.id,\n          symbol: entry.pair.token1.symbol,\n          derivedETH: Number(entry.pair.token1.derivedETH)\n        },\n        totalSupply: Number(entry.pair.totalSupply)\n      },\n      liquidityTokenBalance: Number(entry.liquidityTokenBalance)\n    }));\n  }\n\n};","map":null,"metadata":{},"sourceType":"script"}