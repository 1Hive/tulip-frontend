{"ast":null,"code":"'use strict';\n\nconst {\n  sortBy\n} = require('../../utils');\n\nconst Entry = require('./entry');\n\nclass Wantlist {\n  constructor(stats) {\n    this.set = new Map();\n    this._stats = stats;\n  }\n\n  get length() {\n    return this.set.size;\n  }\n\n  add(cid, priority, wantType) {\n    // Have to import here to avoid circular reference\n    const Message = require('../message');\n\n    const cidStr = cid.toString('base58btc');\n    const entry = this.set.get(cidStr);\n\n    if (entry) {\n      entry.inc();\n      entry.priority = priority; // We can only overwrite want-have with want-block\n\n      if (entry.wantType === Message.WantType.Have && wantType === Message.WantType.Block) {\n        entry.wantType = wantType;\n      }\n    } else {\n      this.set.set(cidStr, new Entry(cid, priority, wantType));\n\n      if (this._stats) {\n        this._stats.push(null, 'wantListSize', 1);\n      }\n    }\n  }\n\n  remove(cid) {\n    const cidStr = cid.toString('base58btc');\n    const entry = this.set.get(cidStr);\n\n    if (!entry) {\n      return;\n    }\n\n    entry.dec(); // only delete when no refs are held\n\n    if (entry.hasRefs()) {\n      return;\n    }\n\n    this.set.delete(cidStr);\n\n    if (this._stats) {\n      this._stats.push(null, 'wantListSize', -1);\n    }\n  }\n\n  removeForce(cidStr) {\n    if (this.set.has(cidStr)) {\n      this.set.delete(cidStr);\n    }\n  }\n\n  forEach(fn) {\n    return this.set.forEach(fn);\n  }\n\n  entries() {\n    return this.set.entries();\n  }\n\n  sortedEntries() {\n    return new Map(sortBy(o => o[1].key, Array.from(this.set.entries())));\n  }\n\n  contains(cid) {\n    const cidStr = cid.toString('base58btc');\n    return this.set.get(cidStr);\n  }\n\n}\n\nWantlist.Entry = Entry;\nmodule.exports = Wantlist;","map":null,"metadata":{},"sourceType":"script"}