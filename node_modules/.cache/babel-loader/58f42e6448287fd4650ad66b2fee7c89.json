{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _toArray = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toArray\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _asyncIterator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar isIpfs = require('is-ipfs');\n\nvar CID = require('cids');\n\nvar _require = require('../../utils/cid'),\n    cidToString = _require.cidToString;\n\nvar _require2 = require('../utils'),\n    withTimeoutOption = _require2.withTimeoutOption;\n/**\n * @typedef {Object} ResolveOptions\n * @prop {string} cidBase - Multibase codec name the CID in the resolved path will be encoded with\n * @prop {boolean} [recursive=true] - Resolve until the result is an IPFS name\n *\n */\n\n/** @typedef {(path: string, options?: ResolveOptions) => Promise<string>} Resolve */\n\n/**\n * IPFS Resolve factory\n *\n * @param {Object} config\n * @param {IPLD} config.ipld - An instance of IPLD\n * @param {NameApi} [config.name] - An IPFS core interface name API\n * @returns {Resolve}\n */\n\n\nmodule.exports = function (_ref) {\n  var ipld = _ref.ipld,\n      name = _ref.name;\n  return withTimeoutOption( /*#__PURE__*/function () {\n    var _resolve = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(path, opts) {\n      var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, resolvedPath, _path$split, _path$split2, hash, rest, cid, results, value, remainderPath, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _value2, result;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              opts = opts || {};\n\n              if (isIpfs.path(path)) {\n                _context.next = 3;\n                break;\n              }\n\n              throw new Error('invalid argument ' + path);\n\n            case 3:\n              if (!isIpfs.ipnsPath(path)) {\n                _context.next = 39;\n                break;\n              }\n\n              if (name) {\n                _context.next = 6;\n                break;\n              }\n\n              throw new Error('failed to resolve IPNS path: name API unavailable');\n\n            case 6:\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _context.prev = 8;\n              _iterator = _asyncIterator(name.resolve(path, opts));\n\n            case 10:\n              _context.next = 12;\n              return _iterator.next();\n\n            case 12:\n              _step = _context.sent;\n              _iteratorNormalCompletion = _step.done;\n              _context.next = 16;\n              return _step.value;\n\n            case 16:\n              _value = _context.sent;\n\n              if (_iteratorNormalCompletion) {\n                _context.next = 23;\n                break;\n              }\n\n              resolvedPath = _value;\n              path = resolvedPath;\n\n            case 20:\n              _iteratorNormalCompletion = true;\n              _context.next = 10;\n              break;\n\n            case 23:\n              _context.next = 29;\n              break;\n\n            case 25:\n              _context.prev = 25;\n              _context.t0 = _context[\"catch\"](8);\n              _didIteratorError = true;\n              _iteratorError = _context.t0;\n\n            case 29:\n              _context.prev = 29;\n              _context.prev = 30;\n\n              if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                _context.next = 34;\n                break;\n              }\n\n              _context.next = 34;\n              return _iterator.return();\n\n            case 34:\n              _context.prev = 34;\n\n              if (!_didIteratorError) {\n                _context.next = 37;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 37:\n              return _context.finish(34);\n\n            case 38:\n              return _context.finish(29);\n\n            case 39:\n              _path$split = path.split('/'), _path$split2 = _toArray(_path$split), hash = _path$split2[2], rest = _path$split2.slice(3); // ['', 'ipfs', 'hash', ...path]\n\n              cid = new CID(hash); // nothing to resolve return the input\n\n              if (!(rest.length === 0)) {\n                _context.next = 43;\n                break;\n              }\n\n              return _context.abrupt(\"return\", \"/ipfs/\".concat(cidToString(cid, {\n                base: opts.cidBase\n              })));\n\n            case 43:\n              path = rest.join('/');\n              results = ipld.resolve(cid, path);\n              value = cid;\n              remainderPath = path;\n              _iteratorNormalCompletion2 = true;\n              _didIteratorError2 = false;\n              _context.prev = 49;\n              _iterator2 = _asyncIterator(results);\n\n            case 51:\n              _context.next = 53;\n              return _iterator2.next();\n\n            case 53:\n              _step2 = _context.sent;\n              _iteratorNormalCompletion2 = _step2.done;\n              _context.next = 57;\n              return _step2.value;\n\n            case 57:\n              _value2 = _context.sent;\n\n              if (_iteratorNormalCompletion2) {\n                _context.next = 64;\n                break;\n              }\n\n              result = _value2;\n\n              if (CID.isCID(result.value)) {\n                value = result.value;\n                remainderPath = result.remainderPath;\n              }\n\n            case 61:\n              _iteratorNormalCompletion2 = true;\n              _context.next = 51;\n              break;\n\n            case 64:\n              _context.next = 70;\n              break;\n\n            case 66:\n              _context.prev = 66;\n              _context.t1 = _context[\"catch\"](49);\n              _didIteratorError2 = true;\n              _iteratorError2 = _context.t1;\n\n            case 70:\n              _context.prev = 70;\n              _context.prev = 71;\n\n              if (!(!_iteratorNormalCompletion2 && _iterator2.return != null)) {\n                _context.next = 75;\n                break;\n              }\n\n              _context.next = 75;\n              return _iterator2.return();\n\n            case 75:\n              _context.prev = 75;\n\n              if (!_didIteratorError2) {\n                _context.next = 78;\n                break;\n              }\n\n              throw _iteratorError2;\n\n            case 78:\n              return _context.finish(75);\n\n            case 79:\n              return _context.finish(70);\n\n            case 80:\n              return _context.abrupt(\"return\", \"/ipfs/\".concat(cidToString(value, {\n                base: opts.cidBase\n              })).concat(remainderPath ? '/' + remainderPath : ''));\n\n            case 81:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[8, 25, 29, 39], [30,, 34, 38], [49, 66, 70, 80], [71,, 75, 79]]);\n    }));\n\n    function resolve(_x, _x2) {\n      return _resolve.apply(this, arguments);\n    }\n\n    return resolve;\n  }());\n};","map":null,"metadata":{},"sourceType":"script"}