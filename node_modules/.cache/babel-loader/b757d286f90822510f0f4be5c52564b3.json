{"ast":null,"code":"import { _ as _slicedToArray } from './slicedToArray-ad07b557.js';\nimport './unsupportedIterableToArray-aef68344.js';\nimport { useState, useEffect, useMemo } from 'react';\nvar A_DAY = 1000 * 60 * 60 * 24;\n\nfunction cachedMap() {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref$expireAfter = _ref.expireAfter,\n      expireAfter = _ref$expireAfter === void 0 ? A_DAY : _ref$expireAfter,\n      _ref$size = _ref.size,\n      size = _ref$size === void 0 ? 100 : _ref$size;\n\n  var cache = new Map(); // Delete the first (oldest) entry if we are above `size`. `cache.size`\n  // should never be greater than `size + 1`, so no need for a loop here.\n\n  function trim() {\n    if (cache.size > size) {\n      cache.delete(cache.keys().next().value);\n    }\n  } // We are using delete() then set() to reset the position everytime the\n  // access is refreshed. That way, the oldest entry is always at the first\n  // position and we donâ€™t need to iterate over the entire cache to find it.\n\n\n  function update(key, value, lastAccess) {\n    cache.delete(key);\n    cache.set(key, {\n      value: value,\n      lastAccess: lastAccess\n    });\n    trim();\n  }\n\n  function get(key) {\n    var now = new Date();\n    var cachedEntry = cache.get(key);\n\n    if (!cachedEntry) {\n      return null;\n    } // Expired: delete the entry\n\n\n    if (now - cachedEntry.lastAccess > expireAfter) {\n      cache.delete(key);\n      return null;\n    }\n\n    update(key, cachedEntry.value, now);\n    return cachedEntry.value;\n  }\n\n  function set(key, value) {\n    update(key, value, new Date());\n  }\n\n  return {\n    clear: function clear() {\n      return cache.clear();\n    },\n    delete: function _delete(key) {\n      return cache.delete(key);\n    },\n    get: get,\n    set: set\n  };\n}\n\nvar srcCache = cachedMap(); // Check if a remote image exists and can be loaded within a specific amount of time.\n\nfunction useImageExists(src) {\n  var timeUntilFallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 50;\n\n  var _useState = useState(false),\n      _useState2 = _slicedToArray(_useState, 2),\n      exists = _useState2[0],\n      setExists = _useState2[1];\n\n  var _useState3 = useState(true),\n      _useState4 = _slicedToArray(_useState3, 2),\n      loading = _useState4[0],\n      setLoading = _useState4[1];\n\n  var _useState5 = useState(false),\n      _useState6 = _slicedToArray(_useState5, 2),\n      displayFallback = _useState6[0],\n      setDisplayFallback = _useState6[1];\n\n  useEffect(function () {\n    var image = new Image();\n    var fallbackTimer = setTimeout(function () {\n      return setDisplayFallback(true);\n    }, timeUntilFallback);\n\n    var init = function init() {\n      if (!src) {\n        setExists(false);\n        setLoading(false);\n        return;\n      }\n\n      if (srcCache.get(src)) {\n        success();\n        return;\n      }\n\n      setExists(false);\n      setLoading(true); // TODO: ensure only one image is loading at a time for a given src.\n\n      image.addEventListener('load', success);\n      image.src = src;\n    };\n\n    var success = function success() {\n      setLoading(false);\n      setExists(true);\n      srcCache.set(src, true);\n      done();\n    };\n\n    var done = function done() {\n      clearTimeout(fallbackTimer);\n\n      if (image) {\n        image.removeEventListener('load', success);\n        image = null;\n      }\n    };\n\n    init();\n    return done;\n  }, [src, timeUntilFallback]);\n  return useMemo(function () {\n    return {\n      src: src,\n      displayFallback: displayFallback,\n      exists: exists,\n      loading: loading\n    };\n  }, [src, displayFallback, exists, loading]);\n} // render prop\n\n\nvar ImageExists = function ImageExists(_ref) {\n  var timeUntilFallback = _ref.timeUntilFallback,\n      src = _ref.src,\n      children = _ref.children;\n  return children(useImageExists(src, timeUntilFallback));\n};\n\nexport { ImageExists, useImageExists };","map":null,"metadata":{},"sourceType":"module"}