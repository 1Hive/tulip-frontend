{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _awaitAsyncGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _wrapAsyncGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar errCode = require('err-code');\n\nvar _require = require('./errors'),\n    messages = _require.messages,\n    codes = _require.codes;\n\nvar all = require('it-all');\n\nvar pAny = require('p-any');\n\nmodule.exports = function (node) {\n  var routers = node._modules.contentRouting || [];\n  var dht = node._dht; // If we have the dht, make it first\n\n  if (dht) {\n    routers.unshift(dht);\n  }\n\n  return {\n    /**\n     * Iterates over all content routers in series to find providers of the given key.\n     * Once a content router succeeds, iteration will stop.\n     *\n     * @param {CID} key The CID key of the content to find\n     * @param {object} [options]\n     * @param {number} [options.timeout] How long the query should run\n     * @param {number} [options.maxNumProviders] - maximum number of providers to find\n     * @returns {AsyncIterable<PeerInfo>}\n     */\n    findProviders: function findProviders(key, options) {\n      return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var result, _iterator, _step, pInfo;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (routers.length) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                throw errCode(new Error('No content routers available'), 'NO_ROUTERS_AVAILABLE');\n\n              case 2:\n                _context2.next = 4;\n                return _awaitAsyncGenerator(pAny(routers.map( /*#__PURE__*/function () {\n                  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(router) {\n                    var provs;\n                    return _regeneratorRuntime.wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            _context.next = 2;\n                            return all(router.findProviders(key, options));\n\n                          case 2:\n                            provs = _context.sent;\n\n                            if (!(!provs || !provs.length)) {\n                              _context.next = 5;\n                              break;\n                            }\n\n                            throw errCode(new Error('not found'), 'NOT_FOUND');\n\n                          case 5:\n                            return _context.abrupt(\"return\", provs);\n\n                          case 6:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee);\n                  }));\n\n                  return function (_x) {\n                    return _ref.apply(this, arguments);\n                  };\n                }())));\n\n              case 4:\n                result = _context2.sent;\n                _iterator = _createForOfIteratorHelper(result);\n                _context2.prev = 6;\n\n                _iterator.s();\n\n              case 8:\n                if ((_step = _iterator.n()).done) {\n                  _context2.next = 14;\n                  break;\n                }\n\n                pInfo = _step.value;\n                _context2.next = 12;\n                return pInfo;\n\n              case 12:\n                _context2.next = 8;\n                break;\n\n              case 14:\n                _context2.next = 19;\n                break;\n\n              case 16:\n                _context2.prev = 16;\n                _context2.t0 = _context2[\"catch\"](6);\n\n                _iterator.e(_context2.t0);\n\n              case 19:\n                _context2.prev = 19;\n\n                _iterator.f();\n\n                return _context2.finish(19);\n\n              case 22:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, null, [[6, 16, 19, 22]]);\n      }))();\n    },\n\n    /**\n     * Iterates over all content routers in parallel to notify it is\n     * a provider of the given key.\n     *\n     * @param {CID} key The CID key of the content to find\n     * @returns {Promise<void>}\n     */\n    provide: function provide(key) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (routers.length) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                throw errCode(new Error('No content routers available'), 'NO_ROUTERS_AVAILABLE');\n\n              case 2:\n                return _context3.abrupt(\"return\", Promise.all(routers.map(function (router) {\n                  return router.provide(key);\n                })));\n\n              case 3:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }))();\n    },\n\n    /**\n     * Store the given key/value pair in the DHT.\n     * @param {Buffer} key\n     * @param {Buffer} value\n     * @param {Object} [options] - put options\n     * @param {number} [options.minPeers] - minimum number of peers required to successfully put\n     * @returns {Promise<void>}\n     */\n    put: function put(key, value, options) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!(!node.isStarted() || !dht.isStarted)) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);\n\n              case 2:\n                return _context4.abrupt(\"return\", dht.put(key, value, options));\n\n              case 3:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }))();\n    },\n\n    /**\n     * Get the value to the given key.\n     * Times out after 1 minute by default.\n     * @param {Buffer} key\n     * @param {Object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout (default: 60000)\n     * @returns {Promise<{from: PeerId, val: Buffer}>}\n     */\n    get: function get(key, options) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (!(!node.isStarted() || !dht.isStarted)) {\n                  _context5.next = 2;\n                  break;\n                }\n\n                throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);\n\n              case 2:\n                return _context5.abrupt(\"return\", dht.get(key, options));\n\n              case 3:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }))();\n    },\n\n    /**\n     * Get the `n` values to the given key without sorting.\n     * @param {Buffer} key\n     * @param {number} nVals\n     * @param {Object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout (default: 60000)\n     * @returns {Promise<Array<{from: PeerId, val: Buffer}>>}\n     */\n    getMany: function getMany(key, nVals, options) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (!(!node.isStarted() || !dht.isStarted)) {\n                  _context6.next = 2;\n                  break;\n                }\n\n                throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);\n\n              case 2:\n                return _context6.abrupt(\"return\", dht.getMany(key, nVals, options));\n\n              case 3:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6);\n      }))();\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"script"}