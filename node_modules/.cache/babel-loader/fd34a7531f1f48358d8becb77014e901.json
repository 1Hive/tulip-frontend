{"ast":null,"code":"'use strict';\n\nconst Store = require('orbit-db-store');\n\nconst DocumentIndex = require('./DocumentIndex');\n\nconst pMap = require('p-map');\n\nconst Readable = require('readable-stream');\n\nconst replaceAll = (str, search, replacement) => str.toString().split(search).join(replacement);\n\nclass DocumentStore extends Store {\n  constructor(ipfs, id, dbname, options) {\n    if (!options) options = {};\n    if (!options.indexBy) Object.assign(options, {\n      indexBy: '_id'\n    });\n    if (!options.Index) Object.assign(options, {\n      Index: DocumentIndex\n    });\n    super(ipfs, id, dbname, options);\n    this._type = 'docstore';\n  }\n\n  get(key, caseSensitive = false) {\n    key = key.toString();\n    const terms = key.split(' ');\n    key = terms.length > 1 ? replaceAll(key, '.', ' ').toLowerCase() : key.toLowerCase();\n\n    const search = e => {\n      if (terms.length > 1) {\n        return replaceAll(e, '.', ' ').toLowerCase().indexOf(key) !== -1;\n      }\n\n      return e.toLowerCase().indexOf(key) !== -1;\n    };\n\n    const mapper = e => this._index.get(e);\n\n    const filter = e => caseSensitive ? e.indexOf(key) !== -1 : search(e);\n\n    return Object.keys(this._index._index).filter(filter).map(mapper);\n  }\n\n  query(mapper, options = {}) {\n    // Whether we return the full operation data or just the db value\n    const fullOp = options.fullOp || false;\n    return Object.keys(this._index._index).map(e => this._index.get(e, fullOp)).filter(mapper);\n  }\n\n  batchPut(docs, onProgressCallback) {\n    const mapper = (doc, idx) => {\n      return this._addOperationBatch({\n        op: 'PUT',\n        key: doc[this.options.indexBy],\n        value: doc\n      }, true, idx === docs.length - 1, onProgressCallback);\n    };\n\n    return pMap(docs, mapper, {\n      concurrency: 1\n    }).then(() => this.saveSnapshot());\n  }\n\n  put(doc, options = {}) {\n    if (!doc[this.options.indexBy]) {\n      throw new Error(`The provided document doesn't contain field '${this.options.indexBy}'`);\n    }\n\n    return this._addOperation({\n      op: 'PUT',\n      key: doc[this.options.indexBy],\n      value: doc\n    }, options);\n  }\n\n  putAll(docs, options = {}) {\n    if (!Array.isArray(docs)) {\n      docs = [docs];\n    }\n\n    if (!docs.every(d => d[this.options.indexBy])) {\n      throw new Error(`The provided document doesn't contain field '${this.options.indexBy}'`);\n    }\n\n    return this._addOperation({\n      op: 'PUTALL',\n      docs: docs.map(value => ({\n        key: value[this.options.indexBy],\n        value\n      }))\n    }, options);\n  }\n\n  del(key, options = {}) {\n    if (!this._index.get(key)) {\n      throw new Error(`No entry with key '${key}' in the database`);\n    }\n\n    return this._addOperation({\n      op: 'DEL',\n      key: key,\n      value: null\n    }, options);\n  }\n\n}\n\nmodule.exports = DocumentStore;","map":null,"metadata":{},"sourceType":"script"}