{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar path = require('path');\n\nvar EventStore = require('orbit-db-eventstore');\n\nvar FeedStore = require('orbit-db-feedstore');\n\nvar KeyValueStore = require('orbit-db-kvstore');\n\nvar CounterStore = require('orbit-db-counterstore');\n\nvar DocumentStore = require('orbit-db-docstore');\n\nvar Pubsub = require('orbit-db-pubsub');\n\nvar Cache = require('orbit-db-cache');\n\nvar Keystore = require('orbit-db-keystore');\n\nvar Identities = require('orbit-db-identity-provider');\n\nvar AccessControllers = require('orbit-db-access-controllers');\n\nvar OrbitDBAddress = require('./orbit-db-address');\n\nvar createDBManifest = require('./db-manifest');\n\nvar exchangeHeads = require('./exchange-heads');\n\nvar _require = require('./utils'),\n    isDefined = _require.isDefined,\n    io = _require.io;\n\nvar Storage = require('orbit-db-storage-adapter');\n\nvar migrations = require('./migrations');\n\nvar Logger = require('logplease');\n\nvar logger = Logger.create('orbit-db');\nLogger.setLogLevel('ERROR'); // Mapping for 'database type' -> Class\n\nvar databaseTypes = {\n  counter: CounterStore,\n  eventlog: EventStore,\n  feed: FeedStore,\n  docstore: DocumentStore,\n  keyvalue: KeyValueStore\n};\n\nvar OrbitDB = /*#__PURE__*/function () {\n  function OrbitDB(ipfs, identity) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, OrbitDB);\n\n    if (!isDefined(ipfs)) {\n      throw new Error('IPFS is a required argument. See https://github.com/orbitdb/orbit-db/blob/master/API.md#createinstance');\n    }\n\n    if (!isDefined(identity)) {\n      throw new Error('identity is a required argument. See https://github.com/orbitdb/orbit-db/blob/master/API.md#createinstance');\n    }\n\n    this._ipfs = ipfs;\n    this.identity = identity;\n    this.id = options.peerId;\n    this._pubsub = !options.offline ? options.broker ? new options.broker(this._ipfs) // eslint-disable-line\n    : new Pubsub(this._ipfs, this.id) : null;\n    this.directory = options.directory || './orbitdb';\n    this.storage = options.storage;\n    this._directConnections = {};\n    this.caches = {};\n    this.caches[this.directory] = {\n      cache: options.cache,\n      handlers: new Set()\n    };\n    this.keystore = options.keystore;\n    this.stores = {}; // AccessControllers module can be passed in to enable\n    // testing with orbit-db-access-controller\n\n    AccessControllers = options.AccessControllers || AccessControllers;\n  }\n\n  _createClass(OrbitDB, [{\n    key: \"cache\",\n    get: function get() {\n      return this.caches[this.directory].cache;\n    }\n  }, {\n    key: \"feed\",\n    value:\n    /* Databases */\n    function () {\n      var _feed = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(address) {\n        var options,\n            _args = arguments;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n                options = Object.assign({\n                  create: true,\n                  type: 'feed'\n                }, options);\n                return _context.abrupt(\"return\", this.open(address, options));\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function feed(_x) {\n        return _feed.apply(this, arguments);\n      }\n\n      return feed;\n    }()\n  }, {\n    key: \"log\",\n    value: function () {\n      var _log = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(address) {\n        var options,\n            _args2 = arguments;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};\n                options = Object.assign({\n                  create: true,\n                  type: 'eventlog'\n                }, options);\n                return _context2.abrupt(\"return\", this.open(address, options));\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function log(_x2) {\n        return _log.apply(this, arguments);\n      }\n\n      return log;\n    }()\n  }, {\n    key: \"eventlog\",\n    value: function () {\n      var _eventlog = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(address) {\n        var options,\n            _args3 = arguments;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                options = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};\n                return _context3.abrupt(\"return\", this.log(address, options));\n\n              case 2:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function eventlog(_x3) {\n        return _eventlog.apply(this, arguments);\n      }\n\n      return eventlog;\n    }()\n  }, {\n    key: \"keyvalue\",\n    value: function () {\n      var _keyvalue = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(address) {\n        var options,\n            _args4 = arguments;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                options = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};\n                options = Object.assign({\n                  create: true,\n                  type: 'keyvalue'\n                }, options);\n                return _context4.abrupt(\"return\", this.open(address, options));\n\n              case 3:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function keyvalue(_x4) {\n        return _keyvalue.apply(this, arguments);\n      }\n\n      return keyvalue;\n    }()\n  }, {\n    key: \"kvstore\",\n    value: function () {\n      var _kvstore = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(address) {\n        var options,\n            _args5 = arguments;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                options = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : {};\n                return _context5.abrupt(\"return\", this.keyvalue(address, options));\n\n              case 2:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function kvstore(_x5) {\n        return _kvstore.apply(this, arguments);\n      }\n\n      return kvstore;\n    }()\n  }, {\n    key: \"counter\",\n    value: function () {\n      var _counter = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(address) {\n        var options,\n            _args6 = arguments;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                options = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : {};\n                options = Object.assign({\n                  create: true,\n                  type: 'counter'\n                }, options);\n                return _context6.abrupt(\"return\", this.open(address, options));\n\n              case 3:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function counter(_x6) {\n        return _counter.apply(this, arguments);\n      }\n\n      return counter;\n    }()\n  }, {\n    key: \"docs\",\n    value: function () {\n      var _docs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(address) {\n        var options,\n            _args7 = arguments;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                options = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : {};\n                options = Object.assign({\n                  create: true,\n                  type: 'docstore'\n                }, options);\n                return _context7.abrupt(\"return\", this.open(address, options));\n\n              case 3:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function docs(_x7) {\n        return _docs.apply(this, arguments);\n      }\n\n      return docs;\n    }()\n  }, {\n    key: \"docstore\",\n    value: function () {\n      var _docstore = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(address) {\n        var options,\n            _args8 = arguments;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                options = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : {};\n                return _context8.abrupt(\"return\", this.docs(address, options));\n\n              case 2:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function docstore(_x8) {\n        return _docstore.apply(this, arguments);\n      }\n\n      return docstore;\n    }()\n  }, {\n    key: \"disconnect\",\n    value: function () {\n      var _disconnect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n        var _this = this;\n\n        var databases, _i, _databases, db, caches, _i2, _caches, directory, removeDirectConnect;\n\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.next = 2;\n                return this.keystore.close();\n\n              case 2:\n                // Close all open databases\n                databases = Object.values(this.stores);\n                _i = 0, _databases = databases;\n\n              case 4:\n                if (!(_i < _databases.length)) {\n                  _context9.next = 12;\n                  break;\n                }\n\n                db = _databases[_i];\n                _context9.next = 8;\n                return db.close();\n\n              case 8:\n                delete this.stores[db.address.toString()];\n\n              case 9:\n                _i++;\n                _context9.next = 4;\n                break;\n\n              case 12:\n                caches = Object.keys(this.caches);\n                _i2 = 0, _caches = caches;\n\n              case 14:\n                if (!(_i2 < _caches.length)) {\n                  _context9.next = 22;\n                  break;\n                }\n\n                directory = _caches[_i2];\n                _context9.next = 18;\n                return this.caches[directory].cache.close();\n\n              case 18:\n                delete this.caches[directory];\n\n              case 19:\n                _i2++;\n                _context9.next = 14;\n                break;\n\n              case 22:\n                // Close a direct connection and remove it from internal state\n                removeDirectConnect = function removeDirectConnect(e) {\n                  _this._directConnections[e].close();\n\n                  delete _this._directConnections[e];\n                }; // Close all direct connections to peers\n\n\n                Object.keys(this._directConnections).forEach(removeDirectConnect); // Disconnect from pubsub\n\n                if (!this._pubsub) {\n                  _context9.next = 27;\n                  break;\n                }\n\n                _context9.next = 27;\n                return this._pubsub.disconnect();\n\n              case 27:\n                // Remove all databases from the state\n                this.stores = {};\n\n              case 28:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function disconnect() {\n        return _disconnect.apply(this, arguments);\n      }\n\n      return disconnect;\n    }() // Alias for disconnect()\n\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _context10.next = 2;\n                return this.disconnect();\n\n              case 2:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function stop() {\n        return _stop.apply(this, arguments);\n      }\n\n      return stop;\n    }()\n  }, {\n    key: \"_createCache\",\n    value: function () {\n      var _createCache2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(path) {\n        var cacheStorage;\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                _context11.next = 2;\n                return this.storage.createStore(path);\n\n              case 2:\n                cacheStorage = _context11.sent;\n                return _context11.abrupt(\"return\", new Cache(cacheStorage));\n\n              case 4:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function _createCache(_x9) {\n        return _createCache2.apply(this, arguments);\n      }\n\n      return _createCache;\n    }()\n    /* Private methods */\n\n  }, {\n    key: \"_createStore\",\n    value: function () {\n      var _createStore2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(type, address, options) {\n        var Store, accessController, opts, identity, store, addr;\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                // Get the type -> class mapping\n                Store = databaseTypes[type];\n\n                if (Store) {\n                  _context12.next = 3;\n                  break;\n                }\n\n                throw new Error(\"Invalid database type '\".concat(type, \"'\"));\n\n              case 3:\n                if (!options.accessControllerAddress) {\n                  _context12.next = 7;\n                  break;\n                }\n\n                _context12.next = 6;\n                return AccessControllers.resolve(this, options.accessControllerAddress, options.accessController);\n\n              case 6:\n                accessController = _context12.sent;\n\n              case 7:\n                opts = Object.assign({\n                  replicate: true\n                }, options, {\n                  accessController: accessController,\n                  cache: options.cache,\n                  onClose: this._onClose.bind(this),\n                  onDrop: this._onDrop.bind(this),\n                  onLoad: this._onLoad.bind(this)\n                });\n                identity = options.identity || this.identity;\n                store = new Store(this._ipfs, identity, address, opts);\n                store.events.on('write', this._onWrite.bind(this)); // ID of the store is the address as a string\n\n                addr = address.toString();\n                this.stores[addr] = store; // Subscribe to pubsub to get updates from peers,\n                // this is what hooks us into the message propagation layer\n                // and the p2p network\n\n                if (!(opts.replicate && this._pubsub)) {\n                  _context12.next = 16;\n                  break;\n                }\n\n                _context12.next = 16;\n                return this._pubsub.subscribe(addr, this._onMessage.bind(this), this._onPeerConnected.bind(this));\n\n              case 16:\n                return _context12.abrupt(\"return\", store);\n\n              case 17:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function _createStore(_x10, _x11, _x12) {\n        return _createStore2.apply(this, arguments);\n      }\n\n      return _createStore;\n    }() // Callback for local writes to the database. We the update to pubsub.\n\n  }, {\n    key: \"_onWrite\",\n    value: function _onWrite(address, entry, heads) {\n      if (!heads) throw new Error(\"'heads' not defined\");\n      if (this._pubsub) this._pubsub.publish(address, heads);\n    } // Callback for receiving a message from the network\n\n  }, {\n    key: \"_onMessage\",\n    value: function () {\n      var _onMessage2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13(address, heads, peer) {\n        var store;\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                store = this.stores[address];\n                _context13.prev = 1;\n                logger.debug(\"Received \".concat(heads.length, \" heads for '\").concat(address, \"':\\n\"), JSON.stringify(heads.map(function (e) {\n                  return e.hash;\n                }), null, 2));\n\n                if (!(store && heads)) {\n                  _context13.next = 8;\n                  break;\n                }\n\n                if (!(heads.length > 0)) {\n                  _context13.next = 7;\n                  break;\n                }\n\n                _context13.next = 7;\n                return store.sync(heads);\n\n              case 7:\n                store.events.emit('peer.exchanged', peer, address, heads);\n\n              case 8:\n                _context13.next = 13;\n                break;\n\n              case 10:\n                _context13.prev = 10;\n                _context13.t0 = _context13[\"catch\"](1);\n                logger.error(_context13.t0);\n\n              case 13:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this, [[1, 10]]);\n      }));\n\n      function _onMessage(_x13, _x14, _x15) {\n        return _onMessage2.apply(this, arguments);\n      }\n\n      return _onMessage;\n    }() // Callback for when a peer connected to a database\n\n  }, {\n    key: \"_onPeerConnected\",\n    value: function () {\n      var _onPeerConnected2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14(address, peer) {\n        var _this2 = this;\n\n        var getStore, getDirectConnection, onChannelCreated, onMessage;\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                logger.debug(\"New peer '\".concat(peer, \"' connected to '\").concat(address, \"'\"));\n\n                getStore = function getStore(address) {\n                  return _this2.stores[address];\n                };\n\n                getDirectConnection = function getDirectConnection(peer) {\n                  return _this2._directConnections[peer];\n                };\n\n                onChannelCreated = function onChannelCreated(channel) {\n                  _this2._directConnections[channel._receiverID] = channel;\n                };\n\n                onMessage = function onMessage(address, heads) {\n                  return _this2._onMessage(address, heads, peer);\n                };\n\n                _context14.next = 7;\n                return exchangeHeads(this._ipfs, address, peer, getStore, getDirectConnection, onMessage, onChannelCreated);\n\n              case 7:\n                if (getStore(address)) {\n                  getStore(address).events.emit('peer', peer);\n                }\n\n              case 8:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function _onPeerConnected(_x16, _x17) {\n        return _onPeerConnected2.apply(this, arguments);\n      }\n\n      return _onPeerConnected;\n    }() // Callback when database was closed\n\n  }, {\n    key: \"_onClose\",\n    value: function () {\n      var _onClose2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee15(db) {\n        var address, store, dir, cache;\n        return _regeneratorRuntime.wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                address = db.address.toString();\n                logger.debug(\"Close \".concat(address)); // Unsubscribe from pubsub\n\n                if (!this._pubsub) {\n                  _context15.next = 5;\n                  break;\n                }\n\n                _context15.next = 5;\n                return this._pubsub.unsubscribe(address);\n\n              case 5:\n                store = this.stores[address];\n                dir = store && store.options.directory ? store.options.directory : this.directory;\n                cache = this.caches[dir];\n\n                if (!(cache && cache.handlers.has(address))) {\n                  _context15.next = 13;\n                  break;\n                }\n\n                cache.handlers.delete(address);\n\n                if (cache.handlers.size) {\n                  _context15.next = 13;\n                  break;\n                }\n\n                _context15.next = 13;\n                return cache.cache.close();\n\n              case 13:\n                delete this.stores[address];\n\n              case 14:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      function _onClose(_x18) {\n        return _onClose2.apply(this, arguments);\n      }\n\n      return _onClose;\n    }()\n  }, {\n    key: \"_onDrop\",\n    value: function () {\n      var _onDrop2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee16(db) {\n        var address, dir;\n        return _regeneratorRuntime.wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                address = db.address.toString();\n                dir = db && db.options.directory ? db.options.directory : this.directory;\n                _context16.next = 4;\n                return this._requestCache(address, dir, db._cache);\n\n              case 4:\n                this.stores[address] = db;\n\n              case 5:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      function _onDrop(_x19) {\n        return _onDrop2.apply(this, arguments);\n      }\n\n      return _onDrop;\n    }()\n  }, {\n    key: \"_onLoad\",\n    value: function () {\n      var _onLoad2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee17(db) {\n        var address, dir;\n        return _regeneratorRuntime.wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                address = db.address.toString();\n                dir = db && db.options.directory ? db.options.directory : this.directory;\n                _context17.next = 4;\n                return this._requestCache(address, dir, db._cache);\n\n              case 4:\n                this.stores[address] = db;\n\n              case 5:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      function _onLoad(_x20) {\n        return _onLoad2.apply(this, arguments);\n      }\n\n      return _onLoad;\n    }()\n  }, {\n    key: \"_determineAddress\",\n    value: function () {\n      var _determineAddress2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee18(name, type) {\n        var options,\n            accessControllerAddress,\n            manifestHash,\n            _args18 = arguments;\n        return _regeneratorRuntime.wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                options = _args18.length > 2 && _args18[2] !== undefined ? _args18[2] : {};\n\n                if (OrbitDB.isValidType(type)) {\n                  _context18.next = 3;\n                  break;\n                }\n\n                throw new Error(\"Invalid database type '\".concat(type, \"'\"));\n\n              case 3:\n                if (!OrbitDBAddress.isValid(name)) {\n                  _context18.next = 5;\n                  break;\n                }\n\n                throw new Error('Given database name is an address. Please give only the name of the database!');\n\n              case 5:\n                // Create an AccessController, use IPFS AC as the default\n                options.accessController = Object.assign({}, {\n                  name: name,\n                  type: 'ipfs'\n                }, options.accessController);\n                _context18.next = 8;\n                return AccessControllers.create(this, options.accessController.type, options.accessController || {});\n\n              case 8:\n                accessControllerAddress = _context18.sent;\n                _context18.next = 11;\n                return createDBManifest(this._ipfs, name, type, accessControllerAddress, options);\n\n              case 11:\n                manifestHash = _context18.sent;\n                return _context18.abrupt(\"return\", OrbitDBAddress.parse(OrbitDBAddress.join(manifestHash, name)));\n\n              case 13:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee18, this);\n      }));\n\n      function _determineAddress(_x21, _x22) {\n        return _determineAddress2.apply(this, arguments);\n      }\n\n      return _determineAddress;\n    }()\n    /* Create and Open databases */\n\n    /*\n      options = {\n        accessController: { write: [] } // array of keys that can write to this database\n        overwrite: false, // whether we should overwrite the existing database if it exists\n      }\n    */\n\n  }, {\n    key: \"create\",\n    value: function () {\n      var _create = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee19(name, type) {\n        var options,\n            dbAddress,\n            haveDB,\n            _args19 = arguments;\n        return _regeneratorRuntime.wrap(function _callee19$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                options = _args19.length > 2 && _args19[2] !== undefined ? _args19[2] : {};\n                logger.debug('create()');\n                logger.debug(\"Creating database '\".concat(name, \"' as \").concat(type)); // Create the database address\n\n                _context19.next = 5;\n                return this._determineAddress(name, type, options);\n\n              case 5:\n                dbAddress = _context19.sent;\n                _context19.next = 8;\n                return this._requestCache(dbAddress.toString(), options.directory);\n\n              case 8:\n                options.cache = _context19.sent;\n                _context19.next = 11;\n                return this._haveLocalData(options.cache, dbAddress);\n\n              case 11:\n                haveDB = _context19.sent;\n\n                if (!(haveDB && !options.overwrite)) {\n                  _context19.next = 14;\n                  break;\n                }\n\n                throw new Error(\"Database '\".concat(dbAddress, \"' already exists!\"));\n\n              case 14:\n                _context19.next = 16;\n                return this._migrate(options, dbAddress);\n\n              case 16:\n                _context19.next = 18;\n                return this._addManifestToCache(options.cache, dbAddress);\n\n              case 18:\n                logger.debug(\"Created database '\".concat(dbAddress, \"'\")); // Open the database\n\n                return _context19.abrupt(\"return\", this.open(dbAddress, options));\n\n              case 20:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee19, this);\n      }));\n\n      function create(_x23, _x24) {\n        return _create.apply(this, arguments);\n      }\n\n      return create;\n    }()\n  }, {\n    key: \"determineAddress\",\n    value: function () {\n      var _determineAddress3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee20(name, type) {\n        var options,\n            opts,\n            _args20 = arguments;\n        return _regeneratorRuntime.wrap(function _callee20$(_context20) {\n          while (1) {\n            switch (_context20.prev = _context20.next) {\n              case 0:\n                options = _args20.length > 2 && _args20[2] !== undefined ? _args20[2] : {};\n                opts = Object.assign({}, {\n                  onlyHash: true\n                }, options);\n                return _context20.abrupt(\"return\", this._determineAddress(name, type, opts));\n\n              case 3:\n              case \"end\":\n                return _context20.stop();\n            }\n          }\n        }, _callee20, this);\n      }));\n\n      function determineAddress(_x25, _x26) {\n        return _determineAddress3.apply(this, arguments);\n      }\n\n      return determineAddress;\n    }()\n  }, {\n    key: \"_requestCache\",\n    value: function () {\n      var _requestCache2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee21(address, directory, existingCache) {\n        var dir, newCache, cache;\n        return _regeneratorRuntime.wrap(function _callee21$(_context21) {\n          while (1) {\n            switch (_context21.prev = _context21.next) {\n              case 0:\n                dir = directory || this.directory;\n\n                if (this.caches[dir]) {\n                  _context21.next = 9;\n                  break;\n                }\n\n                _context21.t0 = existingCache;\n\n                if (_context21.t0) {\n                  _context21.next = 7;\n                  break;\n                }\n\n                _context21.next = 6;\n                return this._createCache(dir);\n\n              case 6:\n                _context21.t0 = _context21.sent;\n\n              case 7:\n                newCache = _context21.t0;\n                this.caches[dir] = {\n                  cache: newCache,\n                  handlers: new Set()\n                };\n\n              case 9:\n                this.caches[dir].handlers.add(address);\n                cache = this.caches[dir].cache; // \"Wake up\" the caches if they need it\n\n                if (!cache) {\n                  _context21.next = 14;\n                  break;\n                }\n\n                _context21.next = 14;\n                return cache.open();\n\n              case 14:\n                return _context21.abrupt(\"return\", cache);\n\n              case 15:\n              case \"end\":\n                return _context21.stop();\n            }\n          }\n        }, _callee21, this);\n      }));\n\n      function _requestCache(_x27, _x28, _x29) {\n        return _requestCache2.apply(this, arguments);\n      }\n\n      return _requestCache;\n    }()\n    /*\n        options = {\n          localOnly: false // if set to true, throws an error if database can't be found locally\n          create: false // whether to create the database\n          type: TODO\n          overwrite: TODO\n         }\n     */\n\n  }, {\n    key: \"open\",\n    value: function () {\n      var _open = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee22(address) {\n        var options,\n            dbAddress,\n            haveDB,\n            manifest,\n            _args22 = arguments;\n        return _regeneratorRuntime.wrap(function _callee22$(_context22) {\n          while (1) {\n            switch (_context22.prev = _context22.next) {\n              case 0:\n                options = _args22.length > 1 && _args22[1] !== undefined ? _args22[1] : {};\n                logger.debug('open()');\n                options = Object.assign({\n                  localOnly: false,\n                  create: false\n                }, options);\n                logger.debug(\"Open database '\".concat(address, \"'\")); // If address is just the name of database, check the options to crate the database\n\n                if (OrbitDBAddress.isValid(address)) {\n                  _context22.next = 16;\n                  break;\n                }\n\n                if (options.create) {\n                  _context22.next = 9;\n                  break;\n                }\n\n                throw new Error('\\'options.create\\' set to \\'false\\'. If you want to create a database, set \\'options.create\\' to \\'true\\'.');\n\n              case 9:\n                if (!(options.create && !options.type)) {\n                  _context22.next = 13;\n                  break;\n                }\n\n                throw new Error(\"Database type not provided! Provide a type with 'options.type' (\".concat(OrbitDB.databaseTypes.join('|'), \")\"));\n\n              case 13:\n                logger.warn(\"Not a valid OrbitDB address '\".concat(address, \"', creating the database\"));\n                options.overwrite = options.overwrite ? options.overwrite : true;\n                return _context22.abrupt(\"return\", this.create(address, options.type, options));\n\n              case 16:\n                // Parse the database address\n                dbAddress = OrbitDBAddress.parse(address);\n                _context22.next = 19;\n                return this._requestCache(dbAddress.toString(), options.directory);\n\n              case 19:\n                options.cache = _context22.sent;\n                _context22.next = 22;\n                return this._haveLocalData(options.cache, dbAddress);\n\n              case 22:\n                haveDB = _context22.sent;\n                logger.debug((haveDB ? 'Found' : 'Didn\\'t find') + \" database '\".concat(dbAddress, \"'\")); // If we want to try and open the database local-only, throw an error\n                // if we don't have the database locally\n\n                if (!(options.localOnly && !haveDB)) {\n                  _context22.next = 27;\n                  break;\n                }\n\n                logger.warn(\"Database '\".concat(dbAddress, \"' doesn't exist!\"));\n                throw new Error(\"Database '\".concat(dbAddress, \"' doesn't exist!\"));\n\n              case 27:\n                logger.debug(\"Loading Manifest for '\".concat(dbAddress, \"'\")); // Get the database manifest from IPFS\n\n                _context22.next = 30;\n                return io.read(this._ipfs, dbAddress.root);\n\n              case 30:\n                manifest = _context22.sent;\n                logger.debug(\"Manifest for '\".concat(dbAddress, \"':\\n\").concat(JSON.stringify(manifest, null, 2))); // Make sure the type from the manifest matches the type that was given as an option\n\n                if (!(manifest.name !== dbAddress.path)) {\n                  _context22.next = 34;\n                  break;\n                }\n\n                throw new Error(\"Manifest '\".concat(manifest.name, \"' cannot be opened as '\").concat(dbAddress.path, \"'\"));\n\n              case 34:\n                if (!(options.type && manifest.type !== options.type)) {\n                  _context22.next = 36;\n                  break;\n                }\n\n                throw new Error(\"Database '\".concat(dbAddress, \"' is type '\").concat(manifest.type, \"' but was opened as '\").concat(options.type, \"'\"));\n\n              case 36:\n                _context22.next = 38;\n                return this._addManifestToCache(options.cache, dbAddress);\n\n              case 38:\n                // Open the the database\n                options = Object.assign({}, options, {\n                  accessControllerAddress: manifest.accessController,\n                  meta: manifest.meta\n                });\n                return _context22.abrupt(\"return\", this._createStore(manifest.type, dbAddress, options));\n\n              case 40:\n              case \"end\":\n                return _context22.stop();\n            }\n          }\n        }, _callee22, this);\n      }));\n\n      function open(_x30) {\n        return _open.apply(this, arguments);\n      }\n\n      return open;\n    }() // Save the database locally\n\n  }, {\n    key: \"_addManifestToCache\",\n    value: function () {\n      var _addManifestToCache2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee23(cache, dbAddress) {\n        return _regeneratorRuntime.wrap(function _callee23$(_context23) {\n          while (1) {\n            switch (_context23.prev = _context23.next) {\n              case 0:\n                _context23.next = 2;\n                return cache.set(path.join(dbAddress.toString(), '_manifest'), dbAddress.root);\n\n              case 2:\n                logger.debug(\"Saved manifest to IPFS as '\".concat(dbAddress.root, \"'\"));\n\n              case 3:\n              case \"end\":\n                return _context23.stop();\n            }\n          }\n        }, _callee23);\n      }));\n\n      function _addManifestToCache(_x31, _x32) {\n        return _addManifestToCache2.apply(this, arguments);\n      }\n\n      return _addManifestToCache;\n    }()\n    /**\n     * Check if we have the database, or part of it, saved locally\n     * @param  {[Cache]} cache [The OrbitDBCache instance containing the local data]\n     * @param  {[OrbitDBAddress]} dbAddress [Address of the database to check]\n     * @return {[Boolean]} [Returns true if we have cached the db locally, false if not]\n     */\n\n  }, {\n    key: \"_haveLocalData\",\n    value: function () {\n      var _haveLocalData2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee24(cache, dbAddress) {\n        var addr, data;\n        return _regeneratorRuntime.wrap(function _callee24$(_context24) {\n          while (1) {\n            switch (_context24.prev = _context24.next) {\n              case 0:\n                if (cache) {\n                  _context24.next = 2;\n                  break;\n                }\n\n                return _context24.abrupt(\"return\", false);\n\n              case 2:\n                addr = dbAddress.toString();\n                _context24.next = 5;\n                return cache.get(path.join(addr, '_manifest'));\n\n              case 5:\n                data = _context24.sent;\n                return _context24.abrupt(\"return\", data !== undefined && data !== null);\n\n              case 7:\n              case \"end\":\n                return _context24.stop();\n            }\n          }\n        }, _callee24);\n      }));\n\n      function _haveLocalData(_x33, _x34) {\n        return _haveLocalData2.apply(this, arguments);\n      }\n\n      return _haveLocalData;\n    }()\n    /**\n     * Runs all migrations inside the src/migration folder\n     * @param Object options  Options to pass into the migration\n     * @param OrbitDBAddress dbAddress Address of database in OrbitDBAddress format\n     */\n\n  }, {\n    key: \"_migrate\",\n    value: function () {\n      var _migrate2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee25(options, dbAddress) {\n        return _regeneratorRuntime.wrap(function _callee25$(_context25) {\n          while (1) {\n            switch (_context25.prev = _context25.next) {\n              case 0:\n                _context25.next = 2;\n                return migrations.run(this, options, dbAddress);\n\n              case 2:\n              case \"end\":\n                return _context25.stop();\n            }\n          }\n        }, _callee25, this);\n      }));\n\n      function _migrate(_x35, _x36) {\n        return _migrate2.apply(this, arguments);\n      }\n\n      return _migrate;\n    }()\n    /**\n     * Returns supported database types as an Array of strings\n     * Eg. [ 'counter', 'eventlog', 'feed', 'docstore', 'keyvalue']\n     * @return {[Array]} [Supported database types]\n     */\n\n  }], [{\n    key: \"Pubsub\",\n    get: function get() {\n      return Pubsub;\n    }\n  }, {\n    key: \"Cache\",\n    get: function get() {\n      return Cache;\n    }\n  }, {\n    key: \"Keystore\",\n    get: function get() {\n      return Keystore;\n    }\n  }, {\n    key: \"Identities\",\n    get: function get() {\n      return Identities;\n    }\n  }, {\n    key: \"AccessControllers\",\n    get: function get() {\n      return AccessControllers;\n    }\n  }, {\n    key: \"Storage\",\n    get: function get() {\n      return Storage;\n    }\n  }, {\n    key: \"OrbitDBAddress\",\n    get: function get() {\n      return OrbitDBAddress;\n    }\n  }, {\n    key: \"EventStore\",\n    get: function get() {\n      return EventStore;\n    }\n  }, {\n    key: \"FeedStore\",\n    get: function get() {\n      return FeedStore;\n    }\n  }, {\n    key: \"KeyValueStore\",\n    get: function get() {\n      return KeyValueStore;\n    }\n  }, {\n    key: \"CounterStore\",\n    get: function get() {\n      return CounterStore;\n    }\n  }, {\n    key: \"DocumentStore\",\n    get: function get() {\n      return DocumentStore;\n    }\n  }, {\n    key: \"createInstance\",\n    value: function () {\n      var _createInstance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee26(ipfs) {\n        var options,\n            _ref,\n            id,\n            storageOptions,\n            keystorePath,\n            keyStorage,\n            cachePath,\n            cacheStorage,\n            finalOptions,\n            _args26 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee26$(_context26) {\n          while (1) {\n            switch (_context26.prev = _context26.next) {\n              case 0:\n                options = _args26.length > 1 && _args26[1] !== undefined ? _args26[1] : {};\n\n                if (isDefined(ipfs)) {\n                  _context26.next = 3;\n                  break;\n                }\n\n                throw new Error('IPFS is a required argument. See https://github.com/orbitdb/orbit-db/blob/master/API.md#createinstance');\n\n              case 3:\n                if (options.offline === undefined) {\n                  options.offline = false;\n                }\n\n                if (!(options.offline && !options.id)) {\n                  _context26.next = 6;\n                  break;\n                }\n\n                throw new Error('Offline mode requires passing an `id` in the options');\n\n              case 6:\n                if (!options.offline) {\n                  _context26.next = 10;\n                  break;\n                }\n\n                _context26.t0 = {\n                  id: options.id\n                };\n                _context26.next = 13;\n                break;\n\n              case 10:\n                _context26.next = 12;\n                return ipfs.id();\n\n              case 12:\n                _context26.t0 = _context26.sent;\n\n              case 13:\n                _ref = _context26.t0;\n                id = _ref.id;\n\n                if (!options.directory) {\n                  options.directory = './orbitdb';\n                }\n\n                if (!options.storage) {\n                  storageOptions = {}; // Create default `level` store\n\n                  options.storage = Storage(null, storageOptions);\n                }\n\n                if (options.identity && options.identity.provider.keystore) {\n                  options.keystore = options.identity.provider.keystore;\n                }\n\n                if (options.keystore) {\n                  _context26.next = 24;\n                  break;\n                }\n\n                keystorePath = path.join(options.directory, id, '/keystore');\n                _context26.next = 22;\n                return options.storage.createStore(keystorePath);\n\n              case 22:\n                keyStorage = _context26.sent;\n                options.keystore = new Keystore(keyStorage);\n\n              case 24:\n                if (options.identity) {\n                  _context26.next = 28;\n                  break;\n                }\n\n                _context26.next = 27;\n                return Identities.createIdentity({\n                  id: options.id || id,\n                  keystore: options.keystore\n                });\n\n              case 27:\n                options.identity = _context26.sent;\n\n              case 28:\n                if (options.cache) {\n                  _context26.next = 34;\n                  break;\n                }\n\n                cachePath = path.join(options.directory, id, '/cache');\n                _context26.next = 32;\n                return options.storage.createStore(cachePath);\n\n              case 32:\n                cacheStorage = _context26.sent;\n                options.cache = new Cache(cacheStorage);\n\n              case 34:\n                finalOptions = Object.assign({}, options, {\n                  peerId: id\n                });\n                return _context26.abrupt(\"return\", new OrbitDB(ipfs, options.identity, finalOptions));\n\n              case 36:\n              case \"end\":\n                return _context26.stop();\n            }\n          }\n        }, _callee26);\n      }));\n\n      function createInstance(_x37) {\n        return _createInstance.apply(this, arguments);\n      }\n\n      return createInstance;\n    }()\n  }, {\n    key: \"databaseTypes\",\n    get: function get() {\n      return Object.keys(databaseTypes);\n    }\n  }, {\n    key: \"isValidType\",\n    value: function isValidType(type) {\n      return Object.keys(databaseTypes).includes(type);\n    }\n  }, {\n    key: \"addDatabaseType\",\n    value: function addDatabaseType(type, store) {\n      if (databaseTypes[type]) throw new Error(\"Type already exists: \".concat(type));\n      databaseTypes[type] = store;\n    }\n  }, {\n    key: \"getDatabaseTypes\",\n    value: function getDatabaseTypes() {\n      return databaseTypes;\n    }\n  }, {\n    key: \"isValidAddress\",\n    value: function isValidAddress(address) {\n      return OrbitDBAddress.isValid(address);\n    }\n  }, {\n    key: \"parseAddress\",\n    value: function parseAddress(address) {\n      return OrbitDBAddress.parse(address);\n    }\n  }]);\n\n  return OrbitDB;\n}();\n\nOrbitDB.prototype.AccessControllers = AccessControllers;\nOrbitDB.prototype.Identities = Identities;\nOrbitDB.prototype.Keystore = Keystore;\nmodule.exports = OrbitDB;","map":null,"metadata":{},"sourceType":"script"}