{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar path = require('path');\n\nvar EventEmitter = require('events');\n\nvar merge = require('lodash.merge');\n\nvar pTimeout = require('p-timeout');\n\nvar multiaddr = require('multiaddr');\n\nvar OrbitDB = require('orbit-db');\n\nvar Pubsub = require('orbit-db-pubsub');\n\nvar AccessControllers = require('orbit-db-access-controllers');\n\nvar OdbStorage = require('orbit-db-storage-adapter');\n\nvar OdbCache = require('orbit-db-cache');\n\nvar OdbKeystore = require('orbit-db-keystore');\n\nvar _require = require('did-resolver'),\n    Resolver = _require.Resolver;\n\nvar get3IdResolver = require('3id-resolver').getResolver;\n\nvar getMuportResolver = require('muport-did-resolver').getResolver;\n\nvar _require2 = require('3box-orbitdb-plugins'),\n    OdbIdentityProvider = _require2.OdbIdentityProvider,\n    LegacyIPFS3BoxAccessController = _require2.LegacyIPFS3BoxAccessController,\n    ThreadAccessController = _require2.ThreadAccessController,\n    ModeratorAccessController = _require2.ModeratorAccessController;\n\nAccessControllers.addAccessController({\n  AccessController: LegacyIPFS3BoxAccessController\n});\nAccessControllers.addAccessController({\n  AccessController: ThreadAccessController\n});\nAccessControllers.addAccessController({\n  AccessController: ModeratorAccessController\n});\n\nvar config = require('./config');\n\nvar Identities = require('orbit-db-identity-provider');\n\nIdentities.addIdentityProvider(OdbIdentityProvider);\nvar PINNING_NODE = config.pinning_node;\nvar PINNING_ROOM = config.pinning_room;\nvar ORBITDB_OPTS = config.orbitdb_options;\nvar entryTypes = {\n  SPACE: 'space',\n  ADDRESS_LINK: 'address-link',\n  AUTH_DATA: 'auth-data'\n};\n\nvar Replicator = /*#__PURE__*/function () {\n  function Replicator(ipfs, opts) {\n    var _this = this;\n\n    (0, _classCallCheck2[\"default\"])(this, Replicator);\n    this.events = new EventEmitter();\n    this.ipfs = ipfs;\n    this._pinningNode = multiaddr(opts.pinningNode || PINNING_NODE);\n    this.ipfs.swarm.connect(this._pinningNode);\n    this._stores = {};\n    this._storePromises = {}; // TODO - this should only be done in 3box-js. For use in\n    // 3box-pinning-node the below code should be disabled\n\n    this._hasPubsubMsgs = {};\n    var threeIdResolver = get3IdResolver(ipfs, {\n      pin: true\n    });\n    var muportResolver = getMuportResolver(ipfs);\n    this.resolver = new Resolver(_objectSpread(_objectSpread({}, threeIdResolver), muportResolver));\n    OdbIdentityProvider.setDidResolver(this.resolver);\n    this._orbitDbOpts = _objectSpread(_objectSpread({}, ORBITDB_OPTS), {}, {\n      format: 'dag-pb',\n      accessController: {\n        type: 'legacy-ipfs-3box',\n        skipManifest: true,\n        resolver: this.resolver\n      }\n    });\n    this.events.on('pinning-room-message', function (topic, data) {\n      if (data.type === 'HAS_ENTRIES' && data.odbAddress) {\n        var odbAddress = data.odbAddress;\n\n        if (_this._pinningRoomFilter) {\n          var hasMsgFor = Object.keys(_this._hasPubsubMsgs);\n\n          if (_this._pinningRoomFilter.length <= hasMsgFor.length) {\n            var haveAllMsgs = _this._pinningRoomFilter.reduce(function (acc, addr) {\n              return acc && hasMsgFor.includes(addr);\n            }, true);\n\n            if (haveAllMsgs) {\n              _this._pubsub.unsubscribe(PINNING_ROOM);\n            }\n          } // Before the pinning room filter is created we will keep all has messages\n          // in memory. After we only care about the ones that are relevant.\n\n\n          if (!_this._pinningRoomFilter.includes(odbAddress)) {\n            return;\n          }\n        }\n\n        _this._hasPubsubMsgs[odbAddress] = data;\n\n        _this.events.emit(\"has-\".concat(odbAddress), data);\n      }\n    });\n  }\n\n  (0, _createClass2[\"default\"])(Replicator, [{\n    key: \"_initPinningRoomFilter\",\n    value: function _initPinningRoomFilter() {\n      this._pinningRoomFilter = this.listStoreAddresses(); // clear out any messages that are not relevant\n\n      for (var odbAddress in this._hasPubsubMsgs) {\n        if (!this._pinningRoomFilter.includes(odbAddress)) {\n          delete this._hasPubsubMsgs[odbAddress];\n        }\n      }\n    }\n  }, {\n    key: \"_init\",\n    value: function () {\n      var _init2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee(opts) {\n        var cachePath, levelDown, cacheProxy, cache, keystorePath, keyStorage, keystore, identity;\n        return _regenerator[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.t0 = Pubsub;\n                _context.t1 = this.ipfs;\n                _context.next = 4;\n                return this.ipfs.id();\n\n              case 4:\n                _context.t2 = _context.sent.id;\n                this._pubsub = new _context.t0(_context.t1, _context.t2); // Passes default cache but with fixed path instead of path based on\n                // orbitdb/ipfs id which can change on page load\n\n                cachePath = path.join(opts.orbitPath || './orbitdb', '/cache');\n                levelDown = OdbStorage(null, {});\n\n                if (!opts.cacheProxy) {\n                  _context.next = 14;\n                  break;\n                }\n\n                _context.next = 11;\n                return opts.cacheProxy(cachePath);\n\n              case 11:\n                _context.t3 = _context.sent;\n                _context.next = 17;\n                break;\n\n              case 14:\n                _context.next = 16;\n                return levelDown.createStore(cachePath);\n\n              case 16:\n                _context.t3 = _context.sent;\n\n              case 17:\n                cacheProxy = _context.t3;\n                cache = new OdbCache(cacheProxy);\n                keystorePath = path.join(opts.orbitPath || './orbitdb', '/keystore');\n                _context.next = 22;\n                return levelDown.createStore(keystorePath);\n\n              case 22:\n                keyStorage = _context.sent;\n                keystore = new OdbKeystore(keyStorage); // Identity not used, passes ref to 3ID orbit identity provider\n\n                _context.next = 26;\n                return Identities.createIdentity({\n                  id: 'nullid',\n                  keystore: keystore\n                });\n\n              case 26:\n                identity = _context.sent;\n                _context.next = 29;\n                return OrbitDB.createInstance(this.ipfs, {\n                  directory: opts.orbitPath,\n                  identity: identity,\n                  cache: cache,\n                  keystore: keystore\n                });\n\n              case 29:\n                this._orbitdb = _context.sent;\n\n              case 30:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function _init(_x) {\n        return _init2.apply(this, arguments);\n      }\n\n      return _init;\n    }()\n  }, {\n    key: \"_joinPinningRoom\",\n    value: function () {\n      var _joinPinningRoom2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee2(firstJoin) {\n        var _this2 = this;\n\n        return _regenerator[\"default\"].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.t0 = !firstJoin;\n\n                if (!_context2.t0) {\n                  _context2.next = 5;\n                  break;\n                }\n\n                _context2.next = 4;\n                return this.ipfs.pubsub.ls();\n\n              case 4:\n                _context2.t0 = _context2.sent.includes(PINNING_ROOM);\n\n              case 5:\n                if (!_context2.t0) {\n                  _context2.next = 7;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 7:\n                this._pubsub.subscribe(PINNING_ROOM, function (topic, data) {\n                  // console.log('message', topic, data)\n                  _this2.events.emit('pinning-room-message', topic, data);\n                }, function (topic, peer) {\n                  // console.log('peer', topic, peer)\n                  _this2.events.emit('pinning-room-peer', topic, peer);\n                });\n\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _joinPinningRoom(_x2) {\n        return _joinPinningRoom2.apply(this, arguments);\n      }\n\n      return _joinPinningRoom;\n    }()\n  }, {\n    key: \"start\",\n    value: function () {\n      var _start = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee4(rootstoreAddress, did) {\n        var _this3 = this;\n\n        var opts,\n            waitForSync,\n            _args4 = arguments;\n        return _regenerator[\"default\"].wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                opts = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};\n                this._did = did;\n                _context4.next = 4;\n                return this._joinPinningRoom(true);\n\n              case 4:\n                this._publishDB({\n                  odbAddress: rootstoreAddress\n                });\n\n                _context4.next = 7;\n                return this._orbitdb.feed(rootstoreAddress, this._orbitDbOpts);\n\n              case 7:\n                this.rootstore = _context4.sent;\n                _context4.next = 10;\n                return this.rootstore.load();\n\n              case 10:\n                this.rootstoreSyncDone = this.syncDB(this.rootstore);\n\n                waitForSync = /*#__PURE__*/function () {\n                  var _ref = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee3() {\n                    var addressLinkPinPromise, authDataPinPromise;\n                    return _regenerator[\"default\"].wrap(function _callee3$(_context3) {\n                      while (1) {\n                        switch (_context3.prev = _context3.next) {\n                          case 0:\n                            _context3.next = 2;\n                            return _this3.rootstoreSyncDone;\n\n                          case 2:\n                            addressLinkPinPromise = _this3.getAddressLinks();\n                            authDataPinPromise = _this3.getAuthData();\n\n                            _this3._initPinningRoomFilter();\n\n                            _context3.next = 7;\n                            return _this3._loadStores(opts);\n\n                          case 7:\n                            _context3.next = 9;\n                            return Promise.all(Object.keys(_this3._stores).map(function (addr) {\n                              return _this3.syncDB(_this3._stores[addr]);\n                            }));\n\n                          case 9:\n                            _context3.next = 11;\n                            return addressLinkPinPromise;\n\n                          case 11:\n                            _context3.next = 13;\n                            return authDataPinPromise;\n\n                          case 13:\n                          case \"end\":\n                            return _context3.stop();\n                        }\n                      }\n                    }, _callee3);\n                  }));\n\n                  return function waitForSync() {\n                    return _ref.apply(this, arguments);\n                  };\n                }();\n\n                this.syncDone = waitForSync();\n\n              case 13:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function start(_x3, _x4) {\n        return _start.apply(this, arguments);\n      }\n\n      return start;\n    }()\n  }, {\n    key: \"new\",\n    value: function () {\n      var _new2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee5(rootstoreName, pubkey, did) {\n        var orbitDbOpts;\n        return _regenerator[\"default\"].wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (!this.rootstore) {\n                  _context5.next = 2;\n                  break;\n                }\n\n                throw new Error('This method can only be called once before the replicator has started');\n\n              case 2:\n                this._did = did;\n                _context5.next = 5;\n                return this._joinPinningRoom(true);\n\n              case 5:\n                orbitDbOpts = merge({}, this._orbitDbOpts, {\n                  accessController: {\n                    write: [pubkey]\n                  }\n                });\n                _context5.next = 8;\n                return this._orbitdb.feed(rootstoreName, orbitDbOpts);\n\n              case 8:\n                this.rootstore = _context5.sent;\n                this._pinningRoomFilter = [];\n\n                this._publishDB({\n                  odbAddress: this.rootstore.address.toString()\n                });\n\n                _context5.next = 13;\n                return this.rootstore.load();\n\n              case 13:\n                this.rootstoreSyncDone = Promise.resolve();\n                this.syncDone = Promise.resolve();\n\n              case 15:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function _new(_x5, _x6, _x7) {\n        return _new2.apply(this, arguments);\n      }\n\n      return _new;\n    }()\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee6() {\n        return _regenerator[\"default\"].wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return this._orbitdb.stop();\n\n              case 2:\n                _context6.next = 4;\n                return this._pubsub.disconnect();\n\n              case 4:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function stop() {\n        return _stop.apply(this, arguments);\n      }\n\n      return stop;\n    }()\n  }, {\n    key: \"addKVStore\",\n    value: function () {\n      var _addKVStore = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee7(name, pubkey, isSpace, did) {\n        var storeAddr, orbitDbOpts, store, storeAddress, entries, entry;\n        return _regenerator[\"default\"].wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (this.rootstore) {\n                  _context7.next = 2;\n                  break;\n                }\n\n                throw new Error('This method can only be called once before the replicator has started');\n\n              case 2:\n                storeAddr = Object.keys(this._stores).find(function (addr) {\n                  return addr.includes(name);\n                });\n\n                if (!storeAddr) {\n                  _context7.next = 5;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", this._stores[storeAddr]);\n\n              case 5:\n                orbitDbOpts = merge({}, this._orbitDbOpts, {\n                  accessController: {\n                    write: [pubkey]\n                  }\n                });\n                _context7.next = 8;\n                return this._orbitdb.keyvalue(name, orbitDbOpts);\n\n              case 8:\n                store = _context7.sent;\n                storeAddress = store.address.toString();\n                this._stores[storeAddress] = store; // add entry to rootstore\n\n                _context7.next = 13;\n                return this.rootstoreSyncDone;\n\n              case 13:\n                _context7.next = 15;\n                return this.rootstore.iterator({\n                  limit: -1\n                }).collect();\n\n              case 15:\n                entries = _context7.sent;\n                entry = entries.find(function (entry) {\n                  return entry.payload.value.odbAddress === storeAddress;\n                });\n\n                if (!isSpace) {\n                  _context7.next = 30;\n                  break;\n                }\n\n                if (entry) {\n                  _context7.next = 23;\n                  break;\n                }\n\n                _context7.next = 21;\n                return this.rootstore.add({\n                  type: entryTypes.SPACE,\n                  DID: did,\n                  odbAddress: storeAddress\n                });\n\n              case 21:\n                _context7.next = 28;\n                break;\n\n              case 23:\n                if (entry.payload.value.type) {\n                  _context7.next = 28;\n                  break;\n                }\n\n                _context7.next = 26;\n                return this.rootstore.del(entry.hash);\n\n              case 26:\n                _context7.next = 28;\n                return this.rootstore.add({\n                  type: entryTypes.SPACE,\n                  DID: did,\n                  odbAddress: storeAddress\n                });\n\n              case 28:\n                _context7.next = 33;\n                break;\n\n              case 30:\n                if (entry) {\n                  _context7.next = 33;\n                  break;\n                }\n\n                _context7.next = 33;\n                return this.rootstore.add({\n                  odbAddress: storeAddress\n                });\n\n              case 33:\n                if (!this._hasPubsubMsgs[storeAddress]) {\n                  this._hasPubsubMsgs[storeAddress] = {\n                    numEntries: 0\n                  };\n                }\n\n                return _context7.abrupt(\"return\", store);\n\n              case 35:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function addKVStore(_x8, _x9, _x10, _x11) {\n        return _addKVStore.apply(this, arguments);\n      }\n\n      return addKVStore;\n    }()\n  }, {\n    key: \"_loadStores\",\n    value: function () {\n      var _loadStores2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee8(_ref2) {\n        var _this4 = this;\n\n        var profile, allSpaces, spacesList, storeEntries, loadPromises;\n        return _regenerator[\"default\"].wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                profile = _ref2.profile, allSpaces = _ref2.allSpaces, spacesList = _ref2.spacesList;\n                storeEntries = this._listStoreEntries();\n                loadPromises = storeEntries.map(function (entry) {\n                  var data = entry.payload.value;\n\n                  if (data.type === entryTypes.SPACE && data.DID) {\n                    _this4._pinDID(data.DID);\n                  }\n\n                  if (profile && (data.odbAddress.includes('public') || data.odbAddress.includes('private'))) {\n                    return _this4._loadKeyValueStore(data.odbAddress);\n                  } else if (data.odbAddress.includes(entryTypes.SPACE) && (allSpaces || spacesList && spacesList.includes(data.odbAddress.split('.')[2]))) {\n                    return _this4._loadKeyValueStore(data.odbAddress);\n                  }\n                });\n                return _context8.abrupt(\"return\", Promise.all(loadPromises));\n\n              case 4:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function _loadStores(_x12) {\n        return _loadStores2.apply(this, arguments);\n      }\n\n      return _loadStores;\n    }()\n  }, {\n    key: \"_loadKeyValueStore\",\n    value: function () {\n      var _loadKeyValueStore2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee9(odbAddress) {\n        var _this5 = this;\n\n        return _regenerator[\"default\"].wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                if (!this._storePromises[odbAddress]) {\n                  this._storePromises[odbAddress] = new Promise(function (resolve, reject) {\n                    _this5._orbitdb.keyvalue(odbAddress, _this5._orbitDbOpts).then(function (store) {\n                      store.load().then(function () {\n                        resolve(store);\n                      });\n                    });\n                  });\n                }\n\n                _context9.next = 3;\n                return this._storePromises[odbAddress];\n\n              case 3:\n                this._stores[odbAddress] = _context9.sent;\n                return _context9.abrupt(\"return\", this._stores[odbAddress]);\n\n              case 5:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function _loadKeyValueStore(_x13) {\n        return _loadKeyValueStore2.apply(this, arguments);\n      }\n\n      return _loadKeyValueStore;\n    }()\n  }, {\n    key: \"getStore\",\n    value: function () {\n      var _getStore = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee10(odbAddress) {\n        return _regenerator[\"default\"].wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                return _context10.abrupt(\"return\", this._stores[odbAddress] || this._loadKeyValueStore(odbAddress));\n\n              case 1:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function getStore(_x14) {\n        return _getStore.apply(this, arguments);\n      }\n\n      return getStore;\n    }()\n  }, {\n    key: \"listStoreAddresses\",\n    value: function listStoreAddresses() {\n      return this._listStoreEntries().map(function (entry) {\n        return entry.payload.value.odbAddress;\n      });\n    }\n  }, {\n    key: \"_listStoreEntries\",\n    value: function _listStoreEntries() {\n      var entries = this.rootstore.iterator({\n        limit: -1\n      }).collect().filter(function (e) {\n        return OrbitDB.isValidAddress(e.payload.value.odbAddress || '');\n      });\n      var uniqueEntries = entries.filter(function (e1, i, a) {\n        return a.findIndex(function (e2) {\n          return e2.payload.value.odbAddress === e1.payload.value.odbAddress;\n        }) === i;\n      });\n      return uniqueEntries;\n    }\n  }, {\n    key: \"getAddressLinks\",\n    value: function () {\n      var _getAddressLinks = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee11() {\n        var entries, linkEntries, resolveLinks, _iterator, _step, entry, cid, dag;\n\n        return _regenerator[\"default\"].wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                _context11.next = 2;\n                return this.rootstore.iterator({\n                  limit: -1\n                }).collect();\n\n              case 2:\n                entries = _context11.sent;\n                linkEntries = entries.filter(function (e) {\n                  return e.payload.value.type === entryTypes.ADDRESS_LINK;\n                });\n                resolveLinks = [];\n                _iterator = _createForOfIteratorHelper(linkEntries);\n                _context11.prev = 6;\n\n                _iterator.s();\n\n              case 8:\n                if ((_step = _iterator.n()).done) {\n                  _context11.next = 23;\n                  break;\n                }\n\n                entry = _step.value;\n                cid = entry.payload.value.data;\n                _context11.prev = 11;\n                _context11.next = 14;\n                return pTimeout(this.ipfs.dag.get(cid), 2500);\n\n              case 14:\n                dag = _context11.sent;\n                resolveLinks.push(Object.assign(dag.value, {\n                  entry: entry\n                }));\n                this.ipfs.pin.add(cid);\n                _context11.next = 21;\n                break;\n\n              case 19:\n                _context11.prev = 19;\n                _context11.t0 = _context11[\"catch\"](11);\n\n              case 21:\n                _context11.next = 8;\n                break;\n\n              case 23:\n                _context11.next = 28;\n                break;\n\n              case 25:\n                _context11.prev = 25;\n                _context11.t1 = _context11[\"catch\"](6);\n\n                _iterator.e(_context11.t1);\n\n              case 28:\n                _context11.prev = 28;\n\n                _iterator.f();\n\n                return _context11.finish(28);\n\n              case 31:\n                return _context11.abrupt(\"return\", resolveLinks);\n\n              case 32:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this, [[6, 25, 28, 31], [11, 19]]);\n      }));\n\n      function getAddressLinks() {\n        return _getAddressLinks.apply(this, arguments);\n      }\n\n      return getAddressLinks;\n    }()\n  }, {\n    key: \"getAuthData\",\n    value: function () {\n      var _getAuthData = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee13() {\n        var _this6 = this;\n\n        var entries, authEntries, resolveLinks;\n        return _regenerator[\"default\"].wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                _context13.next = 2;\n                return this.rootstore.iterator({\n                  limit: -1\n                }).collect();\n\n              case 2:\n                entries = _context13.sent;\n                authEntries = entries.filter(function (e) {\n                  return e.payload.value.type === entryTypes.AUTH_DATA;\n                });\n                resolveLinks = authEntries.map( /*#__PURE__*/function () {\n                  var _ref3 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee12(entry) {\n                    var cid, obj;\n                    return _regenerator[\"default\"].wrap(function _callee12$(_context12) {\n                      while (1) {\n                        switch (_context12.prev = _context12.next) {\n                          case 0:\n                            cid = entry.payload.value.data; // TODO handle missing ipfs obj??, timeouts?\n\n                            _context12.next = 3;\n                            return _this6.ipfs.dag.get(cid);\n\n                          case 3:\n                            obj = _context12.sent.value;\n\n                            _this6.ipfs.pin.add(cid);\n\n                            obj.entry = entry;\n                            return _context12.abrupt(\"return\", obj);\n\n                          case 7:\n                          case \"end\":\n                            return _context12.stop();\n                        }\n                      }\n                    }, _callee12);\n                  }));\n\n                  return function (_x15) {\n                    return _ref3.apply(this, arguments);\n                  };\n                }());\n                return _context13.abrupt(\"return\", Promise.all(resolveLinks));\n\n              case 6:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function getAuthData() {\n        return _getAuthData.apply(this, arguments);\n      }\n\n      return getAuthData;\n    }()\n  }, {\n    key: \"ensureConnected\",\n    value: function () {\n      var _ensureConnected = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee14(odbAddress) {\n        var _this7 = this;\n\n        var isThread, roomPeers;\n        return _regenerator[\"default\"].wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                isThread = odbAddress.includes('thread');\n                _context14.next = 3;\n                return this.ipfs.pubsub.peers(odbAddress);\n\n              case 3:\n                roomPeers = _context14.sent;\n\n                if (!roomPeers.find(function (p) {\n                  return p === _this7._pinningNodePeerId;\n                })) {\n                  this.ipfs.swarm.connect(this._pinningNode);\n                  odbAddress = isThread ? odbAddress : this.rootstore.address.toString();\n\n                  this._publishDB({\n                    odbAddress: odbAddress,\n                    isThread: isThread\n                  }, true);\n                }\n\n              case 5:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function ensureConnected(_x16) {\n        return _ensureConnected.apply(this, arguments);\n      }\n\n      return ensureConnected;\n    }()\n  }, {\n    key: \"_publishDB\",\n    value: function () {\n      var _publishDB2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee15(_ref4, unsubscribe) {\n        var _this8 = this;\n\n        var odbAddress, isThread, pinningNodeJoined;\n        return _regenerator[\"default\"].wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                odbAddress = _ref4.odbAddress, isThread = _ref4.isThread;\n\n                this._joinPinningRoom();\n\n                odbAddress = odbAddress || this.rootstore.address.toString(); // make sure that the pinning node is in the pubsub room before publishing\n\n                pinningNodeJoined = new Promise(function (resolve, reject) {\n                  _this8.events.on('pinning-room-peer', function (topic, peer) {\n                    if (peer === _this8._pinningNodePeerId) {\n                      resolve();\n                    }\n                  });\n                });\n                _context15.next = 6;\n                return this.ipfs.pubsub.peers(PINNING_ROOM);\n\n              case 6:\n                if (_context15.sent.includes(this._pinningNodePeerId)) {\n                  _context15.next = 9;\n                  break;\n                }\n\n                _context15.next = 9;\n                return pinningNodeJoined;\n\n              case 9:\n                this._pubsub.publish(PINNING_ROOM, {\n                  type: isThread ? 'SYNC_DB' : 'PIN_DB',\n                  odbAddress: odbAddress,\n                  did: this._did,\n                  thread: isThread\n                });\n\n                this.events.removeAllListeners('pinning-room-peer');\n\n                if (unsubscribe) {\n                  this._pubsub.unsubscribe(PINNING_ROOM);\n                }\n\n              case 12:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      function _publishDB(_x17, _x18) {\n        return _publishDB2.apply(this, arguments);\n      }\n\n      return _publishDB;\n    }()\n  }, {\n    key: \"_getNumEntries\",\n    value: function () {\n      var _getNumEntries2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee16(odbAddress) {\n        var _this9 = this;\n\n        return _regenerator[\"default\"].wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                return _context16.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  var eventName = \"has-\".concat(odbAddress);\n\n                  _this9.events.on(eventName, function (data) {\n                    _this9.events.removeAllListeners(eventName);\n\n                    resolve(data.numEntries);\n                  });\n\n                  if (_this9._hasPubsubMsgs[odbAddress]) {\n                    _this9.events.removeAllListeners(eventName);\n\n                    resolve(_this9._hasPubsubMsgs[odbAddress].numEntries);\n                  }\n                }));\n\n              case 1:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16);\n      }));\n\n      function _getNumEntries(_x19) {\n        return _getNumEntries2.apply(this, arguments);\n      }\n\n      return _getNumEntries;\n    }()\n  }, {\n    key: \"syncDB\",\n    value: function () {\n      var _syncDB = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee17(dbInstance) {\n        var numRemoteEntries, isNumber;\n        return _regenerator[\"default\"].wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                _context17.next = 2;\n                return this._getNumEntries(dbInstance.address.toString());\n\n              case 2:\n                numRemoteEntries = _context17.sent;\n                isNumber = typeof numRemoteEntries === 'number';\n\n                if (!(isNumber && numRemoteEntries <= dbInstance._oplog.values.length)) {\n                  _context17.next = 6;\n                  break;\n                }\n\n                return _context17.abrupt(\"return\", Promise.resolve());\n\n              case 6:\n                _context17.next = 8;\n                return new Promise(function (resolve, reject) {\n                  dbInstance.events.on('replicated', function () {\n                    if (numRemoteEntries <= dbInstance._oplog.values.length) {\n                      resolve();\n                      dbInstance.events.removeAllListeners('replicated');\n                    }\n                  });\n                });\n\n              case 8:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      function syncDB(_x20) {\n        return _syncDB.apply(this, arguments);\n      }\n\n      return syncDB;\n    }()\n  }, {\n    key: \"_pinDID\",\n    value: function () {\n      var _pinDID2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee18(did) {\n        return _regenerator[\"default\"].wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                if (did) {\n                  _context18.next = 2;\n                  break;\n                }\n\n                return _context18.abrupt(\"return\");\n\n              case 2:\n                _context18.prev = 2;\n                _context18.next = 5;\n                return this.resolver.resolve(did);\n\n              case 5:\n                _context18.next = 9;\n                break;\n\n              case 7:\n                _context18.prev = 7;\n                _context18.t0 = _context18[\"catch\"](2);\n\n              case 9:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee18, this, [[2, 7]]);\n      }));\n\n      function _pinDID(_x21) {\n        return _pinDID2.apply(this, arguments);\n      }\n\n      return _pinDID;\n    }()\n  }, {\n    key: \"_pinningNodePeerId\",\n    get: function get() {\n      return this._pinningNode.getPeerId();\n    }\n  }], [{\n    key: \"create\",\n    value: function () {\n      var _create = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee19(ipfs) {\n        var opts,\n            replicator,\n            _args19 = arguments;\n        return _regenerator[\"default\"].wrap(function _callee19$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                opts = _args19.length > 1 && _args19[1] !== undefined ? _args19[1] : {};\n                replicator = new Replicator(ipfs, opts);\n                _context19.next = 4;\n                return replicator._init(opts);\n\n              case 4:\n                return _context19.abrupt(\"return\", replicator);\n\n              case 5:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee19);\n      }));\n\n      function create(_x22) {\n        return _create.apply(this, arguments);\n      }\n\n      return create;\n    }()\n  }, {\n    key: \"entryTypes\",\n    get: function get() {\n      return entryTypes;\n    }\n  }]);\n  return Replicator;\n}();\n\nmodule.exports = Replicator;","map":null,"metadata":{},"sourceType":"script"}