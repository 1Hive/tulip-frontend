{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _slicedToArray = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime.mark(cborCids);\n\nvar multihashes = require('multihashes');\n\nvar CID = require('cids');\n\nvar protobuf = require('protons');\n\nvar fnv1a = require('fnv1a');\n\nvar varint = require('varint');\n\nvar _require = require('ipld-dag-pb'),\n    DAGNode = _require.DAGNode,\n    DAGLink = _require.DAGLink;\n\nvar multicodec = require('multicodec');\n\nvar _require2 = require('p-queue'),\n    Queue = _require2.default;\n\nvar dagCborLinks = require('dag-cbor-links');\n\nvar log = require('debug')('ipfs:pin:pin-set');\n\nvar pbSchema = require('./pin.proto');\n\nvar _require3 = require('buffer'),\n    Buffer = _require3.Buffer;\n\nvar emptyKeyHash = 'QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n';\nvar emptyKey = multihashes.fromB58String(emptyKeyHash);\nvar defaultFanout = 256;\nvar maxItems = 8192;\nvar pb = protobuf(pbSchema);\nvar HAS_DESCENDANT_CONCURRENCY = 100;\n\nfunction toB58String(hash) {\n  return new CID(hash).toBaseEncodedString();\n}\n\nfunction readHeader(rootNode) {\n  // rootNode.data should be a buffer of the format:\n  // < varint(headerLength) | header | itemData... >\n  var rootData = rootNode.Data;\n  var hdrLength = varint.decode(rootData);\n  var vBytes = varint.decode.bytes;\n\n  if (vBytes <= 0) {\n    throw new Error('Invalid Set header length');\n  }\n\n  if (vBytes + hdrLength > rootData.length) {\n    throw new Error('Impossibly large set header length');\n  }\n\n  var hdrSlice = rootData.slice(vBytes, hdrLength + vBytes);\n  var header = pb.Set.decode(hdrSlice);\n\n  if (header.version !== 1) {\n    throw new Error(\"Unsupported Set version: \".concat(header.version));\n  }\n\n  if (header.fanout > rootNode.Links.length) {\n    throw new Error('Impossibly large fanout');\n  }\n\n  return {\n    header: header,\n    data: rootData.slice(hdrLength + vBytes)\n  };\n}\n\nfunction hash(seed, key) {\n  var buf = Buffer.alloc(4);\n  buf.writeUInt32LE(seed, 0);\n  var data = Buffer.concat([buf, Buffer.from(toB58String(key))]);\n  return fnv1a(data.toString('binary'));\n}\n\nfunction cborCids(node) {\n  var _iterator, _step, _step$value, _, cid;\n\n  return _regeneratorRuntime.wrap(function cborCids$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _iterator = _createForOfIteratorHelper(dagCborLinks(node));\n          _context.prev = 1;\n\n          _iterator.s();\n\n        case 3:\n          if ((_step = _iterator.n()).done) {\n            _context.next = 9;\n            break;\n          }\n\n          _step$value = _slicedToArray(_step.value, 2), _ = _step$value[0], cid = _step$value[1];\n          _context.next = 7;\n          return cid;\n\n        case 7:\n          _context.next = 3;\n          break;\n\n        case 9:\n          _context.next = 14;\n          break;\n\n        case 11:\n          _context.prev = 11;\n          _context.t0 = _context[\"catch\"](1);\n\n          _iterator.e(_context.t0);\n\n        case 14:\n          _context.prev = 14;\n\n          _iterator.f();\n\n          return _context.finish(14);\n\n        case 17:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked, null, [[1, 11, 14, 17]]);\n}\n\nexports = module.exports = function (dag) {\n  var pinSet = {\n    // should this be part of `object` API?\n    hasDescendant: function () {\n      var _hasDescendant = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(parentCid, childhash) {\n        var _yield$dag$get, root, queue, found, seen, searchChild, searchChildren;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                searchChildren = function _searchChildren(cid, node) {\n                  var links = [];\n\n                  if (cid.codec === 'dag-pb') {\n                    links = node.Links;\n                  } else if (cid.codec === 'dag-cbor') {\n                    links = cborCids(node);\n                  }\n\n                  var _iterator2 = _createForOfIteratorHelper(links),\n                      _step2;\n\n                  try {\n                    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                      var link = _step2.value;\n                      var linkCid = cid.codec === 'dag-pb' ? link.Hash : link[1];\n                      var bs58Link = toB58String(linkCid);\n\n                      if (bs58Link === childhash) {\n                        queue.clear();\n                        found = true;\n                        return;\n                      }\n\n                      if (seen[bs58Link]) {\n                        continue;\n                      }\n\n                      seen[bs58Link] = true;\n\n                      if (linkCid.codec !== 'dag-pb' && linkCid.codec !== 'dag-cbor') {\n                        continue;\n                      }\n\n                      queue.add(searchChild(linkCid));\n                    }\n                  } catch (err) {\n                    _iterator2.e(err);\n                  } finally {\n                    _iterator2.f();\n                  }\n                };\n\n                searchChild = function _searchChild(linkCid) {\n                  return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n                    var _yield$dag$get2, childNode;\n\n                    return _regeneratorRuntime.wrap(function _callee$(_context2) {\n                      while (1) {\n                        switch (_context2.prev = _context2.next) {\n                          case 0:\n                            if (!found) {\n                              _context2.next = 2;\n                              break;\n                            }\n\n                            return _context2.abrupt(\"return\");\n\n                          case 2:\n                            _context2.prev = 2;\n                            _context2.next = 5;\n                            return dag.get(linkCid, {\n                              preload: false\n                            });\n\n                          case 5:\n                            _yield$dag$get2 = _context2.sent;\n                            childNode = _yield$dag$get2.value;\n                            searchChildren(linkCid, childNode);\n                            _context2.next = 13;\n                            break;\n\n                          case 10:\n                            _context2.prev = 10;\n                            _context2.t0 = _context2[\"catch\"](2);\n                            log(_context2.t0);\n\n                          case 13:\n                          case \"end\":\n                            return _context2.stop();\n                        }\n                      }\n                    }, _callee, null, [[2, 10]]);\n                  }));\n                };\n\n                if (!(parentCid.codec !== 'dag-pb' && parentCid.codec !== 'dag-cbor')) {\n                  _context3.next = 4;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", false);\n\n              case 4:\n                _context3.next = 6;\n                return dag.get(parentCid, {\n                  preload: false\n                });\n\n              case 6:\n                _yield$dag$get = _context3.sent;\n                root = _yield$dag$get.value;\n                queue = new Queue({\n                  concurrency: HAS_DESCENDANT_CONCURRENCY\n                });\n\n                if (CID.isCID(childhash) || Buffer.isBuffer(childhash)) {\n                  childhash = toB58String(childhash);\n                }\n\n                found = false;\n                seen = {};\n                searchChildren(parentCid, root);\n                _context3.next = 15;\n                return queue.onIdle();\n\n              case 15:\n                return _context3.abrupt(\"return\", found);\n\n              case 16:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function hasDescendant(_x, _x2) {\n        return _hasDescendant.apply(this, arguments);\n      }\n\n      return hasDescendant;\n    }(),\n    storeSet: function () {\n      var _storeSet = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(keys) {\n        var pins, rootNode, cid;\n        return _regeneratorRuntime.wrap(function _callee3$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                pins = keys.map(function (key) {\n                  if (typeof key === 'string' || Buffer.isBuffer(key)) {\n                    key = new CID(key);\n                  }\n\n                  return {\n                    key: key,\n                    data: null\n                  };\n                });\n                _context4.next = 3;\n                return pinSet.storeItems(pins);\n\n              case 3:\n                rootNode = _context4.sent;\n                _context4.next = 6;\n                return dag.put(rootNode, {\n                  version: 0,\n                  format: multicodec.DAG_PB,\n                  hashAlg: multicodec.SHA2_256,\n                  preload: false\n                });\n\n              case 6:\n                cid = _context4.sent;\n                return _context4.abrupt(\"return\", {\n                  node: rootNode,\n                  cid: cid\n                });\n\n              case 8:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      function storeSet(_x3) {\n        return _storeSet.apply(this, arguments);\n      }\n\n      return storeSet;\n    }(),\n    storeItems: function () {\n      var _storeItems = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(items) {\n        var storePins, _storePins;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _storePins = function _storePins3() {\n                  _storePins = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(pins, depth) {\n                    var pbHeader, headerBuf, fanoutLinks, i, nodes, rootLinks, rootData, bins, idx, _iterator3, _step3, bin, child, storeChild, _storeChild;\n\n                    return _regeneratorRuntime.wrap(function _callee5$(_context6) {\n                      while (1) {\n                        switch (_context6.prev = _context6.next) {\n                          case 0:\n                            _storeChild = function _storeChild3() {\n                              _storeChild = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(child, binIdx) {\n                                var opts, cid;\n                                return _regeneratorRuntime.wrap(function _callee4$(_context5) {\n                                  while (1) {\n                                    switch (_context5.prev = _context5.next) {\n                                      case 0:\n                                        opts = {\n                                          version: 0,\n                                          format: multicodec.DAG_PB,\n                                          hashAlg: multicodec.SHA2_256,\n                                          preload: false\n                                        };\n                                        _context5.next = 3;\n                                        return dag.put(child, opts);\n\n                                      case 3:\n                                        cid = _context5.sent;\n                                        fanoutLinks[binIdx] = new DAGLink('', child.size, cid);\n\n                                      case 5:\n                                      case \"end\":\n                                        return _context5.stop();\n                                    }\n                                  }\n                                }, _callee4);\n                              }));\n                              return _storeChild.apply(this, arguments);\n                            };\n\n                            storeChild = function _storeChild2(_x7, _x8) {\n                              return _storeChild.apply(this, arguments);\n                            };\n\n                            pbHeader = pb.Set.encode({\n                              version: 1,\n                              fanout: defaultFanout,\n                              seed: depth\n                            });\n                            headerBuf = Buffer.concat([Buffer.from(varint.encode(pbHeader.length)), pbHeader]);\n                            fanoutLinks = [];\n\n                            for (i = 0; i < defaultFanout; i++) {\n                              fanoutLinks.push(new DAGLink('', 1, emptyKey));\n                            }\n\n                            if (!(pins.length <= maxItems)) {\n                              _context6.next = 13;\n                              break;\n                            }\n\n                            nodes = pins.map(function (item) {\n                              return {\n                                link: new DAGLink('', 1, item.key),\n                                data: item.data || Buffer.alloc(0)\n                              };\n                            }) // sorting makes any ordering of `pins` produce the same DAGNode\n                            .sort(function (a, b) {\n                              return Buffer.compare(a.link.Hash.buffer, b.link.Hash.buffer);\n                            });\n                            rootLinks = fanoutLinks.concat(nodes.map(function (item) {\n                              return item.link;\n                            }));\n                            rootData = Buffer.concat([headerBuf].concat(nodes.map(function (item) {\n                              return item.data;\n                            })));\n                            return _context6.abrupt(\"return\", new DAGNode(rootData, rootLinks));\n\n                          case 13:\n                            // If the array of pins is > maxItems, we:\n                            //  - distribute the pins among `defaultFanout` bins\n                            //    - create a DAGNode for each bin\n                            //      - add each pin as a DAGLink to that bin\n                            //  - create a root DAGNode\n                            //    - add each bin as a DAGLink\n                            //  - send that root DAGNode via callback\n                            // (using go-ipfs' \"wasteful but simple\" approach for consistency)\n                            // https://github.com/ipfs/go-ipfs/blob/master/pin/set.go#L57\n                            bins = pins.reduce(function (bins, pin) {\n                              var n = hash(depth, pin.key) % defaultFanout;\n                              bins[n] = n in bins ? bins[n].concat([pin]) : [pin];\n                              return bins;\n                            }, []);\n                            idx = 0;\n                            _iterator3 = _createForOfIteratorHelper(bins);\n                            _context6.prev = 16;\n\n                            _iterator3.s();\n\n                          case 18:\n                            if ((_step3 = _iterator3.n()).done) {\n                              _context6.next = 28;\n                              break;\n                            }\n\n                            bin = _step3.value;\n                            _context6.next = 22;\n                            return storePins(bin, depth + 1);\n\n                          case 22:\n                            child = _context6.sent;\n                            _context6.next = 25;\n                            return storeChild(child, idx);\n\n                          case 25:\n                            idx++;\n\n                          case 26:\n                            _context6.next = 18;\n                            break;\n\n                          case 28:\n                            _context6.next = 33;\n                            break;\n\n                          case 30:\n                            _context6.prev = 30;\n                            _context6.t0 = _context6[\"catch\"](16);\n\n                            _iterator3.e(_context6.t0);\n\n                          case 33:\n                            _context6.prev = 33;\n\n                            _iterator3.f();\n\n                            return _context6.finish(33);\n\n                          case 36:\n                            return _context6.abrupt(\"return\", new DAGNode(headerBuf, fanoutLinks));\n\n                          case 37:\n                          case \"end\":\n                            return _context6.stop();\n                        }\n                      }\n                    }, _callee5, null, [[16, 30, 33, 36]]);\n                  }));\n                  return _storePins.apply(this, arguments);\n                };\n\n                storePins = function _storePins2(_x5, _x6) {\n                  return _storePins.apply(this, arguments);\n                };\n\n                return _context7.abrupt(\"return\", storePins(items, 0));\n\n              case 3:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee6);\n      }));\n\n      function storeItems(_x4) {\n        return _storeItems.apply(this, arguments);\n      }\n\n      return storeItems;\n    }(),\n    loadSet: function () {\n      var _loadSet = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(rootNode, name) {\n        var link, res, keys, stepPin;\n        return _regeneratorRuntime.wrap(function _callee7$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                link = rootNode.Links.find(function (l) {\n                  return l.Name === name;\n                });\n\n                if (link) {\n                  _context8.next = 3;\n                  break;\n                }\n\n                throw new Error('No link found with name ' + name);\n\n              case 3:\n                _context8.next = 5;\n                return dag.get(link.Hash, '', {\n                  preload: false\n                });\n\n              case 5:\n                res = _context8.sent;\n                keys = [];\n\n                stepPin = function stepPin(link) {\n                  return keys.push(link.Hash);\n                };\n\n                _context8.next = 10;\n                return pinSet.walkItems(res.value, {\n                  stepPin: stepPin\n                });\n\n              case 10:\n                return _context8.abrupt(\"return\", keys);\n\n              case 11:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee7);\n      }));\n\n      function loadSet(_x9, _x10) {\n        return _loadSet.apply(this, arguments);\n      }\n\n      return loadSet;\n    }(),\n    walkItems: function () {\n      var _walkItems = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(node, _ref2) {\n        var _ref2$stepPin, stepPin, _ref2$stepBin, stepBin, pbh, idx, _iterator4, _step4, link, linkHash, res;\n\n        return _regeneratorRuntime.wrap(function _callee8$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _ref2$stepPin = _ref2.stepPin, stepPin = _ref2$stepPin === void 0 ? function () {} : _ref2$stepPin, _ref2$stepBin = _ref2.stepBin, stepBin = _ref2$stepBin === void 0 ? function () {} : _ref2$stepBin;\n                pbh = readHeader(node);\n                idx = 0;\n                _iterator4 = _createForOfIteratorHelper(node.Links);\n                _context9.prev = 4;\n\n                _iterator4.s();\n\n              case 6:\n                if ((_step4 = _iterator4.n()).done) {\n                  _context9.next = 23;\n                  break;\n                }\n\n                link = _step4.value;\n\n                if (!(idx < pbh.header.fanout)) {\n                  _context9.next = 19;\n                  break;\n                }\n\n                // the first pbh.header.fanout links are fanout bins\n                // if a fanout bin is not 'empty', dig into and walk its DAGLinks\n                linkHash = link.Hash.buffer;\n\n                if (emptyKey.equals(linkHash)) {\n                  _context9.next = 17;\n                  break;\n                }\n\n                stepBin(link, idx, pbh.data); // walk the links of this fanout bin\n\n                _context9.next = 14;\n                return dag.get(linkHash, '', {\n                  preload: false\n                });\n\n              case 14:\n                res = _context9.sent;\n                _context9.next = 17;\n                return pinSet.walkItems(res.value, {\n                  stepPin: stepPin,\n                  stepBin: stepBin\n                });\n\n              case 17:\n                _context9.next = 20;\n                break;\n\n              case 19:\n                // otherwise, the link is a pin\n                stepPin(link, idx, pbh.data);\n\n              case 20:\n                idx++;\n\n              case 21:\n                _context9.next = 6;\n                break;\n\n              case 23:\n                _context9.next = 28;\n                break;\n\n              case 25:\n                _context9.prev = 25;\n                _context9.t0 = _context9[\"catch\"](4);\n\n                _iterator4.e(_context9.t0);\n\n              case 28:\n                _context9.prev = 28;\n\n                _iterator4.f();\n\n                return _context9.finish(28);\n\n              case 31:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee8, null, [[4, 25, 28, 31]]);\n      }));\n\n      function walkItems(_x11, _x12) {\n        return _walkItems.apply(this, arguments);\n      }\n\n      return walkItems;\n    }(),\n    getInternalCids: function () {\n      var _getInternalCids = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(rootNode) {\n        var cids, stepBin, _iterator5, _step5, topLevelLink, res;\n\n        return _regeneratorRuntime.wrap(function _callee9$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                // \"Empty block\" used by the pinner\n                cids = [new CID(emptyKey)];\n\n                stepBin = function stepBin(link) {\n                  return cids.push(link.Hash);\n                };\n\n                _iterator5 = _createForOfIteratorHelper(rootNode.Links);\n                _context10.prev = 3;\n\n                _iterator5.s();\n\n              case 5:\n                if ((_step5 = _iterator5.n()).done) {\n                  _context10.next = 15;\n                  break;\n                }\n\n                topLevelLink = _step5.value;\n                cids.push(topLevelLink.Hash);\n                _context10.next = 10;\n                return dag.get(topLevelLink.Hash, '', {\n                  preload: false\n                });\n\n              case 10:\n                res = _context10.sent;\n                _context10.next = 13;\n                return pinSet.walkItems(res.value, {\n                  stepBin: stepBin\n                });\n\n              case 13:\n                _context10.next = 5;\n                break;\n\n              case 15:\n                _context10.next = 20;\n                break;\n\n              case 17:\n                _context10.prev = 17;\n                _context10.t0 = _context10[\"catch\"](3);\n\n                _iterator5.e(_context10.t0);\n\n              case 20:\n                _context10.prev = 20;\n\n                _iterator5.f();\n\n                return _context10.finish(20);\n\n              case 23:\n                return _context10.abrupt(\"return\", cids);\n\n              case 24:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee9, null, [[3, 17, 20, 23]]);\n      }));\n\n      function getInternalCids(_x13) {\n        return _getInternalCids.apply(this, arguments);\n      }\n\n      return getInternalCids;\n    }()\n  };\n  return pinSet;\n};","map":null,"metadata":{},"sourceType":"script"}