{"ast":null,"code":"'use strict';\n\nconst core = require('datastore-core');\n\nconst ShardingStore = core.ShardingDatastore;\n\nconst Block = require('ipld-block');\n\nconst {\n  cidToKey,\n  keyToCid\n} = require('./blockstore-utils');\n\nconst map = require('it-map');\n\nconst pipe = require('it-pipe');\n\nmodule.exports = async (filestore, options) => {\n  const store = await maybeWithSharding(filestore, options);\n  return createBaseStore(store);\n};\n\nfunction maybeWithSharding(filestore, options) {\n  if (options.sharding) {\n    const shard = new core.shard.NextToLast(2);\n    return ShardingStore.createOrOpen(filestore, shard);\n  }\n\n  return filestore;\n}\n\nfunction createBaseStore(store) {\n  return {\n    /**\n     * Query the store.\n     *\n     * @param {Object} query\n     * @param {Object} options\n     * @returns {AsyncIterator<Block>}\n     */\n    async *query(query, options) {\n      // eslint-disable-line require-await\n      yield* store.query(query, options);\n    },\n\n    /**\n     * Get a single block by CID.\n     *\n     * @param {CID} cid\n     * @param {Object} options\n     * @returns {Promise<Block>}\n     */\n    async get(cid, options) {\n      const key = cidToKey(cid);\n      let blockData;\n\n      try {\n        blockData = await store.get(key, options);\n        return new Block(blockData, cid);\n      } catch (err) {\n        if (err.code === 'ERR_NOT_FOUND') {\n          const otherCid = cidToOtherVersion(cid);\n\n          if (!otherCid) {\n            throw err;\n          }\n\n          const otherKey = cidToKey(otherCid);\n          const blockData = await store.get(otherKey, options);\n          await store.put(key, blockData);\n          return new Block(blockData, cid);\n        }\n\n        throw err;\n      }\n    },\n\n    /**\n     * Like get, but for more.\n     *\n     * @param {AsyncIterator<CID>} cids\n     * @param {Object} options\n     * @returns {AsyncIterator<Block>}\n     */\n    async *getMany(cids, options) {\n      for await (const cid of cids) {\n        yield this.get(cid, options);\n      }\n    },\n\n    /**\n     * Write a single block to the store.\n     *\n     * @param {Block} block\n     * @param {Object} options\n     * @returns {Promise<Block>}\n     */\n    async put(block, options) {\n      if (!Block.isBlock(block)) {\n        throw new Error('invalid block');\n      }\n\n      const exists = await this.has(block.cid);\n\n      if (exists) {\n        return this.get(block.cid, options);\n      }\n\n      await store.put(cidToKey(block.cid), block.data, options);\n      return block;\n    },\n\n    /**\n     * Like put, but for more.\n     *\n     * @param {AsyncIterable<Block>|Iterable<Block>} blocks\n     * @param {Object} options\n     * @returns {AsyncIterable<Block>}\n     */\n    async *putMany(blocks, options) {\n      // eslint-disable-line require-await\n      yield* pipe(blocks, source => {\n        // turn them into a key/value pair\n        return map(source, block => {\n          return {\n            key: cidToKey(block.cid),\n            value: block.data\n          };\n        });\n      }, source => {\n        // put them into the datastore\n        return store.putMany(source, options);\n      }, source => {\n        // map the returned key/value back into a block\n        return map(source, ({\n          key,\n          value\n        }) => {\n          return new Block(value, keyToCid(key));\n        });\n      });\n    },\n\n    /**\n     * Does the store contain block with this cid?\n     *\n     * @param {CID} cid\n     * @param {Object} options\n     * @returns {Promise<bool>}\n     */\n    async has(cid, options) {\n      const exists = await store.has(cidToKey(cid), options);\n      if (exists) return exists;\n      const otherCid = cidToOtherVersion(cid);\n      if (!otherCid) return false;\n      return store.has(cidToKey(otherCid), options);\n    },\n\n    /**\n     * Delete a block from the store\n     *\n     * @param {CID} cid\n     * @param {Object} options\n     * @returns {Promise<void>}\n     */\n    async delete(cid, options) {\n      // eslint-disable-line require-await\n      return store.delete(cidToKey(cid), options);\n    },\n\n    /**\n     * Delete a block from the store\n     *\n     * @param {AsyncIterable<CID>} cids\n     * @param {Object} options\n     * @returns {Promise<void>}\n     */\n    async *deleteMany(cids, options) {\n      // eslint-disable-line require-await\n      yield* store.deleteMany(async function* () {\n        for await (const cid of cids) {\n          yield cidToKey(cid);\n        }\n      }(), options);\n    },\n\n    /**\n     * Close the store\n     *\n     * @returns {Promise<void>}\n     */\n    async close() {\n      // eslint-disable-line require-await\n      return store.close();\n    }\n\n  };\n}\n\nfunction cidToOtherVersion(cid) {\n  try {\n    return cid.version === 0 ? cid.toV1() : cid.toV0();\n  } catch (err) {\n    return null;\n  }\n}","map":null,"metadata":{},"sourceType":"script"}