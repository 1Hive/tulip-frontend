{"ast":null,"code":"'use strict';\n\nconst Identity = require('./identity');\n\nconst IdentityProvider = require('./identity-provider-interface.js');\n\nconst OrbitDBIdentityProvider = require('./orbit-db-identity-provider');\n\nconst Keystore = require('orbit-db-keystore');\n\nconst LRU = require('lru');\n\nconst path = require('path');\n\nconst defaultType = 'orbitdb';\nconst identityKeysPath = path.join('./orbitdb', 'identity', 'identitykeys');\nconst supportedTypes = {\n  orbitdb: OrbitDBIdentityProvider\n};\n\nconst getHandlerFor = type => {\n  if (!Identities.isSupported(type)) {\n    throw new Error(`IdentityProvider type '${type}' is not supported`);\n  }\n\n  return supportedTypes[type];\n};\n\nclass Identities {\n  constructor(options) {\n    this._keystore = options.keystore;\n    this._signingKeystore = options.signingKeystore || this._keystore;\n    this._knownIdentities = options.cache || new LRU(options.cacheSize || 100);\n  }\n\n  static get IdentityProvider() {\n    return IdentityProvider;\n  }\n\n  get keystore() {\n    return this._keystore;\n  }\n\n  get signingKeystore() {\n    return this._signingKeystore;\n  }\n\n  async sign(identity, data) {\n    const signingKey = await this.keystore.getKey(identity.id);\n\n    if (!signingKey) {\n      throw new Error(`Private signing key not found from Keystore`);\n    }\n\n    const sig = await this.keystore.sign(signingKey, data);\n    return sig;\n  }\n\n  async verify(signature, publicKey, data, verifier = 'v1') {\n    return this.keystore.verify(signature, publicKey, data, verifier);\n  }\n\n  async createIdentity(options = {}) {\n    const keystore = options.keystore || this.keystore;\n    const type = options.type || defaultType;\n    const identityProvider = type === defaultType ? new OrbitDBIdentityProvider(options.signingKeystore || keystore) : new (getHandlerFor(type))(options);\n    const id = await identityProvider.getId(options);\n\n    if (options.migrate) {\n      await options.migrate({\n        targetStore: keystore._store,\n        targetId: id\n      });\n    }\n\n    const {\n      publicKey,\n      idSignature\n    } = await this.signId(id);\n    const pubKeyIdSignature = await identityProvider.signIdentity(publicKey + idSignature, options);\n    return new Identity(id, publicKey, idSignature, pubKeyIdSignature, type, this);\n  }\n\n  async signId(id) {\n    const keystore = this.keystore;\n    const key = (await keystore.getKey(id)) || (await keystore.createKey(id));\n    const publicKey = keystore.getPublic(key);\n    const idSignature = await keystore.sign(key, id);\n    return {\n      publicKey,\n      idSignature\n    };\n  }\n\n  async verifyIdentity(identity) {\n    if (!Identity.isIdentity(identity)) {\n      return false;\n    }\n\n    const knownID = this._knownIdentities.get(identity.signatures.id);\n\n    if (knownID) {\n      return identity.id === knownID.id && identity.publicKey === knownID.publicKey && identity.signatures.id === knownID.signatures.id && identity.signatures.publicKey === knownID.signatures.publicKey;\n    }\n\n    const verifyIdSig = await this.keystore.verify(identity.signatures.id, identity.publicKey, identity.id);\n    if (!verifyIdSig) return false;\n    const IdentityProvider = getHandlerFor(identity.type);\n    const verified = await IdentityProvider.verifyIdentity(identity);\n\n    if (verified) {\n      this._knownIdentities.set(identity.signatures.id, Identity.toJSON(identity));\n    }\n\n    return verified;\n  }\n\n  static async verifyIdentity(identity) {\n    if (!Identity.isIdentity(identity)) {\n      return false;\n    }\n\n    const verifyIdSig = await Keystore.verify(identity.signatures.id, identity.publicKey, identity.id);\n    if (!verifyIdSig) return false;\n    const IdentityProvider = getHandlerFor(identity.type);\n    return IdentityProvider.verifyIdentity(identity);\n  }\n\n  static async createIdentity(options = {}) {\n    if (!options.keystore) {\n      options.keystore = new Keystore(options.identityKeysPath || identityKeysPath);\n    }\n\n    if (!options.signingKeystore) {\n      if (options.signingKeysPath) {\n        options.signingKeystore = new Keystore(options.signingKeysPath);\n      } else {\n        options.signingKeystore = options.keystore;\n      }\n    }\n\n    options = Object.assign({}, {\n      type: defaultType\n    }, options);\n    const identities = new Identities(options);\n    return identities.createIdentity(options);\n  }\n\n  static isSupported(type) {\n    return Object.keys(supportedTypes).includes(type);\n  }\n\n  static addIdentityProvider(IdentityProvider) {\n    if (!IdentityProvider) {\n      throw new Error('IdentityProvider class needs to be given as an option');\n    }\n\n    if (!IdentityProvider.type || typeof IdentityProvider.type !== 'string') {\n      throw new Error('Given IdentityProvider class needs to implement: static get type() { /* return a string */}.');\n    }\n\n    supportedTypes[IdentityProvider.type] = IdentityProvider;\n  }\n\n  static removeIdentityProvider(type) {\n    delete supportedTypes[type];\n  }\n\n}\n\nmodule.exports = Identities;","map":null,"metadata":{},"sourceType":"script"}