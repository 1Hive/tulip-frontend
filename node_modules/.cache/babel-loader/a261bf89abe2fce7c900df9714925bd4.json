{"ast":null,"code":"import { bigNum } from '../lib/math-utils';\nimport { addressesEqual } from '../lib/web3-utils';\nimport { toMs } from './date-utils';\nexport function transformAppealDataAttributes(appeal) {\n  const {\n    appealedRuling,\n    opposedRuling,\n    appealDeposit,\n    confirmAppealDeposit,\n    round,\n    settledAt\n  } = appeal;\n  return { ...appeal,\n    round: { ...round,\n      number: parseInt(round.number, 10),\n      dispute: { ...round.dispute,\n        lastRoundId: parseInt(round.dispute.lastRoundId, 10),\n        rounds: round.dispute.rounds.map(round => ({ ...round,\n          number: parseInt(round.number, 10)\n        }))\n      }\n    },\n    appealedRuling: parseInt(appealedRuling, 10),\n    opposedRuling: parseInt(opposedRuling, 10),\n    appealDeposit: bigNum(appealDeposit),\n    confirmAppealDeposit: bigNum(confirmAppealDeposit),\n    settledAt: toMs(parseInt(settledAt || 0, 10))\n  };\n}\nexport function shouldAppealerBeRewarded(appeal, connectedAccount) {\n  const {\n    maker,\n    taker,\n    appealedRuling,\n    opposedRuling,\n    round\n  } = appeal;\n  const isMaker = addressesEqual(connectedAccount, maker); // If appealer is maker and the appeal wasn't confirmed\n\n  if (isMaker && !opposedRuling) {\n    return true;\n  }\n\n  const {\n    finalRuling\n  } = round.dispute; // If maker && appealed for the wininig outcome\n\n  if (isMaker && appealedRuling === finalRuling) {\n    return true;\n  }\n\n  const isTaker = addressesEqual(connectedAccount, taker); // If taker && confirmed appealed for the winning outcome\n\n  if (isTaker && opposedRuling === finalRuling) {\n    return true;\n  } // Check if  none of the appealers ruled for the winning outcome\n\n\n  return appealedRuling !== finalRuling && opposedRuling !== finalRuling;\n} // Assumes the appealer should be rewarded\n\nexport function getAppealerFees(appeal, totalFees, connectedAccount) {\n  const {\n    maker,\n    appealDeposit,\n    appealedRuling,\n    taker,\n    confirmAppealDeposit,\n    opposedRuling,\n    round\n  } = appeal;\n  const isMaker = addressesEqual(connectedAccount, maker);\n  const isTaker = addressesEqual(connectedAccount, taker); // If appealer is maker and the appeal wasn't confirmed\n\n  if (isMaker && !opposedRuling) {\n    return appealDeposit;\n  }\n\n  const {\n    finalRuling\n  } = round.dispute;\n  const totalDeposit = appealDeposit.add(confirmAppealDeposit); // if appealed for the wininig outcome\n\n  if (isMaker && appealedRuling === finalRuling || isTaker && opposedRuling === finalRuling) {\n    return totalDeposit.sub(totalFees);\n  } // Note that since we assume that the appealer should be rewarded, we can ensure\n  // that the finalRuling is different from the appealedRuling and the opossedRuling\n\n\n  const feesRefund = totalFees.div(2);\n  return (isMaker ? appealDeposit : confirmAppealDeposit).sub(feesRefund);\n}","map":{"version":3,"sources":["/Users/fabianmolina/Documents/1hive/tulip-frontend/src/utils/appeal-utils.js"],"names":["bigNum","addressesEqual","toMs","transformAppealDataAttributes","appeal","appealedRuling","opposedRuling","appealDeposit","confirmAppealDeposit","round","settledAt","number","parseInt","dispute","lastRoundId","rounds","map","shouldAppealerBeRewarded","connectedAccount","maker","taker","isMaker","finalRuling","isTaker","getAppealerFees","totalFees","totalDeposit","add","sub","feesRefund","div"],"mappings":"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","sourcesContent":["import { bigNum } from '../lib/math-utils'\nimport { addressesEqual } from '../lib/web3-utils'\nimport { toMs } from './date-utils'\n\nexport function transformAppealDataAttributes(appeal) {\n  const {\n    appealedRuling,\n    opposedRuling,\n    appealDeposit,\n    confirmAppealDeposit,\n    round,\n    settledAt,\n  } = appeal\n\n  return {\n    ...appeal,\n    round: {\n      ...round,\n      number: parseInt(round.number, 10),\n      dispute: {\n        ...round.dispute,\n        lastRoundId: parseInt(round.dispute.lastRoundId, 10),\n        rounds: round.dispute.rounds.map(round => ({\n          ...round,\n          number: parseInt(round.number, 10),\n        })),\n      },\n    },\n    appealedRuling: parseInt(appealedRuling, 10),\n    opposedRuling: parseInt(opposedRuling, 10),\n    appealDeposit: bigNum(appealDeposit),\n    confirmAppealDeposit: bigNum(confirmAppealDeposit),\n    settledAt: toMs(parseInt(settledAt || 0, 10)),\n  }\n}\n\nexport function shouldAppealerBeRewarded(appeal, connectedAccount) {\n  const { maker, taker, appealedRuling, opposedRuling, round } = appeal\n\n  const isMaker = addressesEqual(connectedAccount, maker)\n\n  // If appealer is maker and the appeal wasn't confirmed\n  if (isMaker && !opposedRuling) {\n    return true\n  }\n\n  const { finalRuling } = round.dispute\n  // If maker && appealed for the wininig outcome\n  if (isMaker && appealedRuling === finalRuling) {\n    return true\n  }\n\n  const isTaker = addressesEqual(connectedAccount, taker)\n\n  // If taker && confirmed appealed for the winning outcome\n  if (isTaker && opposedRuling === finalRuling) {\n    return true\n  }\n\n  // Check if  none of the appealers ruled for the winning outcome\n  return appealedRuling !== finalRuling && opposedRuling !== finalRuling\n}\n\n// Assumes the appealer should be rewarded\nexport function getAppealerFees(appeal, totalFees, connectedAccount) {\n  const {\n    maker,\n    appealDeposit,\n    appealedRuling,\n    taker,\n    confirmAppealDeposit,\n    opposedRuling,\n    round,\n  } = appeal\n\n  const isMaker = addressesEqual(connectedAccount, maker)\n  const isTaker = addressesEqual(connectedAccount, taker)\n\n  // If appealer is maker and the appeal wasn't confirmed\n  if (isMaker && !opposedRuling) {\n    return appealDeposit\n  }\n\n  const { finalRuling } = round.dispute\n  const totalDeposit = appealDeposit.add(confirmAppealDeposit)\n\n  // if appealed for the wininig outcome\n  if (\n    (isMaker && appealedRuling === finalRuling) ||\n    (isTaker && opposedRuling === finalRuling)\n  ) {\n    return totalDeposit.sub(totalFees)\n  }\n\n  // Note that since we assume that the appealer should be rewarded, we can ensure\n  // that the finalRuling is different from the appealedRuling and the opossedRuling\n  const feesRefund = totalFees.div(2)\n  return (isMaker ? appealDeposit : confirmAppealDeposit).sub(feesRefund)\n}\n"]},"metadata":{},"sourceType":"module"}