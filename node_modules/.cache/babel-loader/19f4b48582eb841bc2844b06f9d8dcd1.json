{"ast":null,"code":"var _objectSpread = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar fetch = require('node-fetch');\n\nvar pageResults = require('graph-results-pager');\n\nvar _require = require('graphql-request'),\n    request = _require.request,\n    gql = _require.gql;\n\nvar _require2 = require('./../constants'),\n    ERC20Abi = _require2.ERC20Abi,\n    coingeckoAPIEndpoints = _require2.coingeckoAPIEndpoints,\n    graphAPIEndpoints = _require2.graphAPIEndpoints,\n    tokenLists = _require2.tokenLists,\n    rpcEndpoints = _require2.rpcEndpoints;\n\nvar _require3 = require('./../utils'),\n    generateContractFunctionList = _require3.generateContractFunctionList,\n    convertToNumber = _require3.convertToNumber;\n\nmodule.exports = {\n  //fetches prices of xdai token ids from coingecko\n  coingeckoTokenPrices: function coingeckoTokenPrices() {\n    var _arguments = arguments;\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var _ref, _ref$token_ids, token_ids, params, data;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _ref = _arguments.length > 0 && _arguments[0] !== undefined ? _arguments[0] : {}, _ref$token_ids = _ref.token_ids, token_ids = _ref$token_ids === void 0 ? undefined : _ref$token_ids;\n              params = new URLSearchParams({\n                vs_currencies: 'usd',\n                contract_addresses: token_ids\n              });\n              _context.next = 4;\n              return fetch(coingeckoAPIEndpoints.prices + params, {\n                method: 'GET',\n                headers: {\n                  'Content-Type': 'application/json'\n                }\n              }).then(function (response) {\n                return response.json();\n              });\n\n            case 4:\n              data = _context.sent;\n              return _context.abrupt(\"return\", data);\n\n            case 6:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }))();\n  },\n  //fetches the honeyswap token list\n  tokens: function tokens() {\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n      var data;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return fetch(tokenLists.honeyswap, {\n                methods: 'GET',\n                headers: {\n                  'Content-Type': 'application/json'\n                }\n              }).then(function (response) {\n                return response.json();\n              });\n\n            case 2:\n              data = _context2.sent;\n              return _context2.abrupt(\"return\", data.tokens);\n\n            case 4:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }))();\n  },\n  //gets a list of all non zero token balances in an wallet address\n  tokenBalances: function tokenBalances() {\n    var _arguments2 = arguments;\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n      var _ref2, _ref2$user_address, user_address, tokens, batch, properties, id_query, tokenData, tokensById, results, _yield$batch$execute, response, tokenIds;\n\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              _ref2 = _arguments2.length > 0 && _arguments2[0] !== undefined ? _arguments2[0] : {}, _ref2$user_address = _ref2.user_address, user_address = _ref2$user_address === void 0 ? undefined : _ref2$user_address;\n\n              if (user_address) {\n                _context3.next = 3;\n                break;\n              }\n\n              throw new Error(\"tulip-data: User address undefined\");\n\n            case 3:\n              _context3.next = 5;\n              return module.exports.tokens();\n\n            case 5:\n              tokens = _context3.sent;\n              batch = generateContractFunctionList({\n                tokens: tokens,\n                user_address: user_address\n              }); // query block number\n              // const batch = generateContractFunctionList({ tokens, blockNumber: 11633038 });\n              //get data from honeyswap\n\n              properties = ['id', 'symbol', 'derivedETH']; //TODO: only fetch needed data\n\n              /*\n              const result = await request(graphAPIEndpoints.honeyswap_v2,\n                  gql`{\n                          tokens(where: {id_in: [\"${tokens[0].address.toLowerCase()}\",\"${tokens[1].address.toLowerCase()}\" ]}) {\n                            id,\n                            symbol,\n                            derivedETH\n                          }\n                      }`\n              );\n               */\n              //proper encoding of _in query\n\n              id_query = '\\[' + '\\\\\"' + tokens[0].address.toLowerCase() + '\\\\\"' + ',' + '\\\\\"' + tokens[1].address.toLowerCase() + '\\\\\"' + '\\]';\n              _context3.next = 11;\n              return pageResults({\n                api: graphAPIEndpoints.honeyswap_v2,\n                query: {\n                  entity: 'tokens',\n                  selection: {\n                    where: {//id_in: [`\\\\\"${tokens[0].address.toLowerCase()}\\\\\"`, `\\\\\"${tokens[0].address.toLowerCase()}\\\\\"`]\n                      //id_in: id_query\n                      //id_in: `\\\\[\\\\\"${tokens[0].address.toLowerCase()}\\\\\", \\\\\"${tokens[1].address.toLowerCase()}\\\\\"\\\\]`\n                    },\n                    block: undefined //block ? { number: block } : timestamp ? { number: await timestampToBlock(timestamp) } : undefined,\n\n                  },\n                  properties: properties\n                }\n              }).then(function (results) {\n                return results;\n              }).catch(function (err) {\n                return console.log(err);\n              });\n\n            case 11:\n              tokenData = _context3.sent;\n              tokensById = {};\n              tokenData.forEach(function (entry) {\n                tokensById[entry.id.toLowerCase()] = _objectSpread({\n                  id: entry.id.toLowerCase()\n                }, entry);\n              }); //console.log(tokensById);\n\n              results = [];\n              _context3.next = 17;\n              return batch.execute();\n\n            case 17:\n              _yield$batch$execute = _context3.sent;\n              response = _yield$batch$execute.response;\n              tokenIds = [];\n              response.forEach(function (_ref3, index) {\n                var _hex = _ref3._hex;\n                //const { name, decimals, symbol } = tokens[index];\n                var _tokens$index = tokens[index],\n                    address = _tokens$index.address,\n                    decimals = _tokens$index.decimals;\n\n                if (_hex !== '0x00') {\n                  var balance = \"\".concat(convertToNumber(_hex, decimals));\n                  var token = tokensById[address.toLowerCase()];\n                  results.push(_objectSpread({\n                    balance: balance,\n                    priceUSD: token.derivedETH,\n                    valueUSD: token.derivedETH * balance\n                  }, tokens[index]));\n                }\n              }); //get prices for the tokens on coingecko and add the values to the result\n\n              /*\n              const prices = await module.exports.tokenPrices({token_ids: tokenIds});\n              results.forEach( token => {\n                  const price = prices[token.address];\n                  if(price) {\n                      token.priceUSD = price.usd;\n                      //token.currency = 'usd';\n                      token.valueUSD = token.balance * price.usd;\n                  }\n              });*/\n\n              return _context3.abrupt(\"return\", _tokenBalances.callback(results));\n\n            case 22:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }))();\n  },\n  //TODO: add more exchanges/only works with honeyswap subgraph and tokenlist for now\n  poolBalances: function poolBalances() {\n    var _arguments3 = arguments;\n    return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n      var _ref4, _ref4$block, block, _ref4$timestamp, timestamp, _ref4$user_address, user_address, properties, poolData, tokens, tokensById, results, pairs;\n\n      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              _ref4 = _arguments3.length > 0 && _arguments3[0] !== undefined ? _arguments3[0] : {}, _ref4$block = _ref4.block, block = _ref4$block === void 0 ? undefined : _ref4$block, _ref4$timestamp = _ref4.timestamp, timestamp = _ref4$timestamp === void 0 ? undefined : _ref4$timestamp, _ref4$user_address = _ref4.user_address, user_address = _ref4$user_address === void 0 ? undefined : _ref4$user_address;\n\n              if (user_address) {\n                _context4.next = 3;\n                break;\n              }\n\n              throw new Error(\"tulip-data: User address undefined\");\n\n            case 3:\n              properties = ['id', 'liquidityPositions { liquidityTokenBalance, pair { token0 { id, derivedETH }, token1 { id, derivedETH }, reserve0, reserve1, reserveUSD, totalSupply} }'];\n              _context4.t0 = pageResults;\n              _context4.t1 = graphAPIEndpoints.honeyswap_v2;\n              _context4.t2 = {\n                id: \"\\\\\\\"\".concat(user_address.toLowerCase(), \"\\\\\\\"\")\n              };\n\n              if (!block) {\n                _context4.next = 11;\n                break;\n              }\n\n              _context4.t3 = {\n                number: block\n              };\n              _context4.next = 20;\n              break;\n\n            case 11:\n              if (!timestamp) {\n                _context4.next = 18;\n                break;\n              }\n\n              _context4.next = 14;\n              return timestampToBlock(timestamp);\n\n            case 14:\n              _context4.t5 = _context4.sent;\n              _context4.t4 = {\n                number: _context4.t5\n              };\n              _context4.next = 19;\n              break;\n\n            case 18:\n              _context4.t4 = undefined;\n\n            case 19:\n              _context4.t3 = _context4.t4;\n\n            case 20:\n              _context4.t6 = _context4.t3;\n              _context4.t7 = {\n                where: _context4.t2,\n                block: _context4.t6\n              };\n              _context4.t8 = properties;\n              _context4.t9 = {\n                entity: 'users',\n                selection: _context4.t7,\n                properties: _context4.t8\n              };\n              _context4.t10 = {\n                api: _context4.t1,\n                query: _context4.t9\n              };\n              _context4.next = 27;\n              return (0, _context4.t0)(_context4.t10).then(function (results) {\n                return results;\n              }).catch(function (err) {\n                return console.log(err);\n              });\n\n            case 27:\n              poolData = _context4.sent;\n              _context4.next = 30;\n              return module.exports.tokens();\n\n            case 30:\n              tokens = _context4.sent;\n              tokensById = [];\n              tokens.forEach(function (token) {\n                tokensById[token.address.toLowerCase()] = token;\n              });\n              results = [];\n\n              if (!(poolData && poolData[0] && poolData[0].liquidityPositions)) {\n                _context4.next = 37;\n                break;\n              }\n\n              pairs = poolData[0].liquidityPositions.forEach(function (position) {\n                var token0 = tokensById[position.pair.token0.id];\n\n                if (!token0) {\n                  throw new Error(\"honeycomb-data: Token0 address not found:\".position.pair.token0.id);\n                }\n\n                var token1 = tokensById[position.pair.token1.id];\n\n                if (!token1) {\n                  throw new Error(\"honeycomb-data: Token1 address not found:\".position.pair.token1.id);\n                }\n                /*\n                    get liquidity value of single token\n                     getLiquidityValue()\n                    from: https://github.com/Uniswap/uniswap-v2-sdk/blob/main/src/entities/pair.ts\n                    JSBI.divide(JSBI.multiply(liquidity.raw, this.reserveOf(token).raw), totalSupplyAdjusted.raw)\n                     let liquidityValueUSD = position.liquidityTokenBalance * position.pair.reserve0 / position.pair.totalSupply;\n                    liquidityValueUSD = liquidityValueUSD * position.pair.token0.derivedETH * 2;\n                */\n\n\n                token0.balance = position.liquidityTokenBalance * position.pair.reserve0 / position.pair.totalSupply;\n                token1.balance = position.liquidityTokenBalance * position.pair.reserve1 / position.pair.totalSupply; //in this case eth == dai == usd\n\n                token0.priceUSD = position.pair.token0.derivedETH;\n                token1.priceUSD = position.pair.token1.derivedETH;\n                token0.valueUSD = token0.balance * position.pair.token0.derivedETH;\n                token1.valueUSD = token1.balance * position.pair.token1.derivedETH;\n                /* get usd value of owned pool tokens */\n\n                var liquidityValueUSD = position.pair.reserveUSD / position.pair.totalSupply * position.liquidityTokenBalance;\n                if (position.liquidityTokenBalance <= 0) return;\n                results.push({\n                  tokens: [token0, token1],\n                  balance: position.liquidityTokenBalance,\n                  valueUSD: liquidityValueUSD\n                });\n              });\n              return _context4.abrupt(\"return\", _poolBalances.callback(results));\n\n            case 37:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }))();\n  }\n};\nvar tokenBalance = {\n  /*\n  properties: [\n      'balance',\n      'name',\n      'address',\n      'symbol',\n      'logoURI',\n      'priceUsd',\n      'valueUsd'\n  ],\n   */\n  callback: function callback(entry) {\n    return {\n      balance: Number(entry.balance),\n      name: entry.name,\n      address: entry.address,\n      symbol: entry.symbol,\n      logoURI: entry.logoURI,\n      priceUSD: Number(entry.priceUSD),\n      valueUSD: Number(entry.valueUSD)\n    };\n  }\n};\nvar _tokenBalances = {\n  callback: function callback(results) {\n    return results.map(function (entry) {\n      return tokenBalance.callback(entry);\n    });\n  }\n};\nvar _poolBalances = {\n  callback: function callback(results) {\n    results.map(function (entry) {\n      var result = {\n        balance: Number(entry.balance),\n        valueUSD: Number(entry.valueUSD)\n      };\n      result.tokens = entry.tokens.map(function (token) {\n        return tokenBalance.callback(token);\n      });\n    });\n    return results;\n  }\n};","map":null,"metadata":{},"sourceType":"script"}