{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncIterator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar errcode = require('err-code');\n\nvar pipe = require('it-pipe');\n\nvar lp = require('it-length-prefixed');\n\nvar pTimeout = require('p-timeout');\n\nvar MulticodecTopology = require('libp2p-interfaces/src/topology/multicodec-topology');\n\nvar rpc = require('./rpc');\n\nvar c = require('./constants');\n\nvar Message = require('./message');\n\nvar utils = require('./utils');\n/**\n * Handle network operations for the dht\n */\n\n\nvar Network = /*#__PURE__*/function () {\n  /**\n   * Create a new network.\n   *\n   * @param {KadDHT} self\n   */\n  function Network(self) {\n    _classCallCheck(this, Network);\n\n    this.dht = self;\n    this.readMessageTimeout = c.READ_MESSAGE_TIMEOUT;\n    this._log = utils.logger(this.dht.peerInfo.id, 'net');\n    this._rpc = rpc(this.dht);\n    this._onPeerConnected = this._onPeerConnected.bind(this);\n    this._running = false;\n  }\n  /**\n   * Start the network.\n   * @returns {Promise<void>}\n   */\n\n\n  _createClass(Network, [{\n    key: \"start\",\n    value: function () {\n      var _start = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var topology;\n        return _regeneratorRuntime.wrap(function _callee2$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!this._running) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\");\n\n              case 2:\n                if (this.dht.isStarted) {\n                  _context3.next = 4;\n                  break;\n                }\n\n                throw errcode(new Error('Can not start network'), 'ERR_CANNOT_START_NETWORK');\n\n              case 4:\n                this._running = true; // Incoming streams\n\n                this.dht.registrar.handle(c.PROTOCOL_DHT, this._rpc); // register protocol with topology\n\n                topology = new MulticodecTopology({\n                  multicodecs: [c.PROTOCOL_DHT],\n                  handlers: {\n                    onConnect: this._onPeerConnected,\n                    onDisconnect: function onDisconnect() {}\n                  }\n                });\n                _context3.next = 9;\n                return this.dht.registrar.register(topology);\n\n              case 9:\n                this._registrarId = _context3.sent;\n\n              case 10:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function start() {\n        return _start.apply(this, arguments);\n      }\n\n      return start;\n    }()\n    /**\n     * Stop all network activity.\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        return _regeneratorRuntime.wrap(function _callee3$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!(!this.dht.isStarted && !this.isStarted)) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\");\n\n              case 2:\n                this._running = false; // unregister protocol and handlers\n\n                _context4.next = 5;\n                return this.dht.registrar.unregister(this._registrarId);\n\n              case 5:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function stop() {\n        return _stop.apply(this, arguments);\n      }\n\n      return stop;\n    }()\n    /**\n     * Is the network online?\n     *\n     * @type {bool}\n     */\n\n  }, {\n    key: \"isStarted\",\n    get: function get() {\n      return this._running;\n    }\n    /**\n     * Are all network components there?\n     *\n     * @type {bool}\n     */\n\n  }, {\n    key: \"isConnected\",\n    get: function get() {\n      // TODO add a way to check if switch has started or not\n      return this.dht.isStarted && this.isStarted;\n    }\n    /**\n     * Registrar notifies a connection successfully with dht protocol.\n     * @private\n     * @param {PeerInfo} peerInfo remote peer info\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"_onPeerConnected\",\n    value: function () {\n      var _onPeerConnected2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(peerInfo) {\n        return _regeneratorRuntime.wrap(function _callee4$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this.dht._add(peerInfo);\n\n              case 2:\n                this._log('added to the routing table: %s', peerInfo.id.toB58String());\n\n              case 3:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function _onPeerConnected(_x2) {\n        return _onPeerConnected2.apply(this, arguments);\n      }\n\n      return _onPeerConnected;\n    }()\n    /**\n     * Send a request and record RTT for latency measurements.\n     * @async\n     * @param {PeerId} to - The peer that should receive a message\n     * @param {Message} msg - The message to send.\n     * @returns {Promise<Message>}\n     */\n\n  }, {\n    key: \"sendRequest\",\n    value: function () {\n      var _sendRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(to, msg) {\n        var id, conn, _yield$conn$newStream, stream;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (this.isConnected) {\n                  _context6.next = 2;\n                  break;\n                }\n\n                throw errcode(new Error('Network is offline'), 'ERR_NETWORK_OFFLINE');\n\n              case 2:\n                id = to.toB58String();\n\n                this._log('sending to: %s', id);\n\n                _context6.next = 6;\n                return this.dht.dialer.connectToPeer(to);\n\n              case 6:\n                conn = _context6.sent;\n                _context6.next = 9;\n                return conn.newStream(c.PROTOCOL_DHT);\n\n              case 9:\n                _yield$conn$newStream = _context6.sent;\n                stream = _yield$conn$newStream.stream;\n                return _context6.abrupt(\"return\", this._writeReadMessage(stream, msg.serialize()));\n\n              case 12:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function sendRequest(_x3, _x4) {\n        return _sendRequest.apply(this, arguments);\n      }\n\n      return sendRequest;\n    }()\n    /**\n     * Sends a message without expecting an answer.\n     *\n     * @param {PeerId} to\n     * @param {Message} msg\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"sendMessage\",\n    value: function () {\n      var _sendMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(to, msg) {\n        var id, conn, _yield$conn$newStream2, stream;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (this.isConnected) {\n                  _context7.next = 2;\n                  break;\n                }\n\n                throw errcode(new Error('Network is offline'), 'ERR_NETWORK_OFFLINE');\n\n              case 2:\n                id = to.toB58String();\n\n                this._log('sending to: %s', id);\n\n                _context7.next = 6;\n                return this.dht.dialer.connectToPeer(to);\n\n              case 6:\n                conn = _context7.sent;\n                _context7.next = 9;\n                return conn.newStream(c.PROTOCOL_DHT);\n\n              case 9:\n                _yield$conn$newStream2 = _context7.sent;\n                stream = _yield$conn$newStream2.stream;\n                return _context7.abrupt(\"return\", this._writeMessage(stream, msg.serialize()));\n\n              case 12:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function sendMessage(_x5, _x6) {\n        return _sendMessage.apply(this, arguments);\n      }\n\n      return sendMessage;\n    }()\n    /**\n     * Write a message and read its response.\n     * If no response is received after the specified timeout\n     * this will error out.\n     *\n     * @param {DuplexIterable} stream - the stream to use\n     * @param {Buffer} msg - the message to send\n     * @returns {Promise<Message>}\n     * @private\n     */\n\n  }, {\n    key: \"_writeReadMessage\",\n    value: function () {\n      var _writeReadMessage2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(stream, msg) {\n        return _regeneratorRuntime.wrap(function _callee7$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                return _context8.abrupt(\"return\", pTimeout(writeReadMessage(stream, msg), this.readMessageTimeout));\n\n              case 1:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function _writeReadMessage(_x7, _x8) {\n        return _writeReadMessage2.apply(this, arguments);\n      }\n\n      return _writeReadMessage;\n    }()\n    /**\n     * Write a message to the given stream.\n     *\n     * @param {DuplexIterable} stream - the stream to use\n     * @param {Buffer} msg - the message to send\n     * @returns {Promise<void>}\n     * @private\n     */\n\n  }, {\n    key: \"_writeMessage\",\n    value: function _writeMessage(stream, msg) {\n      return pipe([msg], lp.encode(), stream);\n    }\n  }]);\n\n  return Network;\n}();\n\nfunction writeReadMessage(stream, msg) {\n  var res;\n  return _regeneratorRuntime.async(function writeReadMessage$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return _regeneratorRuntime.awrap(pipe([msg], lp.encode(), stream, lp.decode(), /*#__PURE__*/function () {\n            var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(source) {\n              var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, chunk;\n\n              return _regeneratorRuntime.wrap(function _callee$(_context2) {\n                while (1) {\n                  switch (_context2.prev = _context2.next) {\n                    case 0:\n                      _iteratorNormalCompletion = true;\n                      _didIteratorError = false;\n                      _context2.prev = 2;\n                      _iterator = _asyncIterator(source);\n\n                    case 4:\n                      _context2.next = 6;\n                      return _iterator.next();\n\n                    case 6:\n                      _step = _context2.sent;\n                      _iteratorNormalCompletion = _step.done;\n                      _context2.next = 10;\n                      return _step.value;\n\n                    case 10:\n                      _value = _context2.sent;\n\n                      if (_iteratorNormalCompletion) {\n                        _context2.next = 17;\n                        break;\n                      }\n\n                      chunk = _value;\n                      return _context2.abrupt(\"return\", chunk.slice());\n\n                    case 14:\n                      _iteratorNormalCompletion = true;\n                      _context2.next = 4;\n                      break;\n\n                    case 17:\n                      _context2.next = 23;\n                      break;\n\n                    case 19:\n                      _context2.prev = 19;\n                      _context2.t0 = _context2[\"catch\"](2);\n                      _didIteratorError = true;\n                      _iteratorError = _context2.t0;\n\n                    case 23:\n                      _context2.prev = 23;\n                      _context2.prev = 24;\n\n                      if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                        _context2.next = 28;\n                        break;\n                      }\n\n                      _context2.next = 28;\n                      return _iterator.return();\n\n                    case 28:\n                      _context2.prev = 28;\n\n                      if (!_didIteratorError) {\n                        _context2.next = 31;\n                        break;\n                      }\n\n                      throw _iteratorError;\n\n                    case 31:\n                      return _context2.finish(28);\n\n                    case 32:\n                      return _context2.finish(23);\n\n                    case 33:\n                    case \"end\":\n                      return _context2.stop();\n                  }\n                }\n              }, _callee, null, [[2, 19, 23, 33], [24,, 28, 32]]);\n            }));\n\n            return function (_x) {\n              return _ref.apply(this, arguments);\n            };\n          }()));\n\n        case 2:\n          res = _context.sent;\n\n          if (!(res.length === 0)) {\n            _context.next = 5;\n            break;\n          }\n\n          throw errcode(new Error('No message received'), 'ERR_NO_MESSAGE_RECEIVED');\n\n        case 5:\n          return _context.abrupt(\"return\", Message.deserialize(res));\n\n        case 6:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n}\n\nmodule.exports = Network;","map":null,"metadata":{},"sourceType":"script"}