{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _createForOfIteratorHelper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _asyncIterator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar path = require('path');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar mapSeries = require('p-each-series');\n\nvar _require = require('p-queue'),\n    PQueue = _require.default;\n\nvar Log = require('ipfs-log');\n\nvar Entry = Log.Entry;\n\nvar Index = require('./Index');\n\nvar Replicator = require('./Replicator');\n\nvar ReplicationInfo = require('./replication-info');\n\nvar Logger = require('logplease');\n\nvar logger = Logger.create('orbit-db.store', {\n  color: Logger.Colors.Blue\n});\nLogger.setLogLevel('ERROR');\n\nvar io = require('orbit-db-io');\n\nvar DefaultOptions = {\n  Index: Index,\n  maxHistory: -1,\n  fetchEntryTimeout: null,\n  referenceCount: 32,\n  replicationConcurrency: 128,\n  syncLocal: false,\n  sortFn: undefined\n};\n\nvar Store = /*#__PURE__*/function () {\n  function Store(ipfs, identity, address, options) {\n    var _this = this;\n\n    _classCallCheck(this, Store);\n\n    if (!identity) {\n      throw new Error('Identity required');\n    } // Set the options\n\n\n    var opts = Object.assign({}, DefaultOptions);\n    Object.assign(opts, options);\n    this.options = opts; // Default type\n\n    this._type = 'store'; // Create IDs, names and paths\n\n    this.id = address.toString();\n    this.identity = identity;\n    this.address = address;\n    this.dbname = address.path || '';\n    this.events = new EventEmitter();\n    this.remoteHeadsPath = path.join(this.id, '_remoteHeads');\n    this.localHeadsPath = path.join(this.id, '_localHeads');\n    this.snapshotPath = path.join(this.id, 'snapshot');\n    this.queuePath = path.join(this.id, 'queue');\n    this.manifestPath = path.join(this.id, '_manifest'); // External dependencies\n\n    this._ipfs = ipfs;\n    this._cache = options.cache; // Access mapping\n\n    var defaultAccess = {\n      canAppend: function canAppend(entry) {\n        return entry.identity.publicKey === identity.publicKey;\n      }\n    };\n    this.access = options.accessController || defaultAccess; // Create the operations log\n\n    this._oplog = new Log(this._ipfs, this.identity, {\n      logId: this.id,\n      access: this.access,\n      sortFn: this.options.sortFn\n    }); // _addOperation queue\n\n    this._opqueue = new PQueue({\n      concurrency: 1\n    }); // Create the index\n\n    this._index = new this.options.Index(this.address.root); // Replication progress info\n\n    this._replicationStatus = new ReplicationInfo(); // Statistics\n\n    this._stats = {\n      snapshot: {\n        bytesLoaded: -1\n      },\n      syncRequestsReceieved: 0\n    };\n\n    try {\n      this._replicator = new Replicator(this, this.options.replicationConcurrency); // For internal backwards compatibility,\n      // to be removed in future releases\n\n      this._loader = this._replicator;\n\n      this._replicator.on('load.added', function (entry) {\n        // Update the latest entry state (latest is the entry with largest clock time)\n        _this._replicationStatus.queued++;\n\n        _this._recalculateReplicationMax(entry.clock ? entry.clock.time : 0); // logger.debug(`<replicate>`)\n\n\n        _this.events.emit('replicate', _this.address.toString(), entry);\n      });\n\n      this._replicator.on('load.progress', function (id, hash, entry, have, bufferedLength) {\n        if (_this._replicationStatus.buffered > bufferedLength) {\n          _this._recalculateReplicationProgress(_this.replicationStatus.progress + bufferedLength);\n        } else {\n          _this._recalculateReplicationProgress(_this._oplog.length + bufferedLength);\n        }\n\n        _this._replicationStatus.buffered = bufferedLength;\n\n        _this._recalculateReplicationMax(_this.replicationStatus.progress); // logger.debug(`<replicate.progress>`)\n\n\n        _this.events.emit('replicate.progress', _this.address.toString(), hash, entry, _this.replicationStatus.progress, _this.replicationStatus.max);\n      });\n\n      var onLoadCompleted = /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(logs, have) {\n          var _iterator2, _step2, log, heads;\n\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.prev = 0;\n                  _iterator2 = _createForOfIteratorHelper(logs);\n                  _context.prev = 2;\n\n                  _iterator2.s();\n\n                case 4:\n                  if ((_step2 = _iterator2.n()).done) {\n                    _context.next = 10;\n                    break;\n                  }\n\n                  log = _step2.value;\n                  _context.next = 8;\n                  return _this._oplog.join(log);\n\n                case 8:\n                  _context.next = 4;\n                  break;\n\n                case 10:\n                  _context.next = 15;\n                  break;\n\n                case 12:\n                  _context.prev = 12;\n                  _context.t0 = _context[\"catch\"](2);\n\n                  _iterator2.e(_context.t0);\n\n                case 15:\n                  _context.prev = 15;\n\n                  _iterator2.f();\n\n                  return _context.finish(15);\n\n                case 18:\n                  _this._replicationStatus.queued -= logs.length;\n                  _this._replicationStatus.buffered = _this._replicator._buffer.length;\n                  _context.next = 22;\n                  return _this._updateIndex();\n\n                case 22:\n                  // only store heads that has been verified and merges\n                  heads = _this._oplog.heads;\n                  _context.next = 25;\n                  return _this._cache.set(_this.remoteHeadsPath, heads);\n\n                case 25:\n                  logger.debug(\"Saved heads \".concat(heads.length, \" [\").concat(heads.map(function (e) {\n                    return e.hash;\n                  }).join(', '), \"]\")); // logger.debug(`<replicated>`)\n\n                  _this.events.emit('replicated', _this.address.toString(), logs.length);\n\n                  _context.next = 32;\n                  break;\n\n                case 29:\n                  _context.prev = 29;\n                  _context.t1 = _context[\"catch\"](0);\n                  console.error(_context.t1);\n\n                case 32:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, null, [[0, 29], [2, 12, 15, 18]]);\n        }));\n\n        return function onLoadCompleted(_x, _x2) {\n          return _ref.apply(this, arguments);\n        };\n      }();\n\n      this._replicator.on('load.end', onLoadCompleted);\n    } catch (e) {\n      console.error('Store Error:', e);\n    }\n\n    this.events.on('replicated.progress', function (address, hash, entry, progress, have) {\n      _this._procEntry(entry);\n    });\n    this.events.on('write', function (address, entry, heads) {\n      _this._procEntry(entry);\n    });\n  }\n\n  _createClass(Store, [{\n    key: \"all\",\n    get: function get() {\n      var _this2 = this;\n\n      return Array.isArray(this._index._index) ? this._index._index : Object.keys(this._index._index).map(function (e) {\n        return _this2._index._index[e];\n      });\n    }\n  }, {\n    key: \"index\",\n    get: function get() {\n      return this._index._index;\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this._type;\n    }\n  }, {\n    key: \"key\",\n    get: function get() {\n      return this._key;\n    }\n    /**\n     * Returns the database's current replication status information\n     * @return {[Object]} [description]\n     */\n\n  }, {\n    key: \"replicationStatus\",\n    get: function get() {\n      return this._replicationStatus;\n    }\n  }, {\n    key: \"setIdentity\",\n    value: function setIdentity(identity) {\n      this.identity = identity;\n\n      this._oplog.setIdentity(identity);\n    }\n  }, {\n    key: \"close\",\n    value: function () {\n      var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var event;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!this.options.onClose) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                _context2.next = 3;\n                return this.options.onClose(this);\n\n              case 3:\n                _context2.next = 5;\n                return this._opqueue.onIdle();\n\n              case 5:\n                // Replicator teardown logic\n                this._replicator.stop(); // Reset replication statistics\n\n\n                this._replicationStatus.reset(); // Reset database statistics\n\n\n                this._stats = {\n                  snapshot: {\n                    bytesLoaded: -1\n                  },\n                  syncRequestsReceieved: 0\n                }; // Remove all event listeners\n\n                for (event in this.events._events) {\n                  this.events.removeAllListeners(event);\n                } // Database is now closed\n                // TODO: afaik we don't use 'closed' event anymore,\n                // to be removed in future releases\n\n\n                this.events.emit('closed', this.address.toString());\n                return _context2.abrupt(\"return\", Promise.resolve());\n\n              case 11:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function close() {\n        return _close.apply(this, arguments);\n      }\n\n      return close;\n    }()\n    /**\n     * Drops a database and removes local data\n     * @return {[None]}\n     */\n\n  }, {\n    key: \"drop\",\n    value: function () {\n      var _drop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!this.options.onDrop) {\n                  _context3.next = 3;\n                  break;\n                }\n\n                _context3.next = 3;\n                return this.options.onDrop(this);\n\n              case 3:\n                _context3.next = 5;\n                return this._cache.del(this.localHeadsPath);\n\n              case 5:\n                _context3.next = 7;\n                return this._cache.del(this.remoteHeadsPath);\n\n              case 7:\n                _context3.next = 9;\n                return this._cache.del(this.snapshotPath);\n\n              case 9:\n                _context3.next = 11;\n                return this._cache.del(this.queuePath);\n\n              case 11:\n                _context3.next = 13;\n                return this._cache.del(this.manifestPath);\n\n              case 13:\n                _context3.next = 15;\n                return this.close();\n\n              case 15:\n                // Reset\n                this._index = new this.options.Index(this.address.root);\n                this._oplog = new Log(this._ipfs, this.identity, {\n                  logId: this.id,\n                  access: this.access,\n                  sortFn: this.options.sortFn\n                });\n                this._cache = this.options.cache;\n\n              case 18:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function drop() {\n        return _drop.apply(this, arguments);\n      }\n\n      return drop;\n    }()\n  }, {\n    key: \"load\",\n    value: function () {\n      var _load = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(amount) {\n        var _this3 = this;\n\n        var opts,\n            fetchEntryTimeout,\n            localHeads,\n            remoteHeads,\n            heads,\n            log,\n            _args4 = arguments;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                opts = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};\n\n                if (typeof amount === 'object') {\n                  opts = amount;\n                  amount = undefined;\n                }\n\n                amount = amount || this.options.maxHistory;\n                fetchEntryTimeout = opts.fetchEntryTimeout || this.options.fetchEntryTimeout;\n\n                if (!this.options.onLoad) {\n                  _context4.next = 7;\n                  break;\n                }\n\n                _context4.next = 7;\n                return this.options.onLoad(this);\n\n              case 7:\n                _context4.next = 9;\n                return this._cache.get(this.localHeadsPath);\n\n              case 9:\n                _context4.t0 = _context4.sent;\n\n                if (_context4.t0) {\n                  _context4.next = 12;\n                  break;\n                }\n\n                _context4.t0 = [];\n\n              case 12:\n                localHeads = _context4.t0;\n                _context4.next = 15;\n                return this._cache.get(this.remoteHeadsPath);\n\n              case 15:\n                _context4.t1 = _context4.sent;\n\n                if (_context4.t1) {\n                  _context4.next = 18;\n                  break;\n                }\n\n                _context4.t1 = [];\n\n              case 18:\n                remoteHeads = _context4.t1;\n                heads = localHeads.concat(remoteHeads);\n\n                if (heads.length > 0) {\n                  this.events.emit('load', this.address.toString(), heads);\n                } // Update the replication status from the heads\n\n\n                heads.forEach(function (h) {\n                  return _this3._recalculateReplicationMax(h.clock.time);\n                }); // Load the log\n\n                _context4.next = 24;\n                return Log.fromEntryHash(this._ipfs, this.identity, heads.map(function (e) {\n                  return e.hash;\n                }), {\n                  logId: this._oplog.id,\n                  access: this.access,\n                  sortFn: this.options.sortFn,\n                  length: amount,\n                  exclude: this._oplog.values,\n                  onProgressCallback: this._onLoadProgress.bind(this),\n                  timeout: fetchEntryTimeout\n                });\n\n              case 24:\n                log = _context4.sent;\n                _context4.next = 27;\n                return this._oplog.join(log, amount);\n\n              case 27:\n                if (!(heads.length > 0)) {\n                  _context4.next = 30;\n                  break;\n                }\n\n                _context4.next = 30;\n                return this._updateIndex();\n\n              case 30:\n                this.events.emit('ready', this.address.toString(), this._oplog.heads);\n\n              case 31:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function load(_x3) {\n        return _load.apply(this, arguments);\n      }\n\n      return load;\n    }()\n  }, {\n    key: \"sync\",\n    value: function () {\n      var _sync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(heads) {\n        var _this4 = this;\n\n        var saveToIpfs, saved;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                this._stats.syncRequestsReceieved += 1;\n                logger.debug(\"Sync request #\".concat(this._stats.syncRequestsReceieved, \" \").concat(heads.length));\n\n                if (!(heads.length === 0)) {\n                  _context6.next = 4;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\");\n\n              case 4:\n                // To simulate network latency, uncomment this line\n                // and comment out the rest of the function\n                // That way the object (received as head message from pubsub)\n                // doesn't get written to IPFS and so when the Replicator is fetching\n                // the log, it'll fetch it from the network instead from the disk.\n                // return this._replicator.load(heads)\n                saveToIpfs = /*#__PURE__*/function () {\n                  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(head) {\n                    var identityProvider, canAppend, logEntry, hash;\n                    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n                      while (1) {\n                        switch (_context5.prev = _context5.next) {\n                          case 0:\n                            if (head) {\n                              _context5.next = 3;\n                              break;\n                            }\n\n                            console.warn(\"Warning: Given input entry was 'null'.\");\n                            return _context5.abrupt(\"return\", Promise.resolve(null));\n\n                          case 3:\n                            identityProvider = _this4.identity.provider;\n\n                            if (identityProvider) {\n                              _context5.next = 6;\n                              break;\n                            }\n\n                            throw new Error('Identity-provider is required, cannot verify entry');\n\n                          case 6:\n                            _context5.next = 8;\n                            return _this4.access.canAppend(head, identityProvider);\n\n                          case 8:\n                            canAppend = _context5.sent;\n\n                            if (canAppend) {\n                              _context5.next = 12;\n                              break;\n                            }\n\n                            console.warn('Warning: Given input entry is not allowed in this log and was discarded (no write access).');\n                            return _context5.abrupt(\"return\", Promise.resolve(null));\n\n                          case 12:\n                            logEntry = Entry.toEntry(head);\n                            _context5.next = 15;\n                            return io.write(_this4._ipfs, Entry.getWriteFormat(logEntry), logEntry, {\n                              links: Entry.IPLD_LINKS,\n                              onlyHash: true\n                            });\n\n                          case 15:\n                            hash = _context5.sent;\n\n                            if (hash !== head.hash) {\n                              console.warn('\"WARNING! Head hash didn\\'t match the contents');\n                            }\n\n                            return _context5.abrupt(\"return\", head);\n\n                          case 18:\n                          case \"end\":\n                            return _context5.stop();\n                        }\n                      }\n                    }, _callee5);\n                  }));\n\n                  return function saveToIpfs(_x5) {\n                    return _ref2.apply(this, arguments);\n                  };\n                }();\n\n                _context6.next = 7;\n                return mapSeries(heads, saveToIpfs);\n\n              case 7:\n                saved = _context6.sent;\n                _context6.next = 10;\n                return this._replicator.load(saved.filter(function (e) {\n                  return e !== null;\n                }));\n\n              case 10:\n                if (!(this._replicator._buffer.length || Object.values(this._replicator._queue).length)) {\n                  _context6.next = 12;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\", new Promise(function (resolve) {\n                  var progressHandler = function progressHandler(address, hash, entry, progress, have) {\n                    if (progress === have) {\n                      _this4.events.off('replicate.progress', progressHandler);\n\n                      _this4.events.once('replicated', resolve);\n                    }\n                  };\n\n                  _this4.events.on('replicate.progress', progressHandler);\n                }));\n\n              case 12:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function sync(_x4) {\n        return _sync.apply(this, arguments);\n      }\n\n      return sync;\n    }()\n  }, {\n    key: \"loadMoreFrom\",\n    value: function loadMoreFrom(amount, entries) {\n      this._replicator.load(entries);\n    }\n  }, {\n    key: \"saveSnapshot\",\n    value: function () {\n      var _saveSnapshot = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n        var unfinished, snapshotData, buf, snapshot;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                unfinished = this._replicator.getQueue();\n                snapshotData = this._oplog.toSnapshot();\n                buf = Buffer.from(JSON.stringify({\n                  id: snapshotData.id,\n                  heads: snapshotData.heads,\n                  size: snapshotData.values.length,\n                  values: snapshotData.values,\n                  type: this.type\n                }));\n                _context7.next = 5;\n                return this._ipfs.add(buf);\n\n              case 5:\n                snapshot = _context7.sent;\n                snapshot.hash = snapshot.cid.toString(); // js-ipfs >= 0.41, ipfs.add results contain a cid property (a CID instance) instead of a string hash property\n\n                _context7.next = 9;\n                return this._cache.set(this.snapshotPath, snapshot);\n\n              case 9:\n                _context7.next = 11;\n                return this._cache.set(this.queuePath, unfinished);\n\n              case 11:\n                logger.debug(\"Saved snapshot: \".concat(snapshot.hash, \", queue length: \").concat(unfinished.length));\n                return _context7.abrupt(\"return\", [snapshot]);\n\n              case 13:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function saveSnapshot() {\n        return _saveSnapshot.apply(this, arguments);\n      }\n\n      return saveSnapshot;\n    }()\n  }, {\n    key: \"loadFromSnapshot\",\n    value: function () {\n      var _loadFromSnapshot = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(onProgressCallback) {\n        var _this5 = this;\n\n        var maxClock, queue, snapshot, chunks, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, chunk, buffer, snapshotData, onProgress, log;\n\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                if (!this.options.onLoad) {\n                  _context8.next = 3;\n                  break;\n                }\n\n                _context8.next = 3;\n                return this.options.onLoad(this);\n\n              case 3:\n                this.events.emit('load', this.address.toString()); // TODO emits inconsistent params, missing heads param\n\n                maxClock = function maxClock(res, val) {\n                  return Math.max(res, val.clock.time);\n                };\n\n                _context8.next = 7;\n                return this._cache.get(this.queuePath);\n\n              case 7:\n                queue = _context8.sent;\n                this.sync(queue || []);\n                _context8.next = 11;\n                return this._cache.get(this.snapshotPath);\n\n              case 11:\n                snapshot = _context8.sent;\n\n                if (!snapshot) {\n                  _context8.next = 63;\n                  break;\n                }\n\n                chunks = [];\n                _iteratorNormalCompletion = true;\n                _didIteratorError = false;\n                _context8.prev = 16;\n                _iterator = _asyncIterator(this._ipfs.cat(snapshot.hash));\n\n              case 18:\n                _context8.next = 20;\n                return _iterator.next();\n\n              case 20:\n                _step = _context8.sent;\n                _iteratorNormalCompletion = _step.done;\n                _context8.next = 24;\n                return _step.value;\n\n              case 24:\n                _value = _context8.sent;\n\n                if (_iteratorNormalCompletion) {\n                  _context8.next = 31;\n                  break;\n                }\n\n                chunk = _value;\n                chunks.push(chunk);\n\n              case 28:\n                _iteratorNormalCompletion = true;\n                _context8.next = 18;\n                break;\n\n              case 31:\n                _context8.next = 37;\n                break;\n\n              case 33:\n                _context8.prev = 33;\n                _context8.t0 = _context8[\"catch\"](16);\n                _didIteratorError = true;\n                _iteratorError = _context8.t0;\n\n              case 37:\n                _context8.prev = 37;\n                _context8.prev = 38;\n\n                if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                  _context8.next = 42;\n                  break;\n                }\n\n                _context8.next = 42;\n                return _iterator.return();\n\n              case 42:\n                _context8.prev = 42;\n\n                if (!_didIteratorError) {\n                  _context8.next = 45;\n                  break;\n                }\n\n                throw _iteratorError;\n\n              case 45:\n                return _context8.finish(42);\n\n              case 46:\n                return _context8.finish(37);\n\n              case 47:\n                buffer = Buffer.concat(chunks);\n                snapshotData = JSON.parse(buffer.toString());\n\n                onProgress = function onProgress(hash, entry, count, total) {\n                  _this5._recalculateReplicationStatus(count, entry.clock.time);\n\n                  _this5._onLoadProgress(hash, entry);\n                }; // Fetch the entries\n                // Timeout 1 sec to only load entries that are already fetched (in order to not get stuck at loading)\n\n\n                this._recalculateReplicationMax(snapshotData.values.reduce(maxClock, 0));\n\n                if (!snapshotData) {\n                  _context8.next = 60;\n                  break;\n                }\n\n                _context8.next = 54;\n                return Log.fromJSON(this._ipfs, this.identity, snapshotData, {\n                  access: this.access,\n                  sortFn: this.options.sortFn,\n                  length: -1,\n                  timeout: 1000,\n                  onProgressCallback: onProgress\n                });\n\n              case 54:\n                log = _context8.sent;\n                _context8.next = 57;\n                return this._oplog.join(log);\n\n              case 57:\n                _context8.next = 59;\n                return this._updateIndex();\n\n              case 59:\n                this.events.emit('replicated', this.address.toString()); // TODO: inconsistent params, count param not emited\n\n              case 60:\n                this.events.emit('ready', this.address.toString(), this._oplog.heads);\n                _context8.next = 64;\n                break;\n\n              case 63:\n                throw new Error(\"Snapshot for \".concat(this.address, \" not found!\"));\n\n              case 64:\n                return _context8.abrupt(\"return\", this);\n\n              case 65:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this, [[16, 33, 37, 47], [38,, 42, 46]]);\n      }));\n\n      function loadFromSnapshot(_x6) {\n        return _loadFromSnapshot.apply(this, arguments);\n      }\n\n      return loadFromSnapshot;\n    }()\n  }, {\n    key: \"_updateIndex\",\n    value: function () {\n      var _updateIndex2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                this._recalculateReplicationMax();\n\n                _context9.next = 3;\n                return this._index.updateIndex(this._oplog);\n\n              case 3:\n                this._recalculateReplicationProgress();\n\n              case 4:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function _updateIndex() {\n        return _updateIndex2.apply(this, arguments);\n      }\n\n      return _updateIndex;\n    }()\n  }, {\n    key: \"syncLocal\",\n    value: function () {\n      var _syncLocal = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {\n        var localHeads, remoteHeads, heads, i, head;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _context10.next = 2;\n                return this._cache.get(this.localHeadsPath);\n\n              case 2:\n                _context10.t0 = _context10.sent;\n\n                if (_context10.t0) {\n                  _context10.next = 5;\n                  break;\n                }\n\n                _context10.t0 = [];\n\n              case 5:\n                localHeads = _context10.t0;\n                _context10.next = 8;\n                return this._cache.get(this.remoteHeadsPath);\n\n              case 8:\n                _context10.t1 = _context10.sent;\n\n                if (_context10.t1) {\n                  _context10.next = 11;\n                  break;\n                }\n\n                _context10.t1 = [];\n\n              case 11:\n                remoteHeads = _context10.t1;\n                heads = localHeads.concat(remoteHeads);\n                i = 0;\n\n              case 14:\n                if (!(i < heads.length)) {\n                  _context10.next = 23;\n                  break;\n                }\n\n                head = heads[i];\n\n                if (this._oplog.heads.includes(head)) {\n                  _context10.next = 20;\n                  break;\n                }\n\n                _context10.next = 19;\n                return this.load();\n\n              case 19:\n                return _context10.abrupt(\"break\", 23);\n\n              case 20:\n                i++;\n                _context10.next = 14;\n                break;\n\n              case 23:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function syncLocal() {\n        return _syncLocal.apply(this, arguments);\n      }\n\n      return syncLocal;\n    }()\n  }, {\n    key: \"_addOperation\",\n    value: function () {\n      var _addOperation2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(data) {\n        var _ref3,\n            onProgressCallback,\n            _ref3$pin,\n            pin,\n            addOperation,\n            _addOperation3,\n            _args12 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _addOperation3 = function _addOperation5() {\n                  _addOperation3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11() {\n                    var entry;\n                    return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n                      while (1) {\n                        switch (_context11.prev = _context11.next) {\n                          case 0:\n                            if (!this._oplog) {\n                              _context11.next = 15;\n                              break;\n                            }\n\n                            if (!this.options.syncLocal) {\n                              _context11.next = 4;\n                              break;\n                            }\n\n                            _context11.next = 4;\n                            return this.syncLocal();\n\n                          case 4:\n                            _context11.next = 6;\n                            return this._oplog.append(data, this.options.referenceCount, pin);\n\n                          case 6:\n                            entry = _context11.sent;\n\n                            this._recalculateReplicationStatus(this.replicationStatus.progress + 1, entry.clock.time);\n\n                            _context11.next = 10;\n                            return this._cache.set(this.localHeadsPath, [entry]);\n\n                          case 10:\n                            _context11.next = 12;\n                            return this._updateIndex();\n\n                          case 12:\n                            this.events.emit('write', this.address.toString(), entry, this._oplog.heads);\n                            if (onProgressCallback) onProgressCallback(entry);\n                            return _context11.abrupt(\"return\", entry.hash);\n\n                          case 15:\n                          case \"end\":\n                            return _context11.stop();\n                        }\n                      }\n                    }, _callee11, this);\n                  }));\n                  return _addOperation3.apply(this, arguments);\n                };\n\n                addOperation = function _addOperation4() {\n                  return _addOperation3.apply(this, arguments);\n                };\n\n                _ref3 = _args12.length > 1 && _args12[1] !== undefined ? _args12[1] : {}, onProgressCallback = _ref3.onProgressCallback, _ref3$pin = _ref3.pin, pin = _ref3$pin === void 0 ? false : _ref3$pin;\n                return _context12.abrupt(\"return\", this._opqueue.add(addOperation.bind(this)));\n\n              case 4:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function _addOperation(_x7) {\n        return _addOperation2.apply(this, arguments);\n      }\n\n      return _addOperation;\n    }()\n  }, {\n    key: \"_addOperationBatch\",\n    value: function _addOperationBatch(data, batchOperation, lastOperation, onProgressCallback) {\n      throw new Error('Not implemented!');\n    }\n  }, {\n    key: \"_procEntry\",\n    value: function _procEntry(entry) {\n      var payload = entry.payload,\n          hash = entry.hash;\n      var op = payload.op;\n\n      if (op) {\n        this.events.emit(\"log.op.\".concat(op), this.address.toString(), hash, payload);\n      } else {\n        this.events.emit('log.op.none', this.address.toString(), hash, payload);\n      }\n\n      this.events.emit('log.op', op, this.address.toString(), hash, payload);\n    }\n  }, {\n    key: \"_onLoadProgress\",\n    value: function _onLoadProgress(hash, entry, progress, total) {\n      this._recalculateReplicationStatus(progress, total);\n\n      this.events.emit('load.progress', this.address.toString(), hash, entry, this.replicationStatus.progress, this.replicationStatus.max);\n    }\n    /* Replication Status state updates */\n\n  }, {\n    key: \"_recalculateReplicationProgress\",\n    value: function _recalculateReplicationProgress(max) {\n      this._replicationStatus.progress = Math.max.apply(null, [this._replicationStatus.progress, this._oplog.length, max || 0]);\n\n      this._recalculateReplicationMax(this.replicationStatus.progress);\n    }\n  }, {\n    key: \"_recalculateReplicationMax\",\n    value: function _recalculateReplicationMax(max) {\n      this._replicationStatus.max = Math.max.apply(null, [this._replicationStatus.max, this._oplog.length, max || 0]);\n    }\n  }, {\n    key: \"_recalculateReplicationStatus\",\n    value: function _recalculateReplicationStatus(maxProgress, maxTotal) {\n      this._recalculateReplicationProgress(maxProgress);\n\n      this._recalculateReplicationMax(maxTotal);\n    }\n  }]);\n\n  return Store;\n}();\n\nmodule.exports = Store;\nmodule.exports.DefaultOptions = DefaultOptions;","map":null,"metadata":{},"sourceType":"script"}