{"ast":null,"code":"'use strict';\n\nclass CancelError extends Error {\n  constructor(reason) {\n    super(reason || 'Promise was canceled');\n    this.name = 'CancelError';\n  }\n\n  get isCanceled() {\n    return true;\n  }\n\n}\n\nclass PCancelable {\n  static fn(userFn) {\n    return (...arguments_) => {\n      return new PCancelable((resolve, reject, onCancel) => {\n        arguments_.push(onCancel); // eslint-disable-next-line promise/prefer-await-to-then\n\n        userFn(...arguments_).then(resolve, reject);\n      });\n    };\n  }\n\n  constructor(executor) {\n    this._cancelHandlers = [];\n    this._isPending = true;\n    this._isCanceled = false;\n    this._rejectOnCancel = true;\n    this._promise = new Promise((resolve, reject) => {\n      this._reject = reject;\n\n      const onResolve = value => {\n        if (!this._isCanceled || !onCancel.shouldReject) {\n          this._isPending = false;\n          resolve(value);\n        }\n      };\n\n      const onReject = error => {\n        this._isPending = false;\n        reject(error);\n      };\n\n      const onCancel = handler => {\n        if (!this._isPending) {\n          throw new Error('The `onCancel` handler was attached after the promise settled.');\n        }\n\n        this._cancelHandlers.push(handler);\n      };\n\n      Object.defineProperties(onCancel, {\n        shouldReject: {\n          get: () => this._rejectOnCancel,\n          set: boolean => {\n            this._rejectOnCancel = boolean;\n          }\n        }\n      });\n      return executor(onResolve, onReject, onCancel);\n    });\n  }\n\n  then(onFulfilled, onRejected) {\n    // eslint-disable-next-line promise/prefer-await-to-then\n    return this._promise.then(onFulfilled, onRejected);\n  }\n\n  catch(onRejected) {\n    return this._promise.catch(onRejected);\n  }\n\n  finally(onFinally) {\n    return this._promise.finally(onFinally);\n  }\n\n  cancel(reason) {\n    if (!this._isPending || this._isCanceled) {\n      return;\n    }\n\n    this._isCanceled = true;\n\n    if (this._cancelHandlers.length > 0) {\n      try {\n        for (const handler of this._cancelHandlers) {\n          handler();\n        }\n      } catch (error) {\n        this._reject(error);\n\n        return;\n      }\n    }\n\n    if (this._rejectOnCancel) {\n      this._reject(new CancelError(reason));\n    }\n  }\n\n  get isCanceled() {\n    return this._isCanceled;\n  }\n\n}\n\nObject.setPrototypeOf(PCancelable.prototype, Promise.prototype);\nmodule.exports = PCancelable;\nmodule.exports.CancelError = CancelError;","map":null,"metadata":{},"sourceType":"script"}