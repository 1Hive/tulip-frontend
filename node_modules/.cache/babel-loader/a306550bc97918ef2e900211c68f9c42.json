{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar PeerId = require('peer-id');\n\nvar crypto = require('libp2p-crypto');\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:secio');\nlog.error = debug('libp2p:secio:error');\n\nvar pbm = require('./secio.proto');\n\nvar support = require('../support');\n\nvar _require2 = require('libp2p-interfaces/src/crypto/errors'),\n    UnexpectedPeerError = _require2.UnexpectedPeerError; // nonceSize is the size of our nonces (in bytes)\n\n\nvar nonceSize = 16;\n\nexports.createProposal = function (state) {\n  state.proposal.out = {\n    rand: crypto.randomBytes(nonceSize),\n    pubkey: state.key.local.public.bytes,\n    exchanges: support.exchanges.join(','),\n    ciphers: support.ciphers.join(','),\n    hashes: support.hashes.join(',')\n  };\n  state.proposalEncoded.out = pbm.Propose.encode(state.proposal.out);\n  return state.proposalEncoded.out;\n};\n\nexports.createExchange = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(state) {\n    var res, selectionOut, sig;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return crypto.keys.generateEphemeralKeyPair(state.protocols.local.curveT);\n\n          case 2:\n            res = _context.sent;\n            state.ephemeralKey.local = res.key;\n            state.shared.generate = res.genSharedKey; // Gather corpus to sign.\n\n            selectionOut = Buffer.concat([state.proposalEncoded.out, state.proposalEncoded.in, state.ephemeralKey.local]);\n            _context.next = 8;\n            return state.key.local.sign(selectionOut);\n\n          case 8:\n            sig = _context.sent;\n            state.exchange.out = {\n              epubkey: state.ephemeralKey.local,\n              signature: sig\n            };\n            return _context.abrupt(\"return\", pbm.Exchange.encode(state.exchange.out));\n\n          case 11:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function (_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nexports.identify = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(state, msg) {\n    var pubkey, remoteId;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            log('1.1 identify');\n            state.proposalEncoded.in = msg;\n            state.proposal.in = pbm.Propose.decode(msg);\n            pubkey = state.proposal.in.pubkey;\n            state.key.remote = crypto.keys.unmarshalPublicKey(pubkey);\n            _context2.next = 7;\n            return PeerId.createFromPubKey(pubkey.toString('base64'));\n\n          case 7:\n            remoteId = _context2.sent;\n\n            if (!state.id.remote) {\n              _context2.next = 14;\n              break;\n            }\n\n            if (!(state.id.remote.toString() !== remoteId.toString())) {\n              _context2.next = 11;\n              break;\n            }\n\n            throw new UnexpectedPeerError('Dialed to the wrong peer: IDs do not match!');\n\n          case 11:\n            state.id.remote.pubKey = state.key.remote;\n            _context2.next = 15;\n            break;\n\n          case 14:\n            state.id.remote = remoteId;\n\n          case 15:\n            log('1.1 identify - %s - identified remote peer as %s', state.id.local.toB58String(), state.id.remote.toB58String());\n\n          case 16:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function (_x2, _x3) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nexports.selectProtocols = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(state) {\n    var local, remote, selected;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            log('1.2 selection');\n            local = {\n              pubKeyBytes: state.key.local.public.bytes,\n              exchanges: support.exchanges,\n              hashes: support.hashes,\n              ciphers: support.ciphers,\n              nonce: state.proposal.out.rand\n            };\n            remote = {\n              pubKeyBytes: state.proposal.in.pubkey,\n              exchanges: state.proposal.in.exchanges.split(','),\n              hashes: state.proposal.in.hashes.split(','),\n              ciphers: state.proposal.in.ciphers.split(','),\n              nonce: state.proposal.in.rand\n            };\n            _context3.next = 5;\n            return support.selectBest(local, remote);\n\n          case 5:\n            selected = _context3.sent;\n            // we use the same params for both directions (must choose same curve)\n            // WARNING: if they dont SelectBest the same way, this won't work...\n            state.protocols.remote = {\n              order: selected.order,\n              curveT: selected.curveT,\n              cipherT: selected.cipherT,\n              hashT: selected.hashT\n            };\n            state.protocols.local = {\n              order: selected.order,\n              curveT: selected.curveT,\n              cipherT: selected.cipherT,\n              hashT: selected.hashT\n            };\n\n          case 8:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function (_x4) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nexports.verify = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(state, msg) {\n    var selectionIn, sigOk;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            log('2.1. verify');\n            state.exchange.in = pbm.Exchange.decode(msg);\n            state.ephemeralKey.remote = state.exchange.in.epubkey;\n            selectionIn = Buffer.concat([state.proposalEncoded.in, state.proposalEncoded.out, state.ephemeralKey.remote]);\n            _context4.next = 6;\n            return state.key.remote.verify(selectionIn, state.exchange.in.signature);\n\n          case 6:\n            sigOk = _context4.sent;\n\n            if (sigOk) {\n              _context4.next = 9;\n              break;\n            }\n\n            throw new Error('Bad signature');\n\n          case 9:\n            log('2.1. verify - signature verified');\n\n          case 10:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n\n  return function (_x5, _x6) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\nexports.generateKeys = /*#__PURE__*/function () {\n  var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(state) {\n    var secret, keys;\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            log('2.2. keys');\n            _context5.next = 3;\n            return state.shared.generate(state.exchange.in.epubkey);\n\n          case 3:\n            secret = _context5.sent;\n            state.shared.secret = secret;\n            _context5.next = 7;\n            return crypto.keys.keyStretcher(state.protocols.local.cipherT, state.protocols.local.hashT, state.shared.secret);\n\n          case 7:\n            keys = _context5.sent;\n\n            if (!(state.protocols.local.order > 0)) {\n              _context5.next = 13;\n              break;\n            }\n\n            state.protocols.local.keys = keys.k1;\n            state.protocols.remote.keys = keys.k2;\n            _context5.next = 19;\n            break;\n\n          case 13:\n            if (!(state.protocols.local.order < 0)) {\n              _context5.next = 18;\n              break;\n            }\n\n            // swap\n            state.protocols.local.keys = keys.k2;\n            state.protocols.remote.keys = keys.k1;\n            _context5.next = 19;\n            break;\n\n          case 18:\n            throw new Error('you are trying to talk to yourself');\n\n          case 19:\n            log('2.3. mac + cipher');\n            _context5.next = 22;\n            return Promise.all([state.protocols.local, state.protocols.remote].map(function (data) {\n              return support.makeMacAndCipher(data);\n            }));\n\n          case 22:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n\n  return function (_x7) {\n    return _ref5.apply(this, arguments);\n  };\n}();\n\nexports.verifyNonce = function (state, n2) {\n  var n1 = state.proposal.out.rand;\n  if (n1.equals(n2)) return;\n  throw new Error(\"Failed to read our encrypted nonce: \".concat(n1.toString('hex'), \" != \").concat(n2.toString('hex')));\n};","map":null,"metadata":{},"sourceType":"script"}