{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _objectSpread = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar log = require('debug')('ipfs:components:init');\n\nvar PeerId = require('peer-id');\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar PeerInfo = require('peer-info');\n\nvar mergeOptions = require('merge-options');\n\nvar getDefaultConfig = require('../runtime/config-nodejs.js');\n\nvar createRepo = require('../runtime/repo-nodejs');\n\nvar Keychain = require('libp2p-keychain');\n\nvar NoKeychain = require('./no-keychain');\n\nvar mortice = require('mortice');\n\nvar _require2 = require('ipld-dag-pb'),\n    DAGNode = _require2.DAGNode;\n\nvar UnixFs = require('ipfs-unixfs');\n\nvar multicodec = require('multicodec');\n\nvar _require3 = require('../errors'),\n    AlreadyInitializingError = _require3.AlreadyInitializingError,\n    AlreadyInitializedError = _require3.AlreadyInitializedError,\n    NotStartedError = _require3.NotStartedError,\n    NotEnabledError = _require3.NotEnabledError;\n\nvar BlockService = require('ipfs-block-service');\n\nvar Ipld = require('ipld');\n\nvar getDefaultIpldOptions = require('../runtime/ipld-nodejs');\n\nvar createPreloader = require('../preload');\n\nvar ERR_REPO_NOT_INITIALIZED = require('ipfs-repo').errors.ERR_REPO_NOT_INITIALIZED;\n\nvar IPNS = require('../ipns');\n\nvar OfflineDatastore = require('../ipns/routing/offline-datastore');\n\nvar initAssets = require('../runtime/init-assets-nodejs');\n\nvar PinManager = require('./pin/pin-manager');\n\nvar Components = require('./');\n\nmodule.exports = function (_ref) {\n  var apiManager = _ref.apiManager,\n      print = _ref.print,\n      constructorOptions = _ref.options;\n  return /*#__PURE__*/function () {\n    var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(options) {\n      var _apiManager$update, cancel, repo, isInitialized, _ref2, peerId, keychain, peerInfo, blockService, ipld, preload, gcLock, dag, object, pinManager, pin, block, add, emptyDirCid, offlineDatastore, ipns, api;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _apiManager$update = apiManager.update({\n                init: function init() {\n                  throw new AlreadyInitializingError();\n                }\n              }), cancel = _apiManager$update.cancel;\n              _context.prev = 1;\n              options = options || {};\n\n              if (typeof constructorOptions.init === 'object') {\n                options = mergeOptions(constructorOptions.init, options);\n              }\n\n              options.pass = options.pass || constructorOptions.pass;\n\n              if (constructorOptions.config) {\n                options.config = mergeOptions(options.config, constructorOptions.config);\n              }\n\n              options.repo = options.repo || constructorOptions.repo;\n              options.repoAutoMigrate = options.repoAutoMigrate || constructorOptions.repoAutoMigrate;\n              repo = typeof options.repo === 'string' || options.repo == null ? createRepo({\n                path: options.repo,\n                autoMigrate: options.repoAutoMigrate\n              }) : options.repo;\n              isInitialized = true;\n\n              if (!repo.closed) {\n                _context.next = 23;\n                break;\n              }\n\n              _context.prev = 11;\n              _context.next = 14;\n              return repo.open();\n\n            case 14:\n              _context.next = 23;\n              break;\n\n            case 16:\n              _context.prev = 16;\n              _context.t0 = _context[\"catch\"](11);\n\n              if (!(_context.t0.code === ERR_REPO_NOT_INITIALIZED)) {\n                _context.next = 22;\n                break;\n              }\n\n              isInitialized = false;\n              _context.next = 23;\n              break;\n\n            case 22:\n              throw _context.t0;\n\n            case 23:\n              if (!(!isInitialized && options.allowNew === false)) {\n                _context.next = 25;\n                break;\n              }\n\n              throw new NotEnabledError('new repo initialization is not enabled');\n\n            case 25:\n              if (!isInitialized) {\n                _context.next = 31;\n                break;\n              }\n\n              _context.next = 28;\n              return initExistingRepo(repo, options);\n\n            case 28:\n              _context.t1 = _context.sent;\n              _context.next = 34;\n              break;\n\n            case 31:\n              _context.next = 33;\n              return initNewRepo(repo, _objectSpread(_objectSpread({}, options), {}, {\n                print: print\n              }));\n\n            case 33:\n              _context.t1 = _context.sent;\n\n            case 34:\n              _ref2 = _context.t1;\n              peerId = _ref2.peerId;\n              keychain = _ref2.keychain;\n              log('peer created');\n              peerInfo = new PeerInfo(peerId);\n              blockService = new BlockService(repo);\n              ipld = new Ipld(getDefaultIpldOptions(blockService, constructorOptions.ipld, log));\n              preload = createPreloader(constructorOptions.preload);\n              _context.next = 44;\n              return preload.start();\n\n            case 44:\n              // Make sure GC lock is specific to repo, for tests where there are\n              // multiple instances of IPFS\n              gcLock = mortice(repo.path, {\n                singleProcess: constructorOptions.repoOwner !== false\n              });\n              dag = {\n                get: Components.dag.get({\n                  ipld: ipld,\n                  preload: preload\n                }),\n                resolve: Components.dag.resolve({\n                  ipld: ipld,\n                  preload: preload\n                }),\n                tree: Components.dag.tree({\n                  ipld: ipld,\n                  preload: preload\n                })\n              };\n              object = {\n                data: Components.object.data({\n                  ipld: ipld,\n                  preload: preload\n                }),\n                get: Components.object.get({\n                  ipld: ipld,\n                  preload: preload\n                }),\n                links: Components.object.links({\n                  dag: dag\n                }),\n                new: Components.object.new({\n                  ipld: ipld,\n                  preload: preload\n                }),\n                patch: {\n                  addLink: Components.object.patch.addLink({\n                    ipld: ipld,\n                    gcLock: gcLock,\n                    preload: preload\n                  }),\n                  appendData: Components.object.patch.appendData({\n                    ipld: ipld,\n                    gcLock: gcLock,\n                    preload: preload\n                  }),\n                  rmLink: Components.object.patch.rmLink({\n                    ipld: ipld,\n                    gcLock: gcLock,\n                    preload: preload\n                  }),\n                  setData: Components.object.patch.setData({\n                    ipld: ipld,\n                    gcLock: gcLock,\n                    preload: preload\n                  })\n                },\n                put: Components.object.put({\n                  ipld: ipld,\n                  gcLock: gcLock,\n                  preload: preload\n                }),\n                stat: Components.object.stat({\n                  ipld: ipld,\n                  preload: preload\n                })\n              };\n              pinManager = new PinManager(repo, dag);\n              _context.next = 50;\n              return pinManager.load();\n\n            case 50:\n              pin = {\n                add: Components.pin.add({\n                  pinManager: pinManager,\n                  gcLock: gcLock,\n                  dag: dag\n                }),\n                ls: Components.pin.ls({\n                  pinManager: pinManager,\n                  dag: dag\n                }),\n                rm: Components.pin.rm({\n                  pinManager: pinManager,\n                  gcLock: gcLock,\n                  dag: dag\n                })\n              }; // FIXME: resolve this circular dependency\n\n              dag.put = Components.dag.put({\n                ipld: ipld,\n                pin: pin,\n                gcLock: gcLock,\n                preload: preload\n              });\n              block = {\n                get: Components.block.get({\n                  blockService: blockService,\n                  preload: preload\n                }),\n                put: Components.block.put({\n                  blockService: blockService,\n                  pin: pin,\n                  gcLock: gcLock,\n                  preload: preload\n                }),\n                rm: Components.block.rm({\n                  blockService: blockService,\n                  gcLock: gcLock,\n                  pinManager: pinManager\n                }),\n                stat: Components.block.stat({\n                  blockService: blockService,\n                  preload: preload\n                })\n              };\n              add = Components.add({\n                block: block,\n                preload: preload,\n                pin: pin,\n                gcLock: gcLock,\n                options: constructorOptions\n              });\n\n              if (!(!isInitialized && !options.emptyRepo)) {\n                _context.next = 66;\n                break;\n              }\n\n              _context.next = 57;\n              return addEmptyDir({\n                dag: dag\n              });\n\n            case 57:\n              emptyDirCid = _context.sent;\n              log('adding default assets');\n              _context.next = 61;\n              return initAssets({\n                add: add,\n                print: print\n              });\n\n            case 61:\n              log('initializing IPNS keyspace'); // Setup the offline routing for IPNS.\n              // This is primarily used for offline ipns modifications, such as the initializeKeyspace feature.\n\n              offlineDatastore = new OfflineDatastore(repo);\n              ipns = new IPNS(offlineDatastore, repo.datastore, peerInfo, keychain, {\n                pass: options.pass\n              });\n              _context.next = 66;\n              return ipns.initializeKeyspace(peerId.privKey, emptyDirCid.toString());\n\n            case 66:\n              api = createApi({\n                add: add,\n                apiManager: apiManager,\n                constructorOptions: constructorOptions,\n                block: block,\n                blockService: blockService,\n                dag: dag,\n                gcLock: gcLock,\n                initOptions: options,\n                ipld: ipld,\n                keychain: keychain,\n                object: object,\n                peerInfo: peerInfo,\n                pin: pin,\n                pinManager: pinManager,\n                preload: preload,\n                print: print,\n                repo: repo\n              });\n              apiManager.update(api, function () {\n                throw new NotStartedError();\n              });\n              _context.next = 74;\n              break;\n\n            case 70:\n              _context.prev = 70;\n              _context.t2 = _context[\"catch\"](1);\n              cancel();\n              throw _context.t2;\n\n            case 74:\n              return _context.abrupt(\"return\", apiManager.api);\n\n            case 75:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[1, 70], [11, 16]]);\n    }));\n\n    function init(_x) {\n      return _init.apply(this, arguments);\n    }\n\n    return init;\n  }();\n};\n\nfunction initNewRepo(_x2, _x3) {\n  return _initNewRepo.apply(this, arguments);\n}\n\nfunction _initNewRepo() {\n  _initNewRepo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(repo, _ref3) {\n    var privateKey, emptyRepo, bits, profiles, config, pass, print, exists, peerId, keychain, keychainOptions;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            privateKey = _ref3.privateKey, emptyRepo = _ref3.emptyRepo, bits = _ref3.bits, profiles = _ref3.profiles, config = _ref3.config, pass = _ref3.pass, print = _ref3.print;\n            emptyRepo = emptyRepo || false;\n            bits = bits == null ? 2048 : Number(bits);\n            config = mergeOptions(applyProfiles(profiles, getDefaultConfig()), config); // Verify repo does not exist yet\n\n            _context4.next = 6;\n            return repo.exists();\n\n          case 6:\n            exists = _context4.sent;\n            log('repo exists?', exists);\n\n            if (!(exists === true)) {\n              _context4.next = 10;\n              break;\n            }\n\n            throw new Error('repo already exists');\n\n          case 10:\n            _context4.next = 12;\n            return createPeerId({\n              privateKey: privateKey,\n              bits: bits,\n              print: print\n            });\n\n          case 12:\n            peerId = _context4.sent;\n            keychain = new NoKeychain();\n            log('identity generated');\n            config.Identity = {\n              PeerID: peerId.toB58String(),\n              PrivKey: peerId.privKey.bytes.toString('base64')\n            };\n            privateKey = peerId.privKey;\n            config.Keychain = Keychain.generateOptions();\n            log('peer identity: %s', config.Identity.PeerID);\n            _context4.next = 21;\n            return repo.init(config);\n\n          case 21:\n            _context4.next = 23;\n            return repo.open();\n\n          case 23:\n            log('repo opened');\n\n            if (!pass) {\n              _context4.next = 30;\n              break;\n            }\n\n            log('creating keychain');\n            keychainOptions = _objectSpread({\n              passPhrase: pass\n            }, config.Keychain);\n            keychain = new Keychain(repo.keys, keychainOptions);\n            _context4.next = 30;\n            return keychain.importPeer('self', {\n              privKey: privateKey\n            });\n\n          case 30:\n            return _context4.abrupt(\"return\", {\n              peerId: peerId,\n              keychain: keychain\n            });\n\n          case 31:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n  return _initNewRepo.apply(this, arguments);\n}\n\nfunction initExistingRepo(_x4, _x5) {\n  return _initExistingRepo.apply(this, arguments);\n}\n\nfunction _initExistingRepo() {\n  _initExistingRepo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(repo, _ref4) {\n    var newConfig, profiles, pass, config, keychain, keychainOptions, peerId;\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            newConfig = _ref4.config, profiles = _ref4.profiles, pass = _ref4.pass;\n            _context5.next = 3;\n            return repo.config.get();\n\n          case 3:\n            config = _context5.sent;\n\n            if (!(newConfig || profiles)) {\n              _context5.next = 9;\n              break;\n            }\n\n            if (profiles) {\n              config = applyProfiles(profiles, config);\n            }\n\n            if (newConfig) {\n              config = mergeOptions(config, newConfig);\n            }\n\n            _context5.next = 9;\n            return repo.config.set(config);\n\n          case 9:\n            keychain = new NoKeychain();\n\n            if (pass) {\n              keychainOptions = _objectSpread({\n                passPhrase: pass\n              }, config.Keychain);\n              keychain = new Keychain(repo.keys, keychainOptions);\n              log('keychain constructed');\n            }\n\n            _context5.next = 13;\n            return PeerId.createFromPrivKey(config.Identity.PrivKey);\n\n          case 13:\n            peerId = _context5.sent;\n\n            if (!pass) {\n              _context5.next = 25;\n              break;\n            }\n\n            _context5.prev = 15;\n            _context5.next = 18;\n            return keychain.findKeyByName('self');\n\n          case 18:\n            _context5.next = 25;\n            break;\n\n          case 20:\n            _context5.prev = 20;\n            _context5.t0 = _context5[\"catch\"](15);\n            log('Creating \"self\" key');\n            _context5.next = 25;\n            return keychain.importPeer('self', peerId);\n\n          case 25:\n            return _context5.abrupt(\"return\", {\n              peerId: peerId,\n              keychain: keychain\n            });\n\n          case 26:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5, null, [[15, 20]]);\n  }));\n  return _initExistingRepo.apply(this, arguments);\n}\n\nfunction createPeerId(_ref5) {\n  var privateKey = _ref5.privateKey,\n      bits = _ref5.bits,\n      print = _ref5.print;\n\n  if (privateKey) {\n    log('using user-supplied private-key');\n    return typeof privateKey === 'object' ? privateKey : PeerId.createFromPrivKey(Buffer.from(privateKey, 'base64'));\n  } else {\n    // Generate peer identity keypair + transform to desired format + add to config.\n    print('generating %s-bit RSA keypair...', bits);\n    return PeerId.create({\n      bits: bits\n    });\n  }\n}\n\nfunction addEmptyDir(_ref6) {\n  var dag = _ref6.dag;\n  var node = new DAGNode(new UnixFs('directory').marshal());\n  return dag.put(node, {\n    version: 0,\n    format: multicodec.DAG_PB,\n    hashAlg: multicodec.SHA2_256,\n    preload: false\n  });\n} // Apply profiles (e.g. ['server', 'lowpower']) to config\n\n\nfunction applyProfiles(profiles, config) {\n  return (profiles || []).reduce(function (config, name) {\n    var profile = require('./config').profiles[name];\n\n    if (!profile) {\n      throw new Error(\"Could not find profile with name '\".concat(name, \"'\"));\n    }\n\n    log('applying profile %s', name);\n    return profile.transform(config);\n  }, config);\n}\n\nfunction createApi(_ref7) {\n  var add = _ref7.add,\n      apiManager = _ref7.apiManager,\n      constructorOptions = _ref7.constructorOptions,\n      block = _ref7.block,\n      blockService = _ref7.blockService,\n      dag = _ref7.dag,\n      gcLock = _ref7.gcLock,\n      initOptions = _ref7.initOptions,\n      ipld = _ref7.ipld,\n      keychain = _ref7.keychain,\n      object = _ref7.object,\n      peerInfo = _ref7.peerInfo,\n      pin = _ref7.pin,\n      pinManager = _ref7.pinManager,\n      preload = _ref7.preload,\n      print = _ref7.print,\n      repo = _ref7.repo;\n\n  var notStarted = /*#__PURE__*/function () {\n    var _ref8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              throw new NotStartedError();\n\n            case 1:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    return function notStarted() {\n      return _ref8.apply(this, arguments);\n    };\n  }();\n\n  var resolve = Components.resolve({\n    ipld: ipld\n  });\n  var refs = Components.refs({\n    ipld: ipld,\n    resolve: resolve,\n    preload: preload\n  });\n  refs.local = Components.refs.local({\n    repo: repo\n  });\n  var api = {\n    add: add,\n    bitswap: {\n      stat: notStarted,\n      unwant: notStarted,\n      wantlist: notStarted\n    },\n    bootstrap: {\n      add: Components.bootstrap.add({\n        repo: repo\n      }),\n      list: Components.bootstrap.list({\n        repo: repo\n      }),\n      rm: Components.bootstrap.rm({\n        repo: repo\n      })\n    },\n    block: block,\n    cat: Components.cat({\n      ipld: ipld,\n      preload: preload\n    }),\n    config: Components.config({\n      repo: repo\n    }),\n    dag: dag,\n    dns: Components.dns(),\n    files: Components.files({\n      ipld: ipld,\n      block: block,\n      blockService: blockService,\n      repo: repo,\n      preload: preload,\n      options: constructorOptions\n    }),\n    get: Components.get({\n      ipld: ipld,\n      preload: preload\n    }),\n    id: Components.id({\n      peerInfo: peerInfo\n    }),\n    init: function () {\n      var _init2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                throw new AlreadyInitializedError();\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      function init() {\n        return _init2.apply(this, arguments);\n      }\n\n      return init;\n    }(),\n    // eslint-disable-line require-await\n    isOnline: Components.isOnline({}),\n    key: {\n      export: Components.key.export({\n        keychain: keychain\n      }),\n      gen: Components.key.gen({\n        keychain: keychain\n      }),\n      import: Components.key.import({\n        keychain: keychain\n      }),\n      info: Components.key.info({\n        keychain: keychain\n      }),\n      list: Components.key.list({\n        keychain: keychain\n      }),\n      rename: Components.key.rename({\n        keychain: keychain\n      }),\n      rm: Components.key.rm({\n        keychain: keychain\n      })\n    },\n    ls: Components.ls({\n      ipld: ipld,\n      preload: preload\n    }),\n    object: object,\n    pin: pin,\n    refs: refs,\n    repo: {\n      gc: Components.repo.gc({\n        gcLock: gcLock,\n        pin: pin,\n        pinManager: pinManager,\n        refs: refs,\n        repo: repo\n      }),\n      stat: Components.repo.stat({\n        repo: repo\n      }),\n      version: Components.repo.version({\n        repo: repo\n      })\n    },\n    resolve: resolve,\n    start: Components.start({\n      apiManager: apiManager,\n      options: constructorOptions,\n      blockService: blockService,\n      gcLock: gcLock,\n      initOptions: initOptions,\n      ipld: ipld,\n      keychain: keychain,\n      peerInfo: peerInfo,\n      pinManager: pinManager,\n      preload: preload,\n      print: print,\n      repo: repo\n    }),\n    stats: {\n      bitswap: notStarted,\n      bw: notStarted,\n      repo: Components.repo.stat({\n        repo: repo\n      })\n    },\n    stop: function stop() {},\n    swarm: {\n      addrs: notStarted,\n      connect: notStarted,\n      disconnect: notStarted,\n      localAddrs: Components.swarm.localAddrs({\n        peerInfo: peerInfo\n      }),\n      peers: notStarted\n    },\n    version: Components.version({\n      repo: repo\n    })\n  };\n  return api;\n}","map":null,"metadata":{},"sourceType":"script"}