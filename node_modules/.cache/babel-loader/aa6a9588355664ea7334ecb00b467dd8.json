{"ast":null,"code":"const CID = require('cids');\n\nconst dagPB = require('ipld-dag-pb');\n\nconst defaultBase = 'base58btc';\n\nconst cidifyString = str => {\n  if (!str) {\n    return str;\n  }\n\n  if (Array.isArray(str)) {\n    return str.map(cidifyString);\n  }\n\n  return new CID(str);\n};\n\nconst stringifyCid = (cid, options) => {\n  if (!cid || typeof cid === 'string') {\n    return cid;\n  }\n\n  if (Array.isArray(cid)) {\n    return cid.map(stringifyCid);\n  }\n\n  if (cid['/']) {\n    return cid['/'];\n  }\n\n  const base = options.base || defaultBase;\n  return cid.toBaseEncodedString(base);\n};\n\nconst writePb = async (ipfs, obj, options) => {\n  const buffer = Buffer.from(JSON.stringify(obj));\n  const dagNode = new dagPB.DAGNode(buffer);\n  const cid = await ipfs.dag.put(dagNode, {\n    format: 'dag-pb',\n    hashAlg: 'sha2-256'\n  });\n  const res = cid.toV0().toBaseEncodedString();\n  const pin = options.pin || false;\n\n  if (pin) {\n    await ipfs.pin.add(res);\n  }\n\n  return res;\n};\n\nconst readPb = async (ipfs, cid) => {\n  const result = await ipfs.dag.get(cid);\n  const dagNode = result.value;\n  return JSON.parse(dagNode.toJSON().data);\n};\n\nconst writeCbor = async (ipfs, obj, options) => {\n  const dagNode = Object.assign({}, obj);\n  const links = options.links || [];\n  links.forEach(prop => {\n    if (dagNode[prop]) {\n      dagNode[prop] = cidifyString(dagNode[prop]);\n    }\n  });\n  const base = options.base || defaultBase;\n  const onlyHash = options.onlyHash || false;\n  const cid = await ipfs.dag.put(dagNode, {\n    onlyHash\n  });\n  const res = cid.toBaseEncodedString(base);\n  const pin = options.pin || false;\n\n  if (pin) {\n    await ipfs.pin.add(res);\n  }\n\n  return res;\n};\n\nconst readCbor = async (ipfs, cid, options) => {\n  const result = await ipfs.dag.get(cid);\n  const obj = result.value;\n  const links = options.links || [];\n  links.forEach(prop => {\n    if (obj[prop]) {\n      obj[prop] = stringifyCid(obj[prop], options);\n    }\n  });\n  return obj;\n};\n\nconst writeObj = async (ipfs, obj, options) => {\n  const onlyHash = options.onlyHash || false;\n  const base = options.base || defaultBase;\n  const opts = Object.assign({}, {\n    onlyHash: onlyHash\n  }, options.format ? {\n    format: options.format,\n    hashAlg: 'sha2-256'\n  } : {});\n\n  if (opts.format === 'dag-pb') {\n    obj = new dagPB.DAGNode(obj);\n  }\n\n  const cid = await ipfs.dag.put(obj, opts);\n  const res = cid.toBaseEncodedString(base);\n  const pin = options.pin || false;\n\n  if (pin) {\n    await ipfs.pin.add(res);\n  }\n\n  return res;\n};\n\nconst formats = {\n  'dag-pb': {\n    read: readPb,\n    write: writePb\n  },\n  'dag-cbor': {\n    write: writeCbor,\n    read: readCbor\n  },\n  'raw': {\n    write: writeObj\n  }\n};\n\nconst write = (ipfs, codec, obj, options = {}) => {\n  const format = formats[codec];\n  if (!format) throw new Error('Unsupported codec');\n  return format.write(ipfs, obj, options);\n};\n\nconst read = (ipfs, cid, options = {}) => {\n  cid = new CID(cid);\n  const format = formats[cid.codec];\n  if (!format) throw new Error('Unsupported codec');\n  return format.read(ipfs, cid, options);\n};\n\nmodule.exports = {\n  read,\n  write\n};","map":null,"metadata":{},"sourceType":"script"}