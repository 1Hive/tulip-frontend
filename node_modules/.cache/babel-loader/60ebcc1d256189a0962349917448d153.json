{"ast":null,"code":"'use strict';\n\nconst isIpfs = require('is-ipfs');\n\nconst CID = require('cids');\n\nconst {\n  DAGNode\n} = require('ipld-dag-pb');\n\nconst {\n  normalizeCidPath\n} = require('../../utils');\n\nconst {\n  Errors\n} = require('interface-datastore');\n\nconst ERR_NOT_FOUND = Errors.notFoundError().code;\n\nconst {\n  withTimeoutOption\n} = require('../../utils');\n\nconst Format = {\n  default: '<dst>',\n  edges: '<src> -> <dst>'\n};\n\nmodule.exports = function ({\n  ipld,\n  resolve,\n  preload\n}) {\n  return withTimeoutOption(async function* refs(ipfsPath, options) {\n    // eslint-disable-line require-await\n    options = options || {};\n\n    if (options.maxDepth === 0) {\n      return;\n    }\n\n    if (options.edges && options.format && options.format !== Format.default) {\n      throw new Error('Cannot set edges to true and also specify format');\n    }\n\n    options.format = options.edges ? Format.edges : options.format || Format.default;\n\n    if (typeof options.maxDepth !== 'number') {\n      options.maxDepth = options.recursive ? Infinity : 1;\n    }\n\n    const rawPaths = Array.isArray(ipfsPath) ? ipfsPath : [ipfsPath];\n    const paths = rawPaths.map(p => getFullPath(preload, p, options));\n\n    for (const path of paths) {\n      yield* refsStream(resolve, ipld, path, options);\n    }\n  });\n};\n\nmodule.exports.Format = Format;\n\nfunction getFullPath(preload, ipfsPath, options) {\n  // normalizeCidPath() strips /ipfs/ off the front of the path so the CID will\n  // be at the front of the path\n  const path = normalizeCidPath(ipfsPath);\n  const pathComponents = path.split('/');\n  const cid = pathComponents[0];\n\n  if (!isIpfs.cid(cid)) {\n    throw new Error(`Error resolving path '${path}': '${cid}' is not a valid CID`);\n  }\n\n  if (options.preload !== false) {\n    preload(cid);\n  }\n\n  return '/ipfs/' + path;\n} // Get a stream of refs at the given path\n\n\nasync function* refsStream(resolve, ipld, path, options) {\n  // Resolve to the target CID of the path\n  const resPath = await resolve(path); // path is /ipfs/<cid>\n\n  const parts = resPath.split('/');\n  const cid = parts[2]; // Traverse the DAG, converting it into a stream\n\n  for await (const obj of objectStream(ipld, cid, options.maxDepth, options.unique)) {\n    // Root object will not have a parent\n    if (!obj.parent) {\n      continue;\n    } // Filter out duplicates (isDuplicate flag is only set if options.unique is set)\n\n\n    if (obj.isDuplicate) {\n      continue;\n    } // Format the links\n    // Clients expect refs to be in the format { ref: <ref> }\n\n\n    yield {\n      ref: formatLink(obj.parent.cid, obj.node.cid, obj.node.name, options.format)\n    };\n  }\n} // Get formatted link\n\n\nfunction formatLink(srcCid, dstCid, linkName, format) {\n  let out = format.replace(/<src>/g, srcCid.toString());\n  out = out.replace(/<dst>/g, dstCid.toString());\n  out = out.replace(/<linkname>/g, linkName);\n  return out;\n} // Do a depth first search of the DAG, starting from the given root cid\n\n\nasync function* objectStream(ipld, rootCid, maxDepth, uniqueOnly) {\n  // eslint-disable-line require-await\n  const seen = new Set();\n\n  async function* traverseLevel(parent, depth) {\n    const nextLevelDepth = depth + 1; // Check the depth\n\n    if (nextLevelDepth > maxDepth) {\n      return;\n    } // Get this object's links\n\n\n    try {\n      // Look at each link, parent and the new depth\n      for (const link of await getLinks(ipld, parent.cid)) {\n        yield {\n          parent: parent,\n          node: link,\n          isDuplicate: uniqueOnly && seen.has(link.cid.toString())\n        };\n\n        if (uniqueOnly) {\n          seen.add(link.cid.toString());\n        }\n\n        yield* traverseLevel(link, nextLevelDepth);\n      }\n    } catch (err) {\n      if (err.code === ERR_NOT_FOUND) {\n        err.message = `Could not find object with CID: ${parent.cid}`;\n      }\n\n      throw err;\n    }\n  }\n\n  yield* traverseLevel({\n    cid: rootCid\n  }, 0);\n} // Fetch a node from IPLD then get all its links\n\n\nasync function getLinks(ipld, cid) {\n  const node = await ipld.get(new CID(cid));\n\n  if (DAGNode.isDAGNode(node)) {\n    return node.Links.map(({\n      Name,\n      Hash\n    }) => ({\n      name: Name,\n      cid: new CID(Hash)\n    }));\n  }\n\n  return getNodeLinks(node);\n} // Recursively search the node for CIDs\n\n\nfunction getNodeLinks(node, path = '') {\n  let links = [];\n\n  for (const [name, value] of Object.entries(node)) {\n    if (CID.isCID(value)) {\n      links.push({\n        name: path + name,\n        cid: value\n      });\n    } else if (typeof value === 'object') {\n      links = links.concat(getNodeLinks(value, path + name + '/'));\n    }\n  }\n\n  return links;\n}","map":null,"metadata":{},"sourceType":"script"}