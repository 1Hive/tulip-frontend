{"ast":null,"code":"/* @flow */\n'use strict';\n\nconst Key = require('interface-datastore').Key;\n\nconst readme = require('./shard-readme'); // eslint-disable-next-line\n\n/*:: import type {Datastore, Callback} from 'interface-datastore'\n\nexport interface ShardV1 {\n  name: string;\n  param: number;\n  fun(string): string;\n  toString(): string;\n}\n*/\n\n\nconst PREFIX = exports.PREFIX = '/repo/flatfs/shard/';\nconst SHARDING_FN = exports.SHARDING_FN = 'SHARDING';\nexports.README_FN = '_README';\n\nclass Shard {\n  /* :: name: string */\n\n  /* :: param: number */\n\n  /* :: _padding: string */\n  constructor(param\n  /* : number */\n  ) {\n    this.param = param;\n  }\n\n  fun(str\n  /* : string */\n  )\n  /* : string */\n  {\n    throw new Error('implement me');\n  }\n\n  toString()\n  /* : string */\n  {\n    return `${PREFIX}v1/${this.name}/${this.param}`;\n  }\n\n}\n\nclass Prefix extends Shard {\n  constructor(prefixLen\n  /* : number */\n  ) {\n    super(prefixLen);\n    this._padding = ''.padStart(prefixLen, '_');\n    this.name = 'prefix';\n  }\n\n  fun(noslash\n  /* : string */\n  )\n  /* : string */\n  {\n    return (noslash + this._padding).slice(0, this.param);\n  }\n\n}\n\nclass Suffix extends Shard {\n  constructor(suffixLen\n  /* : number */\n  ) {\n    super(suffixLen);\n    this._padding = ''.padStart(suffixLen, '_');\n    this.name = 'suffix';\n  }\n\n  fun(noslash\n  /* : string */\n  )\n  /* : string */\n  {\n    const s = this._padding + noslash;\n    return s.slice(s.length - this.param);\n  }\n\n}\n\nclass NextToLast extends Shard {\n  constructor(suffixLen\n  /* : number */\n  ) {\n    super(suffixLen);\n    this._padding = ''.padStart(suffixLen + 1, '_');\n    this.name = 'next-to-last';\n  }\n\n  fun(noslash\n  /* : string */\n  )\n  /* : string */\n  {\n    const s = this._padding + noslash;\n    const offset = s.length - this.param - 1;\n    return s.slice(offset, offset + this.param);\n  }\n\n}\n/**\n * Convert a given string to the matching sharding function.\n *\n * @param {string} str\n * @returns {ShardV1}\n */\n\n\nfunction parseShardFun(str\n/* : string */\n) {\n  str = str.trim();\n\n  if (str.length === 0) {\n    throw new Error('empty shard string');\n  }\n\n  if (!str.startsWith(PREFIX)) {\n    throw new Error(`invalid or no path prefix: ${str}`);\n  }\n\n  const parts = str.slice(PREFIX.length).split('/');\n  const version = parts[0];\n\n  if (version !== 'v1') {\n    throw new Error(`expect 'v1' version, got '${version}'`);\n  }\n\n  const name = parts[1];\n\n  if (!parts[2]) {\n    throw new Error('missing param');\n  }\n\n  const param = parseInt(parts[2], 10);\n\n  switch (name) {\n    case 'prefix':\n      return new Prefix(param);\n\n    case 'suffix':\n      return new Suffix(param);\n\n    case 'next-to-last':\n      return new NextToLast(param);\n\n    default:\n      throw new Error(`unkown sharding function: ${name}`);\n  }\n}\n\nexports.readShardFun = async (path\n/* : string */\n, store) =>\n/* : Promise<ShardV1> */\n{\n  const key = new Key(path).child(new Key(SHARDING_FN));\n  const get = typeof store.getRaw === 'function' ? store.getRaw.bind(store) : store.get.bind(store);\n  const res = await get(key);\n  return parseShardFun((res || '').toString().trim());\n};\n\nexports.readme = readme;\nexports.parseShardFun = parseShardFun;\nexports.Prefix = Prefix;\nexports.Suffix = Suffix;\nexports.NextToLast = NextToLast;","map":null,"metadata":{},"sourceType":"script"}