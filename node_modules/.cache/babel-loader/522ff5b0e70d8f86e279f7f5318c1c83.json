{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar debug = require('debug');\n\nvar EventEmitter = require('events');\n\nvar errcode = require('err-code');\n\nvar PeerInfo = require('peer-info');\n\nvar MulticodecTopology = require('libp2p-interfaces/src/topology/multicodec-topology');\n\nvar message = require('./message');\n\nvar Peer = require('./peer');\n\nvar utils = require('./utils');\n\nvar _require = require('./message/sign'),\n    signMessage = _require.signMessage,\n    verifySignature = _require.verifySignature;\n\nfunction validateRegistrar(registrar) {\n  // registrar handling\n  if (typeof registrar !== 'object') {\n    throw new Error('a registrar object is required');\n  }\n\n  if (typeof registrar.handle !== 'function') {\n    throw new Error('a handle function must be provided in registrar');\n  }\n\n  if (typeof registrar.register !== 'function') {\n    throw new Error('a register function must be provided in registrar');\n  }\n\n  if (typeof registrar.unregister !== 'function') {\n    throw new Error('a unregister function must be provided in registrar');\n  }\n}\n/**\n * PubsubBaseProtocol handles the peers and connections logic for pubsub routers\n */\n\n\nvar PubsubBaseProtocol = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(PubsubBaseProtocol, _EventEmitter);\n\n  var _super = _createSuper(PubsubBaseProtocol);\n\n  /**\n   * @param {Object} props\n   * @param {String} props.debugName log namespace\n   * @param {Array<string>|string} props.multicodecs protocol identificers to connect\n   * @param {PeerInfo} props.peerInfo peer's peerInfo\n   * @param {Object} props.registrar registrar for libp2p protocols\n   * @param {function} props.registrar.handle\n   * @param {function} props.registrar.register\n   * @param {function} props.registrar.unregister\n   * @param {boolean} [props.signMessages] if messages should be signed, defaults to true\n   * @param {boolean} [props.strictSigning] if message signing should be required, defaults to true\n   * @abstract\n   */\n  function PubsubBaseProtocol(_ref) {\n    var _this;\n\n    var debugName = _ref.debugName,\n        multicodecs = _ref.multicodecs,\n        peerInfo = _ref.peerInfo,\n        registrar = _ref.registrar,\n        _ref$signMessages = _ref.signMessages,\n        signMessages = _ref$signMessages === void 0 ? true : _ref$signMessages,\n        _ref$strictSigning = _ref.strictSigning,\n        strictSigning = _ref$strictSigning === void 0 ? true : _ref$strictSigning;\n\n    _classCallCheck(this, PubsubBaseProtocol);\n\n    if (typeof debugName !== 'string') {\n      throw new Error('a debugname `string` is required');\n    }\n\n    if (!multicodecs) {\n      throw new Error('multicodecs are required');\n    }\n\n    if (!PeerInfo.isPeerInfo(peerInfo)) {\n      throw new Error('peer info must be an instance of `peer-info`');\n    }\n\n    validateRegistrar(registrar);\n    _this = _super.call(this);\n    _this.log = debug(debugName);\n    _this.log.err = debug(\"\".concat(debugName, \":error\"));\n    _this.multicodecs = utils.ensureArray(multicodecs);\n    _this.peerInfo = peerInfo;\n    _this.registrar = registrar;\n    _this.started = false;\n    /**\n     * Map of topics to which peers are subscribed to\n     *\n     * @type {Map<string, Peer>}\n     */\n\n    _this.topics = new Map();\n    /**\n     * Map of peers.\n     *\n     * @type {Map<string, Peer>}\n     */\n\n    _this.peers = new Map(); // Message signing\n\n    if (signMessages) {\n      _this.peerId = _this.peerInfo.id;\n    }\n    /**\n     * If message signing should be required for incoming messages\n     * @type {boolean}\n     */\n\n\n    _this.strictSigning = strictSigning;\n    _this._registrarId = undefined;\n    _this._onIncomingStream = _this._onIncomingStream.bind(_assertThisInitialized(_this));\n    _this._onPeerConnected = _this._onPeerConnected.bind(_assertThisInitialized(_this));\n    _this._onPeerDisconnected = _this._onPeerDisconnected.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n  /**\n   * Register the pubsub protocol onto the libp2p node.\n   * @returns {Promise<void>}\n   */\n\n\n  _createClass(PubsubBaseProtocol, [{\n    key: \"start\",\n    value: function () {\n      var _start = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var topology;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this.started) {\n                  _context.next = 2;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 2:\n                this.log('starting'); // Incoming streams\n\n                this.registrar.handle(this.multicodecs, this._onIncomingStream); // register protocol with topology\n\n                topology = new MulticodecTopology({\n                  multicodecs: this.multicodecs,\n                  handlers: {\n                    onConnect: this._onPeerConnected,\n                    onDisconnect: this._onPeerDisconnected\n                  }\n                });\n                _context.next = 7;\n                return this.registrar.register(topology);\n\n              case 7:\n                this._registrarId = _context.sent;\n                this.log('started');\n                this.started = true;\n\n              case 10:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function start() {\n        return _start.apply(this, arguments);\n      }\n\n      return start;\n    }()\n    /**\n     * Unregister the pubsub protocol and the streams with other peers will be closed.\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (this.started) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 2:\n                _context2.next = 4;\n                return this.registrar.unregister(this._registrarId);\n\n              case 4:\n                this.log('stopping');\n                this.peers.forEach(function (peer) {\n                  return peer.close();\n                });\n                this.peers = new Map();\n                this.started = false;\n                this.log('stopped');\n\n              case 9:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function stop() {\n        return _stop.apply(this, arguments);\n      }\n\n      return stop;\n    }()\n    /**\n     * On an incoming stream event.\n     * @private\n     * @param {Object} props\n     * @param {string} props.protocol\n     * @param {DuplexStream} props.strean\n     * @param {Connection} props.connection connection\n     */\n\n  }, {\n    key: \"_onIncomingStream\",\n    value: function () {\n      var _onIncomingStream2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(_ref2) {\n        var protocol, stream, connection, peerInfo, idB58Str, peer;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                protocol = _ref2.protocol, stream = _ref2.stream, connection = _ref2.connection;\n                _context3.next = 3;\n                return PeerInfo.create(connection.remotePeer);\n\n              case 3:\n                peerInfo = _context3.sent;\n                peerInfo.protocols.add(protocol);\n                idB58Str = peerInfo.id.toB58String();\n                peer = this._addPeer(peerInfo);\n\n                this._processMessages(idB58Str, stream, peer);\n\n              case 8:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function _onIncomingStream(_x) {\n        return _onIncomingStream2.apply(this, arguments);\n      }\n\n      return _onIncomingStream;\n    }()\n    /**\n     * Registrar notifies a connection successfully with pubsub protocol.\n     * @private\n     * @param {PeerInfo} peerInfo remote peer info\n     * @param {Connection} conn connection to the peer\n     */\n\n  }, {\n    key: \"_onPeerConnected\",\n    value: function () {\n      var _onPeerConnected2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(peerInfo, conn) {\n        var idB58Str, peer, _yield$conn$newStream, stream;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                idB58Str = peerInfo.id.toB58String();\n                this.log('connected', idB58Str);\n                peer = this._addPeer(peerInfo);\n                _context4.prev = 3;\n                _context4.next = 6;\n                return conn.newStream(this.multicodecs);\n\n              case 6:\n                _yield$conn$newStream = _context4.sent;\n                stream = _yield$conn$newStream.stream;\n                peer.attachConnection(stream);\n                _context4.next = 14;\n                break;\n\n              case 11:\n                _context4.prev = 11;\n                _context4.t0 = _context4[\"catch\"](3);\n                this.log.err(_context4.t0);\n\n              case 14:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[3, 11]]);\n      }));\n\n      function _onPeerConnected(_x2, _x3) {\n        return _onPeerConnected2.apply(this, arguments);\n      }\n\n      return _onPeerConnected;\n    }()\n    /**\n     * Registrar notifies a closing connection with pubsub protocol.\n     * @private\n     * @param {PeerInfo} peerInfo peer info\n     * @param {Error} err error for connection end\n     */\n\n  }, {\n    key: \"_onPeerDisconnected\",\n    value: function _onPeerDisconnected(peerInfo, err) {\n      var idB58Str = peerInfo.id.toB58String();\n      var peer = this.peers.get(idB58Str);\n      this.log('connection ended', idB58Str, err ? err.message : '');\n\n      this._removePeer(peer);\n    }\n    /**\n     * Add a new connected peer to the peers map.\n     * @private\n     * @param {PeerInfo} peerInfo peer info\n     * @returns {PeerInfo}\n     */\n\n  }, {\n    key: \"_addPeer\",\n    value: function _addPeer(peerInfo) {\n      var _this2 = this;\n\n      var id = peerInfo.id.toB58String();\n      var existing = this.peers.get(id);\n\n      if (!existing) {\n        this.log('new peer', id);\n        var peer = new Peer(peerInfo);\n        this.peers.set(id, peer);\n        existing = peer;\n        peer.once('close', function () {\n          return _this2._removePeer(peer);\n        });\n      }\n\n      return existing;\n    }\n    /**\n     * Remove a peer from the peers map.\n     * @private\n     * @param {Peer} peer peer state\n     * @returns {PeerInfo}\n     */\n\n  }, {\n    key: \"_removePeer\",\n    value: function _removePeer(peer) {\n      if (!peer) return;\n      var id = peer.info.id.toB58String();\n      this.log('delete peer', id);\n      this.peers.delete(id);\n      return peer;\n    }\n    /**\n     * Validates the given message. The signature will be checked for authenticity.\n     * @param {rpc.RPC.Message} message\n     * @returns {Promise<Boolean>}\n     */\n\n  }, {\n    key: \"validate\",\n    value: function () {\n      var _validate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(message) {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (!(this.strictSigning && !message.signature)) {\n                  _context5.next = 3;\n                  break;\n                }\n\n                this.log('Signing required and no signature was present, dropping message:', message);\n                return _context5.abrupt(\"return\", false);\n\n              case 3:\n                if (!message.signature) {\n                  _context5.next = 7;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", verifySignature(message));\n\n              case 7:\n                return _context5.abrupt(\"return\", true);\n\n              case 8:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function validate(_x4) {\n        return _validate.apply(this, arguments);\n      }\n\n      return validate;\n    }()\n    /**\n     * Normalizes the message and signs it, if signing is enabled\n     * @private\n     * @param {Message} message\n     * @returns {Promise<Message>}\n     */\n\n  }, {\n    key: \"_buildMessage\",\n    value: function _buildMessage(message) {\n      var msg = utils.normalizeOutRpcMessage(message);\n\n      if (this.peerId) {\n        return signMessage(this.peerId, msg);\n      } else {\n        return message;\n      }\n    }\n    /**\n     * Get a list of the peer-ids that are subscribed to one topic.\n     * @param {string} topic\n     * @returns {Array<string>}\n     */\n\n  }, {\n    key: \"getSubscribers\",\n    value: function getSubscribers(topic) {\n      if (!this.started) {\n        throw errcode(new Error('not started yet'), 'ERR_NOT_STARTED_YET');\n      }\n\n      if (!topic || typeof topic !== 'string') {\n        throw errcode(new Error('a string topic must be provided'), 'ERR_NOT_VALID_TOPIC');\n      }\n\n      return Array.from(this.peers.values()).filter(function (peer) {\n        return peer.topics.has(topic);\n      }).map(function (peer) {\n        return peer.info.id.toB58String();\n      });\n    }\n    /**\n     * Overriding the implementation of publish should handle the appropriate algorithms for the publish/subscriber implementation.\n     * For example, a Floodsub implementation might simply publish each message to each topic for every peer\n     * @abstract\n     * @param {Array<string>|string} topics\n     * @param {Array<any>|any} messages\n     * @returns {Promise}\n     *\n     */\n\n  }, {\n    key: \"publish\",\n    value: function publish(topics, messages) {\n      throw errcode(new Error('publish must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED');\n    }\n    /**\n     * Overriding the implementation of subscribe should handle the appropriate algorithms for the publish/subscriber implementation.\n     * For example, a Floodsub implementation might simply send a message for every peer showing interest in the topics\n     * @abstract\n     * @param {Array<string>|string} topics\n     * @returns {void}\n     */\n\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(topics) {\n      throw errcode(new Error('subscribe must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED');\n    }\n    /**\n     * Overriding the implementation of unsubscribe should handle the appropriate algorithms for the publish/subscriber implementation.\n     * For example, a Floodsub implementation might simply send a message for every peer revoking interest in the topics\n     * @abstract\n     * @param {Array<string>|string} topics\n     * @returns {void}\n     */\n\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(topics) {\n      throw errcode(new Error('unsubscribe must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED');\n    }\n    /**\n     * Overriding the implementation of getTopics should handle the appropriate algorithms for the publish/subscriber implementation.\n     * Get the list of subscriptions the peer is subscribed to.\n     * @abstract\n     * @returns {Array<string>}\n     */\n\n  }, {\n    key: \"getTopics\",\n    value: function getTopics() {\n      throw errcode(new Error('getTopics must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED');\n    }\n    /**\n     * Overriding the implementation of _processMessages should keep the connection and is\n     * responsible for processing each RPC message received by other peers.\n     * @abstract\n     * @param {string} idB58Str peer id string in base58\n     * @param {Connection} conn connection\n     * @param {Peer} peer A Pubsub Peer\n     * @returns {void}\n     *\n     */\n\n  }, {\n    key: \"_processMessages\",\n    value: function _processMessages(idB58Str, conn, peer) {\n      throw errcode(new Error('_processMessages must be implemented by the subclass'), 'ERR_NOT_IMPLEMENTED');\n    }\n  }]);\n\n  return PubsubBaseProtocol;\n}(EventEmitter);\n\nmodule.exports = PubsubBaseProtocol;\nmodule.exports.message = message;\nmodule.exports.utils = utils;","map":null,"metadata":{},"sourceType":"script"}