{"ast":null,"code":"'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst Bucket = require('hamt-sharding/src/bucket');\n\nconst multihashing = require('multihashing-async'); // FIXME: this is copy/pasted from ipfs-unixfs-importer/src/dir-sharded.js\n\n\nconst hashFn = async function (value) {\n  const hash = await multihashing(Buffer.from(value, 'utf8'), 'murmur3-128'); // Multihashing inserts preamble of 2 bytes. Remove it.\n  // Also, murmur3 outputs 128 bit but, accidently, IPFS Go's\n  // implementation only uses the first 64, so we must do the same\n  // for parity..\n\n  const justHash = hash.slice(2, 10);\n  const length = justHash.length;\n  const result = Buffer.alloc(length); // TODO: invert buffer because that's how Go impl does it\n\n  for (let i = 0; i < length; i++) {\n    result[length - i - 1] = justHash[i];\n  }\n\n  return result;\n};\n\nhashFn.code = 0x22; // TODO: get this from multihashing-async?\n\nconst addLinksToHamtBucket = (links, bucket, rootBucket) => {\n  return Promise.all(links.map(link => {\n    if (link.Name.length === 2) {\n      const pos = parseInt(link.Name, 16);\n      return bucket._putObjectAt(pos, new Bucket({\n        hashFn\n      }, bucket, pos));\n    }\n\n    return rootBucket.put(link.Name.substring(2), true);\n  }));\n};\n\nconst toPrefix = position => {\n  return position.toString('16').toUpperCase().padStart(2, '0').substring(0, 2);\n};\n\nconst toBucketPath = position => {\n  let bucket = position.bucket;\n  const path = [];\n\n  while (bucket._parent) {\n    path.push(bucket);\n    bucket = bucket._parent;\n  }\n\n  path.push(bucket);\n  return path.reverse();\n};\n\nconst findShardCid = async (node, name, ipld, context, options) => {\n  if (!context) {\n    context = {\n      rootBucket: new Bucket({\n        hashFn\n      }),\n      hamtDepth: 1\n    };\n    context.lastBucket = context.rootBucket;\n  }\n\n  await addLinksToHamtBucket(node.Links, context.lastBucket, context.rootBucket);\n  const position = await context.rootBucket._findNewBucketAndPos(name);\n  let prefix = toPrefix(position.pos);\n  const bucketPath = toBucketPath(position);\n\n  if (bucketPath.length > context.hamtDepth) {\n    context.lastBucket = bucketPath[context.hamtDepth];\n    prefix = toPrefix(context.lastBucket._posAtParent);\n  }\n\n  const link = node.Links.find(link => {\n    const entryPrefix = link.Name.substring(0, 2);\n    const entryName = link.Name.substring(2);\n\n    if (entryPrefix !== prefix) {\n      // not the entry or subshard we're looking for\n      return;\n    }\n\n    if (entryName && entryName !== name) {\n      // not the entry we're looking for\n      return;\n    }\n\n    return true;\n  });\n\n  if (!link) {\n    return null;\n  }\n\n  if (link.Name.substring(2) === name) {\n    return link.Hash;\n  }\n\n  context.hamtDepth++;\n  node = await ipld.get(link.Hash, options);\n  return findShardCid(node, name, ipld, context, options);\n};\n\nmodule.exports = findShardCid;","map":null,"metadata":{},"sourceType":"script"}