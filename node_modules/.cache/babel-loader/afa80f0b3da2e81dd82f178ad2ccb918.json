{"ast":null,"code":"'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst {\n  Key,\n  Adapter\n} = require('interface-datastore');\n\nconst {\n  encodeBase32,\n  keyToTopic,\n  topicToKey\n} = require('./utils');\n\nconst errcode = require('err-code');\n\nconst debug = require('debug');\n\nconst log = debug('datastore-pubsub:publisher');\nlog.error = debug('datastore-pubsub:publisher:error'); // DatastorePubsub is responsible for providing an api for pubsub to be used as a datastore with\n// [TieredDatastore]{@link https://github.com/ipfs/js-datastore-core/blob/master/src/tiered.js}\n\nclass DatastorePubsub extends Adapter {\n  /**\n   * Creates an instance of DatastorePubsub.\n   * @param {*} pubsub - pubsub implementation.\n   * @param {*} datastore - datastore instance.\n   * @param {*} peerId - peer-id instance.\n   * @param {Object} validator - validator functions.\n   * @param {function(record, peerId, callback)} validator.validate - function to validate a record.\n   * @param {function(received, current, callback)} validator.select - function to select the newest between two records.\n   * @param {function(key, callback)} subscriptionKeyFn - optional function to manipulate the key topic received before processing it.\n   * @memberof DatastorePubsub\n   */\n  constructor(pubsub, datastore, peerId, validator, subscriptionKeyFn) {\n    super();\n\n    if (!validator) {\n      throw errcode(new TypeError('missing validator'), 'ERR_INVALID_PARAMETERS');\n    }\n\n    if (typeof validator.validate !== 'function') {\n      throw errcode(new TypeError('missing validate function'), 'ERR_INVALID_PARAMETERS');\n    }\n\n    if (typeof validator.select !== 'function') {\n      throw errcode(new TypeError('missing select function'), 'ERR_INVALID_PARAMETERS');\n    }\n\n    if (subscriptionKeyFn && typeof subscriptionKeyFn !== 'function') {\n      throw errcode(new TypeError('invalid subscriptionKeyFn received'), 'ERR_INVALID_PARAMETERS');\n    }\n\n    this._pubsub = pubsub;\n    this._datastore = datastore;\n    this._peerId = peerId;\n    this._validator = validator;\n    this._handleSubscriptionKeyFn = subscriptionKeyFn; // Bind _onMessage function, which is called by pubsub.\n\n    this._onMessage = this._onMessage.bind(this);\n  }\n  /**\n   * Publishes a value through pubsub.\n   * @param {Buffer} key identifier of the value to be published.\n   * @param {Buffer} val value to be propagated.\n   * @returns {Promise}\n   */\n\n\n  async put(key, val) {\n    // eslint-disable-line require-await\n    if (!Buffer.isBuffer(key)) {\n      const errMsg = 'datastore key does not have a valid format';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY');\n    }\n\n    if (!Buffer.isBuffer(val)) {\n      const errMsg = 'received value is not a buffer';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_VALUE_RECEIVED');\n    }\n\n    const stringifiedTopic = keyToTopic(key);\n    log(`publish value for topic ${stringifiedTopic}`); // Publish record to pubsub\n\n    return this._pubsub.publish(stringifiedTopic, val);\n  }\n  /**\n   * Try to subscribe a topic with Pubsub and returns the local value if available.\n   * @param {Buffer} key identifier of the value to be subscribed.\n   * @returns {Promise<Buffer>}\n   */\n\n\n  async get(key) {\n    if (!Buffer.isBuffer(key)) {\n      const errMsg = 'datastore key does not have a valid format';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY');\n    }\n\n    const stringifiedTopic = keyToTopic(key);\n    const subscriptions = await this._pubsub.getTopics(); // If already subscribed, just try to get it\n\n    if (subscriptions && Array.isArray(subscriptions) && subscriptions.indexOf(stringifiedTopic) > -1) {\n      return this._getLocal(key);\n    } // subscribe\n\n\n    try {\n      await this._pubsub.subscribe(stringifiedTopic, this._onMessage);\n    } catch (err) {\n      const errMsg = `cannot subscribe topic ${stringifiedTopic}`;\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_SUBSCRIBING_TOPIC');\n    }\n\n    log(`subscribed values for key ${stringifiedTopic}`);\n    return this._getLocal(key);\n  }\n  /**\n   * Unsubscribe topic.\n   * @param {Buffer} key identifier of the value to unsubscribe.\n   * @returns {void}\n   */\n\n\n  unsubscribe(key) {\n    const stringifiedTopic = keyToTopic(key);\n    return this._pubsub.unsubscribe(stringifiedTopic, this._onMessage);\n  } // Get record from local datastore\n\n\n  async _getLocal(key) {\n    // encode key - base32(/ipns/{cid})\n    const routingKey = new Key('/' + encodeBase32(key), false);\n    let dsVal;\n\n    try {\n      dsVal = await this._datastore.get(routingKey);\n    } catch (err) {\n      if (err.code !== 'ERR_NOT_FOUND') {\n        const errMsg = `unexpected error getting the ipns record for ${routingKey.toString()}`;\n        log.error(errMsg);\n        throw errcode(new Error(errMsg), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD');\n      }\n\n      const errMsg = `local record requested was not found for ${routingKey.toString()}`;\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_NOT_FOUND');\n    }\n\n    if (!Buffer.isBuffer(dsVal)) {\n      const errMsg = 'found record that we couldn\\'t convert to a value';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_INVALID_RECORD_RECEIVED');\n    }\n\n    return dsVal;\n  } // handles pubsub subscription messages\n\n\n  async _onMessage(msg) {\n    const {\n      data,\n      from,\n      topicIDs\n    } = msg;\n    let key;\n\n    try {\n      key = topicToKey(topicIDs[0]);\n    } catch (err) {\n      log.error(err);\n      return;\n    }\n\n    log(`message received for topic ${topicIDs[0]}`); // Stop if the message is from the peer (it already stored it while publishing to pubsub)\n\n    if (from === this._peerId.toB58String()) {\n      log('message discarded as it is from the same peer');\n      return;\n    }\n\n    if (this._handleSubscriptionKeyFn) {\n      let res;\n\n      try {\n        res = await this._handleSubscriptionKeyFn(key);\n      } catch (err) {\n        log.error('message discarded by the subscriptionKeyFn');\n        return;\n      }\n\n      key = res;\n    }\n\n    try {\n      await this._storeIfSubscriptionIsBetter(key, data);\n    } catch (err) {\n      log.error(err);\n    }\n  } // Store the received record if it is better than the current stored\n\n\n  async _storeIfSubscriptionIsBetter(key, data) {\n    let isBetter = false;\n\n    try {\n      isBetter = await this._isBetter(key, data);\n    } catch (err) {\n      if (err.code !== 'ERR_NOT_VALID_RECORD') {\n        throw err;\n      }\n    }\n\n    if (isBetter) {\n      await this._storeRecord(Buffer.from(key), data);\n    }\n  } // Validate record according to the received validation function\n\n\n  async _validateRecord(value, peerId) {\n    // eslint-disable-line require-await\n    return this._validator.validate(value, peerId);\n  } // Select the best record according to the received select function.\n\n\n  async _selectRecord(receivedRecord, currentRecord) {\n    const res = await this._validator.select(receivedRecord, currentRecord); // If the selected was the first (0), it should be stored (true)\n\n    return res === 0;\n  } // Verify if the record received through pubsub is valid and better than the one currently stored\n\n\n  async _isBetter(key, val) {\n    // validate received record\n    let error, valid;\n\n    try {\n      valid = await this._validateRecord(val, key);\n    } catch (err) {\n      error = err;\n    } // If not valid, it is not better than the one currently available\n\n\n    if (error || !valid) {\n      const errMsg = 'record received through pubsub is not valid';\n      log.error(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_NOT_VALID_RECORD');\n    } // Get Local record\n\n\n    const dsKey = new Key(key);\n    let currentRecord;\n\n    try {\n      currentRecord = await this._getLocal(dsKey.toBuffer());\n    } catch (err) {\n      // if the old one is invalid, the new one is *always* better\n      return true;\n    } // if the same record, do not need to store\n\n\n    if (currentRecord.equals(val)) {\n      return false;\n    } // verify if the received record should replace the current one\n\n\n    return this._selectRecord(val, currentRecord);\n  } // add record to datastore\n\n\n  async _storeRecord(key, data) {\n    // encode key - base32(/ipns/{cid})\n    const routingKey = new Key('/' + encodeBase32(key), false);\n    await this._datastore.put(routingKey, data);\n    log(`record for ${keyToTopic(key)} was stored in the datastore`);\n  }\n\n  open() {\n    const errMsg = 'open function was not implemented yet';\n    log.error(errMsg);\n    throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET');\n  }\n\n  has(key) {\n    const errMsg = 'has function was not implemented yet';\n    log.error(errMsg);\n    throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET');\n  }\n\n  delete(key) {\n    const errMsg = 'delete function was not implemented yet';\n    log.error(errMsg);\n    throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET');\n  }\n\n  close() {\n    const errMsg = 'close function was not implemented yet';\n    log.error(errMsg);\n    throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET');\n  }\n\n  batch() {\n    const errMsg = 'batch function was not implemented yet';\n    log.error(errMsg);\n    throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET');\n  }\n\n  query() {\n    const errMsg = 'query function was not implemented yet';\n    log.error(errMsg);\n    throw errcode(new Error(errMsg), 'ERR_NOT_IMPLEMENTED_YET');\n  }\n\n}\n\nexports = module.exports = DatastorePubsub;","map":null,"metadata":{},"sourceType":"script"}