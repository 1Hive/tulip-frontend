{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar multibase = require('multibase');\n\nvar sha = require('multihashing-async/src/sha');\n\nvar errcode = require('err-code');\n\nvar exporter = require('./exporter');\n\nmodule.exports = function (keysProtobuf, randomBytes, crypto) {\n  crypto = crypto || require('./secp256k1')(randomBytes);\n\n  var Secp256k1PublicKey = /*#__PURE__*/function () {\n    function Secp256k1PublicKey(key) {\n      _classCallCheck(this, Secp256k1PublicKey);\n\n      crypto.validatePublicKey(key);\n      this._key = key;\n    }\n\n    _createClass(Secp256k1PublicKey, [{\n      key: \"verify\",\n      value: function verify(data, sig) {\n        return crypto.hashAndVerify(this._key, sig, data);\n      }\n    }, {\n      key: \"marshal\",\n      value: function marshal() {\n        return crypto.compressPublicKey(this._key);\n      }\n    }, {\n      key: \"bytes\",\n      get: function get() {\n        return keysProtobuf.PublicKey.encode({\n          Type: keysProtobuf.KeyType.Secp256k1,\n          Data: this.marshal()\n        });\n      }\n    }, {\n      key: \"equals\",\n      value: function equals(key) {\n        return this.bytes.equals(key.bytes);\n      }\n    }, {\n      key: \"hash\",\n      value: function hash() {\n        return sha.multihashing(this.bytes, 'sha2-256');\n      }\n    }]);\n\n    return Secp256k1PublicKey;\n  }();\n\n  var Secp256k1PrivateKey = /*#__PURE__*/function () {\n    function Secp256k1PrivateKey(key, publicKey) {\n      _classCallCheck(this, Secp256k1PrivateKey);\n\n      this._key = key;\n      this._publicKey = publicKey || crypto.computePublicKey(key);\n      crypto.validatePrivateKey(this._key);\n      crypto.validatePublicKey(this._publicKey);\n    }\n\n    _createClass(Secp256k1PrivateKey, [{\n      key: \"sign\",\n      value: function sign(message) {\n        return crypto.hashAndSign(this._key, message);\n      }\n    }, {\n      key: \"public\",\n      get: function get() {\n        return new Secp256k1PublicKey(this._publicKey);\n      }\n    }, {\n      key: \"marshal\",\n      value: function marshal() {\n        return this._key;\n      }\n    }, {\n      key: \"bytes\",\n      get: function get() {\n        return keysProtobuf.PrivateKey.encode({\n          Type: keysProtobuf.KeyType.Secp256k1,\n          Data: this.marshal()\n        });\n      }\n    }, {\n      key: \"equals\",\n      value: function equals(key) {\n        return this.bytes.equals(key.bytes);\n      }\n    }, {\n      key: \"hash\",\n      value: function hash() {\n        return sha.multihashing(this.bytes, 'sha2-256');\n      }\n      /**\n       * Gets the ID of the key.\n       *\n       * The key id is the base58 encoding of the SHA-256 multihash of its public key.\n       * The public key is a protobuf encoding containing a type and the DER encoding\n       * of the PKCS SubjectPublicKeyInfo.\n       *\n       * @returns {Promise<string>}\n       */\n\n    }, {\n      key: \"id\",\n      value: function () {\n        var _id = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n          var hash;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.next = 2;\n                  return this.public.hash();\n\n                case 2:\n                  hash = _context.sent;\n                  return _context.abrupt(\"return\", multibase.encode('base58btc', hash).toString().slice(1));\n\n                case 4:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this);\n        }));\n\n        function id() {\n          return _id.apply(this, arguments);\n        }\n\n        return id;\n      }()\n      /**\n       * Exports the key into a password protected `format`\n       *\n       * @param {string} password - The password to encrypt the key\n       * @param {string} [format=libp2p-key] - The format in which to export as\n       * @returns {Promise<string>} The encrypted private key\n       */\n\n    }, {\n      key: \"export\",\n      value: function () {\n        var _export2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(password) {\n          var format,\n              _args2 = arguments;\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  format = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : 'libp2p-key';\n\n                  if (!(format === 'libp2p-key')) {\n                    _context2.next = 5;\n                    break;\n                  }\n\n                  return _context2.abrupt(\"return\", exporter.export(this.bytes, password));\n\n                case 5:\n                  throw errcode(new Error(\"export format '\".concat(format, \"' is not supported\")), 'ERR_INVALID_EXPORT_FORMAT');\n\n                case 6:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, this);\n        }));\n\n        function _export(_x) {\n          return _export2.apply(this, arguments);\n        }\n\n        return _export;\n      }()\n    }]);\n\n    return Secp256k1PrivateKey;\n  }();\n\n  function unmarshalSecp256k1PrivateKey(bytes) {\n    return new Secp256k1PrivateKey(bytes);\n  }\n\n  function unmarshalSecp256k1PublicKey(bytes) {\n    return new Secp256k1PublicKey(bytes);\n  }\n\n  function generateKeyPair() {\n    return _generateKeyPair.apply(this, arguments);\n  }\n\n  function _generateKeyPair() {\n    _generateKeyPair = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n      var privateKeyBytes;\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return crypto.generateKey();\n\n            case 2:\n              privateKeyBytes = _context3.sent;\n              return _context3.abrupt(\"return\", new Secp256k1PrivateKey(privateKeyBytes));\n\n            case 4:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n    return _generateKeyPair.apply(this, arguments);\n  }\n\n  return {\n    Secp256k1PublicKey: Secp256k1PublicKey,\n    Secp256k1PrivateKey: Secp256k1PrivateKey,\n    unmarshalSecp256k1PrivateKey: unmarshalSecp256k1PrivateKey,\n    unmarshalSecp256k1PublicKey: unmarshalSecp256k1PublicKey,\n    generateKeyPair: generateKeyPair\n  };\n};","map":null,"metadata":{},"sourceType":"script"}