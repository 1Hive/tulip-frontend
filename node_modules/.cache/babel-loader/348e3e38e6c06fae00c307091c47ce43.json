{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _slicedToArray = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar CID = require('cids');\n\nvar PeerInfo = require('peer-info');\n\nvar errcode = require('err-code');\n\nvar Message = require('../../message');\n\nvar utils = require('../../utils');\n\nmodule.exports = function (dht) {\n  var log = utils.logger(dht.peerInfo.id, 'rpc:get-providers');\n  /**\n   * Process `GetProviders` DHT messages.\n   *\n   * @param {PeerInfo} peer\n   * @param {Message} msg\n   * @returns {Promise<Message>}\n   */\n\n  return /*#__PURE__*/function () {\n    var _getProviders = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(peer, msg) {\n      var cid, dsKey, _yield$Promise$all, _yield$Promise$all2, has, peers, closer, providers, response;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.prev = 0;\n              cid = new CID(msg.key);\n              _context.next = 7;\n              break;\n\n            case 4:\n              _context.prev = 4;\n              _context.t0 = _context[\"catch\"](0);\n              throw errcode(new Error(\"Invalid CID: \".concat(_context.t0.message)), 'ERR_INVALID_CID');\n\n            case 7:\n              log('%s', cid.toBaseEncodedString());\n              dsKey = utils.bufferToKey(cid.buffer);\n              _context.next = 11;\n              return Promise.all([dht.datastore.has(dsKey), dht.providers.getProviders(cid), dht._betterPeersToQuery(msg, peer)]);\n\n            case 11:\n              _yield$Promise$all = _context.sent;\n              _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 3);\n              has = _yield$Promise$all2[0];\n              peers = _yield$Promise$all2[1];\n              closer = _yield$Promise$all2[2];\n              providers = peers.map(function (p) {\n                if (dht.peerStore.has(p)) {\n                  return dht.peerStore.get(p);\n                }\n\n                return dht.peerStore.put(new PeerInfo(p));\n              });\n\n              if (has) {\n                providers.push(dht.peerInfo);\n              }\n\n              response = new Message(msg.type, msg.key, msg.clusterLevel);\n\n              if (providers.length > 0) {\n                response.providerPeers = providers;\n              }\n\n              if (closer.length > 0) {\n                response.closerPeers = closer;\n              }\n\n              log('got %s providers %s closerPeers', providers.length, closer.length);\n              return _context.abrupt(\"return\", response);\n\n            case 23:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[0, 4]]);\n    }));\n\n    function getProviders(_x, _x2) {\n      return _getProviders.apply(this, arguments);\n    }\n\n    return getProviders;\n  }();\n};","map":null,"metadata":{},"sourceType":"script"}