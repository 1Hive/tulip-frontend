{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar loadMfsRoot = require('./with-mfs-root');\n\nvar toPathComponents = require('./to-path-components');\n\nvar exporter = require('ipfs-unixfs-exporter');\n\nvar errCode = require('err-code');\n\nvar IPFS_PREFIX = 'ipfs';\n\nvar toMfsPath = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(context, path) {\n    var outputArray, paths, root;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            outputArray = Array.isArray(path);\n            paths = Array.isArray(path) ? path : [path];\n            _context2.next = 4;\n            return loadMfsRoot(context);\n\n          case 4:\n            root = _context2.sent;\n            paths = paths.map(function (path) {\n              path = (path || '').trim();\n              path = path.replace(/(\\/\\/+)/g, '/');\n\n              if (path.endsWith('/') && path.length > 1) {\n                path = path.substring(0, path.length - 1);\n              }\n\n              if (!path) {\n                throw errCode(new Error('paths must not be empty'), 'ERR_NO_PATH');\n              }\n\n              if (path.substring(0, 1) !== '/') {\n                throw errCode(new Error('paths must start with a leading slash'), 'ERR_INVALID_PATH');\n              }\n\n              if (path.substring(path.length - 1) === '/') {\n                path = path.substring(0, path.length - 1);\n              }\n\n              var pathComponents = toPathComponents(path);\n\n              if (pathComponents[0] === IPFS_PREFIX) {\n                // e.g. /ipfs/QMfoo or /ipfs/Qmfoo/sub/path\n                var _mfsDirectory;\n\n                if (pathComponents.length === 2) {\n                  _mfsDirectory = \"/\".concat(pathComponents.join('/'));\n                } else {\n                  _mfsDirectory = \"/\".concat(pathComponents.slice(0, pathComponents.length - 1).join('/'));\n                }\n\n                return {\n                  type: 'ipfs',\n                  depth: pathComponents.length - 2,\n                  mfsPath: \"/\".concat(pathComponents.join('/')),\n                  mfsDirectory: _mfsDirectory,\n                  parts: pathComponents,\n                  path: \"/\".concat(pathComponents.join('/')),\n                  name: pathComponents[pathComponents.length - 1]\n                };\n              }\n\n              var mfsPath = \"/\".concat(IPFS_PREFIX, \"/\").concat(root).concat(pathComponents.length ? '/' + pathComponents.join('/') : '');\n              var mfsDirectory = \"/\".concat(IPFS_PREFIX, \"/\").concat(root, \"/\").concat(pathComponents.slice(0, pathComponents.length - 1).join('/'));\n              return {\n                type: 'mfs',\n                depth: pathComponents.length,\n                mfsDirectory: mfsDirectory,\n                mfsPath: mfsPath,\n                parts: pathComponents,\n                path: \"/\".concat(pathComponents.join('/')),\n                name: pathComponents[pathComponents.length - 1]\n              };\n            });\n            _context2.next = 8;\n            return Promise.all(paths.map( /*#__PURE__*/function () {\n              var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(path) {\n                var cidPath, res;\n                return _regeneratorRuntime.wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        cidPath = path.type === 'mfs' ? path.mfsPath : path.path;\n                        _context.prev = 1;\n                        _context.next = 4;\n                        return exporter(cidPath, context.ipld);\n\n                      case 4:\n                        res = _context.sent;\n                        path.cid = res.cid;\n                        path.mfsPath = \"/ipfs/\".concat(res.path);\n                        path.unixfs = res.unixfs;\n                        path.content = res.content;\n                        _context.next = 15;\n                        break;\n\n                      case 11:\n                        _context.prev = 11;\n                        _context.t0 = _context[\"catch\"](1);\n\n                        if (!(_context.t0.code !== 'ERR_NOT_FOUND')) {\n                          _context.next = 15;\n                          break;\n                        }\n\n                        throw _context.t0;\n\n                      case 15:\n                        path.exists = Boolean(path.cid);\n\n                      case 16:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee, null, [[1, 11]]);\n              }));\n\n              return function (_x3) {\n                return _ref2.apply(this, arguments);\n              };\n            }()));\n\n          case 8:\n            if (!outputArray) {\n              _context2.next = 10;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", paths);\n\n          case 10:\n            return _context2.abrupt(\"return\", paths[0]);\n\n          case 11:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function toMfsPath(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nmodule.exports = toMfsPath;","map":null,"metadata":{},"sourceType":"script"}