{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || Object.assign || function (t) {\n  for (var s, i = 1, n = arguments.length; i < n; i++) {\n    s = arguments[i];\n\n    for (var p in s) {\n      if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n  }\n\n  return t;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [op[0] & 2, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _global = typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : {};\n\nvar NativeWebSocket = _global.WebSocket || _global.MozWebSocket;\n\nvar Backoff = require(\"backo2\");\n\nvar eventemitter3_1 = require(\"eventemitter3\");\n\nvar is_string_1 = require(\"./utils/is-string\");\n\nvar is_object_1 = require(\"./utils/is-object\");\n\nvar printer_1 = require(\"graphql/language/printer\");\n\nvar getOperationAST_1 = require(\"graphql/utilities/getOperationAST\");\n\nvar symbol_observable_1 = require(\"symbol-observable\");\n\nvar protocol_1 = require(\"./protocol\");\n\nvar defaults_1 = require(\"./defaults\");\n\nvar message_types_1 = require(\"./message-types\");\n\nvar SubscriptionClient = function () {\n  function SubscriptionClient(url, options, webSocketImpl, webSocketProtocols) {\n    var _a = options || {},\n        _b = _a.connectionCallback,\n        connectionCallback = _b === void 0 ? undefined : _b,\n        _c = _a.connectionParams,\n        connectionParams = _c === void 0 ? {} : _c,\n        _d = _a.timeout,\n        timeout = _d === void 0 ? defaults_1.WS_TIMEOUT : _d,\n        _e = _a.reconnect,\n        reconnect = _e === void 0 ? false : _e,\n        _f = _a.reconnectionAttempts,\n        reconnectionAttempts = _f === void 0 ? Infinity : _f,\n        _g = _a.lazy,\n        lazy = _g === void 0 ? false : _g,\n        _h = _a.inactivityTimeout,\n        inactivityTimeout = _h === void 0 ? 0 : _h;\n\n    this.wsImpl = webSocketImpl || NativeWebSocket;\n\n    if (!this.wsImpl) {\n      throw new Error('Unable to find native implementation, or alternative implementation for WebSocket!');\n    }\n\n    this.wsProtocols = webSocketProtocols || protocol_1.GRAPHQL_WS;\n    this.connectionCallback = connectionCallback;\n    this.url = url;\n    this.operations = {};\n    this.nextOperationId = 0;\n    this.wsTimeout = timeout;\n    this.unsentMessagesQueue = [];\n    this.reconnect = reconnect;\n    this.reconnecting = false;\n    this.reconnectionAttempts = reconnectionAttempts;\n    this.lazy = !!lazy;\n    this.inactivityTimeout = inactivityTimeout;\n    this.closedByUser = false;\n    this.backoff = new Backoff({\n      jitter: 0.5\n    });\n    this.eventEmitter = new eventemitter3_1.EventEmitter();\n    this.middlewares = [];\n    this.client = null;\n    this.maxConnectTimeGenerator = this.createMaxConnectTimeGenerator();\n    this.connectionParams = this.getConnectionParams(connectionParams);\n\n    if (!this.lazy) {\n      this.connect();\n    }\n  }\n\n  Object.defineProperty(SubscriptionClient.prototype, \"status\", {\n    get: function get() {\n      if (this.client === null) {\n        return this.wsImpl.CLOSED;\n      }\n\n      return this.client.readyState;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  SubscriptionClient.prototype.close = function (isForced, closedByUser) {\n    if (isForced === void 0) {\n      isForced = true;\n    }\n\n    if (closedByUser === void 0) {\n      closedByUser = true;\n    }\n\n    this.clearInactivityTimeout();\n\n    if (this.client !== null) {\n      this.closedByUser = closedByUser;\n\n      if (isForced) {\n        this.clearCheckConnectionInterval();\n        this.clearMaxConnectTimeout();\n        this.clearTryReconnectTimeout();\n        this.unsubscribeAll();\n        this.sendMessage(undefined, message_types_1.default.GQL_CONNECTION_TERMINATE, null);\n      }\n\n      this.client.close();\n      this.client = null;\n      this.eventEmitter.emit('disconnected');\n\n      if (!isForced) {\n        this.tryReconnect();\n      }\n    }\n  };\n\n  SubscriptionClient.prototype.request = function (request) {\n    var _a;\n\n    var getObserver = this.getObserver.bind(this);\n    var executeOperation = this.executeOperation.bind(this);\n\n    var _unsubscribe = this.unsubscribe.bind(this);\n\n    var opId;\n    this.clearInactivityTimeout();\n    return _a = {}, _a[symbol_observable_1.default] = function () {\n      return this;\n    }, _a.subscribe = function (observerOrNext, onError, onComplete) {\n      var observer = getObserver(observerOrNext, onError, onComplete);\n      opId = executeOperation(request, function (error, result) {\n        if (error === null && result === null) {\n          if (observer.complete) {\n            observer.complete();\n          }\n        } else if (error) {\n          if (observer.error) {\n            observer.error(error[0]);\n          }\n        } else {\n          if (observer.next) {\n            observer.next(result);\n          }\n        }\n      });\n      return {\n        unsubscribe: function unsubscribe() {\n          if (opId) {\n            _unsubscribe(opId);\n\n            opId = null;\n          }\n        }\n      };\n    }, _a;\n  };\n\n  SubscriptionClient.prototype.on = function (eventName, callback, context) {\n    var handler = this.eventEmitter.on(eventName, callback, context);\n    return function () {\n      handler.off(eventName, callback, context);\n    };\n  };\n\n  SubscriptionClient.prototype.onConnected = function (callback, context) {\n    return this.on('connected', callback, context);\n  };\n\n  SubscriptionClient.prototype.onConnecting = function (callback, context) {\n    return this.on('connecting', callback, context);\n  };\n\n  SubscriptionClient.prototype.onDisconnected = function (callback, context) {\n    return this.on('disconnected', callback, context);\n  };\n\n  SubscriptionClient.prototype.onReconnected = function (callback, context) {\n    return this.on('reconnected', callback, context);\n  };\n\n  SubscriptionClient.prototype.onReconnecting = function (callback, context) {\n    return this.on('reconnecting', callback, context);\n  };\n\n  SubscriptionClient.prototype.onError = function (callback, context) {\n    return this.on('error', callback, context);\n  };\n\n  SubscriptionClient.prototype.unsubscribeAll = function () {\n    var _this = this;\n\n    Object.keys(this.operations).forEach(function (subId) {\n      _this.unsubscribe(subId);\n    });\n  };\n\n  SubscriptionClient.prototype.applyMiddlewares = function (options) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      var queue = function queue(funcs, scope) {\n        var next = function next(error) {\n          if (error) {\n            reject(error);\n          } else {\n            if (funcs.length > 0) {\n              var f = funcs.shift();\n\n              if (f) {\n                f.applyMiddleware.apply(scope, [options, next]);\n              }\n            } else {\n              resolve(options);\n            }\n          }\n        };\n\n        next();\n      };\n\n      queue(_this.middlewares.slice(), _this);\n    });\n  };\n\n  SubscriptionClient.prototype.use = function (middlewares) {\n    var _this = this;\n\n    middlewares.map(function (middleware) {\n      if (typeof middleware.applyMiddleware === 'function') {\n        _this.middlewares.push(middleware);\n      } else {\n        throw new Error('Middleware must implement the applyMiddleware function.');\n      }\n    });\n    return this;\n  };\n\n  SubscriptionClient.prototype.getConnectionParams = function (connectionParams) {\n    return function () {\n      return new Promise(function (resolve, reject) {\n        if (typeof connectionParams === 'function') {\n          try {\n            return resolve(connectionParams.call(null));\n          } catch (error) {\n            return reject(error);\n          }\n        }\n\n        resolve(connectionParams);\n      });\n    };\n  };\n\n  SubscriptionClient.prototype.executeOperation = function (options, handler) {\n    var _this = this;\n\n    if (this.client === null) {\n      this.connect();\n    }\n\n    var opId = this.generateOperationId();\n    this.operations[opId] = {\n      options: options,\n      handler: handler\n    };\n    this.applyMiddlewares(options).then(function (processedOptions) {\n      _this.checkOperationOptions(processedOptions, handler);\n\n      if (_this.operations[opId]) {\n        _this.operations[opId] = {\n          options: processedOptions,\n          handler: handler\n        };\n\n        _this.sendMessage(opId, message_types_1.default.GQL_START, processedOptions);\n      }\n    }).catch(function (error) {\n      _this.unsubscribe(opId);\n\n      handler(_this.formatErrors(error));\n    });\n    return opId;\n  };\n\n  SubscriptionClient.prototype.getObserver = function (observerOrNext, _error, _complete) {\n    if (typeof observerOrNext === 'function') {\n      return {\n        next: function next(v) {\n          return observerOrNext(v);\n        },\n        error: function error(e) {\n          return _error && _error(e);\n        },\n        complete: function complete() {\n          return _complete && _complete();\n        }\n      };\n    }\n\n    return observerOrNext;\n  };\n\n  SubscriptionClient.prototype.createMaxConnectTimeGenerator = function () {\n    var minValue = 1000;\n    var maxValue = this.wsTimeout;\n    return new Backoff({\n      min: minValue,\n      max: maxValue,\n      factor: 1.2\n    });\n  };\n\n  SubscriptionClient.prototype.clearCheckConnectionInterval = function () {\n    if (this.checkConnectionIntervalId) {\n      clearInterval(this.checkConnectionIntervalId);\n      this.checkConnectionIntervalId = null;\n    }\n  };\n\n  SubscriptionClient.prototype.clearMaxConnectTimeout = function () {\n    if (this.maxConnectTimeoutId) {\n      clearTimeout(this.maxConnectTimeoutId);\n      this.maxConnectTimeoutId = null;\n    }\n  };\n\n  SubscriptionClient.prototype.clearTryReconnectTimeout = function () {\n    if (this.tryReconnectTimeoutId) {\n      clearTimeout(this.tryReconnectTimeoutId);\n      this.tryReconnectTimeoutId = null;\n    }\n  };\n\n  SubscriptionClient.prototype.clearInactivityTimeout = function () {\n    if (this.inactivityTimeoutId) {\n      clearTimeout(this.inactivityTimeoutId);\n      this.inactivityTimeoutId = null;\n    }\n  };\n\n  SubscriptionClient.prototype.setInactivityTimeout = function () {\n    var _this = this;\n\n    if (this.inactivityTimeout > 0 && Object.keys(this.operations).length === 0) {\n      this.inactivityTimeoutId = setTimeout(function () {\n        if (Object.keys(_this.operations).length === 0) {\n          _this.close();\n        }\n      }, this.inactivityTimeout);\n    }\n  };\n\n  SubscriptionClient.prototype.checkOperationOptions = function (options, handler) {\n    var query = options.query,\n        variables = options.variables,\n        operationName = options.operationName;\n\n    if (!query) {\n      throw new Error('Must provide a query.');\n    }\n\n    if (!handler) {\n      throw new Error('Must provide an handler.');\n    }\n\n    if (!is_string_1.default(query) && !getOperationAST_1.getOperationAST(query, operationName) || operationName && !is_string_1.default(operationName) || variables && !is_object_1.default(variables)) {\n      throw new Error('Incorrect option types. query must be a string or a document,' + '`operationName` must be a string, and `variables` must be an object.');\n    }\n  };\n\n  SubscriptionClient.prototype.buildMessage = function (id, type, payload) {\n    var payloadToReturn = payload && payload.query ? __assign({}, payload, {\n      query: typeof payload.query === 'string' ? payload.query : printer_1.print(payload.query)\n    }) : payload;\n    return {\n      id: id,\n      type: type,\n      payload: payloadToReturn\n    };\n  };\n\n  SubscriptionClient.prototype.formatErrors = function (errors) {\n    if (Array.isArray(errors)) {\n      return errors;\n    }\n\n    if (errors && errors.errors) {\n      return this.formatErrors(errors.errors);\n    }\n\n    if (errors && errors.message) {\n      return [errors];\n    }\n\n    return [{\n      name: 'FormatedError',\n      message: 'Unknown error',\n      originalError: errors\n    }];\n  };\n\n  SubscriptionClient.prototype.sendMessage = function (id, type, payload) {\n    this.sendMessageRaw(this.buildMessage(id, type, payload));\n  };\n\n  SubscriptionClient.prototype.sendMessageRaw = function (message) {\n    switch (this.status) {\n      case this.wsImpl.OPEN:\n        var serializedMessage = JSON.stringify(message);\n\n        try {\n          JSON.parse(serializedMessage);\n        } catch (e) {\n          this.eventEmitter.emit('error', new Error(\"Message must be JSON-serializable. Got: \" + message));\n        }\n\n        this.client.send(serializedMessage);\n        break;\n\n      case this.wsImpl.CONNECTING:\n        this.unsentMessagesQueue.push(message);\n        break;\n\n      default:\n        if (!this.reconnecting) {\n          this.eventEmitter.emit('error', new Error('A message was not sent because socket is not connected, is closing or ' + 'is already closed. Message was: ' + JSON.stringify(message)));\n        }\n\n    }\n  };\n\n  SubscriptionClient.prototype.generateOperationId = function () {\n    return String(++this.nextOperationId);\n  };\n\n  SubscriptionClient.prototype.tryReconnect = function () {\n    var _this = this;\n\n    if (!this.reconnect || this.backoff.attempts >= this.reconnectionAttempts) {\n      return;\n    }\n\n    if (!this.reconnecting) {\n      Object.keys(this.operations).forEach(function (key) {\n        _this.unsentMessagesQueue.push(_this.buildMessage(key, message_types_1.default.GQL_START, _this.operations[key].options));\n      });\n      this.reconnecting = true;\n    }\n\n    this.clearTryReconnectTimeout();\n    var delay = this.backoff.duration();\n    this.tryReconnectTimeoutId = setTimeout(function () {\n      _this.connect();\n    }, delay);\n  };\n\n  SubscriptionClient.prototype.flushUnsentMessagesQueue = function () {\n    var _this = this;\n\n    this.unsentMessagesQueue.forEach(function (message) {\n      _this.sendMessageRaw(message);\n    });\n    this.unsentMessagesQueue = [];\n  };\n\n  SubscriptionClient.prototype.checkConnection = function () {\n    if (this.wasKeepAliveReceived) {\n      this.wasKeepAliveReceived = false;\n      return;\n    }\n\n    if (!this.reconnecting) {\n      this.close(false, true);\n    }\n  };\n\n  SubscriptionClient.prototype.checkMaxConnectTimeout = function () {\n    var _this = this;\n\n    this.clearMaxConnectTimeout();\n    this.maxConnectTimeoutId = setTimeout(function () {\n      if (_this.status !== _this.wsImpl.OPEN) {\n        _this.reconnecting = true;\n\n        _this.close(false, true);\n      }\n    }, this.maxConnectTimeGenerator.duration());\n  };\n\n  SubscriptionClient.prototype.connect = function () {\n    var _this = this;\n\n    this.client = new this.wsImpl(this.url, this.wsProtocols);\n    this.checkMaxConnectTimeout();\n\n    this.client.onopen = function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var connectionParams, error_1;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (!(this.status === this.wsImpl.OPEN)) return [3, 4];\n              this.clearMaxConnectTimeout();\n              this.closedByUser = false;\n              this.eventEmitter.emit(this.reconnecting ? 'reconnecting' : 'connecting');\n              _a.label = 1;\n\n            case 1:\n              _a.trys.push([1, 3,, 4]);\n\n              return [4, this.connectionParams()];\n\n            case 2:\n              connectionParams = _a.sent();\n              this.sendMessage(undefined, message_types_1.default.GQL_CONNECTION_INIT, connectionParams);\n              this.flushUnsentMessagesQueue();\n              return [3, 4];\n\n            case 3:\n              error_1 = _a.sent();\n              this.sendMessage(undefined, message_types_1.default.GQL_CONNECTION_ERROR, error_1);\n              this.flushUnsentMessagesQueue();\n              return [3, 4];\n\n            case 4:\n              return [2];\n          }\n        });\n      });\n    };\n\n    this.client.onclose = function () {\n      if (!_this.closedByUser) {\n        _this.close(false, false);\n      }\n    };\n\n    this.client.onerror = function (err) {\n      _this.eventEmitter.emit('error', err);\n    };\n\n    this.client.onmessage = function (_a) {\n      var data = _a.data;\n\n      _this.processReceivedData(data);\n    };\n  };\n\n  SubscriptionClient.prototype.processReceivedData = function (receivedData) {\n    var parsedMessage;\n    var opId;\n\n    try {\n      parsedMessage = JSON.parse(receivedData);\n      opId = parsedMessage.id;\n    } catch (e) {\n      throw new Error(\"Message must be JSON-parseable. Got: \" + receivedData);\n    }\n\n    if ([message_types_1.default.GQL_DATA, message_types_1.default.GQL_COMPLETE, message_types_1.default.GQL_ERROR].indexOf(parsedMessage.type) !== -1 && !this.operations[opId]) {\n      this.unsubscribe(opId);\n      return;\n    }\n\n    switch (parsedMessage.type) {\n      case message_types_1.default.GQL_CONNECTION_ERROR:\n        if (this.connectionCallback) {\n          this.connectionCallback(parsedMessage.payload);\n        }\n\n        break;\n\n      case message_types_1.default.GQL_CONNECTION_ACK:\n        this.eventEmitter.emit(this.reconnecting ? 'reconnected' : 'connected');\n        this.reconnecting = false;\n        this.backoff.reset();\n        this.maxConnectTimeGenerator.reset();\n\n        if (this.connectionCallback) {\n          this.connectionCallback();\n        }\n\n        break;\n\n      case message_types_1.default.GQL_COMPLETE:\n        this.operations[opId].handler(null, null);\n        delete this.operations[opId];\n        break;\n\n      case message_types_1.default.GQL_ERROR:\n        this.operations[opId].handler(this.formatErrors(parsedMessage.payload), null);\n        delete this.operations[opId];\n        break;\n\n      case message_types_1.default.GQL_DATA:\n        var parsedPayload = !parsedMessage.payload.errors ? parsedMessage.payload : __assign({}, parsedMessage.payload, {\n          errors: this.formatErrors(parsedMessage.payload.errors)\n        });\n        this.operations[opId].handler(null, parsedPayload);\n        break;\n\n      case message_types_1.default.GQL_CONNECTION_KEEP_ALIVE:\n        var firstKA = typeof this.wasKeepAliveReceived === 'undefined';\n        this.wasKeepAliveReceived = true;\n\n        if (firstKA) {\n          this.checkConnection();\n        }\n\n        if (this.checkConnectionIntervalId) {\n          clearInterval(this.checkConnectionIntervalId);\n          this.checkConnection();\n        }\n\n        this.checkConnectionIntervalId = setInterval(this.checkConnection.bind(this), this.wsTimeout);\n        break;\n\n      default:\n        throw new Error('Invalid message type!');\n    }\n  };\n\n  SubscriptionClient.prototype.unsubscribe = function (opId) {\n    if (this.operations[opId]) {\n      delete this.operations[opId];\n      this.setInactivityTimeout();\n      this.sendMessage(opId, message_types_1.default.GQL_STOP, undefined);\n    }\n  };\n\n  return SubscriptionClient;\n}();\n\nexports.SubscriptionClient = SubscriptionClient;","map":null,"metadata":{},"sourceType":"script"}