{"ast":null,"code":"'use strict';\n\nconst applyDefaultOptions = require('./utils/apply-default-options');\n\nconst toMfsPath = require('./utils/to-mfs-path');\n\nconst log = require('debug')('ipfs:mfs:touch');\n\nconst errCode = require('err-code');\n\nconst UnixFS = require('ipfs-unixfs');\n\nconst toTrail = require('./utils/to-trail');\n\nconst addLink = require('./utils/add-link');\n\nconst updateTree = require('./utils/update-tree');\n\nconst updateMfsRoot = require('./utils/update-mfs-root');\n\nconst {\n  DAGNode\n} = require('ipld-dag-pb');\n\nconst mc = require('multicodec');\n\nconst mh = require('multihashes');\n\nconst pipe = require('it-pipe');\n\nconst importer = require('ipfs-unixfs-importer');\n\nconst exporter = require('ipfs-unixfs-exporter');\n\nconst last = require('it-last');\n\nconst cp = require('./cp');\n\nconst rm = require('./rm');\n\nconst persist = require('ipfs-unixfs-importer/src/utils/persist');\n\nconst {\n  withTimeoutOption\n} = require('../../utils');\n\nconst defaultOptions = {\n  flush: true,\n  shardSplitThreshold: 1000,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  recursive: false\n};\n\nfunction calculateModification(mode, originalMode, isDirectory) {\n  let modification = 0;\n\n  if (mode.includes('x') || mode.includes('X') && (isDirectory || originalMode & 0o1 || originalMode & 0o10 || originalMode & 0o100)) {\n    modification += 1;\n  }\n\n  if (mode.includes('w')) {\n    modification += 2;\n  }\n\n  if (mode.includes('r')) {\n    modification += 4;\n  }\n\n  return modification;\n}\n\nfunction calculateUGO(references, modification) {\n  let ugo = 0;\n\n  if (references.includes('u')) {\n    ugo += modification << 6;\n  }\n\n  if (references.includes('g')) {\n    ugo += modification << 3;\n  }\n\n  if (references.includes('o')) {\n    ugo += modification;\n  }\n\n  return ugo;\n}\n\nfunction calculateSpecial(references, mode, modification) {\n  if (mode.includes('t')) {\n    modification += parseInt('1000', 8);\n  }\n\n  if (mode.includes('s')) {\n    if (references.includes('u')) {\n      modification += parseInt('4000', 8);\n    }\n\n    if (references.includes('g')) {\n      modification += parseInt('2000', 8);\n    }\n  }\n\n  return modification;\n} // https://en.wikipedia.org/wiki/Chmod#Symbolic_modes\n\n\nfunction parseSymbolicMode(input, originalMode, isDirectory) {\n  if (!originalMode) {\n    originalMode = 0;\n  }\n\n  const match = input.match(/^(u?g?o?a?)(-?\\+?=?)?(r?w?x?X?s?t?)$/);\n\n  if (!match) {\n    throw new Error(`Invalid file mode: ${input}`);\n  }\n\n  let [_, // eslint-disable-line no-unused-vars\n  references, operator, mode] = match;\n\n  if (references === 'a' || !references) {\n    references = 'ugo';\n  }\n\n  let modification = calculateModification(mode, originalMode, isDirectory);\n  modification = calculateUGO(references, modification);\n  modification = calculateSpecial(references, mode, modification);\n\n  if (operator === '=') {\n    if (references.includes('u')) {\n      // blank u bits\n      originalMode = originalMode & parseInt('7077', 8); // or them together\n\n      originalMode = originalMode | modification;\n    }\n\n    if (references.includes('g')) {\n      // blank g bits\n      originalMode = originalMode & parseInt('7707', 8); // or them together\n\n      originalMode = originalMode | modification;\n    }\n\n    if (references.includes('o')) {\n      // blank o bits\n      originalMode = originalMode & parseInt('7770', 8); // or them together\n\n      originalMode = originalMode | modification;\n    }\n\n    return originalMode;\n  }\n\n  if (operator === '+') {\n    return modification | originalMode;\n  }\n\n  if (operator === '-') {\n    return modification ^ originalMode;\n  }\n}\n\nfunction calculateMode(mode, metadata) {\n  if (typeof mode === 'string' || mode instanceof String) {\n    if (mode.match(/^\\d+$/g)) {\n      mode = parseInt(mode, 8);\n    } else {\n      mode = mode.split(',').reduce((curr, acc) => {\n        return parseSymbolicMode(acc, curr, metadata.isDirectory());\n      }, metadata.mode);\n    }\n  }\n\n  return mode;\n}\n\nmodule.exports = context => {\n  return withTimeoutOption(async function mfsChmod(path, mode, options) {\n    options = applyDefaultOptions(options, defaultOptions);\n    log(`Fetching stats for ${path}`);\n    const {\n      cid,\n      mfsDirectory,\n      name\n    } = await toMfsPath(context, path);\n\n    if (cid.codec !== 'dag-pb') {\n      throw errCode(new Error(`${path} was not a UnixFS node`), 'ERR_NOT_UNIXFS');\n    }\n\n    if (options.recursive) {\n      // recursively export from root CID, change perms of each entry then reimport\n      // but do not reimport files, only manipulate dag-pb nodes\n      const root = await pipe(async function* () {\n        for await (const entry of exporter.recursive(cid, context.ipld)) {\n          let node = await context.ipld.get(entry.cid);\n          entry.unixfs.mode = calculateMode(mode, entry.unixfs);\n          node = new DAGNode(entry.unixfs.marshal(), node.Links);\n          yield {\n            path: entry.path,\n            content: node\n          };\n        }\n      }, source => importer(source, context.block, { ...options,\n        pin: false,\n        dagBuilder: async function* (source, block, options) {\n          for await (const entry of source) {\n            yield async function () {\n              const cid = await persist(entry.content.serialize(), block, options);\n              return {\n                cid,\n                path: entry.path,\n                unixfs: UnixFS.unmarshal(entry.content.Data),\n                node: entry.content\n              };\n            };\n          }\n        }\n      }), nodes => last(nodes)); // remove old path from mfs\n\n      await rm(context)(path, options); // add newly created tree to mfs at path\n\n      await cp(context)(`/ipfs/${root.cid}`, path, options);\n      return;\n    }\n\n    let node = await context.ipld.get(cid);\n    const metadata = UnixFS.unmarshal(node.Data);\n    metadata.mode = calculateMode(mode, metadata);\n    node = new DAGNode(metadata.marshal(), node.Links);\n    const updatedCid = await context.ipld.put(node, mc.DAG_PB, {\n      cidVersion: cid.version,\n      hashAlg: mh.names[options.hashAlg],\n      onlyHash: !options.flush\n    });\n    const trail = await toTrail(context, mfsDirectory, options);\n    const parent = trail[trail.length - 1];\n    const parentNode = await context.ipld.get(parent.cid);\n    const result = await addLink(context, {\n      parent: parentNode,\n      name: name,\n      cid: updatedCid,\n      size: node.serialize().length,\n      flush: options.flush,\n      hashAlg: options.hashAlg,\n      cidVersion: cid.version\n    });\n    parent.cid = result.cid; // update the tree with the new child\n\n    const newRootCid = await updateTree(context, trail, options); // Update the MFS record with the new CID for the root of the tree\n\n    await updateMfsRoot(context, newRootCid);\n  });\n};","map":null,"metadata":{},"sourceType":"script"}