{"ast":null,"code":"'use strict';\n\nconst Block = require('ipld-block');\n\nconst multihashing = require('multihashing-async');\n\nconst CID = require('cids');\n\nconst isIPFS = require('is-ipfs');\n\nconst {\n  withTimeoutOption\n} = require('../../utils');\n\nmodule.exports = ({\n  blockService,\n  pin,\n  gcLock,\n  preload\n}) => {\n  return withTimeoutOption(async function put(block, options) {\n    options = options || {};\n\n    if (Array.isArray(block)) {\n      throw new Error('Array is not supported');\n    }\n\n    if (!Block.isBlock(block)) {\n      if (options.cid && isIPFS.cid(options.cid)) {\n        block = new Block(block, CID.isCID(options.cid) ? options.cid : new CID(options.cid));\n      } else {\n        const mhtype = options.mhtype || 'sha2-256';\n        const format = options.format || 'dag-pb';\n        let cidVersion;\n\n        if (options.version == null) {\n          // Pick appropriate CID version\n          cidVersion = mhtype === 'sha2-256' && format === 'dag-pb' ? 0 : 1;\n        } else {\n          cidVersion = options.version;\n        }\n\n        const multihash = await multihashing(block, mhtype);\n        const cid = new CID(cidVersion, format, multihash);\n        block = new Block(block, cid);\n      }\n    }\n\n    const release = await gcLock.readLock();\n\n    try {\n      await blockService.put(block, {\n        signal: options.signal\n      });\n\n      if (options.preload !== false) {\n        preload(block.cid);\n      }\n\n      if (options.pin === true) {\n        await pin.add(block.cid, {\n          recursive: true,\n          signal: options.signal\n        });\n      }\n\n      return block;\n    } finally {\n      release();\n    }\n  });\n};","map":null,"metadata":{},"sourceType":"script"}