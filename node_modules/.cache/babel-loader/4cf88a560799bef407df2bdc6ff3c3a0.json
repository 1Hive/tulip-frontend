{"ast":null,"code":"const getIterator = require('get-iterator');\n\nconst AbortError = require('./AbortError'); // Wrap an iterator to make it abortable, allow cleanup when aborted via onAbort\n\n\nconst toAbortableSource = (source, signal, options) => toMultiAbortableSource(source, Array.isArray(signal) ? signal : [{\n  signal,\n  options\n}]);\n\nconst toMultiAbortableSource = (source, signals) => {\n  source = getIterator(source);\n  signals = signals.map(({\n    signal,\n    options\n  }) => ({\n    signal,\n    options: options || {}\n  }));\n\n  async function* abortable() {\n    let nextAbortHandler;\n\n    const abortHandler = () => {\n      if (nextAbortHandler) nextAbortHandler();\n    };\n\n    for (const {\n      signal\n    } of signals) {\n      signal.addEventListener('abort', abortHandler);\n    }\n\n    while (true) {\n      let result;\n\n      try {\n        for (const {\n          signal,\n          options\n        } of signals) {\n          if (signal.aborted) {\n            const {\n              abortMessage,\n              abortCode\n            } = options;\n            throw new AbortError(abortMessage, abortCode);\n          }\n        }\n\n        const abort = new Promise((resolve, reject) => {\n          nextAbortHandler = () => {\n            const {\n              options\n            } = signals.find(({\n              signal\n            }) => signal.aborted);\n            const {\n              abortMessage,\n              abortCode\n            } = options;\n            reject(new AbortError(abortMessage, abortCode));\n          };\n        }); // Race the iterator and the abort signals\n\n        result = await Promise.race([abort, source.next()]);\n        nextAbortHandler = null;\n      } catch (err) {\n        for (const {\n          signal\n        } of signals) {\n          signal.removeEventListener('abort', abortHandler);\n        } // Might not have been aborted by a known signal\n\n\n        const aborter = signals.find(({\n          signal\n        }) => signal.aborted);\n        const isKnownAborter = err.type === 'aborted' && aborter;\n\n        if (isKnownAborter && aborter.options.onAbort) {\n          // Do any custom abort handling for the iterator\n          await aborter.options.onAbort(source);\n        } // End the iterator if it is a generator\n\n\n        if (typeof source.return === 'function') {\n          await source.return();\n        }\n\n        if (isKnownAborter && aborter.options.returnOnAbort) {\n          return;\n        }\n\n        throw err;\n      }\n\n      if (result.done) break;\n      yield result.value;\n    }\n\n    for (const {\n      signal\n    } of signals) {\n      signal.removeEventListener('abort', abortHandler);\n    }\n  }\n\n  return abortable();\n};\n\nconst toAbortableSink = (sink, signal, options) => toMultiAbortableSink(sink, Array.isArray(signal) ? signal : [{\n  signal,\n  options\n}]);\n\nconst toMultiAbortableSink = (sink, signals) => source => sink(toMultiAbortableSource(source, signals));\n\nconst toAbortableDuplex = (duplex, signal, options) => toMultiAbortableDuplex(duplex, Array.isArray(signal) ? signal : [{\n  signal,\n  options\n}]);\n\nconst toMultiAbortableDuplex = (duplex, signals) => ({\n  sink: toMultiAbortableSink(duplex.sink, signals),\n  source: toMultiAbortableSource(duplex.source, signals)\n});\n\nmodule.exports = toAbortableSource;\nmodule.exports.AbortError = AbortError;\nmodule.exports.source = toAbortableSource;\nmodule.exports.sink = toAbortableSink;\nmodule.exports.transform = toAbortableSink;\nmodule.exports.duplex = toAbortableDuplex;","map":null,"metadata":{},"sourceType":"script"}