{"ast":null,"code":"'use strict';\n\nconst Block = require('ipld-block');\n\nconst CID = require('cids');\n\nconst mergeOptions = require('merge-options');\n\nconst ipldDagCbor = require('ipld-dag-cbor');\n\nconst ipldDagPb = require('ipld-dag-pb');\n\nconst ipldRaw = require('ipld-raw');\n\nconst multicodec = require('multicodec');\n\nconst typical = require('typical');\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst {\n  extendIterator\n} = require('./util');\n\nclass IPLDResolver {\n  constructor(userOptions) {\n    const options = mergeOptions(IPLDResolver.defaultOptions, userOptions);\n\n    if (!options.blockService) {\n      throw new Error('Missing blockservice');\n    }\n\n    this.bs = options.blockService; // Object with current list of active resolvers\n\n    this.resolvers = {};\n\n    if (typeof options.loadFormat !== 'function') {\n      this.loadFormat = codec => {\n        const codecName = multicodec.print[codec];\n        throw new Error(`No resolver found for codec \"${codecName}\"`);\n      };\n    } else {\n      this.loadFormat = options.loadFormat;\n    } // Enable all supplied formats\n\n\n    for (const format of options.formats) {\n      this.addFormat(format);\n    }\n  }\n  /**\n   * Add support for an IPLD Format.\n   *\n   * @param {Object} format - The implementation of an IPLD Format.\n   * @returns {this}\n   */\n\n\n  addFormat(format) {\n    const codec = format.codec;\n\n    if (this.resolvers[format.format]) {\n      const codecName = multicodec.print[codec];\n      throw new Error(`Resolver already exists for codec \"${codecName}\"`);\n    }\n\n    this.resolvers[codec] = format;\n    return this;\n  }\n  /**\n   * Remove support for an IPLD Format.\n   *\n   * @param {number} codec - The codec of the IPLD Format to remove.\n   * @returns {this}\n   */\n\n\n  removeFormat(codec) {\n    if (this.resolvers[codec]) {\n      delete this.resolvers[codec];\n    }\n\n    return this;\n  }\n  /**\n   * Retrieves IPLD Nodes along the `path` that is rooted at `cid`.\n   *\n   * @param {CID} cid - the CID the resolving starts.\n   * @param {string} path - the path that should be resolved.\n   * @param {Object} [options] -  Options is an object with the following properties.\n   * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation.\n   * @returns {Iterable.<Promise.<{remainderPath: string, value}>>} - Returns an async iterator of all the IPLD Nodes that were traversed during the path resolving. Every element is an object with these fields:\n   *   - `remainderPath`: the part of the path that wasn’t resolved yet.\n   *   - `value`: the value where the resolved path points to. If further traversing is possible, then the value is a CID object linking to another IPLD Node. If it was possible to fully resolve the path, value is the value the path points to. So if you need the CID of the IPLD Node you’re currently at, just take the value of the previously returned IPLD Node.\n   */\n\n\n  resolve(cid, path, options) {\n    if (!CID.isCID(cid)) {\n      throw new Error('`cid` argument must be a CID');\n    }\n\n    if (typeof path !== 'string') {\n      throw new Error('`path` argument must be a string');\n    }\n\n    const generator = async function* () {\n      // End iteration if there isn't a CID to follow anymore\n      while (cid !== null) {\n        const format = await this._getFormat(cid.codec); // get block\n        // use local resolver\n        // update path value\n\n        const block = await this.bs.get(cid, options);\n        const result = format.resolver.resolve(block.data, path); // Prepare for the next iteration if there is a `remainderPath`\n\n        path = result.remainderPath;\n        let value = result.value; // NOTE vmx 2018-11-29: Not all IPLD Formats return links as\n        // CIDs yet. Hence try to convert old style links to CIDs\n\n        if (Object.keys(value).length === 1 && '/' in value) {\n          try {\n            value = new CID(value['/']);\n          } catch (_error) {\n            value = null;\n          }\n        }\n\n        cid = CID.isCID(value) ? value : null;\n        yield {\n          remainderPath: path,\n          value\n        };\n      }\n    }.bind(this);\n\n    return extendIterator(generator());\n  }\n  /**\n   * Get a node by CID.\n   *\n   * @param {CID} cid - The CID of the IPLD Node that should be retrieved.\n   * @param {Object} [options] -  Options is an object with the following properties.\n   * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation.\n   * @returns {Promise.<Object>} - Returns a Promise with the IPLD Node that correspond to the given `cid`.\n   */\n\n\n  async get(cid, options) {\n    const block = await this.bs.get(cid, options);\n    const format = await this._getFormat(block.cid.codec);\n    const node = format.util.deserialize(block.data);\n    return node;\n  }\n  /**\n   * Get multiple nodes back from an array of CIDs.\n   *\n   * @param {Iterable.<CID>} cids - The CIDs of the IPLD Nodes that should be retrieved.\n   * @param {Object} [options] -  Options is an object with the following properties.\n   * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation.\n   * @returns {Iterable.<Promise.<Object>>} - Returns an async iterator with the IPLD Nodes that correspond to the given `cids`.\n   */\n\n\n  getMany(cids, options) {\n    if (!typical.isIterable(cids) || typeof cids === 'string' || Buffer.isBuffer(cids)) {\n      throw new Error('`cids` must be an iterable of CIDs');\n    }\n\n    const generator = async function* () {\n      for await (const cid of cids) {\n        yield this.get(cid, options);\n      }\n    }.bind(this);\n\n    return extendIterator(generator());\n  }\n  /**\n   * Stores the given IPLD Node of a recognized IPLD Format.\n   *\n   * @param {Object} node - The deserialized IPLD node that should be inserted.\n   * @param {number} format - The multicodec of the format that IPLD Node should be encoded in.\n   * @param {Object} [userOptions] -  Options is an object with the following properties.\n   * @param {number} [userOtions.hashAlg=hash algorithm of the given multicodec] - The hashing algorithm that is used to calculate the CID.\n   * @param {number} [userOptions.cidVersion=1] - The CID version to use.\n   * @param {boolean} [userOptions.onlyHash=false] - If true the serialized form of the IPLD Node will not be passed to the underlying block store.\n   * @param {AbortSignal} [userOptions.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation.\n   * @returns {Promise.<CID>} - Returns the CID of the serialized IPLD Nodes.\n   */\n\n\n  async put(node, format, userOptions) {\n    if (format === undefined) {\n      throw new Error('`put` requires a format');\n    }\n\n    if (typeof format !== 'number') {\n      throw new Error('`format` parameter must be number (multicodec)');\n    }\n\n    const formatImpl = await this._getFormat(format);\n    const defaultOptions = {\n      hashAlg: formatImpl.defaultHashAlg,\n      cidVersion: 1,\n      onlyHash: false\n    };\n    const options = mergeOptions(defaultOptions, userOptions);\n    const cidOptions = {\n      cidVersion: options.cidVersion,\n      hashAlg: options.hashAlg,\n      onlyHash: options.onlyHash\n    };\n    const serialized = formatImpl.util.serialize(node);\n    const cid = await formatImpl.util.cid(serialized, cidOptions);\n\n    if (!options.onlyHash) {\n      const block = new Block(serialized, cid);\n      await this.bs.put(block, options);\n    }\n\n    return cid;\n  }\n  /**\n   * Stores the given IPLD Nodes of a recognized IPLD Format.\n   *\n   * @param {Iterable.<Object>} nodes - Deserialized IPLD nodes that should be inserted.\n   * @param {number} format - The multicodec of the format that IPLD Node should be encoded in.\n   * @param {Object} [userOptions] -  Options are applied to any of the `nodes` and is an object with the following properties.\n   * @param {number} [userOtions.hashAlg=hash algorithm of the given multicodec] - The hashing algorithm that is used to calculate the CID.\n   * @param {number} [userOptions.cidVersion=1] - The CID version to use.\n   * @param {boolean} [userOptions.onlyHash=false] - If true the serialized form of the IPLD Node will not be passed to the underlying block store.\n   * @param {AbortSignal} [userOptions.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation.\n   * @returns {Iterable.<Promise.<CID>>} - Returns an async iterator with the CIDs of the serialized IPLD Nodes.\n   */\n\n\n  putMany(nodes, format, userOptions) {\n    if (!typical.isIterable(nodes) || typeof nodes === 'string' || Buffer.isBuffer(nodes)) {\n      throw new Error('`nodes` must be an iterable');\n    }\n\n    if (format === undefined) {\n      throw new Error('`put` requires a format');\n    }\n\n    if (typeof format !== 'number') {\n      throw new Error('`format` parameter must be number (multicodec)');\n    }\n\n    let options;\n    let formatImpl;\n\n    const generator = async function* () {\n      for await (const node of nodes) {\n        // Lazy load the options not when the iterator is initialized, but\n        // when we hit the first iteration. This way the constructor can be\n        // a synchronous function.\n        if (options === undefined) {\n          formatImpl = await this._getFormat(format);\n          const defaultOptions = {\n            hashAlg: formatImpl.defaultHashAlg,\n            cidVersion: 1,\n            onlyHash: false\n          };\n          options = mergeOptions(defaultOptions, userOptions);\n        }\n\n        yield this.put(node, format, options);\n      }\n    }.bind(this);\n\n    return extendIterator(generator());\n  }\n  /**\n   * Remove an IPLD Node by the given CID.\n   *\n   * @param {CID} cid - The CID of the IPLD Node that should be removed.\n   * @param {Object} [options] -  Options is an object with the following properties.\n   * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation.\n   * @return {Promise.<CID>} The CID of the removed IPLD Node.\n   */\n\n\n  async remove(cid, options) {\n    // eslint-disable-line require-await\n    return this.bs.delete(cid, options);\n  }\n  /**\n   * Remove IPLD Nodes by the given CIDs.\n   *\n   * Throws an error if any of the Blocks can’t be removed. This operation is\n   * *not* atomic, some Blocks might have already been removed.\n   *\n   * @param {Iterable.<CID>} cids - The CIDs of the IPLD Nodes that should be removed.\n   * @param {Object} [options] -  Options is an object with the following properties.\n   * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation.\n   * @return {Iterable.<Promise.<CID>>} Returns an async iterator with the CIDs of the removed IPLD Nodes.\n   */\n\n\n  removeMany(cids, options) {\n    if (!typical.isIterable(cids) || typeof cids === 'string' || Buffer.isBuffer(cids)) {\n      throw new Error('`cids` must be an iterable of CIDs');\n    }\n\n    const generator = async function* () {\n      for await (const cid of cids) {\n        yield this.remove(cid, options);\n      }\n    }.bind(this);\n\n    return extendIterator(generator());\n  }\n  /**\n   * Returns all the paths that can be resolved into.\n   *\n   * @param {Object} cid - The ID to get the paths from\n   * @param {string} [offsetPath=''] - the path to start to retrieve the other paths from.\n   * @param {Object} [userOptions]\n   * @param {number} [userOptions.recursive=false] - whether to get the paths recursively or not. `false` resolves only the paths of the given CID.\n   * @param {AbortSignal} [userOptions.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation.\n   * @returns {Iterable.<Promise.<String>>} - Returns an async iterator with paths that can be resolved into\n   */\n\n\n  tree(cid, offsetPath, userOptions) {\n    if (typeof offsetPath === 'object') {\n      userOptions = offsetPath;\n      offsetPath = undefined;\n    }\n\n    offsetPath = offsetPath || '';\n    const defaultOptions = {\n      recursive: false\n    };\n    const options = mergeOptions(defaultOptions, userOptions); // If a path is a link then follow it and return its CID\n\n    const maybeRecurse = async (block, treePath) => {\n      // A treepath we might want to follow recursively\n      const format = await this._getFormat(block.cid.codec);\n      const result = format.resolver.resolve(block.data, treePath); // Something to follow recusively, hence push it into the queue\n\n      if (CID.isCID(result.value)) {\n        return result.value;\n      } else {\n        return null;\n      }\n    };\n\n    const generator = async function* () {\n      // The list of paths that will get returned\n      const treePaths = []; // The current block, needed to call `isLink()` on every interation\n\n      let block; // The list of items we want to follow recursively. The items are\n      // an object consisting of the CID and the currently already resolved\n      // path\n\n      const queue = [{\n        cid,\n        basePath: ''\n      }]; // The path that was already traversed\n\n      let basePath; // End of iteration if there aren't any paths left to return or\n      // if we don't want to traverse recursively and have already\n      // returne the first level\n\n      while (treePaths.length > 0 || queue.length > 0) {\n        // There aren't any paths left, get them from the given CID\n        if (treePaths.length === 0 && queue.length > 0) {\n          ({\n            cid,\n            basePath\n          } = queue.shift());\n          const format = await this._getFormat(cid.codec);\n          block = await this.bs.get(cid, options);\n          const paths = format.resolver.tree(block.data);\n          treePaths.push(...paths);\n        }\n\n        const treePath = treePaths.shift();\n        let fullPath = basePath + treePath; // Only follow links if recursion is intended\n\n        if (options.recursive) {\n          cid = await maybeRecurse(block, treePath);\n\n          if (cid !== null) {\n            queue.push({\n              cid,\n              basePath: fullPath + '/'\n            });\n          }\n        } // Return it if it matches the given offset path, but is not the\n        // offset path itself\n\n\n        if (fullPath.startsWith(offsetPath) && fullPath.length > offsetPath.length) {\n          if (offsetPath.length > 0) {\n            fullPath = fullPath.slice(offsetPath.length + 1);\n          }\n\n          yield fullPath;\n        }\n      }\n    }.bind(this);\n\n    return extendIterator(generator());\n  }\n  /*           */\n\n  /* internals */\n\n  /*           */\n\n\n  async _getFormat(codec) {\n    // TODO vmx 2019-01-24: Once all CIDs support accessing the codec code\n    // instead of the name, remove this part\n    if (typeof codec === 'string') {\n      const constantName = codec.toUpperCase().replace(/-/g, '_');\n      codec = multicodec[constantName];\n    }\n\n    if (this.resolvers[codec]) {\n      return this.resolvers[codec];\n    } // If not supported, attempt to dynamically load this format\n\n\n    const format = await this.loadFormat(codec);\n    this.addFormat(format);\n    return format;\n  }\n\n}\n/**\n * Default options for IPLD.\n */\n\n\nIPLDResolver.defaultOptions = {\n  formats: [ipldDagCbor, ipldDagPb, ipldRaw]\n};\nmodule.exports = IPLDResolver;","map":null,"metadata":{},"sourceType":"script"}