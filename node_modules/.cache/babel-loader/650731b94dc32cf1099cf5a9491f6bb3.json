{"ast":null,"code":"'use strict';\n\nconst AggregateError = require('aggregate-error');\n\nconst PCancelable = require('p-cancelable');\n\nclass FilterError extends Error {}\n\nconst pSome = (iterable, options) => new PCancelable((resolve, reject, onCancel) => {\n  const {\n    count,\n    filter = () => true\n  } = options;\n\n  if (!Number.isFinite(count)) {\n    reject(new TypeError(`Expected a finite number, got ${typeof options.count}`));\n    return;\n  }\n\n  const values = [];\n  const errors = [];\n  let elementCount = 0;\n  let isSettled = false;\n  const completed = new Set();\n\n  const maybeSettle = () => {\n    if (values.length === count) {\n      resolve(values);\n      isSettled = true;\n    }\n\n    if (elementCount - errors.length < count) {\n      reject(new AggregateError(errors));\n      isSettled = true;\n    }\n\n    return isSettled;\n  };\n\n  const cancelPending = () => {\n    for (const promise of iterable) {\n      if (!completed.has(promise) && typeof promise.cancel === 'function') {\n        promise.cancel();\n      }\n    }\n  };\n\n  onCancel(cancelPending);\n\n  for (const element of iterable) {\n    elementCount++;\n\n    (async () => {\n      try {\n        const value = await element;\n\n        if (isSettled) {\n          return;\n        }\n\n        if (!filter(value)) {\n          throw new FilterError('Value does not satisfy filter');\n        }\n\n        values.push(value);\n      } catch (error) {\n        errors.push(error);\n      } finally {\n        completed.add(element);\n\n        if (!isSettled && maybeSettle()) {\n          cancelPending();\n        }\n      }\n    })();\n  }\n\n  if (count > elementCount) {\n    reject(new RangeError(`Expected input to contain at least ${options.count} items, but contains ${elementCount} items`));\n    cancelPending();\n  }\n});\n\nmodule.exports = pSome;\nmodule.exports.AggregateError = AggregateError;\nmodule.exports.FilterError = FilterError;","map":null,"metadata":{},"sourceType":"script"}