{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst log = debug('libp2p:upgrader');\nlog.error = debug('libp2p:upgrader:error');\n\nconst Multistream = require('multistream-select');\n\nconst {\n  Connection\n} = require('libp2p-interfaces/src/connection');\n\nconst PeerId = require('peer-id');\n\nconst pipe = require('it-pipe');\n\nconst errCode = require('err-code');\n\nconst mutableProxy = require('mutable-proxy');\n\nconst {\n  codes\n} = require('./errors');\n/**\n * @typedef MultiaddrConnection\n * @property {function} sink\n * @property {AsyncIterator} source\n * @property {*} conn\n * @property {Multiaddr} remoteAddr\n */\n\n/**\n * @typedef CryptoResult\n * @property {*} conn A duplex iterable\n * @property {PeerId} remotePeer\n * @property {string} protocol\n */\n\n\nclass Upgrader {\n  /**\n   * @param {object} options\n   * @param {PeerId} options.localPeer\n   * @param {Metrics} options.metrics\n   * @param {Map<string, Crypto>} options.cryptos\n   * @param {Map<string, Muxer>} options.muxers\n   * @param {function(Connection)} options.onConnection Called when a connection is upgraded\n   * @param {function(Connection)} options.onConnectionEnd\n   */\n  constructor({\n    localPeer,\n    metrics,\n    cryptos,\n    muxers,\n    onConnectionEnd = () => {},\n    onConnection = () => {}\n  }) {\n    this.localPeer = localPeer;\n    this.metrics = metrics;\n    this.cryptos = cryptos || new Map();\n    this.muxers = muxers || new Map();\n    this.protector = null;\n    this.protocols = new Map();\n    this.onConnection = onConnection;\n    this.onConnectionEnd = onConnectionEnd;\n  }\n  /**\n   * Upgrades an inbound connection\n   * @async\n   * @param {MultiaddrConnection} maConn\n   * @returns {Promise<Connection>}\n   */\n\n\n  async upgradeInbound(maConn) {\n    let encryptedConn;\n    let remotePeer;\n    let upgradedConn;\n    let Muxer;\n    let cryptoProtocol;\n    let setPeer;\n    let proxyPeer;\n\n    if (this.metrics) {\n      ({\n        setTarget: setPeer,\n        proxy: proxyPeer\n      } = mutableProxy());\n      const idString = parseInt(Math.random() * 1e9).toString(36) + Date.now();\n      setPeer({\n        toB58String: () => idString\n      });\n      maConn = this.metrics.trackStream({\n        stream: maConn,\n        remotePeer: proxyPeer\n      });\n    }\n\n    log('Starting the inbound connection upgrade'); // Protect\n\n    let protectedConn = maConn;\n\n    if (this.protector) {\n      protectedConn = await this.protector.protect(maConn);\n    }\n\n    try {\n      // Encrypt the connection\n      ({\n        conn: encryptedConn,\n        remotePeer,\n        protocol: cryptoProtocol\n      } = await this._encryptInbound(this.localPeer, protectedConn, this.cryptos)); // Multiplex the connection\n\n      if (this.muxers.size) {\n        ({\n          stream: upgradedConn,\n          Muxer\n        } = await this._multiplexInbound(encryptedConn, this.muxers));\n      } else {\n        upgradedConn = encryptedConn;\n      }\n    } catch (err) {\n      log.error('Failed to upgrade inbound connection', err);\n      await maConn.close(err);\n      throw err;\n    }\n\n    if (this.metrics) {\n      this.metrics.updatePlaceholder(proxyPeer, remotePeer);\n      setPeer(remotePeer);\n    }\n\n    log('Successfully upgraded inbound connection');\n    return this._createConnection({\n      cryptoProtocol,\n      direction: 'inbound',\n      maConn,\n      upgradedConn,\n      Muxer,\n      remotePeer\n    });\n  }\n  /**\n   * Upgrades an outbound connection\n   * @async\n   * @param {MultiaddrConnection} maConn\n   * @returns {Promise<Connection>}\n   */\n\n\n  async upgradeOutbound(maConn) {\n    let remotePeerId;\n\n    try {\n      remotePeerId = PeerId.createFromB58String(maConn.remoteAddr.getPeerId());\n    } catch (err) {\n      log.error('multiaddr did not contain a valid peer id', err);\n    }\n\n    let encryptedConn;\n    let remotePeer;\n    let upgradedConn;\n    let cryptoProtocol;\n    let Muxer;\n    let setPeer;\n    let proxyPeer;\n\n    if (this.metrics) {\n      ({\n        setTarget: setPeer,\n        proxy: proxyPeer\n      } = mutableProxy());\n      const idString = parseInt(Math.random() * 1e9).toString(36) + Date.now();\n      setPeer({\n        toB58String: () => idString\n      });\n      maConn = this.metrics.trackStream({\n        stream: maConn,\n        remotePeer: proxyPeer\n      });\n    }\n\n    log('Starting the outbound connection upgrade'); // Protect\n\n    let protectedConn = maConn;\n\n    if (this.protector) {\n      protectedConn = await this.protector.protect(maConn);\n    }\n\n    try {\n      // Encrypt the connection\n      ({\n        conn: encryptedConn,\n        remotePeer,\n        protocol: cryptoProtocol\n      } = await this._encryptOutbound(this.localPeer, protectedConn, remotePeerId, this.cryptos)); // Multiplex the connection\n\n      if (this.muxers.size) {\n        ({\n          stream: upgradedConn,\n          Muxer\n        } = await this._multiplexOutbound(encryptedConn, this.muxers));\n      } else {\n        upgradedConn = encryptedConn;\n      }\n    } catch (err) {\n      log.error('Failed to upgrade outbound connection', err);\n      await maConn.close(err);\n      throw err;\n    }\n\n    if (this.metrics) {\n      this.metrics.updatePlaceholder(proxyPeer, remotePeer);\n      setPeer(remotePeer);\n    }\n\n    log('Successfully upgraded outbound connection');\n    return this._createConnection({\n      cryptoProtocol,\n      direction: 'outbound',\n      maConn,\n      upgradedConn,\n      Muxer,\n      remotePeer\n    });\n  }\n  /**\n   * A convenience method for generating a new `Connection`\n   * @private\n   * @param {object} options\n   * @param {string} cryptoProtocol The crypto protocol that was negotiated\n   * @param {string} direction One of ['inbound', 'outbound']\n   * @param {MultiaddrConnection} maConn The transport layer connection\n   * @param {*} upgradedConn A duplex connection returned from multiplexer and/or crypto selection\n   * @param {Muxer} Muxer The muxer to be used for muxing\n   * @param {PeerId} remotePeer The peer the connection is with\n   * @returns {Connection}\n   */\n\n\n  _createConnection({\n    cryptoProtocol,\n    direction,\n    maConn,\n    upgradedConn,\n    Muxer,\n    remotePeer\n  }) {\n    let muxer;\n    let newStream; // eslint-disable-next-line prefer-const\n\n    let connection;\n\n    if (Muxer) {\n      // Create the muxer\n      muxer = new Muxer({\n        // Run anytime a remote stream is created\n        onStream: async muxedStream => {\n          const mss = new Multistream.Listener(muxedStream);\n\n          try {\n            const {\n              stream,\n              protocol\n            } = await mss.handle(Array.from(this.protocols.keys()));\n            log('%s: incoming stream opened on %s', direction, protocol);\n            if (this.metrics) this.metrics.trackStream({\n              stream,\n              remotePeer,\n              protocol\n            });\n            connection.addStream(muxedStream, {\n              protocol\n            });\n\n            this._onStream({\n              connection,\n              stream,\n              protocol\n            });\n          } catch (err) {\n            log.error(err);\n          }\n        },\n        // Run anytime a stream closes\n        onStreamEnd: muxedStream => {\n          connection.removeStream(muxedStream.id);\n        }\n      });\n\n      newStream = async protocols => {\n        log('%s: starting new stream on %s', direction, protocols);\n        const muxedStream = muxer.newStream();\n        const mss = new Multistream.Dialer(muxedStream);\n\n        try {\n          const {\n            stream,\n            protocol\n          } = await mss.select(protocols);\n          if (this.metrics) this.metrics.trackStream({\n            stream,\n            remotePeer,\n            protocol\n          });\n          return {\n            stream: { ...muxedStream,\n              ...stream\n            },\n            protocol\n          };\n        } catch (err) {\n          log.error('could not create new stream', err);\n          throw errCode(err, codes.ERR_UNSUPPORTED_PROTOCOL);\n        }\n      }; // Pipe all data through the muxer\n\n\n      pipe(upgradedConn, muxer, upgradedConn).catch(log.error);\n    }\n\n    const _timeline = maConn.timeline;\n    maConn.timeline = new Proxy(_timeline, {\n      set: (...args) => {\n        if (connection && args[1] === 'close' && args[2] && !_timeline.close) {\n          connection.stat.status = 'closed';\n          this.onConnectionEnd(connection);\n        }\n\n        return Reflect.set(...args);\n      }\n    });\n    maConn.timeline.upgraded = Date.now();\n\n    const errConnectionNotMultiplexed = () => {\n      throw errCode(new Error('connection is not multiplexed'), 'ERR_CONNECTION_NOT_MULTIPLEXED');\n    }; // Create the connection\n\n\n    connection = new Connection({\n      localAddr: maConn.localAddr,\n      remoteAddr: maConn.remoteAddr,\n      localPeer: this.localPeer,\n      remotePeer: remotePeer,\n      stat: {\n        direction,\n        timeline: maConn.timeline,\n        multiplexer: Muxer && Muxer.multicodec,\n        encryption: cryptoProtocol\n      },\n      newStream: newStream || errConnectionNotMultiplexed,\n      getStreams: () => muxer ? muxer.streams : errConnectionNotMultiplexed,\n      close: err => maConn.close(err)\n    });\n    this.onConnection(connection);\n    return connection;\n  }\n  /**\n   * Routes incoming streams to the correct handler\n   * @private\n   * @param {object} options\n   * @param {Connection} options.connection The connection the stream belongs to\n   * @param {Stream} options.stream\n   * @param {string} options.protocol\n   */\n\n\n  _onStream({\n    connection,\n    stream,\n    protocol\n  }) {\n    const handler = this.protocols.get(protocol);\n    handler({\n      connection,\n      stream,\n      protocol\n    });\n  }\n  /**\n   * Attempts to encrypt the incoming `connection` with the provided `cryptos`.\n   * @private\n   * @async\n   * @param {PeerId} localPeer The initiators PeerInfo\n   * @param {*} connection\n   * @param {Map<string, Crypto>} cryptos\n   * @returns {CryptoResult} An encrypted connection, remote peer `PeerId` and the protocol of the `Crypto` used\n   */\n\n\n  async _encryptInbound(localPeer, connection, cryptos) {\n    const mss = new Multistream.Listener(connection);\n    const protocols = Array.from(cryptos.keys());\n    log('handling inbound crypto protocol selection', protocols);\n\n    try {\n      const {\n        stream,\n        protocol\n      } = await mss.handle(protocols);\n      const crypto = cryptos.get(protocol);\n      log('encrypting inbound connection...');\n      return { ...(await crypto.secureInbound(localPeer, stream)),\n        protocol\n      };\n    } catch (err) {\n      throw errCode(err, codes.ERR_ENCRYPTION_FAILED);\n    }\n  }\n  /**\n   * Attempts to encrypt the given `connection` with the provided `cryptos`.\n   * The first `Crypto` module to succeed will be used\n   * @private\n   * @async\n   * @param {PeerId} localPeer The initiators PeerInfo\n   * @param {*} connection\n   * @param {PeerId} remotePeerId\n   * @param {Map<string, Crypto>} cryptos\n   * @returns {CryptoResult} An encrypted connection, remote peer `PeerId` and the protocol of the `Crypto` used\n   */\n\n\n  async _encryptOutbound(localPeer, connection, remotePeerId, cryptos) {\n    const mss = new Multistream.Dialer(connection);\n    const protocols = Array.from(cryptos.keys());\n    log('selecting outbound crypto protocol', protocols);\n\n    try {\n      const {\n        stream,\n        protocol\n      } = await mss.select(protocols);\n      const crypto = cryptos.get(protocol);\n      log('encrypting outbound connection to %j', remotePeerId);\n      return { ...(await crypto.secureOutbound(localPeer, stream, remotePeerId)),\n        protocol\n      };\n    } catch (err) {\n      throw errCode(err, codes.ERR_ENCRYPTION_FAILED);\n    }\n  }\n  /**\n   * Selects one of the given muxers via multistream-select. That\n   * muxer will be used for all future streams on the connection.\n   * @private\n   * @async\n   * @param {*} connection A basic duplex connection to multiplex\n   * @param {Map<string, Muxer>} muxers The muxers to attempt multiplexing with\n   * @returns {*} A muxed connection\n   */\n\n\n  async _multiplexOutbound(connection, muxers) {\n    const dialer = new Multistream.Dialer(connection);\n    const protocols = Array.from(muxers.keys());\n    log('outbound selecting muxer %s', protocols);\n\n    try {\n      const {\n        stream,\n        protocol\n      } = await dialer.select(protocols);\n      log('%s selected as muxer protocol', protocol);\n      const Muxer = muxers.get(protocol);\n      return {\n        stream,\n        Muxer\n      };\n    } catch (err) {\n      throw errCode(err, codes.ERR_MUXER_UNAVAILABLE);\n    }\n  }\n  /**\n   * Registers support for one of the given muxers via multistream-select. The\n   * selected muxer will be used for all future streams on the connection.\n   * @private\n   * @async\n   * @param {*} connection A basic duplex connection to multiplex\n   * @param {Map<string, Muxer>} muxers The muxers to attempt multiplexing with\n   * @returns {*} A muxed connection\n   */\n\n\n  async _multiplexInbound(connection, muxers) {\n    const listener = new Multistream.Listener(connection);\n    const protocols = Array.from(muxers.keys());\n    log('inbound handling muxers %s', protocols);\n\n    try {\n      const {\n        stream,\n        protocol\n      } = await listener.handle(protocols);\n      const Muxer = muxers.get(protocol);\n      return {\n        stream,\n        Muxer\n      };\n    } catch (err) {\n      throw errCode(err, codes.ERR_MUXER_UNAVAILABLE);\n    }\n  }\n\n}\n\nmodule.exports = Upgrader;","map":null,"metadata":{},"sourceType":"script"}