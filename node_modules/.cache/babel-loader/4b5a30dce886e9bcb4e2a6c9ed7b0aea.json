{"ast":null,"code":"/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _wrapAsyncGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar _awaitAsyncGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _asyncIterator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar _asyncGeneratorDelegate = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate\");\n\nvar _require = require('streaming-iterables'),\n    parallelMap = _require.parallelMap;\n\nvar CID = require('cids');\n\nvar _require2 = require('../../utils'),\n    resolvePath = _require2.resolvePath;\n\nvar PinManager = require('./pin-manager');\n\nvar PinTypes = PinManager.PinTypes;\n\nvar _require3 = require('../../utils'),\n    withTimeoutOption = _require3.withTimeoutOption;\n\nvar PIN_LS_CONCURRENCY = 8;\n\nmodule.exports = function (_ref) {\n  var pinManager = _ref.pinManager,\n      dag = _ref.dag;\n  return withTimeoutOption( /*#__PURE__*/function () {\n    var _ls = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(paths, options) {\n      var type, err, cids, pins, indirects;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              options = options || {};\n              type = PinTypes.all;\n\n              if (paths && !Array.isArray(paths) && !CID.isCID(paths) && typeof paths !== 'string') {\n                options = paths;\n                paths = null;\n              }\n\n              if (!options.type) {\n                _context2.next = 9;\n                break;\n              }\n\n              type = options.type;\n\n              if (typeof options.type === 'string') {\n                type = options.type.toLowerCase();\n              }\n\n              err = PinManager.checkPinType(type);\n\n              if (!err) {\n                _context2.next = 9;\n                break;\n              }\n\n              throw err;\n\n            case 9:\n              if (!paths) {\n                _context2.next = 16;\n                break;\n              }\n\n              paths = Array.isArray(paths) ? paths : [paths]; // check the pinned state of specific hashes\n\n              _context2.next = 13;\n              return _awaitAsyncGenerator(resolvePath(dag, paths));\n\n            case 13:\n              cids = _context2.sent;\n              return _context2.delegateYield(_asyncGeneratorDelegate(_asyncIterator(parallelMap(PIN_LS_CONCURRENCY, /*#__PURE__*/function () {\n                var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(cid) {\n                  var _yield$pinManager$isP, reason, pinned;\n\n                  return _regeneratorRuntime.wrap(function _callee$(_context) {\n                    while (1) {\n                      switch (_context.prev = _context.next) {\n                        case 0:\n                          _context.next = 2;\n                          return pinManager.isPinnedWithType(cid, type);\n\n                        case 2:\n                          _yield$pinManager$isP = _context.sent;\n                          reason = _yield$pinManager$isP.reason;\n                          pinned = _yield$pinManager$isP.pinned;\n\n                          if (pinned) {\n                            _context.next = 7;\n                            break;\n                          }\n\n                          throw new Error(\"path '\".concat(paths[cids.indexOf(cid)], \"' is not pinned\"));\n\n                        case 7:\n                          if (!(reason === PinTypes.direct || reason === PinTypes.recursive)) {\n                            _context.next = 9;\n                            break;\n                          }\n\n                          return _context.abrupt(\"return\", {\n                            cid: cid,\n                            type: reason\n                          });\n\n                        case 9:\n                          return _context.abrupt(\"return\", {\n                            cid: cid,\n                            type: \"\".concat(PinTypes.indirect, \" through \").concat(reason)\n                          });\n\n                        case 10:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }\n                  }, _callee);\n                }));\n\n                return function (_x3) {\n                  return _ref2.apply(this, arguments);\n                };\n              }(), cids)), _awaitAsyncGenerator), \"t0\", 15);\n\n            case 15:\n              return _context2.abrupt(\"return\");\n\n            case 16:\n              // show all pinned items of type\n              pins = [];\n\n              if (type === PinTypes.direct || type === PinTypes.all) {\n                pins = pins.concat(Array.from(pinManager.directPins).map(function (cid) {\n                  return {\n                    type: PinTypes.direct,\n                    cid: new CID(cid)\n                  };\n                }));\n              }\n\n              if (type === PinTypes.recursive || type === PinTypes.all) {\n                pins = pins.concat(Array.from(pinManager.recursivePins).map(function (cid) {\n                  return {\n                    type: PinTypes.recursive,\n                    cid: new CID(cid)\n                  };\n                }));\n              }\n\n              if (!(type === PinTypes.indirect || type === PinTypes.all)) {\n                _context2.next = 24;\n                break;\n              }\n\n              _context2.next = 22;\n              return _awaitAsyncGenerator(pinManager.getIndirectKeys(options));\n\n            case 22:\n              indirects = _context2.sent;\n              pins = pins // if something is pinned both directly and indirectly,\n              // report the indirect entry\n              .filter(function (_ref3) {\n                var cid = _ref3.cid;\n                return !indirects.includes(cid.toString()) || !pinManager.directPins.has(cid.toString());\n              }).concat(indirects.map(function (cid) {\n                return {\n                  type: PinTypes.indirect,\n                  cid: new CID(cid)\n                };\n              }));\n\n            case 24:\n              return _context2.delegateYield(_asyncGeneratorDelegate(_asyncIterator(pins), _awaitAsyncGenerator), \"t1\", 25);\n\n            case 25:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    function ls(_x, _x2) {\n      return _ls.apply(this, arguments);\n    }\n\n    return ls;\n  }());\n};","map":null,"metadata":{},"sourceType":"script"}