{"ast":null,"code":"/* eslint-disable no-undef */\n'use strict';\n\nvar _defineProperty = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _objectSpread = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _awaitAsyncGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _wrapAsyncGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar _asyncIterator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar _require = require('./http/fetch'),\n    _fetch = _require.fetch,\n    Request = _require.Request,\n    Headers = _require.Headers;\n\nvar _require2 = require('./http/error'),\n    TimeoutError = _require2.TimeoutError,\n    HTTPError = _require2.HTTPError;\n\nvar merge = require('merge-options').bind({\n  ignoreUndefined: true\n});\n\nvar _require3 = require('iso-url'),\n    URL = _require3.URL,\n    URLSearchParams = _require3.URLSearchParams;\n\nvar TextDecoder = require('./text-decoder');\n\nvar AbortController = require('abort-controller');\n\nvar anySignal = require('any-signal');\n\nvar timeout = function timeout(promise, ms, abortController) {\n  if (ms === undefined) {\n    return promise;\n  }\n\n  var start = Date.now();\n\n  var timedOut = function timedOut() {\n    var time = Date.now() - start;\n    return time >= ms;\n  };\n\n  return new Promise(function (resolve, reject) {\n    var timeoutID = setTimeout(function () {\n      if (timedOut()) {\n        reject(new TimeoutError());\n        abortController.abort();\n      }\n    }, ms);\n\n    var after = function after(next) {\n      return function (res) {\n        clearTimeout(timeoutID);\n\n        if (timedOut()) {\n          reject(new TimeoutError());\n          return;\n        }\n\n        next(res);\n      };\n    };\n\n    promise.then(after(resolve), after(reject));\n  });\n};\n\nvar defaults = {\n  headers: {},\n  throwHttpErrors: true,\n  credentials: 'same-origin',\n  transformSearchParams: function transformSearchParams(p) {\n    return p;\n  }\n};\n/**\n * @typedef {Object} APIOptions - creates a new type named 'SpecialType'\n * @prop {any} [body] - Request body\n * @prop {Object} [json] - JSON shortcut\n * @prop {string} [method] - GET, POST, PUT, DELETE, etc.\n * @prop {string} [base] - The base URL to use in case url is a relative URL\n * @prop {Headers|Record<string, string>} [headers] - Request header.\n * @prop {number} [timeout] - Amount of time until request should timeout in ms.\n * @prop {AbortSignal} [signal] - Signal to abort the request.\n * @prop {URLSearchParams|Object} [searchParams] - URL search param.\n * @prop {string} [credentials]\n * @prop {boolean} [throwHttpErrors]\n * @prop {function(URLSearchParams): URLSearchParams } [transformSearchParams]\n * @prop {function(any): any} [transform] - When iterating the response body, transform each chunk with this function.\n * @prop {function(Response): Promise<void>} [handleError] - Handle errors\n * @prop {function({total:number, loaded:number, lengthComputable:boolean}):void} [onUploadProgress] - Can be passed to track upload progress\n * @prop {function({total:number, loaded:number, lengthComputable:boolean}):void} [onDownloadProgress] - Can be passed to track download progress\n */\n\nvar HTTP = /*#__PURE__*/function () {\n  /**\n   *\n   * @param {APIOptions} options\n   */\n  function HTTP() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, HTTP);\n\n    /** @type {APIOptions} */\n    this.opts = merge(defaults, options);\n  }\n  /**\n   * Fetch\n   *\n   * @param {string | URL | Request} resource\n   * @param {APIOptions} options\n   * @returns {Promise<Response>}\n   */\n\n\n  _createClass(HTTP, [{\n    key: \"fetch\",\n    value: function () {\n      var _fetch2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(resource) {\n        var options,\n            opts,\n            url,\n            abortController,\n            signal,\n            response,\n            _args2 = arguments;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};\n\n                /** @type {APIOptions} */\n                opts = merge(this.opts, options);\n                opts.headers = new Headers(opts.headers); // validate resource type\n\n                if (!(typeof resource !== 'string' && !(resource instanceof URL || resource instanceof Request))) {\n                  _context2.next = 5;\n                  break;\n                }\n\n                throw new TypeError('`resource` must be a string, URL, or Request');\n\n              case 5:\n                if (!(opts.base && typeof opts.base === 'string' && typeof resource === 'string')) {\n                  _context2.next = 10;\n                  break;\n                }\n\n                if (!resource.startsWith('/')) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                throw new Error('`resource` must not begin with a slash when using `base`');\n\n              case 8:\n                if (!opts.base.endsWith('/')) {\n                  opts.base += '/';\n                }\n\n                resource = opts.base + resource;\n\n              case 10:\n                // TODO: try to remove the logic above or fix URL instance input without trailing '/'\n                url = new URL(resource, opts.base);\n\n                if (opts.searchParams) {\n                  url.search = opts.transformSearchParams(new URLSearchParams(opts.searchParams));\n                }\n\n                if (opts.json !== undefined) {\n                  opts.body = JSON.stringify(opts.json);\n                  opts.headers.set('content-type', 'application/json');\n                }\n\n                abortController = new AbortController();\n                signal = anySignal([abortController.signal, opts.signal]);\n                _context2.next = 17;\n                return timeout(_fetch(url, _objectSpread(_objectSpread({}, opts), {}, {\n                  signal: signal,\n                  timeout: undefined\n                })), opts.timeout, abortController);\n\n              case 17:\n                response = _context2.sent;\n\n                if (!(!response.ok && opts.throwHttpErrors)) {\n                  _context2.next = 23;\n                  break;\n                }\n\n                if (!opts.handleError) {\n                  _context2.next = 22;\n                  break;\n                }\n\n                _context2.next = 22;\n                return opts.handleError(response);\n\n              case 22:\n                throw new HTTPError(response);\n\n              case 23:\n                response.iterator = function () {\n                  var it = streamToAsyncIterator(response.body);\n\n                  if (!isAsyncIterator(it)) {\n                    throw new Error('Can\\'t convert fetch body into a Async Iterator:');\n                  }\n\n                  return it;\n                };\n\n                response.ndjson = /*#__PURE__*/_wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n                  var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, chunk;\n\n                  return _regeneratorRuntime.wrap(function _callee$(_context) {\n                    while (1) {\n                      switch (_context.prev = _context.next) {\n                        case 0:\n                          _iteratorNormalCompletion = true;\n                          _didIteratorError = false;\n                          _context.prev = 2;\n                          _iterator = _asyncIterator(ndjson(response.iterator()));\n\n                        case 4:\n                          _context.next = 6;\n                          return _awaitAsyncGenerator(_iterator.next());\n\n                        case 6:\n                          _step = _context.sent;\n                          _iteratorNormalCompletion = _step.done;\n                          _context.next = 10;\n                          return _awaitAsyncGenerator(_step.value);\n\n                        case 10:\n                          _value = _context.sent;\n\n                          if (_iteratorNormalCompletion) {\n                            _context.next = 23;\n                            break;\n                          }\n\n                          chunk = _value;\n\n                          if (!options.transform) {\n                            _context.next = 18;\n                            break;\n                          }\n\n                          _context.next = 16;\n                          return options.transform(chunk);\n\n                        case 16:\n                          _context.next = 20;\n                          break;\n\n                        case 18:\n                          _context.next = 20;\n                          return chunk;\n\n                        case 20:\n                          _iteratorNormalCompletion = true;\n                          _context.next = 4;\n                          break;\n\n                        case 23:\n                          _context.next = 29;\n                          break;\n\n                        case 25:\n                          _context.prev = 25;\n                          _context.t0 = _context[\"catch\"](2);\n                          _didIteratorError = true;\n                          _iteratorError = _context.t0;\n\n                        case 29:\n                          _context.prev = 29;\n                          _context.prev = 30;\n\n                          if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                            _context.next = 34;\n                            break;\n                          }\n\n                          _context.next = 34;\n                          return _awaitAsyncGenerator(_iterator.return());\n\n                        case 34:\n                          _context.prev = 34;\n\n                          if (!_didIteratorError) {\n                            _context.next = 37;\n                            break;\n                          }\n\n                          throw _iteratorError;\n\n                        case 37:\n                          return _context.finish(34);\n\n                        case 38:\n                          return _context.finish(29);\n\n                        case 39:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }\n                  }, _callee, null, [[2, 25, 29, 39], [30,, 34, 38]]);\n                }));\n                return _context2.abrupt(\"return\", response);\n\n              case 26:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function fetch(_x2) {\n        return _fetch2.apply(this, arguments);\n      }\n\n      return fetch;\n    }()\n    /**\n     * @param {string | URL | Request} resource\n     * @param {APIOptions} options\n     * @returns {Promise<Response>}\n     */\n\n  }, {\n    key: \"post\",\n    value: function post(resource) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.fetch(resource, _objectSpread(_objectSpread({}, options), {}, {\n        method: 'POST'\n      }));\n    }\n    /**\n     * @param {string | URL | Request} resource\n     * @param {APIOptions} options\n     * @returns {Promise<Response>}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(resource) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.fetch(resource, _objectSpread(_objectSpread({}, options), {}, {\n        method: 'GET'\n      }));\n    }\n    /**\n     * @param {string | URL | Request} resource\n     * @param {APIOptions} options\n     * @returns {Promise<Response>}\n     */\n\n  }, {\n    key: \"put\",\n    value: function put(resource) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.fetch(resource, _objectSpread(_objectSpread({}, options), {}, {\n        method: 'PUT'\n      }));\n    }\n    /**\n     * @param {string | URL | Request} resource\n     * @param {APIOptions} options\n     * @returns {Promise<Response>}\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete(resource) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.fetch(resource, _objectSpread(_objectSpread({}, options), {}, {\n        method: 'DELETE'\n      }));\n    }\n    /**\n     * @param {string | URL | Request} resource\n     * @param {APIOptions} options\n     * @returns {Promise<Response>}\n     */\n\n  }, {\n    key: \"options\",\n    value: function options(resource) {\n      var _options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      return this.fetch(resource, _objectSpread(_objectSpread({}, _options), {}, {\n        method: 'OPTIONS'\n      }));\n    }\n  }]);\n\n  return HTTP;\n}();\n/**\n * Parses NDJSON chunks from an iterator\n *\n * @param {AsyncGenerator<Uint8Array, void, any>} source\n * @returns {AsyncGenerator<Object, void, any>}\n */\n\n\nvar ndjson = /*#__PURE__*/function () {\n  var _ref2 = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(source) {\n    var decoder, buf, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _value2, chunk, lines, i, l;\n\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            decoder = new TextDecoder();\n            buf = '';\n            _iteratorNormalCompletion2 = true;\n            _didIteratorError2 = false;\n            _context3.prev = 4;\n            _iterator2 = _asyncIterator(source);\n\n          case 6:\n            _context3.next = 8;\n            return _awaitAsyncGenerator(_iterator2.next());\n\n          case 8:\n            _step2 = _context3.sent;\n            _iteratorNormalCompletion2 = _step2.done;\n            _context3.next = 12;\n            return _awaitAsyncGenerator(_step2.value);\n\n          case 12:\n            _value2 = _context3.sent;\n\n            if (_iteratorNormalCompletion2) {\n              _context3.next = 30;\n              break;\n            }\n\n            chunk = _value2;\n            buf += decoder.decode(chunk, {\n              stream: true\n            });\n            lines = buf.split(/\\r?\\n/);\n            i = 0;\n\n          case 18:\n            if (!(i < lines.length - 1)) {\n              _context3.next = 26;\n              break;\n            }\n\n            l = lines[i].trim();\n\n            if (!(l.length > 0)) {\n              _context3.next = 23;\n              break;\n            }\n\n            _context3.next = 23;\n            return JSON.parse(l);\n\n          case 23:\n            i++;\n            _context3.next = 18;\n            break;\n\n          case 26:\n            buf = lines[lines.length - 1];\n\n          case 27:\n            _iteratorNormalCompletion2 = true;\n            _context3.next = 6;\n            break;\n\n          case 30:\n            _context3.next = 36;\n            break;\n\n          case 32:\n            _context3.prev = 32;\n            _context3.t0 = _context3[\"catch\"](4);\n            _didIteratorError2 = true;\n            _iteratorError2 = _context3.t0;\n\n          case 36:\n            _context3.prev = 36;\n            _context3.prev = 37;\n\n            if (!(!_iteratorNormalCompletion2 && _iterator2.return != null)) {\n              _context3.next = 41;\n              break;\n            }\n\n            _context3.next = 41;\n            return _awaitAsyncGenerator(_iterator2.return());\n\n          case 41:\n            _context3.prev = 41;\n\n            if (!_didIteratorError2) {\n              _context3.next = 44;\n              break;\n            }\n\n            throw _iteratorError2;\n\n          case 44:\n            return _context3.finish(41);\n\n          case 45:\n            return _context3.finish(36);\n\n          case 46:\n            buf += decoder.decode();\n            buf = buf.trim();\n\n            if (!(buf.length !== 0)) {\n              _context3.next = 51;\n              break;\n            }\n\n            _context3.next = 51;\n            return JSON.parse(buf);\n\n          case 51:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, null, [[4, 32, 36, 46], [37,, 41, 45]]);\n  }));\n\n  return function ndjson(_x) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nvar streamToAsyncIterator = function streamToAsyncIterator(source) {\n  if (isAsyncIterator(source)) {\n    // Workaround for https://github.com/node-fetch/node-fetch/issues/766\n    if (Object.prototype.hasOwnProperty.call(source, 'readable') && Object.prototype.hasOwnProperty.call(source, 'writable')) {\n      var iter = source[Symbol.asyncIterator]();\n\n      var wrapper = _defineProperty({\n        next: iter.next.bind(iter),\n        return: function _return() {\n          source.destroy();\n          return iter.return();\n        }\n      }, Symbol.asyncIterator, function () {\n        return wrapper;\n      });\n\n      return wrapper;\n    }\n\n    return source;\n  }\n\n  var reader = source.getReader();\n  return _defineProperty({\n    next: function next() {\n      return reader.read();\n    },\n    return: function _return() {\n      reader.releaseLock();\n      return {};\n    }\n  }, Symbol.asyncIterator, function () {\n    return this;\n  });\n};\n\nvar isAsyncIterator = function isAsyncIterator(obj) {\n  return typeof obj === 'object' && obj !== null && // typeof obj.next === 'function' &&\n  typeof obj[Symbol.asyncIterator] === 'function';\n};\n\nHTTP.HTTPError = HTTPError;\nHTTP.TimeoutError = TimeoutError;\nHTTP.streamToAsyncIterator = streamToAsyncIterator;\n/**\n * @param {string | URL | Request} resource\n * @param {APIOptions} options\n * @returns {Promise<Response>}\n */\n\nHTTP.post = function (resource, options) {\n  return new HTTP(options).post(resource, options);\n};\n/**\n * @param {string | URL | Request} resource\n * @param {APIOptions} options\n * @returns {Promise<Response>}\n */\n\n\nHTTP.get = function (resource, options) {\n  return new HTTP(options).get(resource, options);\n};\n/**\n * @param {string | URL | Request} resource\n * @param {APIOptions} options\n * @returns {Promise<Response>}\n */\n\n\nHTTP.put = function (resource, options) {\n  return new HTTP(options).put(resource, options);\n};\n/**\n * @param {string | URL | Request} resource\n * @param {APIOptions} options\n * @returns {Promise<Response>}\n */\n\n\nHTTP.delete = function (resource, options) {\n  return new HTTP(options).delete(resource, options);\n};\n/**\n * @param {string | URL | Request} resource\n * @param {APIOptions} options\n * @returns {Promise<Response>}\n */\n\n\nHTTP.options = function (resource, options) {\n  return new HTTP(options).options(resource, options);\n};\n\nmodule.exports = HTTP;","map":null,"metadata":{},"sourceType":"script"}