{"ast":null,"code":"import { HNYMovement as anjMovementTypes, HNYBalance as anjBalanceTypes, movementDirection, STAKE_ACTIVATION_MOVEMENT } from '../types/anj-types';\nimport { bigNum } from '../lib/math-utils';\n/**\r\n * Function intended to group Stake and Activation movements that were created at the same time\r\n *  into one StakeActivation movement\r\n * This is needed since moving HNY from wallet to Active Balance, two movements\r\n *  are performed (Wallet (stake) => InactiveBalance; Inactive balance (activate) => Active balance)\r\n * @param {Array} movements Array of original movements\r\n * @returns {Array} Resuling array of movements grouped by the logic described above\r\n */\n\nexport const groupMovements = movements => {\n  // If the juror is activating from the wallet we need to just show an incoming movement in the Active balance\n  // and an outgoing movement in the Wallet balance\n  return movements.reduce((movements, currentMovement, index, prevMovements) => {\n    const prevMovement = prevMovements[index - 1];\n\n    if (index > 0 && anjMovementTypes[prevMovement.type] === anjMovementTypes.Activation && anjMovementTypes[currentMovement.type] === anjMovementTypes.Stake && prevMovement.createdAt === currentMovement.createdAt) {\n      movements[movements.length - 1].type = STAKE_ACTIVATION_MOVEMENT;\n      return movements;\n    }\n\n    movements.push({ ...currentMovement,\n      effectiveTermId: currentMovement.effectiveTermId ? parseInt(currentMovement.effectiveTermId, 10) : null,\n      amount: bigNum(currentMovement.amount)\n    });\n    return movements;\n  }, []);\n}; // The intention here is to know which movements types should correspond with each balance\n\nexport const acceptedMovementsPerBalance = new Map([[anjBalanceTypes.Wallet, [{\n  type: anjMovementTypes.Stake,\n  direction: movementDirection.Outgoing\n}, {\n  type: anjMovementTypes.Unstake,\n  direction: movementDirection.Incoming\n}, {\n  type: anjMovementTypes.StakeActivation,\n  direction: movementDirection.Outgoing\n}]], [anjBalanceTypes.Inactive, [{\n  type: anjMovementTypes.Stake,\n  direction: movementDirection.Incoming\n}, {\n  type: anjMovementTypes.Unstake,\n  direction: movementDirection.Outgoing\n}, {\n  type: anjMovementTypes.Reward,\n  direction: movementDirection.Incoming\n}, {\n  type: anjMovementTypes.Activation,\n  direction: movementDirection.Outgoing\n}, {\n  type: anjMovementTypes.Deactivation,\n  direction: movementDirection.Incoming\n}]], [anjBalanceTypes.Active, [{\n  type: anjMovementTypes.StakeActivation,\n  direction: movementDirection.Incoming\n}, {\n  type: anjMovementTypes.Activation,\n  direction: movementDirection.Incoming\n}, {\n  type: anjMovementTypes.Deactivation,\n  direction: movementDirection.Outgoing\n}, {\n  type: anjMovementTypes.DeactivationProcess,\n  direction: movementDirection.Locked\n}, {\n  type: anjMovementTypes.Lock,\n  direction: movementDirection.Locked\n}, {\n  type: anjMovementTypes.Unlock,\n  direction: movementDirection.Incoming\n}, {\n  type: anjMovementTypes.Slash,\n  direction: movementDirection.Outgoing\n}]]]);\nexport function isMovementOf(movements, movementType) {\n  return movements.some(movement => movement.type === movementType);\n}\n/**\r\n * Gets the direction of a movement [Incoming, Outgoing, Locked]\r\n * @param {Array} acceptedMovements Array of movements accepted for `movementType`\r\n * @param {Symbol} movementType type of movement\r\n * @returns {Symbol} The direction of the movement\r\n */\n\nexport function getMovementDirection(acceptedMovements, movementType) {\n  const {\n    direction\n  } = acceptedMovements.find(elem => elem.type === movementType);\n  return direction;\n}\n/**\r\n * Tells whether a movement is effective or not\r\n * @param {Object} movement Movement to check effectiveness of\r\n * @param {Number} currentTermId Id of the current term\r\n * @returns {Boolean} True if the movement is effective\r\n */\n\nexport function isMovementEffective(movement, currentTermId) {\n  if (!movement.effectiveTermId) return true;\n  return movement.effectiveTermId <= currentTermId;\n}\nexport function getAmountNotEffectiveByMovement(movements, movementType) {\n  return movements.filter(mov => !mov.isEffective && anjMovementTypes[mov.type] === movementType).reduce((acc, mov) => acc.add(mov.amount), bigNum(0));\n}\n/**\r\n * Gets the total amount not yet effective for a given type of balance\r\n * @param {Array} movements Array of movements to get the total not effective from\r\n * @param {Symbol} balanceType Type of balance [Wallet, Inactive, Active]\r\n * @returns {BigNum} Total amount not yet effective\r\n */\n\nexport function getAmountNotEffectiveByBalance(movements, balanceType) {\n  // We need to calulate the total not effective amount for the active and inactive balance\n  // Note that we don't do this for the wallet balance since all its corresponding movements are done effective inmediately\n  // Note that this assumes the termDuration is less than 24hrs\n  if (balanceType === anjBalanceTypes.Wallet) {\n    return bigNum(0);\n  }\n\n  const movementType = balanceType === anjBalanceTypes.Active ? anjMovementTypes.Activation : anjMovementTypes.Deactivation;\n  return getAmountNotEffectiveByMovement(movements, movementType);\n}\n/**\r\n * gets the latest movement depending on the type of balance\r\n * @dev Note that for the Active balance, if there are deactivation requests not yet effective\r\n * we must give them priority over the rest\r\n *\r\n * @param {Array} movements Array of movements to get the latest from\r\n * @param {Symbol} balanceType Type of balance [Wallet, Inactive, Active]\r\n * @returns {Object} Latest movement (if any) relative to the type of balance\r\n */\n\nexport function getLatestMovementByBalance(movements, balanceType) {\n  if (!movements.length) {\n    return null;\n  } // We have to give a special treatment to the active balance since\n  // deactivation requests that are not yet effective have more priority than the rest\n\n\n  if (balanceType === anjBalanceTypes.Active) {\n    const totalDeactivationsNotEffective = getAmountNotEffectiveByMovement(movements, anjMovementTypes.Deactivation);\n\n    if (totalDeactivationsNotEffective.gt(0)) {\n      return {\n        amount: totalDeactivationsNotEffective,\n        type: anjMovementTypes.DeactivationProcess\n      };\n    }\n  } // Get the latest movement\n\n\n  let latestMovement = movements[0];\n  const latestMovementType = anjMovementTypes[latestMovement.type]; // If the latest movement for the active or inactive balance is a deactivation, we must check that the deactivation is effective\n\n  if (latestMovementType === anjMovementTypes.Deactivation) {\n    if (balanceType === anjBalanceTypes.Inactive && !latestMovement.isEffective) {\n      // In case the deactivation is not effective, we'll get the most recent effective or immediate movement for the inactive balance\n      // Note that the array is orderer by most recent desc\n      latestMovement = movements.find(movement => movement.isEffective || movement.isImmediate);\n\n      if (!latestMovement || anjMovementTypes[latestMovement.type] !== anjMovementTypes.Deactivation) {\n        return latestMovement;\n      }\n    } // We get here if all this conditions are given\n    // - Latest movement is a Deactivation\n    // - Latest movement is Effective\n    // - We are calculating latest movement for Active or Inactive balance\n    // In all these cases, we need to get all deactivations\n    // done effective on the same term as this latest movement\n\n\n    return { ...latestMovement,\n      amount: getTotalEffectiveAt(movements, anjMovementTypes.Deactivation, latestMovement.effectiveTermId)\n    };\n  }\n\n  return latestMovement;\n}\n/**\r\n * Calculates the aggregated effective movements amount at term `termId`\r\n * @param {Array} movements Array of movements\r\n * @param {Symbol} movementType Type of movement\r\n * @param {Number} termId Id of the term\r\n * @returns {BigNum} Total effective movements amount at `termId`\r\n */\n\nfunction getTotalEffectiveAt(movements, movementType, termId) {\n  return movements.filter(movement => anjMovementTypes[movement.type] === movementType && movement.effectiveTermId === termId).reduce((acc, movement) => acc.add(movement.amount), bigNum(0));\n}\n\nexport function convertMovement(acceptedMovements, movement) {\n  if (!movement) return null;\n  const movementType = typeof movement.type === 'symbol' ? movement.type : anjMovementTypes[movement.type];\n  const direction = getMovementDirection(acceptedMovements, movementType);\n  return {\n    type: movementType,\n    amount: movement.amount,\n    direction\n  };\n}\nexport function getUpdatedLockedMovement(lockedBalance, latestMovement) {\n  if (!lockedBalance || lockedBalance.eq(0)) {\n    return latestMovement;\n  } // In the case that the juror has locked balance, we must update the active balance latest movement\n\n\n  const movementTypeLock = anjMovementTypes.Lock;\n  let newLockedAmount = lockedBalance; // If active balance latest movement is a deactivation process, we must update the amount\n\n  if ((latestMovement === null || latestMovement === void 0 ? void 0 : latestMovement.type) === anjMovementTypes.DeactivationProcess) {\n    newLockedAmount = newLockedAmount.add(latestMovement.amount);\n  }\n\n  return { ...latestMovement,\n    amount: newLockedAmount,\n    type: movementTypeLock\n  };\n}","map":{"version":3,"sources":["/Users/fabianmolina/Documents/1hive/tulip-frontend/src/utils/anj-movement-utils.js"],"names":["HNYMovement","anjMovementTypes","HNYBalance","anjBalanceTypes","movementDirection","STAKE_ACTIVATION_MOVEMENT","bigNum","groupMovements","movements","reduce","currentMovement","index","prevMovements","prevMovement","type","Activation","Stake","createdAt","length","push","effectiveTermId","parseInt","amount","acceptedMovementsPerBalance","Map","Wallet","direction","Outgoing","Unstake","Incoming","StakeActivation","Inactive","Reward","Deactivation","Active","DeactivationProcess","Locked","Lock","Unlock","Slash","isMovementOf","movementType","some","movement","getMovementDirection","acceptedMovements","find","elem","isMovementEffective","currentTermId","getAmountNotEffectiveByMovement","filter","mov","isEffective","acc","add","getAmountNotEffectiveByBalance","balanceType","getLatestMovementByBalance","totalDeactivationsNotEffective","gt","latestMovement","latestMovementType","isImmediate","getTotalEffectiveAt","termId","convertMovement","getUpdatedLockedMovement","lockedBalance","eq","movementTypeLock","newLockedAmount"],"mappings":"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","sourcesContent":["import {\r\n  HNYMovement as anjMovementTypes,\r\n  HNYBalance as anjBalanceTypes,\r\n  movementDirection,\r\n  STAKE_ACTIVATION_MOVEMENT,\r\n} from '../types/anj-types'\r\nimport { bigNum } from '../lib/math-utils'\r\n\r\n/**\r\n * Function intended to group Stake and Activation movements that were created at the same time\r\n *  into one StakeActivation movement\r\n * This is needed since moving HNY from wallet to Active Balance, two movements\r\n *  are performed (Wallet (stake) => InactiveBalance; Inactive balance (activate) => Active balance)\r\n * @param {Array} movements Array of original movements\r\n * @returns {Array} Resuling array of movements grouped by the logic described above\r\n */\r\nexport const groupMovements = movements => {\r\n  // If the juror is activating from the wallet we need to just show an incoming movement in the Active balance\r\n  // and an outgoing movement in the Wallet balance\r\n  return movements.reduce(\r\n    (movements, currentMovement, index, prevMovements) => {\r\n      const prevMovement = prevMovements[index - 1]\r\n\r\n      if (\r\n        index > 0 &&\r\n        anjMovementTypes[prevMovement.type] === anjMovementTypes.Activation &&\r\n        anjMovementTypes[currentMovement.type] === anjMovementTypes.Stake &&\r\n        prevMovement.createdAt === currentMovement.createdAt\r\n      ) {\r\n        movements[movements.length - 1].type = STAKE_ACTIVATION_MOVEMENT\r\n        return movements\r\n      }\r\n\r\n      movements.push({\r\n        ...currentMovement,\r\n        effectiveTermId: currentMovement.effectiveTermId\r\n          ? parseInt(currentMovement.effectiveTermId, 10)\r\n          : null,\r\n        amount: bigNum(currentMovement.amount),\r\n      })\r\n\r\n      return movements\r\n    },\r\n    []\r\n  )\r\n}\r\n\r\n// The intention here is to know which movements types should correspond with each balance\r\nexport const acceptedMovementsPerBalance = new Map([\r\n  [\r\n    anjBalanceTypes.Wallet,\r\n    [\r\n      { type: anjMovementTypes.Stake, direction: movementDirection.Outgoing },\r\n      { type: anjMovementTypes.Unstake, direction: movementDirection.Incoming },\r\n      {\r\n        type: anjMovementTypes.StakeActivation,\r\n        direction: movementDirection.Outgoing,\r\n      },\r\n    ],\r\n  ],\r\n  [\r\n    anjBalanceTypes.Inactive,\r\n    [\r\n      { type: anjMovementTypes.Stake, direction: movementDirection.Incoming },\r\n      { type: anjMovementTypes.Unstake, direction: movementDirection.Outgoing },\r\n      { type: anjMovementTypes.Reward, direction: movementDirection.Incoming },\r\n      {\r\n        type: anjMovementTypes.Activation,\r\n        direction: movementDirection.Outgoing,\r\n      },\r\n      {\r\n        type: anjMovementTypes.Deactivation,\r\n        direction: movementDirection.Incoming,\r\n      },\r\n    ],\r\n  ],\r\n  [\r\n    anjBalanceTypes.Active,\r\n    [\r\n      {\r\n        type: anjMovementTypes.StakeActivation,\r\n        direction: movementDirection.Incoming,\r\n      },\r\n      {\r\n        type: anjMovementTypes.Activation,\r\n        direction: movementDirection.Incoming,\r\n      },\r\n      {\r\n        type: anjMovementTypes.Deactivation,\r\n        direction: movementDirection.Outgoing,\r\n      },\r\n      {\r\n        type: anjMovementTypes.DeactivationProcess,\r\n        direction: movementDirection.Locked,\r\n      },\r\n      { type: anjMovementTypes.Lock, direction: movementDirection.Locked },\r\n      { type: anjMovementTypes.Unlock, direction: movementDirection.Incoming },\r\n      { type: anjMovementTypes.Slash, direction: movementDirection.Outgoing },\r\n    ],\r\n  ],\r\n])\r\n\r\nexport function isMovementOf(movements, movementType) {\r\n  return movements.some(movement => movement.type === movementType)\r\n}\r\n\r\n/**\r\n * Gets the direction of a movement [Incoming, Outgoing, Locked]\r\n * @param {Array} acceptedMovements Array of movements accepted for `movementType`\r\n * @param {Symbol} movementType type of movement\r\n * @returns {Symbol} The direction of the movement\r\n */\r\nexport function getMovementDirection(acceptedMovements, movementType) {\r\n  const { direction } = acceptedMovements.find(\r\n    elem => elem.type === movementType\r\n  )\r\n\r\n  return direction\r\n}\r\n\r\n/**\r\n * Tells whether a movement is effective or not\r\n * @param {Object} movement Movement to check effectiveness of\r\n * @param {Number} currentTermId Id of the current term\r\n * @returns {Boolean} True if the movement is effective\r\n */\r\nexport function isMovementEffective(movement, currentTermId) {\r\n  if (!movement.effectiveTermId) return true\r\n\r\n  return movement.effectiveTermId <= currentTermId\r\n}\r\n\r\nexport function getAmountNotEffectiveByMovement(movements, movementType) {\r\n  return movements\r\n    .filter(\r\n      mov => !mov.isEffective && anjMovementTypes[mov.type] === movementType\r\n    )\r\n    .reduce((acc, mov) => acc.add(mov.amount), bigNum(0))\r\n}\r\n\r\n/**\r\n * Gets the total amount not yet effective for a given type of balance\r\n * @param {Array} movements Array of movements to get the total not effective from\r\n * @param {Symbol} balanceType Type of balance [Wallet, Inactive, Active]\r\n * @returns {BigNum} Total amount not yet effective\r\n */\r\nexport function getAmountNotEffectiveByBalance(movements, balanceType) {\r\n  // We need to calulate the total not effective amount for the active and inactive balance\r\n  // Note that we don't do this for the wallet balance since all its corresponding movements are done effective inmediately\r\n  // Note that this assumes the termDuration is less than 24hrs\r\n  if (balanceType === anjBalanceTypes.Wallet) {\r\n    return bigNum(0)\r\n  }\r\n\r\n  const movementType =\r\n    balanceType === anjBalanceTypes.Active\r\n      ? anjMovementTypes.Activation\r\n      : anjMovementTypes.Deactivation\r\n\r\n  return getAmountNotEffectiveByMovement(movements, movementType)\r\n}\r\n\r\n/**\r\n * gets the latest movement depending on the type of balance\r\n * @dev Note that for the Active balance, if there are deactivation requests not yet effective\r\n * we must give them priority over the rest\r\n *\r\n * @param {Array} movements Array of movements to get the latest from\r\n * @param {Symbol} balanceType Type of balance [Wallet, Inactive, Active]\r\n * @returns {Object} Latest movement (if any) relative to the type of balance\r\n */\r\nexport function getLatestMovementByBalance(movements, balanceType) {\r\n  if (!movements.length) {\r\n    return null\r\n  }\r\n\r\n  // We have to give a special treatment to the active balance since\r\n  // deactivation requests that are not yet effective have more priority than the rest\r\n  if (balanceType === anjBalanceTypes.Active) {\r\n    const totalDeactivationsNotEffective = getAmountNotEffectiveByMovement(\r\n      movements,\r\n      anjMovementTypes.Deactivation\r\n    )\r\n\r\n    if (totalDeactivationsNotEffective.gt(0)) {\r\n      return {\r\n        amount: totalDeactivationsNotEffective,\r\n        type: anjMovementTypes.DeactivationProcess,\r\n      }\r\n    }\r\n  }\r\n\r\n  // Get the latest movement\r\n  let latestMovement = movements[0]\r\n  const latestMovementType = anjMovementTypes[latestMovement.type]\r\n\r\n  // If the latest movement for the active or inactive balance is a deactivation, we must check that the deactivation is effective\r\n  if (latestMovementType === anjMovementTypes.Deactivation) {\r\n    if (\r\n      balanceType === anjBalanceTypes.Inactive &&\r\n      !latestMovement.isEffective\r\n    ) {\r\n      // In case the deactivation is not effective, we'll get the most recent effective or immediate movement for the inactive balance\r\n      // Note that the array is orderer by most recent desc\r\n      latestMovement = movements.find(\r\n        movement => movement.isEffective || movement.isImmediate\r\n      )\r\n\r\n      if (\r\n        !latestMovement ||\r\n        anjMovementTypes[latestMovement.type] !== anjMovementTypes.Deactivation\r\n      ) {\r\n        return latestMovement\r\n      }\r\n    }\r\n\r\n    // We get here if all this conditions are given\r\n    // - Latest movement is a Deactivation\r\n    // - Latest movement is Effective\r\n    // - We are calculating latest movement for Active or Inactive balance\r\n\r\n    // In all these cases, we need to get all deactivations\r\n    // done effective on the same term as this latest movement\r\n    return {\r\n      ...latestMovement,\r\n      amount: getTotalEffectiveAt(\r\n        movements,\r\n        anjMovementTypes.Deactivation,\r\n        latestMovement.effectiveTermId\r\n      ),\r\n    }\r\n  }\r\n\r\n  return latestMovement\r\n}\r\n\r\n/**\r\n * Calculates the aggregated effective movements amount at term `termId`\r\n * @param {Array} movements Array of movements\r\n * @param {Symbol} movementType Type of movement\r\n * @param {Number} termId Id of the term\r\n * @returns {BigNum} Total effective movements amount at `termId`\r\n */\r\nfunction getTotalEffectiveAt(movements, movementType, termId) {\r\n  return movements\r\n    .filter(\r\n      movement =>\r\n        anjMovementTypes[movement.type] === movementType &&\r\n        movement.effectiveTermId === termId\r\n    )\r\n    .reduce((acc, movement) => acc.add(movement.amount), bigNum(0))\r\n}\r\n\r\nexport function convertMovement(acceptedMovements, movement) {\r\n  if (!movement) return null\r\n\r\n  const movementType =\r\n    typeof movement.type === 'symbol'\r\n      ? movement.type\r\n      : anjMovementTypes[movement.type]\r\n\r\n  const direction = getMovementDirection(acceptedMovements, movementType)\r\n\r\n  return {\r\n    type: movementType,\r\n    amount: movement.amount,\r\n    direction,\r\n  }\r\n}\r\n\r\nexport function getUpdatedLockedMovement(lockedBalance, latestMovement) {\r\n  if (!lockedBalance || lockedBalance.eq(0)) {\r\n    return latestMovement\r\n  }\r\n\r\n  // In the case that the juror has locked balance, we must update the active balance latest movement\r\n  const movementTypeLock = anjMovementTypes.Lock\r\n  let newLockedAmount = lockedBalance\r\n\r\n  // If active balance latest movement is a deactivation process, we must update the amount\r\n  if (latestMovement?.type === anjMovementTypes.DeactivationProcess) {\r\n    newLockedAmount = newLockedAmount.add(latestMovement.amount)\r\n  }\r\n\r\n  return {\r\n    ...latestMovement,\r\n    amount: newLockedAmount,\r\n    type: movementTypeLock,\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}