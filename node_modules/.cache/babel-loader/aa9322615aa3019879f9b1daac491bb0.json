{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar mh = require('multihashes');\n\nvar multibase = require('multibase');\n\nvar multicodec = require('multicodec');\n\nvar CIDUtil = require('./cid-util');\n\nvar uint8ArrayConcat = require('uint8arrays/concat');\n\nvar uint8ArrayToString = require('uint8arrays/to-string');\n\nvar uint8ArrayEquals = require('uint8arrays/equals');\n\nvar codecs = multicodec.nameToCode;\nvar codecInts =\n/** @type {CodecName[]} */\nObject.keys(codecs).reduce(function (p, name) {\n  p[codecs[name]] = name;\n  return p;\n},\n/** @type {Record<CodecCode, CodecName>} */\n{});\nvar symbol = Symbol.for('@ipld/js-cid/CID');\n/**\n * @typedef {Object} SerializedCID\n * @property {string} codec\n * @property {number} version\n * @property {Uint8Array} hash\n */\n\n/**\n * @typedef {0|1} CIDVersion\n * @typedef {import('multibase').BaseNameOrCode} BaseNameOrCode\n * @typedef {import('multicodec').CodecName} CodecName\n * @typedef {import('multicodec').CodecCode} CodecCode\n */\n\n/**\n * Class representing a CID `<mbase><version><mcodec><mhash>`\n * , as defined in [ipld/cid](https://github.com/multiformats/cid).\n *\n * @class CID\n */\n\nvar CID = /*#__PURE__*/function () {\n  /**\n   * Create a new CID.\n   *\n   * The algorithm for argument input is roughly:\n   * ```\n   * if (cid)\n   *   -> create a copy\n   * else if (str)\n   *   if (1st char is on multibase table) -> CID String\n   *   else -> bs58 encoded multihash\n   * else if (Uint8Array)\n   *   if (1st byte is 0 or 1) -> CID\n   *   else -> multihash\n   * else if (Number)\n   *   -> construct CID by parts\n   * ```\n   *\n   * @param {CIDVersion | string | Uint8Array | CID} version\n   * @param {string|number} [codec]\n   * @param {Uint8Array} [multihash]\n   * @param {string} [multibaseName]\n   *\n   * @example\n   * new CID(<version>, <codec>, <multihash>, <multibaseName>)\n   * new CID(<cidStr>)\n   * new CID(<cid.bytes>)\n   * new CID(<multihash>)\n   * new CID(<bs58 encoded multihash>)\n   * new CID(<cid>)\n   */\n  function CID(version, codec, multihash, multibaseName) {\n    _classCallCheck(this, CID);\n\n    // We have below three blank field accessors only because\n    // otherwise TS will not pick them up if done after assignemnts\n\n    /**\n     * The version of the CID.\n     *\n     * @type {CIDVersion}\n     */\n    // eslint-disable-next-line no-unused-expressions\n    this.version;\n    /**\n     * The codec of the CID.\n     *\n     * @deprecated\n     * @type {CodecName}\n     */\n    // eslint-disable-next-line no-unused-expressions\n\n    this.codec;\n    /**\n     * The multihash of the CID.\n     *\n     * @type {Uint8Array}\n     */\n    // eslint-disable-next-line no-unused-expressions\n\n    this.multihash;\n    Object.defineProperty(this, symbol, {\n      value: true\n    });\n\n    if (CID.isCID(version)) {\n      // version is an exising CID instance\n      var cid =\n      /** @type {CID} */\n      version;\n      this.version = cid.version;\n      this.codec = cid.codec;\n      this.multihash = cid.multihash; // Default guard for when a CID < 0.7 is passed with no multibaseName\n      // @ts-ignore\n\n      this.multibaseName = cid.multibaseName || (cid.version === 0 ? 'base58btc' : 'base32');\n      return;\n    }\n\n    if (typeof version === 'string') {\n      // e.g. 'base32' or false\n      var baseName = multibase.isEncoded(version);\n\n      if (baseName) {\n        // version is a CID String encoded with multibase, so v1\n        var _cid = multibase.decode(version);\n\n        this.version =\n        /** @type {CIDVersion} */\n        parseInt(_cid[0].toString(), 16);\n        this.codec = multicodec.getCodec(_cid.slice(1));\n        this.multihash = multicodec.rmPrefix(_cid.slice(1));\n        this.multibaseName = baseName;\n      } else {\n        // version is a base58btc string multihash, so v0\n        this.version = 0;\n        this.codec = 'dag-pb';\n        this.multihash = mh.fromB58String(version);\n        this.multibaseName = 'base58btc';\n      }\n\n      CID.validateCID(this);\n      Object.defineProperty(this, 'string', {\n        value: version\n      });\n      return;\n    }\n\n    if (version instanceof Uint8Array) {\n      var v = parseInt(version[0].toString(), 16);\n\n      if (v === 1) {\n        // version is a CID Uint8Array\n        var _cid2 = version;\n        this.version = v;\n        this.codec = multicodec.getCodec(_cid2.slice(1));\n        this.multihash = multicodec.rmPrefix(_cid2.slice(1));\n        this.multibaseName = 'base32';\n      } else {\n        // version is a raw multihash Uint8Array, so v0\n        this.version = 0;\n        this.codec = 'dag-pb';\n        this.multihash = version;\n        this.multibaseName = 'base58btc';\n      }\n\n      CID.validateCID(this);\n      return;\n    } // otherwise, assemble the CID from the parameters\n\n\n    this.version = version;\n\n    if (typeof codec === 'number') {\n      // @ts-ignore\n      codec = codecInts[codec];\n    }\n\n    this.codec =\n    /** @type {CodecName} */\n    codec;\n    this.multihash =\n    /** @type {Uint8Array} */\n    multihash;\n    /**\n     * Multibase name as string.\n     *\n     * @deprecated\n     * @type {string}\n     */\n\n    this.multibaseName = multibaseName || (version === 0 ? 'base58btc' : 'base32');\n    CID.validateCID(this);\n  }\n  /**\n   * The CID as a `Uint8Array`\n   *\n   * @returns {Uint8Array}\n   *\n   */\n\n\n  _createClass(CID, [{\n    key: \"bytes\",\n    get: function get() {\n      // @ts-ignore\n      var bytes = this._bytes;\n\n      if (!bytes) {\n        if (this.version === 0) {\n          bytes = this.multihash;\n        } else if (this.version === 1) {\n          var codec = multicodec.getCodeVarint(this.codec);\n          bytes = uint8ArrayConcat([[1], codec, this.multihash], 1 + codec.byteLength + this.multihash.byteLength);\n        } else {\n          throw new Error('unsupported version');\n        } // Cache this Uint8Array so it doesn't have to be recreated\n\n\n        Object.defineProperty(this, '_bytes', {\n          value: bytes\n        });\n      }\n\n      return bytes;\n    }\n    /**\n     * The prefix of the CID.\n     *\n     * @returns {Uint8Array}\n     */\n\n  }, {\n    key: \"prefix\",\n    get: function get() {\n      var codec = multicodec.getCodeVarint(this.codec);\n      var multihash = mh.prefix(this.multihash);\n      var prefix = uint8ArrayConcat([[this.version], codec, multihash], 1 + codec.byteLength + multihash.byteLength);\n      return prefix;\n    }\n    /**\n     * The codec of the CID in its number form.\n     *\n     * @returns {CodecCode}\n     */\n\n  }, {\n    key: \"code\",\n    get: function get() {\n      return codecs[this.codec];\n    }\n    /**\n     * Convert to a CID of version `0`.\n     *\n     * @returns {CID}\n     */\n\n  }, {\n    key: \"toV0\",\n    value: function toV0() {\n      if (this.codec !== 'dag-pb') {\n        throw new Error('Cannot convert a non dag-pb CID to CIDv0');\n      }\n\n      var _mh$decode = mh.decode(this.multihash),\n          name = _mh$decode.name,\n          length = _mh$decode.length;\n\n      if (name !== 'sha2-256') {\n        throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');\n      }\n\n      if (length !== 32) {\n        throw new Error('Cannot convert non 32 byte multihash CID to CIDv0');\n      }\n\n      return new CID(0, this.codec, this.multihash);\n    }\n    /**\n     * Convert to a CID of version `1`.\n     *\n     * @returns {CID}\n     */\n\n  }, {\n    key: \"toV1\",\n    value: function toV1() {\n      return new CID(1, this.codec, this.multihash);\n    }\n    /**\n     * Encode the CID into a string.\n     *\n     * @param {BaseNameOrCode} [base=this.multibaseName] - Base encoding to use.\n     * @returns {string}\n     */\n\n  }, {\n    key: \"toBaseEncodedString\",\n    value: function toBaseEncodedString() {\n      var base = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.multibaseName;\n\n      // @ts-ignore non enumerable cache property\n      if (this.string && this.string.length !== 0 && base === this.multibaseName) {\n        // @ts-ignore non enumerable cache property\n        return this.string;\n      }\n\n      var str;\n\n      if (this.version === 0) {\n        if (base !== 'base58btc') {\n          throw new Error('not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()');\n        }\n\n        str = mh.toB58String(this.multihash);\n      } else if (this.version === 1) {\n        str = uint8ArrayToString(multibase.encode(base, this.bytes));\n      } else {\n        throw new Error('unsupported version');\n      }\n\n      if (base === this.multibaseName) {\n        // cache the string value\n        Object.defineProperty(this, 'string', {\n          value: str\n        });\n      }\n\n      return str;\n    }\n    /**\n     * CID(QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n)\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: Symbol.for('nodejs.util.inspect.custom'),\n    value: function value() {\n      return 'CID(' + this.toString() + ')';\n    }\n    /**\n     * Encode the CID into a string.\n     *\n     * @param {BaseNameOrCode} [base=this.multibaseName] - Base encoding to use.\n     * @returns {string}\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString(base) {\n      return this.toBaseEncodedString(base);\n    }\n    /**\n     * Serialize to a plain object.\n     *\n     * @returns {SerializedCID}\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        codec: this.codec,\n        version: this.version,\n        hash: this.multihash\n      };\n    }\n    /**\n     * Compare equality with another CID.\n     *\n     * @param {CID} other\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return this.codec === other.codec && this.version === other.version && uint8ArrayEquals(this.multihash, other.multihash);\n    }\n    /**\n     * Test if the given input is a valid CID object.\n     * Throws if it is not.\n     *\n     * @param {any} other - The other CID.\n     * @returns {void}\n     */\n\n  }], [{\n    key: \"validateCID\",\n    value: function validateCID(other) {\n      var errorMsg = CIDUtil.checkCIDComponents(other);\n\n      if (errorMsg) {\n        throw new Error(errorMsg);\n      }\n    }\n    /**\n     * Check if object is a CID instance\n     *\n     * @param {any} value\n     * @returns {value is CID}\n     */\n\n  }, {\n    key: \"isCID\",\n    value: function isCID(value) {\n      return value instanceof CID || Boolean(value && value[symbol]);\n    }\n  }]);\n\n  return CID;\n}();\n\nCID.codecs = codecs;\nmodule.exports = CID;","map":null,"metadata":{},"sourceType":"script"}