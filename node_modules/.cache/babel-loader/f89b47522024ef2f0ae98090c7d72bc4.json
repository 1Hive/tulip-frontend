{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _require = require('./utils'),\n    deepEqual = _require.deepEqual;\n\nvar sum = function sum(acc, val) {\n  return acc + val;\n};\n/**\n * G-Counter\n *\n * Operation-based Increment-Only Counter CRDT\n *\n * Sources: \n * \"A comprehensive study of Convergent and Commutative Replicated Data Types\"\n * http://hal.upmc.fr/inria-00555588/document, \"3.1.1 Op-based counter and 3.1.2  State-based increment-only Counter (G-Counter)\"\n */\n\n\nvar GCounter = /*#__PURE__*/function () {\n  function GCounter(id, counter) {\n    _classCallCheck(this, GCounter);\n\n    this.id = id;\n    this._counters = counter ? counter : {};\n    this._counters[this.id] = this._counters[this.id] ? this._counters[this.id] : 0;\n  }\n\n  _createClass(GCounter, [{\n    key: \"value\",\n    get: function get() {\n      return Object.values(this._counters).reduce(sum, 0);\n    }\n  }, {\n    key: \"increment\",\n    value: function increment(amount) {\n      if (amount && amount < 1) return;\n      if (amount === undefined || amount === null) amount = 1;\n      this._counters[this.id] = this._counters[this.id] + amount;\n    }\n  }, {\n    key: \"merge\",\n    value: function merge(other) {\n      var _this = this;\n\n      // Go through each counter in the other counter\n      Object.entries(other._counters).forEach(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            id = _ref2[0],\n            value = _ref2[1];\n\n        // Take the maximum of the counter value we have or the counter value they have\n        _this._counters[id] = Math.max(_this._counters[id] || 0, value);\n      });\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        id: this.id,\n        counters: this._counters\n      };\n    }\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(other) {\n      return GCounter.isEqual(this, other);\n    }\n  }], [{\n    key: \"from\",\n    value: function from(json) {\n      return new GCounter(json.id, json.counters);\n    }\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(a, b) {\n      if (a.id !== b.id) return false;\n      return deepEqual(a._counters, b._counters);\n    }\n  }]);\n\n  return GCounter;\n}();\n\nmodule.exports = GCounter;","map":null,"metadata":{},"sourceType":"script"}