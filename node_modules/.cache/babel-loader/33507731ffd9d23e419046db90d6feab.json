{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _slicedToArray = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar Block = require('ipld-block');\n\nvar CID = require('cids');\n\nvar _require = require('multicodec'),\n    getName = _require.getName;\n\nvar vd = require('varint-decoder');\n\nvar multihashing = require('multihashing-async');\n\nvar _require2 = require('../../utils'),\n    isMapEqual = _require2.isMapEqual;\n\nvar _require3 = require('./message.proto'),\n    Message = _require3.Message;\n\nvar Entry = require('./entry');\n\nvar BitswapMessage = /*#__PURE__*/function () {\n  function BitswapMessage(full) {\n    _classCallCheck(this, BitswapMessage);\n\n    this.full = full;\n    this.wantlist = new Map();\n    this.blocks = new Map();\n    this.blockPresences = new Map();\n    this.pendingBytes = 0;\n  }\n\n  _createClass(BitswapMessage, [{\n    key: \"empty\",\n    get: function get() {\n      return this.blocks.size === 0 && this.wantlist.size === 0 && this.blockPresences.size === 0;\n    }\n  }, {\n    key: \"addEntry\",\n    value: function addEntry(cid, priority, wantType, cancel, sendDontHave) {\n      if (wantType == null) {\n        wantType = BitswapMessage.WantType.Block;\n      }\n\n      var cidStr = cid.toString('base58btc');\n      var entry = this.wantlist.get(cidStr);\n\n      if (entry) {\n        // Only change priority if want is of the same type\n        if (entry.wantType === wantType) {\n          entry.priority = priority;\n        } // Only change from \"dont cancel\" to \"do cancel\"\n\n\n        if (cancel) {\n          entry.cancel = Boolean(cancel);\n        } // Only change from \"dont send\" to \"do send\" DONT_HAVE\n\n\n        if (sendDontHave) {\n          entry.sendDontHave = Boolean(sendDontHave);\n        } // want-block overrides existing want-have\n\n\n        if (wantType === BitswapMessage.WantType.Block && entry.wantType === BitswapMessage.WantType.Have) {\n          entry.wantType = wantType;\n        }\n      } else {\n        this.wantlist.set(cidStr, new Entry(cid, priority, wantType, cancel, sendDontHave));\n      }\n    }\n  }, {\n    key: \"addBlock\",\n    value: function addBlock(block) {\n      var cidStr = block.cid.toString('base58btc');\n      this.blocks.set(cidStr, block);\n    }\n  }, {\n    key: \"addHave\",\n    value: function addHave(cid) {\n      var cidStr = cid.toString('base58btc');\n\n      if (!this.blockPresences.has(cidStr)) {\n        this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.Have);\n      }\n    }\n  }, {\n    key: \"addDontHave\",\n    value: function addDontHave(cid) {\n      var cidStr = cid.toString('base58btc');\n\n      if (!this.blockPresences.has(cidStr)) {\n        this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.DontHave);\n      }\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel(cid) {\n      var cidStr = cid.toString('base58btc');\n      this.wantlist.delete(cidStr);\n      this.addEntry(cid, 0, BitswapMessage.WantType.Block, true, false);\n    }\n  }, {\n    key: \"setPendingBytes\",\n    value: function setPendingBytes(size) {\n      this.pendingBytes = size;\n    }\n    /*\n     * Serializes to Bitswap Message protobuf of\n     * version 1.0.0\n     */\n\n  }, {\n    key: \"serializeToBitswap100\",\n    value: function serializeToBitswap100() {\n      var msg = {\n        wantlist: {\n          entries: Array.from(this.wantlist.values()).map(function (entry) {\n            return {\n              block: entry.cid.buffer,\n              // cid\n              priority: Number(entry.priority),\n              cancel: Boolean(entry.cancel)\n            };\n          })\n        },\n        blocks: Array.from(this.blocks.values()).map(function (block) {\n          return block.data;\n        })\n      };\n\n      if (this.full) {\n        msg.wantlist.full = true;\n      }\n\n      return Message.encode(msg);\n    }\n    /*\n     * Serializes to Bitswap Message protobuf of\n     * version 1.1.0\n     */\n\n  }, {\n    key: \"serializeToBitswap110\",\n    value: function serializeToBitswap110() {\n      var msg = {\n        wantlist: {\n          entries: Array.from(this.wantlist.values()).map(function (entry) {\n            return {\n              block: entry.cid.buffer,\n              // cid\n              priority: Number(entry.priority),\n              wantType: entry.wantType,\n              cancel: Boolean(entry.cancel),\n              sendDontHave: Boolean(entry.sendDontHave)\n            };\n          })\n        },\n        blockPresences: [],\n        payload: []\n      };\n\n      if (this.full) {\n        msg.wantlist.full = true;\n      }\n\n      this.blocks.forEach(function (block) {\n        msg.payload.push({\n          prefix: block.cid.prefix,\n          data: block.data\n        });\n      });\n\n      var _iterator = _createForOfIteratorHelper(this.blockPresences),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n              cidStr = _step$value[0],\n              bpType = _step$value[1];\n\n          msg.blockPresences.push({\n            cid: new CID(cidStr).buffer,\n            type: bpType\n          });\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      if (this.pendingBytes > 0) {\n        msg.pendingBytes = this.pendingBytes;\n      }\n\n      return Message.encode(msg);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      if (this.full !== other.full || this.pendingBytes !== other.pendingBytes || !isMapEqual(this.wantlist, other.wantlist) || !isMapEqual(this.blocks, other.blocks) || !isMapEqual(this.blockPresences, other.blockPresences)) {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: Symbol.toStringTag,\n    get: function get() {\n      var list = Array.from(this.wantlist.keys());\n      var blocks = Array.from(this.blocks.keys());\n      return \"BitswapMessage <full: \".concat(this.full, \", list: \").concat(list, \", blocks: \").concat(blocks, \">\");\n    }\n  }]);\n\n  return BitswapMessage;\n}();\n\nBitswapMessage.deserialize = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(raw) {\n    var decoded, isFull, msg;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            decoded = Message.decode(raw);\n            isFull = decoded.wantlist && decoded.wantlist.full || false;\n            msg = new BitswapMessage(isFull);\n\n            if (decoded.wantlist) {\n              decoded.wantlist.entries.forEach(function (entry) {\n                // note: entry.block is the CID here\n                var cid = new CID(entry.block);\n                msg.addEntry(cid, entry.priority, entry.wantType, entry.cancel, entry.sendDontHave);\n              });\n            }\n\n            if (decoded.blockPresences) {\n              decoded.blockPresences.forEach(function (blockPresence) {\n                var cid = new CID(blockPresence.cid);\n\n                if (blockPresence.type === BitswapMessage.BlockPresenceType.Have) {\n                  msg.addHave(cid);\n                } else {\n                  msg.addDontHave(cid);\n                }\n              });\n            } // Bitswap 1.0.0\n            // decoded.blocks are just the byte arrays\n\n\n            if (!(decoded.blocks.length > 0)) {\n              _context3.next = 9;\n              break;\n            }\n\n            _context3.next = 8;\n            return Promise.all(decoded.blocks.map( /*#__PURE__*/function () {\n              var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(b) {\n                var hash, cid;\n                return _regeneratorRuntime.wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        _context.next = 2;\n                        return multihashing(b, 'sha2-256');\n\n                      case 2:\n                        hash = _context.sent;\n                        cid = new CID(hash);\n                        msg.addBlock(new Block(b, cid));\n\n                      case 5:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee);\n              }));\n\n              return function (_x2) {\n                return _ref2.apply(this, arguments);\n              };\n            }()));\n\n          case 8:\n            return _context3.abrupt(\"return\", msg);\n\n          case 9:\n            if (!(decoded.payload.length > 0)) {\n              _context3.next = 14;\n              break;\n            }\n\n            _context3.next = 12;\n            return Promise.all(decoded.payload.map( /*#__PURE__*/function () {\n              var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(p) {\n                var values, cidVersion, multicodec, hashAlg, hash, cid;\n                return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                  while (1) {\n                    switch (_context2.prev = _context2.next) {\n                      case 0:\n                        if (!(!p.prefix || !p.data)) {\n                          _context2.next = 2;\n                          break;\n                        }\n\n                        return _context2.abrupt(\"return\");\n\n                      case 2:\n                        values = vd(p.prefix);\n                        cidVersion = values[0];\n                        multicodec = values[1];\n                        hashAlg = values[2]; // const hashLen = values[3] // We haven't need to use this so far\n\n                        _context2.next = 8;\n                        return multihashing(p.data, hashAlg);\n\n                      case 8:\n                        hash = _context2.sent;\n                        cid = new CID(cidVersion, getName(multicodec), hash);\n                        msg.addBlock(new Block(p.data, cid));\n\n                      case 11:\n                      case \"end\":\n                        return _context2.stop();\n                    }\n                  }\n                }, _callee2);\n              }));\n\n              return function (_x3) {\n                return _ref3.apply(this, arguments);\n              };\n            }()));\n\n          case 12:\n            msg.setPendingBytes(decoded.pendingBytes);\n            return _context3.abrupt(\"return\", msg);\n\n          case 14:\n            return _context3.abrupt(\"return\", msg);\n\n          case 15:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function (_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nBitswapMessage.blockPresenceSize = function (cid) {\n  // It's ok if this is not exactly right: it's used to estimate the size of\n  // the HAVE / DONT_HAVE on the wire, but when doing that calculation we leave\n  // plenty of padding under the maximum message size.\n  // (It's more important for this to be fast).\n  return cid.buffer.length + 1;\n};\n\nBitswapMessage.Entry = Entry;\nBitswapMessage.WantType = {\n  Block: Message.Wantlist.WantType.Block,\n  Have: Message.Wantlist.WantType.Have\n};\nBitswapMessage.BlockPresenceType = {\n  Have: Message.BlockPresenceType.Have,\n  DontHave: Message.BlockPresenceType.DontHave\n};\nmodule.exports = BitswapMessage;","map":null,"metadata":{},"sourceType":"script"}