{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar Bitswap = require('ipfs-bitswap');\n\nvar multiaddr = require('multiaddr');\n\nvar get = require('dlv');\n\nvar defer = require('p-defer');\n\nvar IPNS = require('../ipns');\n\nvar routingConfig = require('../ipns/routing/config');\n\nvar _require = require('../errors'),\n    AlreadyInitializedError = _require.AlreadyInitializedError,\n    NotEnabledError = _require.NotEnabledError;\n\nvar Components = require('./');\n\nvar createMfsPreload = require('../mfs-preload');\n\nvar _require2 = require('../utils'),\n    withTimeoutOption = _require2.withTimeoutOption;\n\nmodule.exports = function (_ref) {\n  var apiManager = _ref.apiManager,\n      constructorOptions = _ref.options,\n      blockService = _ref.blockService,\n      gcLock = _ref.gcLock,\n      initOptions = _ref.initOptions,\n      ipld = _ref.ipld,\n      keychain = _ref.keychain,\n      peerInfo = _ref.peerInfo,\n      pinManager = _ref.pinManager,\n      preload = _ref.preload,\n      print = _ref.print,\n      repo = _ref.repo;\n  return withTimeoutOption( /*#__PURE__*/function () {\n    var _start = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var startPromise, _apiManager$update, cancel, config, libp2p, ipnsRouting, ipns, bitswap, dag, pin, block, files, mfsPreload, api;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              startPromise = defer();\n              _apiManager$update = apiManager.update({\n                start: function start() {\n                  return startPromise.promise;\n                }\n              }), cancel = _apiManager$update.cancel;\n              _context.prev = 2;\n\n              if (!repo.closed) {\n                _context.next = 6;\n                break;\n              }\n\n              _context.next = 6;\n              return repo.open();\n\n            case 6:\n              _context.next = 8;\n              return repo.config.get();\n\n            case 8:\n              config = _context.sent;\n\n              if (config.Addresses && config.Addresses.Swarm) {\n                config.Addresses.Swarm.forEach(function (addr) {\n                  var ma = multiaddr(addr); // multiaddrs that go via a signalling server or other intermediary (e.g. stardust,\n                  // webrtc-star) can have the intermediary's peer ID in the address, so append our\n                  // peer ID to the end of it\n\n                  var maId = ma.getPeerId();\n\n                  if (maId && maId !== peerInfo.id.toB58String()) {\n                    ma = ma.encapsulate(\"/p2p/\".concat(peerInfo.id.toB58String()));\n                  }\n\n                  peerInfo.multiaddrs.add(ma);\n                });\n              }\n\n              libp2p = Components.libp2p({\n                options: constructorOptions,\n                repo: repo,\n                peerInfo: peerInfo,\n                print: print,\n                config: config\n              });\n              _context.next = 13;\n              return libp2p.start();\n\n            case 13:\n              peerInfo.multiaddrs.forEach(function (ma) {\n                return print(\"Swarm listening on \".concat(ma, \"/p2p/\").concat(peerInfo.id.toB58String()));\n              });\n              ipnsRouting = routingConfig({\n                libp2p: libp2p,\n                repo: repo,\n                peerInfo: peerInfo,\n                options: constructorOptions\n              });\n              ipns = new IPNS(ipnsRouting, repo.datastore, peerInfo, keychain, {\n                pass: initOptions.pass\n              });\n              bitswap = new Bitswap(libp2p, repo.blocks, {\n                statsEnabled: true\n              });\n              _context.next = 19;\n              return bitswap.start();\n\n            case 19:\n              blockService.setExchange(bitswap);\n              dag = {\n                get: Components.dag.get({\n                  ipld: ipld,\n                  preload: preload\n                }),\n                resolve: Components.dag.resolve({\n                  ipld: ipld,\n                  preload: preload\n                }),\n                tree: Components.dag.tree({\n                  ipld: ipld,\n                  preload: preload\n                })\n              };\n              pin = {\n                add: Components.pin.add({\n                  pinManager: pinManager,\n                  gcLock: gcLock,\n                  dag: dag\n                }),\n                ls: Components.pin.ls({\n                  pinManager: pinManager,\n                  dag: dag\n                }),\n                rm: Components.pin.rm({\n                  pinManager: pinManager,\n                  gcLock: gcLock,\n                  dag: dag\n                })\n              }; // FIXME: resolve this circular dependency\n\n              dag.put = Components.dag.put({\n                ipld: ipld,\n                pin: pin,\n                gcLock: gcLock,\n                preload: preload\n              });\n              block = {\n                get: Components.block.get({\n                  blockService: blockService,\n                  preload: preload\n                }),\n                put: Components.block.put({\n                  blockService: blockService,\n                  pin: pin,\n                  gcLock: gcLock,\n                  preload: preload\n                }),\n                rm: Components.block.rm({\n                  blockService: blockService,\n                  gcLock: gcLock,\n                  pinManager: pinManager\n                }),\n                stat: Components.block.stat({\n                  blockService: blockService,\n                  preload: preload\n                })\n              };\n              files = Components.files({\n                ipld: ipld,\n                block: block,\n                blockService: blockService,\n                repo: repo,\n                preload: preload,\n                options: constructorOptions\n              });\n              mfsPreload = createMfsPreload({\n                files: files,\n                preload: preload,\n                options: constructorOptions.preload\n              });\n              _context.next = 28;\n              return Promise.all([ipns.republisher.start(), preload.start(), mfsPreload.start()]);\n\n            case 28:\n              api = createApi({\n                apiManager: apiManager,\n                bitswap: bitswap,\n                block: block,\n                blockService: blockService,\n                config: config,\n                constructorOptions: constructorOptions,\n                dag: dag,\n                files: files,\n                gcLock: gcLock,\n                initOptions: initOptions,\n                ipld: ipld,\n                ipns: ipns,\n                keychain: keychain,\n                libp2p: libp2p,\n                mfsPreload: mfsPreload,\n                peerInfo: peerInfo,\n                pin: pin,\n                pinManager: pinManager,\n                preload: preload,\n                print: print,\n                repo: repo\n              });\n              apiManager.update(api, function () {\n                return undefined;\n              });\n              _context.next = 37;\n              break;\n\n            case 32:\n              _context.prev = 32;\n              _context.t0 = _context[\"catch\"](2);\n              cancel();\n              startPromise.reject(_context.t0);\n              throw _context.t0;\n\n            case 37:\n              startPromise.resolve(apiManager.api);\n              return _context.abrupt(\"return\", apiManager.api);\n\n            case 39:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[2, 32]]);\n    }));\n\n    function start() {\n      return _start.apply(this, arguments);\n    }\n\n    return start;\n  }());\n};\n\nfunction createApi(_ref2) {\n  var apiManager = _ref2.apiManager,\n      bitswap = _ref2.bitswap,\n      block = _ref2.block,\n      blockService = _ref2.blockService,\n      config = _ref2.config,\n      constructorOptions = _ref2.constructorOptions,\n      dag = _ref2.dag,\n      files = _ref2.files,\n      gcLock = _ref2.gcLock,\n      initOptions = _ref2.initOptions,\n      ipld = _ref2.ipld,\n      ipns = _ref2.ipns,\n      keychain = _ref2.keychain,\n      libp2p = _ref2.libp2p,\n      mfsPreload = _ref2.mfsPreload,\n      peerInfo = _ref2.peerInfo,\n      pin = _ref2.pin,\n      pinManager = _ref2.pinManager,\n      preload = _ref2.preload,\n      print = _ref2.print,\n      repo = _ref2.repo;\n  var object = {\n    data: Components.object.data({\n      ipld: ipld,\n      preload: preload\n    }),\n    get: Components.object.get({\n      ipld: ipld,\n      preload: preload\n    }),\n    links: Components.object.links({\n      dag: dag\n    }),\n    new: Components.object.new({\n      ipld: ipld,\n      preload: preload\n    }),\n    patch: {\n      addLink: Components.object.patch.addLink({\n        ipld: ipld,\n        gcLock: gcLock,\n        preload: preload\n      }),\n      appendData: Components.object.patch.appendData({\n        ipld: ipld,\n        gcLock: gcLock,\n        preload: preload\n      }),\n      rmLink: Components.object.patch.rmLink({\n        ipld: ipld,\n        gcLock: gcLock,\n        preload: preload\n      }),\n      setData: Components.object.patch.setData({\n        ipld: ipld,\n        gcLock: gcLock,\n        preload: preload\n      })\n    },\n    put: Components.object.put({\n      ipld: ipld,\n      gcLock: gcLock,\n      preload: preload\n    }),\n    stat: Components.object.stat({\n      ipld: ipld,\n      preload: preload\n    })\n  };\n  var add = Components.add({\n    block: block,\n    preload: preload,\n    pin: pin,\n    gcLock: gcLock,\n    options: constructorOptions\n  });\n  var isOnline = Components.isOnline({\n    libp2p: libp2p\n  });\n\n  var dhtNotEnabled = /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              throw new NotEnabledError('dht not enabled');\n\n            case 1:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    return function dhtNotEnabled() {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n\n  var dht = get(libp2p, '_config.dht.enabled', false) ? Components.dht({\n    libp2p: libp2p,\n    repo: repo\n  }) : {\n    get: dhtNotEnabled,\n    put: dhtNotEnabled,\n    findProvs: dhtNotEnabled,\n    findPeer: dhtNotEnabled,\n    provide: dhtNotEnabled,\n    query: dhtNotEnabled\n  };\n  var dns = Components.dns();\n  var name = {\n    pubsub: {\n      cancel: Components.name.pubsub.cancel({\n        ipns: ipns,\n        options: constructorOptions\n      }),\n      state: Components.name.pubsub.state({\n        ipns: ipns,\n        options: constructorOptions\n      }),\n      subs: Components.name.pubsub.subs({\n        ipns: ipns,\n        options: constructorOptions\n      })\n    },\n    publish: Components.name.publish({\n      ipns: ipns,\n      dag: dag,\n      peerInfo: peerInfo,\n      isOnline: isOnline,\n      keychain: keychain,\n      options: constructorOptions\n    }),\n    resolve: Components.name.resolve({\n      dns: dns,\n      ipns: ipns,\n      peerInfo: peerInfo,\n      isOnline: isOnline,\n      options: constructorOptions\n    })\n  };\n  var resolve = Components.resolve({\n    name: name,\n    ipld: ipld\n  });\n  var refs = Components.refs({\n    ipld: ipld,\n    resolve: resolve,\n    preload: preload\n  });\n  refs.local = Components.refs.local({\n    repo: repo\n  });\n\n  var pubsubNotEnabled = /*#__PURE__*/function () {\n    var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              throw new NotEnabledError('pubsub not enabled');\n\n            case 1:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n\n    return function pubsubNotEnabled() {\n      return _ref4.apply(this, arguments);\n    };\n  }();\n\n  var pubsub = get(constructorOptions, 'config.Pubsub.Enabled', get(config, 'Pubsub.Enabled', true)) ? Components.pubsub({\n    libp2p: libp2p\n  }) : {\n    subscribe: pubsubNotEnabled,\n    unsubscribe: pubsubNotEnabled,\n    publish: pubsubNotEnabled,\n    ls: pubsubNotEnabled,\n    peers: pubsubNotEnabled\n  };\n  var api = {\n    add: add,\n    bitswap: {\n      stat: Components.bitswap.stat({\n        bitswap: bitswap\n      }),\n      unwant: Components.bitswap.unwant({\n        bitswap: bitswap\n      }),\n      wantlist: Components.bitswap.wantlist({\n        bitswap: bitswap\n      })\n    },\n    block: block,\n    bootstrap: {\n      add: Components.bootstrap.add({\n        repo: repo\n      }),\n      list: Components.bootstrap.list({\n        repo: repo\n      }),\n      rm: Components.bootstrap.rm({\n        repo: repo\n      })\n    },\n    cat: Components.cat({\n      ipld: ipld,\n      preload: preload\n    }),\n    config: Components.config({\n      repo: repo\n    }),\n    dag: dag,\n    dht: dht,\n    dns: dns,\n    files: files,\n    get: Components.get({\n      ipld: ipld,\n      preload: preload\n    }),\n    id: Components.id({\n      peerInfo: peerInfo,\n      libp2p: libp2p\n    }),\n    init: function () {\n      var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                throw new AlreadyInitializedError();\n\n              case 1:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      function init() {\n        return _init.apply(this, arguments);\n      }\n\n      return init;\n    }(),\n    // eslint-disable-line require-await\n    isOnline: isOnline,\n    key: {\n      export: Components.key.export({\n        keychain: keychain\n      }),\n      gen: Components.key.gen({\n        keychain: keychain\n      }),\n      import: Components.key.import({\n        keychain: keychain\n      }),\n      info: Components.key.info({\n        keychain: keychain\n      }),\n      list: Components.key.list({\n        keychain: keychain\n      }),\n      rename: Components.key.rename({\n        keychain: keychain\n      }),\n      rm: Components.key.rm({\n        keychain: keychain\n      })\n    },\n    libp2p: libp2p,\n    ls: Components.ls({\n      ipld: ipld,\n      preload: preload\n    }),\n    name: name,\n    object: object,\n    pin: pin,\n    ping: Components.ping({\n      libp2p: libp2p\n    }),\n    pubsub: pubsub,\n    refs: refs,\n    repo: {\n      gc: Components.repo.gc({\n        gcLock: gcLock,\n        pin: pin,\n        pinManager: pinManager,\n        refs: refs,\n        repo: repo\n      }),\n      stat: Components.repo.stat({\n        repo: repo\n      }),\n      version: Components.repo.version({\n        repo: repo\n      })\n    },\n    resolve: resolve,\n    start: function start() {\n      return apiManager.api;\n    },\n    stats: {\n      bitswap: Components.bitswap.stat({\n        bitswap: bitswap\n      }),\n      bw: libp2p.metrics ? Components.stats.bw({\n        libp2p: libp2p\n      }) : /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                throw new NotEnabledError('libp2p metrics not enabled');\n\n              case 1:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      })),\n      repo: Components.repo.stat({\n        repo: repo\n      })\n    },\n    stop: Components.stop({\n      apiManager: apiManager,\n      bitswap: bitswap,\n      options: constructorOptions,\n      blockService: blockService,\n      gcLock: gcLock,\n      initOptions: initOptions,\n      ipld: ipld,\n      ipns: ipns,\n      keychain: keychain,\n      libp2p: libp2p,\n      mfsPreload: mfsPreload,\n      peerInfo: peerInfo,\n      preload: preload,\n      print: print,\n      repo: repo\n    }),\n    swarm: {\n      addrs: Components.swarm.addrs({\n        libp2p: libp2p\n      }),\n      connect: Components.swarm.connect({\n        libp2p: libp2p\n      }),\n      disconnect: Components.swarm.disconnect({\n        libp2p: libp2p\n      }),\n      localAddrs: Components.swarm.localAddrs({\n        peerInfo: peerInfo\n      }),\n      peers: Components.swarm.peers({\n        libp2p: libp2p\n      })\n    },\n    version: Components.version({\n      repo: repo\n    })\n  };\n  return api;\n}","map":null,"metadata":{},"sourceType":"script"}