{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _asyncIterator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar _get = require('just-safe-get');\n\nvar debug = require('debug');\n\nvar Big = require('bignumber.js');\n\nvar errcode = require('err-code');\n\nvar migrator = require('ipfs-repo-migrations');\n\nvar bytes = require('bytes');\n\nvar pathJoin = require('ipfs-utils/src/path-join');\n\nvar constants = require('./constants');\n\nvar backends = require('./backends');\n\nvar version = require('./version');\n\nvar config = require('./config');\n\nvar spec = require('./spec');\n\nvar apiAddr = require('./api-addr');\n\nvar blockstore = require('./blockstore');\n\nvar defaultOptions = require('./default-options');\n\nvar defaultDatastore = require('./default-datastore');\n\nvar ERRORS = require('./errors');\n\nvar log = debug('repo');\nvar noLimit = Number.MAX_SAFE_INTEGER;\nvar AUTO_MIGRATE_CONFIG_KEY = 'repoAutoMigrate';\nvar lockers = {\n  memory: require('./lock-memory'),\n  fs: require('./lock')\n};\n/**\n * IpfsRepo implements all required functionality to read and write to an ipfs repo.\n *\n */\n\nvar IpfsRepo = /*#__PURE__*/function () {\n  /**\n   * @param {string} repoPath - path where the repo is stored\n   * @param {object} options - Configuration\n   */\n  function IpfsRepo(repoPath, options) {\n    _classCallCheck(this, IpfsRepo);\n\n    if (typeof repoPath !== 'string') {\n      throw new Error('missing repoPath');\n    }\n\n    this.options = buildOptions(options);\n    this.closed = true;\n    this.path = repoPath;\n    this._locker = this._getLocker();\n    this.root = backends.create('root', this.path, this.options);\n    this.version = version(this.root);\n    this.config = config(this.root);\n    this.spec = spec(this.root);\n    this.apiAddr = apiAddr(this.root);\n  }\n  /**\n   * Initialize a new repo.\n   *\n   * @param {Object} config - config to write into `config`.\n   * @returns {Promise<void>}\n   */\n\n\n  _createClass(IpfsRepo, [{\n    key: \"init\",\n    value: function () {\n      var _init = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(config) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                log('initializing at: %s', this.path);\n                _context.next = 3;\n                return this._openRoot();\n\n              case 3:\n                _context.next = 5;\n                return this.config.set(buildConfig(config));\n\n              case 5:\n                _context.next = 7;\n                return this.spec.set(buildDatastoreSpec(config));\n\n              case 7:\n                _context.next = 9;\n                return this.version.set(constants.repoVersion);\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function init(_x) {\n        return _init.apply(this, arguments);\n      }\n\n      return init;\n    }()\n    /**\n     * Check if the repo is already initialized.\n     * @returns {Promise<Boolean>}\n     */\n\n  }, {\n    key: \"isInitialized\",\n    value: function () {\n      var _isInitialized = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (this.closed) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", true);\n\n              case 2:\n                _context2.prev = 2;\n                _context2.next = 5;\n                return this._openRoot();\n\n              case 5:\n                _context2.next = 7;\n                return this._checkInitialized();\n\n              case 7:\n                _context2.next = 9;\n                return this.root.close();\n\n              case 9:\n                return _context2.abrupt(\"return\", true);\n\n              case 12:\n                _context2.prev = 12;\n                _context2.t0 = _context2[\"catch\"](2);\n                return _context2.abrupt(\"return\", false);\n\n              case 15:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[2, 12]]);\n      }));\n\n      function isInitialized() {\n        return _isInitialized.apply(this, arguments);\n      }\n\n      return isInitialized;\n    }()\n    /**\n     * Open the repo. If the repo is already open an error will be thrown.\n     * If the repo is not initialized it will throw an error.\n     *\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"open\",\n    value: function () {\n      var _open = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var blocksBaseStore, isCompatible;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (this.closed) {\n                  _context3.next = 2;\n                  break;\n                }\n\n                throw errcode(new Error('repo is already open'), ERRORS.ERR_REPO_ALREADY_OPEN);\n\n              case 2:\n                log('opening at: %s', this.path); // check if the repo is already initialized\n\n                _context3.prev = 3;\n                _context3.next = 6;\n                return this._openRoot();\n\n              case 6:\n                _context3.next = 8;\n                return this._checkInitialized();\n\n              case 8:\n                _context3.next = 10;\n                return this._openLock(this.path);\n\n              case 10:\n                this.lockfile = _context3.sent;\n                log('acquired repo.lock');\n                log('creating datastore');\n                this.datastore = backends.create('datastore', pathJoin(this.path, 'datastore'), this.options);\n                _context3.next = 16;\n                return this.datastore.open();\n\n              case 16:\n                log('creating blocks');\n                blocksBaseStore = backends.create('blocks', pathJoin(this.path, 'blocks'), this.options);\n                _context3.next = 20;\n                return blocksBaseStore.open();\n\n              case 20:\n                _context3.next = 22;\n                return blockstore(blocksBaseStore, this.options.storageBackendOptions.blocks);\n\n              case 22:\n                this.blocks = _context3.sent;\n                log('creating keystore');\n                this.keys = backends.create('keys', pathJoin(this.path, 'keys'), this.options);\n                _context3.next = 27;\n                return this.keys.open();\n\n              case 27:\n                _context3.next = 29;\n                return this.version.check(constants.repoVersion);\n\n              case 29:\n                isCompatible = _context3.sent;\n\n                if (isCompatible) {\n                  _context3.next = 39;\n                  break;\n                }\n\n                _context3.next = 33;\n                return this._isAutoMigrationEnabled();\n\n              case 33:\n                if (!_context3.sent) {\n                  _context3.next = 38;\n                  break;\n                }\n\n                _context3.next = 36;\n                return this._migrate(constants.repoVersion);\n\n              case 36:\n                _context3.next = 39;\n                break;\n\n              case 38:\n                throw new ERRORS.InvalidRepoVersionError('Incompatible repo versions. Automatic migrations disabled. Please migrate the repo manually.');\n\n              case 39:\n                this.closed = false;\n                log('all opened');\n                _context3.next = 56;\n                break;\n\n              case 43:\n                _context3.prev = 43;\n                _context3.t0 = _context3[\"catch\"](3);\n\n                if (!this.lockfile) {\n                  _context3.next = 55;\n                  break;\n                }\n\n                _context3.prev = 46;\n                _context3.next = 49;\n                return this._closeLock();\n\n              case 49:\n                this.lockfile = null;\n                _context3.next = 55;\n                break;\n\n              case 52:\n                _context3.prev = 52;\n                _context3.t1 = _context3[\"catch\"](46);\n                log('error removing lock', _context3.t1);\n\n              case 55:\n                throw _context3.t0;\n\n              case 56:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[3, 43], [46, 52]]);\n      }));\n\n      function open() {\n        return _open.apply(this, arguments);\n      }\n\n      return open;\n    }()\n    /**\n     * Returns the repo locker to be used. Null will be returned if no locker is requested\n     *\n     * @private\n     * @returns {Locker}\n     */\n\n  }, {\n    key: \"_getLocker\",\n    value: function _getLocker() {\n      if (typeof this.options.lock === 'string') {\n        if (!lockers[this.options.lock]) {\n          throw new Error('Unknown lock type: ' + this.options.lock);\n        }\n\n        return lockers[this.options.lock];\n      }\n\n      if (!this.options.lock) {\n        throw new Error('No lock provided');\n      }\n\n      return this.options.lock;\n    }\n    /**\n     * Opens the root backend, catching and ignoring an 'Already open' error\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"_openRoot\",\n    value: function () {\n      var _openRoot2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.prev = 0;\n                _context4.next = 3;\n                return this.root.open();\n\n              case 3:\n                _context4.next = 9;\n                break;\n\n              case 5:\n                _context4.prev = 5;\n                _context4.t0 = _context4[\"catch\"](0);\n\n                if (!(_context4.t0.message !== 'Already open')) {\n                  _context4.next = 9;\n                  break;\n                }\n\n                throw _context4.t0;\n\n              case 9:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[0, 5]]);\n      }));\n\n      function _openRoot() {\n        return _openRoot2.apply(this, arguments);\n      }\n\n      return _openRoot;\n    }()\n    /**\n     * Creates a lock on the repo if a locker is specified. The lockfile object will\n     * be returned in the callback if one has been created.\n     *\n     * @param {string} path\n     * @returns {Promise<lockfile>}\n     */\n\n  }, {\n    key: \"_openLock\",\n    value: function () {\n      var _openLock2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(path) {\n        var lockfile;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this._locker.lock(path);\n\n              case 2:\n                lockfile = _context5.sent;\n\n                if (!(typeof lockfile.close !== 'function')) {\n                  _context5.next = 5;\n                  break;\n                }\n\n                throw errcode(new Error('Locks must have a close method'), 'ERR_NO_CLOSE_FUNCTION');\n\n              case 5:\n                return _context5.abrupt(\"return\", lockfile);\n\n              case 6:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function _openLock(_x2) {\n        return _openLock2.apply(this, arguments);\n      }\n\n      return _openLock;\n    }()\n    /**\n     * Closes the lock on the repo\n     *\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"_closeLock\",\n    value: function _closeLock() {\n      return this.lockfile.close();\n    }\n    /**\n     * Check if the repo is already initialized.\n     * @private\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"_checkInitialized\",\n    value: function () {\n      var _checkInitialized2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        var config, _yield$Promise$all, _yield$Promise$all2;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                log('init check');\n                _context6.prev = 1;\n                _context6.next = 4;\n                return Promise.all([this.config.exists(), this.spec.exists(), this.version.exists()]);\n\n              case 4:\n                _yield$Promise$all = _context6.sent;\n                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 1);\n                config = _yield$Promise$all2[0];\n                _context6.next = 14;\n                break;\n\n              case 9:\n                _context6.prev = 9;\n                _context6.t0 = _context6[\"catch\"](1);\n\n                if (!(_context6.t0.code === 'ERR_NOT_FOUND')) {\n                  _context6.next = 13;\n                  break;\n                }\n\n                throw errcode(new Error('repo is not initialized yet'), ERRORS.ERR_REPO_NOT_INITIALIZED, {\n                  path: this.path\n                });\n\n              case 13:\n                throw _context6.t0;\n\n              case 14:\n                if (config) {\n                  _context6.next = 16;\n                  break;\n                }\n\n                throw errcode(new Error('repo is not initialized yet'), ERRORS.ERR_REPO_NOT_INITIALIZED, {\n                  path: this.path\n                });\n\n              case 16:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this, [[1, 9]]);\n      }));\n\n      function _checkInitialized() {\n        return _checkInitialized2.apply(this, arguments);\n      }\n\n      return _checkInitialized;\n    }()\n    /**\n     * Close the repo and cleanup.\n     *\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"close\",\n    value: function () {\n      var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (!this.closed) {\n                  _context7.next = 2;\n                  break;\n                }\n\n                throw errcode(new Error('repo is already closed'), ERRORS.ERR_REPO_ALREADY_CLOSED);\n\n              case 2:\n                log('closing at: %s', this.path);\n                _context7.prev = 3;\n                _context7.next = 6;\n                return this.apiAddr.delete();\n\n              case 6:\n                _context7.next = 12;\n                break;\n\n              case 8:\n                _context7.prev = 8;\n                _context7.t0 = _context7[\"catch\"](3);\n\n                if (!(_context7.t0.code !== ERRORS.ERR_REPO_NOT_INITIALIZED && !_context7.t0.message.startsWith('ENOENT'))) {\n                  _context7.next = 12;\n                  break;\n                }\n\n                throw _context7.t0;\n\n              case 12:\n                _context7.next = 14;\n                return Promise.all([this.root, this.blocks, this.keys, this.datastore].map(function (store) {\n                  return store.close();\n                }));\n\n              case 14:\n                log('unlocking');\n                this.closed = true;\n                _context7.next = 18;\n                return this._closeLock();\n\n              case 18:\n                this.lockfile = null;\n\n              case 19:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[3, 8]]);\n      }));\n\n      function close() {\n        return _close.apply(this, arguments);\n      }\n\n      return close;\n    }()\n    /**\n     * Check if a repo exists.\n     *\n     * @returns {Promise<bool>}\n     */\n\n  }, {\n    key: \"exists\",\n    value: function () {\n      var _exists = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                return _context8.abrupt(\"return\", this.version.exists());\n\n              case 1:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function exists() {\n        return _exists.apply(this, arguments);\n      }\n\n      return exists;\n    }()\n    /**\n     * Get repo status.\n     *\n     * @returns {Object}\n     */\n\n  }, {\n    key: \"stat\",\n    value: function () {\n      var _stat = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n        var _yield$Promise$all3, _yield$Promise$all4, storageMax, blocks, version, datastore, keys, size;\n\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.next = 2;\n                return Promise.all([this._storageMaxStat(), this._blockStat(), this.version.get(), getSize(this.datastore), getSize(this.keys)]);\n\n              case 2:\n                _yield$Promise$all3 = _context9.sent;\n                _yield$Promise$all4 = _slicedToArray(_yield$Promise$all3, 5);\n                storageMax = _yield$Promise$all4[0];\n                blocks = _yield$Promise$all4[1];\n                version = _yield$Promise$all4[2];\n                datastore = _yield$Promise$all4[3];\n                keys = _yield$Promise$all4[4];\n                size = blocks.size.plus(datastore).plus(keys);\n                return _context9.abrupt(\"return\", {\n                  repoPath: this.path,\n                  storageMax: storageMax,\n                  version: version,\n                  numObjects: blocks.count,\n                  repoSize: size\n                });\n\n              case 11:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function stat() {\n        return _stat.apply(this, arguments);\n      }\n\n      return stat;\n    }()\n  }, {\n    key: \"_isAutoMigrationEnabled\",\n    value: function () {\n      var _isAutoMigrationEnabled2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {\n        var autoMigrateConfig;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                if (!(this.options.autoMigrate !== undefined)) {\n                  _context10.next = 2;\n                  break;\n                }\n\n                return _context10.abrupt(\"return\", this.options.autoMigrate);\n\n              case 2:\n                _context10.prev = 2;\n                _context10.next = 5;\n                return this.config.get(AUTO_MIGRATE_CONFIG_KEY);\n\n              case 5:\n                autoMigrateConfig = _context10.sent;\n                _context10.next = 15;\n                break;\n\n              case 8:\n                _context10.prev = 8;\n                _context10.t0 = _context10[\"catch\"](2);\n\n                if (!(_context10.t0.code === ERRORS.NotFoundError.code)) {\n                  _context10.next = 14;\n                  break;\n                }\n\n                autoMigrateConfig = true; // Config's default value is True\n\n                _context10.next = 15;\n                break;\n\n              case 14:\n                throw _context10.t0;\n\n              case 15:\n                return _context10.abrupt(\"return\", autoMigrateConfig);\n\n              case 16:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this, [[2, 8]]);\n      }));\n\n      function _isAutoMigrationEnabled() {\n        return _isAutoMigrationEnabled2.apply(this, arguments);\n      }\n\n      return _isAutoMigrationEnabled;\n    }()\n  }, {\n    key: \"_migrate\",\n    value: function () {\n      var _migrate2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(toVersion) {\n        var currentRepoVersion;\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                _context11.next = 2;\n                return this.version.get();\n\n              case 2:\n                currentRepoVersion = _context11.sent;\n\n                if (!(currentRepoVersion > toVersion)) {\n                  _context11.next = 8;\n                  break;\n                }\n\n                log('reverting to version ' + toVersion);\n                return _context11.abrupt(\"return\", migrator.revert(this.path, toVersion, {\n                  ignoreLock: true,\n                  repoOptions: this.options\n                }));\n\n              case 8:\n                log('migrating to version ' + toVersion);\n                return _context11.abrupt(\"return\", migrator.migrate(this.path, toVersion, {\n                  ignoreLock: true,\n                  repoOptions: this.options\n                }));\n\n              case 10:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function _migrate(_x3) {\n        return _migrate2.apply(this, arguments);\n      }\n\n      return _migrate;\n    }()\n  }, {\n    key: \"_storageMaxStat\",\n    value: function () {\n      var _storageMaxStat2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12() {\n        var max;\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _context12.prev = 0;\n                _context12.next = 3;\n                return this.config.get('Datastore.StorageMax');\n\n              case 3:\n                max = _context12.sent;\n                return _context12.abrupt(\"return\", new Big(bytes(max)));\n\n              case 7:\n                _context12.prev = 7;\n                _context12.t0 = _context12[\"catch\"](0);\n                return _context12.abrupt(\"return\", new Big(noLimit));\n\n              case 10:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this, [[0, 7]]);\n      }));\n\n      function _storageMaxStat() {\n        return _storageMaxStat2.apply(this, arguments);\n      }\n\n      return _storageMaxStat;\n    }()\n  }, {\n    key: \"_blockStat\",\n    value: function () {\n      var _blockStat2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13() {\n        var count, size, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, block;\n\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                count = new Big(0);\n                size = new Big(0);\n                _iteratorNormalCompletion = true;\n                _didIteratorError = false;\n                _context13.prev = 4;\n                _iterator = _asyncIterator(this.blocks.query({}));\n\n              case 6:\n                _context13.next = 8;\n                return _iterator.next();\n\n              case 8:\n                _step = _context13.sent;\n                _iteratorNormalCompletion = _step.done;\n                _context13.next = 12;\n                return _step.value;\n\n              case 12:\n                _value = _context13.sent;\n\n                if (_iteratorNormalCompletion) {\n                  _context13.next = 20;\n                  break;\n                }\n\n                block = _value;\n                count = count.plus(1);\n                size = size.plus(block.value.byteLength).plus(block.key._buf.byteLength);\n\n              case 17:\n                _iteratorNormalCompletion = true;\n                _context13.next = 6;\n                break;\n\n              case 20:\n                _context13.next = 26;\n                break;\n\n              case 22:\n                _context13.prev = 22;\n                _context13.t0 = _context13[\"catch\"](4);\n                _didIteratorError = true;\n                _iteratorError = _context13.t0;\n\n              case 26:\n                _context13.prev = 26;\n                _context13.prev = 27;\n\n                if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                  _context13.next = 31;\n                  break;\n                }\n\n                _context13.next = 31;\n                return _iterator.return();\n\n              case 31:\n                _context13.prev = 31;\n\n                if (!_didIteratorError) {\n                  _context13.next = 34;\n                  break;\n                }\n\n                throw _iteratorError;\n\n              case 34:\n                return _context13.finish(31);\n\n              case 35:\n                return _context13.finish(26);\n\n              case 36:\n                return _context13.abrupt(\"return\", {\n                  count: count,\n                  size: size\n                });\n\n              case 37:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this, [[4, 22, 26, 36], [27,, 31, 35]]);\n      }));\n\n      function _blockStat() {\n        return _blockStat2.apply(this, arguments);\n      }\n\n      return _blockStat;\n    }()\n  }]);\n\n  return IpfsRepo;\n}();\n\nfunction getSize(_x4) {\n  return _getSize.apply(this, arguments);\n}\n\nfunction _getSize() {\n  _getSize = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14(queryFn) {\n    var sum, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _value2, block;\n\n    return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n      while (1) {\n        switch (_context14.prev = _context14.next) {\n          case 0:\n            sum = new Big(0);\n            _iteratorNormalCompletion2 = true;\n            _didIteratorError2 = false;\n            _context14.prev = 3;\n            _iterator2 = _asyncIterator(queryFn.query({}));\n\n          case 5:\n            _context14.next = 7;\n            return _iterator2.next();\n\n          case 7:\n            _step2 = _context14.sent;\n            _iteratorNormalCompletion2 = _step2.done;\n            _context14.next = 11;\n            return _step2.value;\n\n          case 11:\n            _value2 = _context14.sent;\n\n            if (_iteratorNormalCompletion2) {\n              _context14.next = 18;\n              break;\n            }\n\n            block = _value2;\n            sum.plus(block.value.byteLength).plus(block.key._buf.byteLength);\n\n          case 15:\n            _iteratorNormalCompletion2 = true;\n            _context14.next = 5;\n            break;\n\n          case 18:\n            _context14.next = 24;\n            break;\n\n          case 20:\n            _context14.prev = 20;\n            _context14.t0 = _context14[\"catch\"](3);\n            _didIteratorError2 = true;\n            _iteratorError2 = _context14.t0;\n\n          case 24:\n            _context14.prev = 24;\n            _context14.prev = 25;\n\n            if (!(!_iteratorNormalCompletion2 && _iterator2.return != null)) {\n              _context14.next = 29;\n              break;\n            }\n\n            _context14.next = 29;\n            return _iterator2.return();\n\n          case 29:\n            _context14.prev = 29;\n\n            if (!_didIteratorError2) {\n              _context14.next = 32;\n              break;\n            }\n\n            throw _iteratorError2;\n\n          case 32:\n            return _context14.finish(29);\n\n          case 33:\n            return _context14.finish(24);\n\n          case 34:\n            return _context14.abrupt(\"return\", sum);\n\n          case 35:\n          case \"end\":\n            return _context14.stop();\n        }\n      }\n    }, _callee14, null, [[3, 20, 24, 34], [25,, 29, 33]]);\n  }));\n  return _getSize.apply(this, arguments);\n}\n\nmodule.exports = IpfsRepo;\nmodule.exports.utils = {\n  blockstore: require('./blockstore-utils')\n};\nmodule.exports.repoVersion = constants.repoVersion;\nmodule.exports.errors = ERRORS;\n\nfunction buildOptions(_options) {\n  var options = Object.assign({}, defaultOptions, _options);\n  options.storageBackends = Object.assign({}, defaultOptions.storageBackends, options.storageBackends);\n  options.storageBackendOptions = Object.assign({}, defaultOptions.storageBackendOptions, options.storageBackendOptions);\n  return options;\n} // TODO this should come from js-ipfs instead\n\n\nfunction buildConfig(_config) {\n  _config.datastore = Object.assign({}, defaultDatastore, _get(_config, 'datastore', {}));\n  return _config;\n}\n\nfunction buildDatastoreSpec(_config) {\n  var spec = Object.assign({}, defaultDatastore.Spec, _get(_config, 'datastore.Spec', {}));\n  return {\n    type: spec.type,\n    mounts: spec.mounts.map(function (mounting) {\n      return {\n        mountpoint: mounting.mountpoint,\n        type: mounting.child.type,\n        path: mounting.child.path,\n        shardFunc: mounting.child.shardFunc\n      };\n    })\n  };\n}","map":null,"metadata":{},"sourceType":"script"}