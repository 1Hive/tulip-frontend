{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar NanoDate = require('timestamp-nano');\n\nvar _require = require('interface-datastore'),\n    Key = _require.Key;\n\nvar crypto = require('libp2p-crypto');\n\nvar PeerId = require('peer-id');\n\nvar multihash = require('multihashes');\n\nvar errCode = require('err-code');\n\nvar _require2 = require('buffer'),\n    Buffer = _require2.Buffer;\n\nvar multibase = require('multibase');\n\nvar debug = require('debug');\n\nvar log = debug('jsipns');\nlog.error = debug('jsipns:error');\n\nvar ipnsEntryProto = require('./pb/ipns.proto');\n\nvar _require3 = require('./utils'),\n    parseRFC3339 = _require3.parseRFC3339;\n\nvar ERRORS = require('./errors');\n\nvar ID_MULTIHASH_CODE = multihash.names.id;\nvar namespace = '/ipns/';\n/**\n * IPNS entry\n * @typedef {Object} IpnsEntry\n * @property {string} value - value to be stored in the record\n * @property {Buffer} signature - signature of the record\n * @property {number} validityType - Type of validation being used\n * @property {string} validity - expiration datetime for the record in RFC3339 format\n * @property {number} sequence - number representing the version of the record\n */\n\n/**\n * Creates a new ipns entry and signs it with the given private key.\n * The ipns entry validity should follow the [RFC3339]{@link https://www.ietf.org/rfc/rfc3339.txt} with nanoseconds precision.\n * Note: This function does not embed the public key. If you want to do that, use `EmbedPublicKey`.\n *\n * @param {Object} privateKey private key for signing the record.\n * @param {string} value value to be stored in the record.\n * @param {number} seq number representing the current version of the record.\n * @param {number|string} lifetime lifetime of the record (in milliseconds).\n * @returns {Promise<IpnsEntry>} entry\n */\n\nvar create = function create(privateKey, value, seq, lifetime) {\n  // Validity in ISOString with nanoseconds precision and validity type EOL\n  var isoValidity = new NanoDate(Date.now() + Number(lifetime)).toString();\n  var validityType = ipnsEntryProto.ValidityType.EOL;\n  return _create(privateKey, value, seq, isoValidity, validityType);\n};\n/**\n * Same as create(), but instead of generating a new Date, it receives the intended expiration time\n * WARNING: nano precision is not standard, make sure the value in seconds is 9 orders of magnitude lesser than the one provided.\n * @param {Object} privateKey private key for signing the record.\n * @param {string} value value to be stored in the record.\n * @param {number} seq number representing the current version of the record.\n * @param {string} expiration expiration datetime for record in the [RFC3339]{@link https://www.ietf.org/rfc/rfc3339.txt} with nanoseconds precision.\n * @returns {Promise<IpnsEntry>} entry\n */\n\n\nvar createWithExpiration = function createWithExpiration(privateKey, value, seq, expiration) {\n  var validityType = ipnsEntryProto.ValidityType.EOL;\n  return _create(privateKey, value, seq, expiration, validityType);\n};\n\nvar _create = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(privateKey, value, seq, isoValidity, validityType) {\n    var signature, entry;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return sign(privateKey, value, validityType, isoValidity);\n\n          case 2:\n            signature = _context.sent;\n            entry = {\n              value: value,\n              signature: signature,\n              validityType: validityType,\n              validity: isoValidity,\n              sequence: seq\n            };\n            log(\"ipns entry for \".concat(value, \" created\"));\n            return _context.abrupt(\"return\", entry);\n\n          case 6:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function _create(_x, _x2, _x3, _x4, _x5) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * Validates the given ipns entry against the given public key.\n *\n * @param {Object} publicKey public key for validating the record.\n * @param {IpnsEntry} entry ipns entry record.\n * @returns {Promise}\n */\n\n\nvar _validate = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(publicKey, entry) {\n    var value, validityType, validity, dataForSignature, isValid, validityDate;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            value = entry.value, validityType = entry.validityType, validity = entry.validity;\n            dataForSignature = ipnsEntryDataForSig(value, validityType, validity); // Validate Signature\n\n            _context2.prev = 2;\n            _context2.next = 5;\n            return publicKey.verify(dataForSignature, entry.signature);\n\n          case 5:\n            isValid = _context2.sent;\n            _context2.next = 11;\n            break;\n\n          case 8:\n            _context2.prev = 8;\n            _context2.t0 = _context2[\"catch\"](2);\n            isValid = false;\n\n          case 11:\n            if (isValid) {\n              _context2.next = 14;\n              break;\n            }\n\n            log.error('record signature verification failed');\n            throw errCode(new Error('record signature verification failed'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n\n          case 14:\n            if (!(validityType === ipnsEntryProto.ValidityType.EOL)) {\n              _context2.next = 28;\n              break;\n            }\n\n            _context2.prev = 15;\n            validityDate = parseRFC3339(validity.toString());\n            _context2.next = 23;\n            break;\n\n          case 19:\n            _context2.prev = 19;\n            _context2.t1 = _context2[\"catch\"](15);\n            log.error('unrecognized validity format (not an rfc3339 format)');\n            throw errCode(new Error('unrecognized validity format (not an rfc3339 format)'), ERRORS.ERR_UNRECOGNIZED_FORMAT);\n\n          case 23:\n            if (!(validityDate < Date.now())) {\n              _context2.next = 26;\n              break;\n            }\n\n            log.error('record has expired');\n            throw errCode(new Error('record has expired'), ERRORS.ERR_IPNS_EXPIRED_RECORD);\n\n          case 26:\n            _context2.next = 31;\n            break;\n\n          case 28:\n            if (!validityType) {\n              _context2.next = 31;\n              break;\n            }\n\n            log.error('unrecognized validity type');\n            throw errCode(new Error('unrecognized validity type'), ERRORS.ERR_UNRECOGNIZED_VALIDITY);\n\n          case 31:\n            log(\"ipns entry for \".concat(value, \" is valid\"));\n\n          case 32:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[2, 8], [15, 19]]);\n  }));\n\n  return function validate(_x6, _x7) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n/**\n * Embed the given public key in the given entry. While not strictly required,\n * some nodes (eg. DHT servers) may reject IPNS entries that don't embed their\n * public keys as they may not be able to validate them efficiently.\n * As a consequence of nodes needing to validade a record upon receipt, they need\n * the public key associated with it. For olde RSA keys, it is easier if we just\n * send this as part of the record itself. For newer ed25519 keys, the public key\n * can be embedded in the peerId.\n *\n * @param {Object} publicKey public key to embed.\n * @param {Object} entry ipns entry record.\n * @return {IpnsEntry} entry with public key embedded\n */\n\n\nvar embedPublicKey = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(publicKey, entry) {\n    var error, peerId, extractedPublicKey;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            if (!(!publicKey || !publicKey.bytes || !entry)) {\n              _context3.next = 4;\n              break;\n            }\n\n            error = new Error('one or more of the provided parameters are not defined');\n            log.error(error);\n            throw errCode(error, ERRORS.ERR_UNDEFINED_PARAMETER);\n\n          case 4:\n            _context3.prev = 4;\n            _context3.next = 7;\n            return PeerId.createFromPubKey(publicKey.bytes);\n\n          case 7:\n            peerId = _context3.sent;\n            _context3.next = 13;\n            break;\n\n          case 10:\n            _context3.prev = 10;\n            _context3.t0 = _context3[\"catch\"](4);\n            throw errCode(_context3.t0, ERRORS.ERR_PEER_ID_FROM_PUBLIC_KEY);\n\n          case 13:\n            _context3.prev = 13;\n            extractedPublicKey = extractPublicKeyFromId(peerId);\n            _context3.next = 21;\n            break;\n\n          case 17:\n            _context3.prev = 17;\n            _context3.t1 = _context3[\"catch\"](13);\n            log.error(_context3.t1);\n            throw errCode(_context3.t1, ERRORS.ERR_PUBLIC_KEY_FROM_ID);\n\n          case 21:\n            if (!extractedPublicKey) {\n              _context3.next = 23;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", null);\n\n          case 23:\n            _context3.prev = 23;\n            entry.pubKey = crypto.keys.marshalPublicKey(publicKey);\n            _context3.next = 31;\n            break;\n\n          case 27:\n            _context3.prev = 27;\n            _context3.t2 = _context3[\"catch\"](23);\n            log.error(_context3.t2);\n            throw _context3.t2;\n\n          case 31:\n            return _context3.abrupt(\"return\", entry);\n\n          case 32:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, null, [[4, 10], [13, 17], [23, 27]]);\n  }));\n\n  return function embedPublicKey(_x8, _x9) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n/**\n * Extracts a public key matching `pid` from the ipns record.\n *\n * @param {Object} peerId peer identifier object.\n * @param {IpnsEntry} entry ipns entry record.\n * @returns {Object} the public key\n */\n\n\nvar extractPublicKey = function extractPublicKey(peerId, entry) {\n  if (!entry || !peerId) {\n    var error = new Error('one or more of the provided parameters are not defined');\n    log.error(error);\n    throw errCode(error, ERRORS.ERR_UNDEFINED_PARAMETER);\n  }\n\n  if (entry.pubKey) {\n    var pubKey;\n\n    try {\n      pubKey = crypto.keys.unmarshalPublicKey(entry.pubKey);\n    } catch (err) {\n      log.error(err);\n      throw err;\n    }\n\n    return pubKey;\n  }\n\n  if (peerId.pubKey) {\n    return peerId.pubKey;\n  }\n\n  throw Object.assign(new Error('no public key is available'), {\n    code: ERRORS.ERR_UNDEFINED_PARAMETER\n  });\n}; // rawStdEncoding with RFC4648\n\n\nvar rawStdEncoding = function rawStdEncoding(key) {\n  return multibase.encode('base32', key).toString().slice(1).toUpperCase();\n};\n/**\n * Get key for storing the record locally.\n * Format: /ipns/${base32(<HASH>)}\n *\n * @param {Buffer} key peer identifier object.\n * @returns {string}\n */\n\n\nvar getLocalKey = function getLocalKey(key) {\n  return new Key(\"/ipns/\".concat(rawStdEncoding(key)));\n};\n/**\n * Get key for sharing the record in the routing mechanism.\n * Format: ${base32(/ipns/<HASH>)}, ${base32(/pk/<HASH>)}\n *\n * @param {Buffer} pid peer identifier represented by the multihash of the public key as Buffer.\n * @returns {Object} containing the `nameKey` and the `ipnsKey`.\n */\n\n\nvar getIdKeys = function getIdKeys(pid) {\n  var pkBuffer = Buffer.from('/pk/');\n  var ipnsBuffer = Buffer.from('/ipns/');\n  return {\n    routingPubKey: new Key(Buffer.concat([pkBuffer, pid]), false),\n    // Added on https://github.com/ipfs/js-ipns/pull/8#issue-213857876 (pkKey will be deprecated in a future release)\n    pkKey: new Key(rawStdEncoding(Buffer.concat([pkBuffer, pid]))),\n    routingKey: new Key(Buffer.concat([ipnsBuffer, pid]), false),\n    // Added on https://github.com/ipfs/js-ipns/pull/6#issue-213631461 (ipnsKey will be deprecated in a future release)\n    ipnsKey: new Key(rawStdEncoding(Buffer.concat([ipnsBuffer, pid])))\n  };\n}; // Sign ipns record data\n\n\nvar sign = function sign(privateKey, value, validityType, validity) {\n  try {\n    var dataForSignature = ipnsEntryDataForSig(value, validityType, validity);\n    return privateKey.sign(dataForSignature);\n  } catch (error) {\n    log.error('record signature creation failed');\n    throw errCode(new Error('record signature creation failed: ' + error.message), ERRORS.ERR_SIGNATURE_CREATION);\n  }\n}; // Utility for getting the validity type code name of a validity\n\n\nvar getValidityType = function getValidityType(validityType) {\n  if (validityType.toString() === '0') {\n    return 'EOL';\n  }\n\n  var error = new Error(\"unrecognized validity type \".concat(validityType.toString()));\n  log.error(error);\n  throw errCode(error, ERRORS.ERR_UNRECOGNIZED_VALIDITY);\n}; // Utility for creating the record data for being signed\n\n\nvar ipnsEntryDataForSig = function ipnsEntryDataForSig(value, validityType, validity) {\n  var valueBuffer = Buffer.from(value);\n  var validityTypeBuffer = Buffer.from(getValidityType(validityType));\n  var validityBuffer = Buffer.from(validity);\n  return Buffer.concat([valueBuffer, validityBuffer, validityTypeBuffer]);\n}; // Utility for extracting the public key from a peer-id\n\n\nvar extractPublicKeyFromId = function extractPublicKeyFromId(peerId) {\n  var decodedId = multihash.decode(peerId.id);\n\n  if (decodedId.code !== ID_MULTIHASH_CODE) {\n    return null;\n  }\n\n  return crypto.keys.unmarshalPublicKey(decodedId.digest);\n};\n\nvar marshal = ipnsEntryProto.encode;\nvar unmarshal = ipnsEntryProto.decode;\nvar validator = {\n  validate: function () {\n    var _validate2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(marshalledData, key) {\n      var receivedEntry, bufferId, peerId, pubKey;\n      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              receivedEntry = unmarshal(marshalledData);\n              bufferId = key.slice('/ipns/'.length);\n              peerId = PeerId.createFromBytes(bufferId); // extract public key\n\n              pubKey = extractPublicKey(peerId, receivedEntry); // Record validation\n\n              _context4.next = 6;\n              return _validate(pubKey, receivedEntry);\n\n            case 6:\n              return _context4.abrupt(\"return\", true);\n\n            case 7:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n\n    function validate(_x10, _x11) {\n      return _validate2.apply(this, arguments);\n    }\n\n    return validate;\n  }(),\n  select: function select(dataA, dataB) {\n    var entryA = unmarshal(dataA);\n    var entryB = unmarshal(dataB);\n    return entryA.sequence > entryB.sequence ? 0 : 1;\n  }\n};\nmodule.exports = {\n  // create ipns entry record\n  create: create,\n  // create ipns entry record specifying the expiration time\n  createWithExpiration: createWithExpiration,\n  // validate ipns entry record\n  validate: _validate,\n  // embed public key in the record\n  embedPublicKey: embedPublicKey,\n  // extract public key from the record\n  extractPublicKey: extractPublicKey,\n  // get key for storing the entry locally\n  getLocalKey: getLocalKey,\n  // get keys for routing\n  getIdKeys: getIdKeys,\n  // marshal\n  marshal: marshal,\n  // unmarshal\n  unmarshal: unmarshal,\n  // validator\n  validator: validator,\n  // namespace\n  namespace: namespace,\n  namespaceLength: namespace.length\n};","map":null,"metadata":{},"sourceType":"script"}