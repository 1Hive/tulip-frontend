{"ast":null,"code":"'use strict';\n\nconst path = require('path');\n\nconst EventEmitter = require('events');\n\nconst PROTOCOL = require('./protocol');\n\nconst encode = require('./encoding');\n\nconst waitForPeers = require('./wait-for-peers');\n\nconst getPeerID = require('./get-peer-id');\n/**\n * Communication channel over Pubsub between two IPFS nodes\n */\n\n\nclass DirectChannel extends EventEmitter {\n  constructor(ipfs, receiverID) {\n    super(); // IPFS instance to use internally\n\n    this._ipfs = ipfs;\n\n    if (!ipfs.pubsub) {\n      throw new Error('This IPFS node does not support pubsub.');\n    }\n\n    this._receiverID = receiverID;\n\n    if (!this._receiverID) {\n      throw new Error('Receiver ID was undefined');\n    } // See _setup() for more state initialization\n\n  }\n  /**\n   * Channel ID\n   * @return {[String]} Channel's ID\n   */\n\n\n  get id() {\n    return this._id;\n  }\n  /**\n   * Peers participating in this channel\n   * @return {[Array]} Array of peer IDs participating in this channel\n   */\n\n\n  get peers() {\n    return this._peers;\n  }\n\n  async connect() {\n    await waitForPeers(this._ipfs, [this._receiverID], this._id);\n  }\n  /**\n   * Send a message to the other peer\n   * @param  {[Any]} message Payload\n   */\n\n\n  async send(message) {\n    let m = encode(message);\n    await this._ipfs.pubsub.publish(this._id, m);\n  }\n  /**\n   * Close the channel\n   */\n\n\n  close() {\n    this.removeAllListeners('message');\n\n    this._ipfs.pubsub.unsubscribe(this._id, this._messageHandler);\n  }\n\n  async _setup() {\n    this._senderID = await getPeerID(this._ipfs); // Channel's participants\n\n    this._peers = Array.from([this._senderID, this._receiverID]).sort(); // ID of the channel is \"<peer1 id>/<peer 2 id>\"\"\n\n    this._id = '/' + PROTOCOL + '/' + this._peers.join('/'); // Function to use to handle incoming messages\n\n    this._messageHandler = message => {\n      // Make sure the message is coming from the correct peer\n      const isValid = message && message.from === this._receiverID; // Filter out all messages that didn't come from the second peer\n\n      if (isValid) {\n        this.emit('message', message);\n      }\n    };\n  }\n\n  async _openChannel() {\n    await this._setup();\n    await this._ipfs.pubsub.subscribe(this._id, this._messageHandler);\n  }\n\n  static async open(ipfs, receiverID) {\n    const channel = new DirectChannel(ipfs, receiverID);\n    await channel._openChannel();\n    return channel;\n  }\n\n}\n\nmodule.exports = DirectChannel;","map":null,"metadata":{},"sourceType":"script"}