{"ast":null,"code":"import _classCallCheck from \"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { Buffer } from 'buffer';\nimport { generateKeypair, isValidPublicKey } from '../utils';\nimport { AbstractHandshake } from \"./abstract-handshake\";\nexport var XX = /*#__PURE__*/function (_AbstractHandshake) {\n  _inherits(XX, _AbstractHandshake);\n\n  var _super = _createSuper(XX);\n\n  function XX() {\n    _classCallCheck(this, XX);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(XX, [{\n    key: \"initializeInitiator\",\n    value: function initializeInitiator(prologue, s, rs, psk) {\n      var name = \"Noise_XX_25519_ChaChaPoly_SHA256\";\n      var ss = this.initializeSymmetric(name);\n      this.mixHash(ss, prologue);\n      var re = Buffer.alloc(32);\n      return {\n        ss: ss,\n        s: s,\n        rs: rs,\n        psk: psk,\n        re: re\n      };\n    }\n  }, {\n    key: \"initializeResponder\",\n    value: function initializeResponder(prologue, s, rs, psk) {\n      var name = \"Noise_XX_25519_ChaChaPoly_SHA256\";\n      var ss = this.initializeSymmetric(name);\n      this.mixHash(ss, prologue);\n      var re = Buffer.alloc(32);\n      return {\n        ss: ss,\n        s: s,\n        rs: rs,\n        psk: psk,\n        re: re\n      };\n    }\n  }, {\n    key: \"writeMessageA\",\n    value: function writeMessageA(hs, payload, e) {\n      var ns = Buffer.alloc(0);\n\n      if (e) {\n        hs.e = e;\n      } else {\n        hs.e = generateKeypair();\n      }\n\n      var ne = hs.e.publicKey;\n      this.mixHash(hs.ss, ne);\n      var ciphertext = this.encryptAndHash(hs.ss, payload);\n      return {\n        ne: ne,\n        ns: ns,\n        ciphertext: ciphertext\n      };\n    }\n  }, {\n    key: \"writeMessageB\",\n    value: function writeMessageB(hs, payload) {\n      hs.e = generateKeypair();\n      var ne = hs.e.publicKey;\n      this.mixHash(hs.ss, ne);\n      this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));\n      var spk = Buffer.from(hs.s.publicKey);\n      var ns = this.encryptAndHash(hs.ss, spk);\n      this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));\n      var ciphertext = this.encryptAndHash(hs.ss, payload);\n      return {\n        ne: ne,\n        ns: ns,\n        ciphertext: ciphertext\n      };\n    }\n  }, {\n    key: \"writeMessageC\",\n    value: function writeMessageC(hs, payload) {\n      var spk = Buffer.from(hs.s.publicKey);\n      var ns = this.encryptAndHash(hs.ss, spk);\n      this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));\n      var ciphertext = this.encryptAndHash(hs.ss, payload);\n      var ne = this.createEmptyKey();\n      var messageBuffer = {\n        ne: ne,\n        ns: ns,\n        ciphertext: ciphertext\n      };\n\n      var _this$split = this.split(hs.ss),\n          cs1 = _this$split.cs1,\n          cs2 = _this$split.cs2;\n\n      return {\n        h: hs.ss.h,\n        messageBuffer: messageBuffer,\n        cs1: cs1,\n        cs2: cs2\n      };\n    }\n  }, {\n    key: \"readMessageA\",\n    value: function readMessageA(hs, message) {\n      if (isValidPublicKey(message.ne)) {\n        hs.re = message.ne;\n      }\n\n      this.mixHash(hs.ss, hs.re);\n      return this.decryptAndHash(hs.ss, message.ciphertext);\n    }\n  }, {\n    key: \"readMessageB\",\n    value: function readMessageB(hs, message) {\n      if (isValidPublicKey(message.ne)) {\n        hs.re = message.ne;\n      }\n\n      this.mixHash(hs.ss, hs.re);\n\n      if (!hs.e) {\n        throw new Error(\"Handshake state `e` param is missing.\");\n      }\n\n      this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));\n\n      var _this$decryptAndHash = this.decryptAndHash(hs.ss, message.ns),\n          ns = _this$decryptAndHash.plaintext,\n          valid1 = _this$decryptAndHash.valid;\n\n      if (valid1 && ns.length === 32 && isValidPublicKey(ns)) {\n        hs.rs = ns;\n      }\n\n      this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));\n\n      var _this$decryptAndHash2 = this.decryptAndHash(hs.ss, message.ciphertext),\n          plaintext = _this$decryptAndHash2.plaintext,\n          valid2 = _this$decryptAndHash2.valid;\n\n      return {\n        plaintext: plaintext,\n        valid: valid1 && valid2\n      };\n    }\n  }, {\n    key: \"readMessageC\",\n    value: function readMessageC(hs, message) {\n      var _this$decryptAndHash3 = this.decryptAndHash(hs.ss, message.ns),\n          ns = _this$decryptAndHash3.plaintext,\n          valid1 = _this$decryptAndHash3.valid;\n\n      if (valid1 && ns.length === 32 && isValidPublicKey(ns)) {\n        hs.rs = ns;\n      }\n\n      if (!hs.e) {\n        throw new Error(\"Handshake state `e` param is missing.\");\n      }\n\n      this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));\n\n      var _this$decryptAndHash4 = this.decryptAndHash(hs.ss, message.ciphertext),\n          plaintext = _this$decryptAndHash4.plaintext,\n          valid2 = _this$decryptAndHash4.valid;\n\n      var _this$split2 = this.split(hs.ss),\n          cs1 = _this$split2.cs1,\n          cs2 = _this$split2.cs2;\n\n      return {\n        h: hs.ss.h,\n        plaintext: plaintext,\n        valid: valid1 && valid2,\n        cs1: cs1,\n        cs2: cs2\n      };\n    }\n  }, {\n    key: \"initSession\",\n    value: function initSession(initiator, prologue, s) {\n      var psk = this.createEmptyKey();\n      var rs = Buffer.alloc(32); // no static key yet\n\n      var hs;\n\n      if (initiator) {\n        hs = this.initializeInitiator(prologue, s, rs, psk);\n      } else {\n        hs = this.initializeResponder(prologue, s, rs, psk);\n      }\n\n      return {\n        hs: hs,\n        i: initiator,\n        mc: 0\n      };\n    }\n  }, {\n    key: \"sendMessage\",\n    value: function sendMessage(session, message, ephemeral) {\n      var messageBuffer;\n\n      if (session.mc === 0) {\n        messageBuffer = this.writeMessageA(session.hs, message, ephemeral);\n      } else if (session.mc === 1) {\n        messageBuffer = this.writeMessageB(session.hs, message);\n      } else if (session.mc === 2) {\n        var _this$writeMessageC = this.writeMessageC(session.hs, message),\n            h = _this$writeMessageC.h,\n            resultingBuffer = _this$writeMessageC.messageBuffer,\n            cs1 = _this$writeMessageC.cs1,\n            cs2 = _this$writeMessageC.cs2;\n\n        messageBuffer = resultingBuffer;\n        session.h = h;\n        session.cs1 = cs1;\n        session.cs2 = cs2;\n      } else if (session.mc > 2) {\n        if (session.i) {\n          if (!session.cs1) {\n            throw new Error(\"CS1 (cipher state) is not defined\");\n          }\n\n          messageBuffer = this.writeMessageRegular(session.cs1, message);\n        } else {\n          if (!session.cs2) {\n            throw new Error(\"CS2 (cipher state) is not defined\");\n          }\n\n          messageBuffer = this.writeMessageRegular(session.cs2, message);\n        }\n      } else {\n        throw new Error(\"Session invalid.\");\n      }\n\n      session.mc++;\n      return messageBuffer;\n    }\n  }, {\n    key: \"recvMessage\",\n    value: function recvMessage(session, message) {\n      var plaintext = Buffer.alloc(0);\n      var valid = false;\n\n      if (session.mc === 0) {\n        var _this$readMessageA = this.readMessageA(session.hs, message);\n\n        plaintext = _this$readMessageA.plaintext;\n        valid = _this$readMessageA.valid;\n      } else if (session.mc === 1) {\n        var _this$readMessageB = this.readMessageB(session.hs, message);\n\n        plaintext = _this$readMessageB.plaintext;\n        valid = _this$readMessageB.valid;\n      } else if (session.mc === 2) {\n        var _this$readMessageC = this.readMessageC(session.hs, message),\n            h = _this$readMessageC.h,\n            resultingPlaintext = _this$readMessageC.plaintext,\n            resultingValid = _this$readMessageC.valid,\n            cs1 = _this$readMessageC.cs1,\n            cs2 = _this$readMessageC.cs2;\n\n        plaintext = resultingPlaintext;\n        valid = resultingValid;\n        session.h = h;\n        session.cs1 = cs1;\n        session.cs2 = cs2;\n      }\n\n      session.mc++;\n      return {\n        plaintext: plaintext,\n        valid: valid\n      };\n    }\n  }]);\n\n  return XX;\n}(AbstractHandshake);","map":null,"metadata":{},"sourceType":"module"}