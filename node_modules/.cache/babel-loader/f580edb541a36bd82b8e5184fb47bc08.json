{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createLink = createLink;\nexports.validateLink = validateLink;\nexports.authenticate = authenticate;\n\nvar _constants = require(\"./constants\");\n\nvar _ethereum = _interopRequireDefault(require(\"./blockchains/ethereum\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nconst findDID = did => did.match(/(did:(3|muport):[a-zA-Z0-9])\\w+/)[0];\n\nconst handlers = {\n  [_constants.ADDRESS_TYPES.ethereum]: _ethereum.default,\n  [_constants.ADDRESS_TYPES.ethereumEOA]: _ethereum.default,\n  [_constants.ADDRESS_TYPES.erc1271]: _ethereum.default\n};\nconst typeDetectors = [_ethereum.default.typeDetector];\n\nasync function detectType(address) {\n  for (const detect of typeDetectors) {\n    const type = await detect(address);\n    if (type) return type;\n  }\n}\n\nasync function createLink(did, address, provider, opts = {}) {\n  const type = opts.type || (await detectType(address));\n  if (!handlers[type]) throw new Error(`creating link with type ${type}, not supported`);\n  const produceProof = handlers[type].createLink;\n  const proof = await produceProof(did, address, type, provider, opts);\n\n  if (proof) {\n    return proof;\n  } else {\n    throw new Error(`Unable to create proof with type ${type}`);\n  }\n}\n\nasync function validateLink(proof, did) {\n  const validate = handlers[proof.type].validateLink;\n  if (typeof validate !== 'function') throw new Error(`proof with type ${proof.type} not supported`);\n  const validProof = await validate(proof);\n\n  if (validProof) {\n    validProof.did = findDID(validProof.message);\n    return validProof;\n  } else {\n    return null;\n  }\n}\n\nasync function authenticate(message, address, provider) {\n  const type = await detectType(address);\n  return handlers[type].authenticate(message, address, provider);\n}","map":null,"metadata":{},"sourceType":"script"}