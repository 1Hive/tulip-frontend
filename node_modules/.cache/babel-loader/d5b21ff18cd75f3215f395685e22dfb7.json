{"ast":null,"code":"const pageResults = require('graph-results-pager');\n\nconst ws = require('isomorphic-ws');\n\nconst {\n  SubscriptionClient\n} = require('subscriptions-transport-ws');\n\nconst {\n  request,\n  gql\n} = require('graphql-request');\n\nconst {\n  subWeeks,\n  getUnixTime,\n  fromUnixTime\n} = require(\"date-fns\");\n\nconst {\n  graphAPIEndpoints,\n  graphWSEndpoints,\n  TWENTY_FOUR_HOURS\n} = require('./../../constants');\n\nconst {\n  timestampToBlock,\n  timestampsToBlocks,\n  blockToTimestamp\n} = require('./../../utils');\n\nconst {\n  ethPrice\n} = require('./../exchange/eth');\n\nmodule.exports = {\n  async pair({\n    block = undefined,\n    timestamp = undefined,\n    pair_address = undefined\n  } = {}) {\n    if (!pair_address) {\n      throw new Error(\"sushi-data: Pair address undefined\");\n    }\n\n    block = block ? block : timestamp ? await timestampToBlock(timestamp) : undefined;\n    block = block ? `block: { number: ${block} }` : \"\";\n    const result = await request(graphAPIEndpoints.exchange, gql`{\n                    pair(id: \"${pair_address.toLowerCase()}\", ${block}) {\n                        ${pairs.properties.toString()}\n                    }\n                }`);\n    return pairs.callback([result.pair])[0];\n  },\n\n  async pair24h({\n    block = undefined,\n    timestamp = undefined,\n    pair_address = undefined\n  } = {}) {\n    if (!pair_address) {\n      throw new Error(\"sushi-data: Pair address undefined\");\n    }\n\n    let timestampNow = timestamp ? timestamp : block ? await blockToTimestamp(block) : Math.floor(Date.now() / 1000);\n    timestamp24ago = timestampNow - TWENTY_FOUR_HOURS;\n    timestamp48ago = timestamp24ago - TWENTY_FOUR_HOURS;\n    block = timestamp ? await timestampToBlock(timestamp) : block;\n    block24ago = await timestampToBlock(timestamp24ago);\n    block48ago = await timestampToBlock(timestamp48ago);\n    const result = await module.exports.pair({\n      block: block,\n      pair_address\n    });\n    const result24ago = await module.exports.pair({\n      block: block24ago,\n      pair_address\n    });\n    const result48ago = await module.exports.pair({\n      block: block48ago,\n      pair_address\n    });\n    const ethPriceUSD = await ethPrice({\n      block: block\n    });\n    const ethPriceUSD24ago = await ethPrice({\n      block: block24ago\n    });\n    return pairs.callback24h([result], [result24ago], [result48ago], ethPriceUSD, ethPriceUSD24ago)[0];\n  },\n\n  async pairHourData({\n    minTimestamp = undefined,\n    maxTimestamp = undefined,\n    minBlock = undefined,\n    maxBlock = undefined,\n    pair_address = undefined\n  } = {}) {\n    if (!pair_address) {\n      throw new Error(\"sushi-data: Pair address undefined\");\n    }\n\n    minTimestamp = minBlock ? blockToTimestamp(minBlock) : minTimestamp;\n    maxTimestamp = maxBlock ? blockToTimestamp(maxBlock) : maxTimestamp;\n    const endTime = maxTimestamp ? fromUnixTime(maxTimestamp) : new Date();\n    let time = minTimestamp ? minTimestamp : getUnixTime(subWeeks(endTime, 1)); // create an array of hour start times until we reach current hour\n\n    const timestamps = [];\n\n    while (time <= getUnixTime(endTime) - 3600) {\n      timestamps.push(time);\n      time += 3600;\n    }\n\n    let blocks = await timestampsToBlocks(timestamps);\n    const query = gql`{\n                ${blocks.map((block, i) => gql`\n                    timestamp${timestamps[i]}: pair(id: \"${pair_address.toLowerCase()}\", block: {number: ${block}}) {\n                        ${pairs.properties.toString()}\n                }`)}\n            }`;\n    let result = await request(graphAPIEndpoints.exchange, query);\n    result = Object.keys(result).map(key => ({ ...result[key],\n      timestamp: Number(key.split(\"timestamp\")[1])\n    })).sort((a, b) => a.timestamp - b.timestamp);\n    return pairs.callbackHourData(result);\n  },\n\n  async pairDayData({\n    minTimestamp = undefined,\n    maxTimestamp = undefined,\n    minBlock = undefined,\n    maxBlock = undefined,\n    pair_address = undefined\n  } = {}) {\n    if (!pair_address) {\n      throw new Error(\"sushi-data: Pair address undefined\");\n    }\n\n    return pageResults({\n      api: graphAPIEndpoints.exchange,\n      query: {\n        entity: 'pairDayDatas',\n        selection: {\n          orderDirection: 'desc',\n          where: {\n            pair: `\\\\\"${pair_address.toLowerCase()}\\\\\"`,\n            date_gte: minTimestamp || (minBlock ? await blockToTimestamp(minBlock) : undefined),\n            date_lte: maxTimestamp || (maxBlock ? await blockToTimestamp(maxBlock) : undefined)\n          }\n        },\n        properties: pairs.propertiesDayData\n      }\n    }).then(results => pairs.callbackDayData(results)).catch(err => console.log(err));\n  },\n\n  observePair({\n    pair_address = undefined\n  }) {\n    if (!pair_address) {\n      throw new Error(\"sushi-data: Pair address undefined\");\n    }\n\n    const query = gql`\n            subscription {\n                pair(id: \"${pair_address.toLowerCase()}\") {\n                    ${pairs.properties.toString()}\n                }\n            }`;\n    const client = new SubscriptionClient(graphWSEndpoints.exchange, {\n      reconnect: true\n    }, ws);\n    const observable = client.request({\n      query\n    });\n    return {\n      subscribe({\n        next,\n        error,\n        complete\n      }) {\n        return observable.subscribe({\n          next(results) {\n            next(pairs.callback([results.data.pair])[0]);\n          },\n\n          error,\n          complete\n        });\n      }\n\n    };\n  },\n\n  async pairs({\n    block = undefined,\n    timestamp = undefined,\n    max = undefined,\n    pair_addresses = undefined\n  } = {}) {\n    if (pair_addresses) {\n      block = block ? block : timestamp ? await timestampToBlock(timestamp) : undefined;\n      block = block ? `block: { number: ${block} }` : \"\";\n      const query = gql`{\n                    ${pair_addresses.map((pair, i) => `\n                        pair${i}: pair(id: \"${pair.toLowerCase()}\", ${block}) {\n                            ${pairs.properties.toString()}\n                    }`)}\n                }`;\n      const result = Object.values(await request(graphAPIEndpoints.exchange, query));\n      return pairs.callback(result);\n    }\n\n    return pageResults({\n      api: graphAPIEndpoints.exchange,\n      query: {\n        entity: 'pairs',\n        selection: {\n          block: block ? {\n            number: block\n          } : timestamp ? {\n            number: await timestampToBlock(timestamp)\n          } : undefined\n        },\n        properties: pairs.properties\n      },\n      max\n    }).then(results => pairs.callback(results)).catch(err => console.log(err));\n  },\n\n  async pairs24h({\n    block = undefined,\n    timestamp = undefined,\n    max = undefined\n  } = {}) {\n    let timestampNow = timestamp ? timestamp : block ? await blockToTimestamp(block) : Math.floor(Date.now() / 1000);\n    timestamp24ago = timestampNow - TWENTY_FOUR_HOURS;\n    timestamp48ago = timestamp24ago - TWENTY_FOUR_HOURS;\n    block = timestamp ? await timestampToBlock(timestamp) : block;\n    block24ago = await timestampToBlock(timestamp24ago);\n    block48ago = await timestampToBlock(timestamp48ago);\n    const results = await module.exports.pairs({\n      block: block,\n      max\n    });\n    const results24ago = await module.exports.pairs({\n      block: block24ago,\n      max\n    });\n    const results48ago = await module.exports.pairs({\n      block: block48ago,\n      max\n    });\n    const ethPriceUSD = await ethPrice({\n      block: block\n    });\n    const ethPriceUSD24ago = await ethPrice({\n      block: block24ago\n    });\n    return pairs.callback24h(results, results24ago, results48ago, ethPriceUSD, ethPriceUSD24ago);\n  },\n\n  observePairs() {\n    const query = gql`\n            subscription {\n                pairs(first: 1000, orderBy: reserveUSD, orderDirection: desc) {\n                    ${pairs.properties.toString()}\n                }\n        }`;\n    const client = new SubscriptionClient(graphWSEndpoints.exchange, {\n      reconnect: true\n    }, ws);\n    const observable = client.request({\n      query\n    });\n    return {\n      subscribe({\n        next,\n        error,\n        complete\n      }) {\n        return observable.subscribe({\n          next(results) {\n            next(pairs.callback(results.data.pairs));\n          },\n\n          error,\n          complete\n        });\n      }\n\n    };\n  }\n\n};\nconst pairs = {\n  properties: ['id', 'token0 { id, name, symbol, totalSupply, derivedETH }', 'token1 { id, name, symbol, totalSupply, derivedETH }', 'reserve0', 'reserve1', 'totalSupply', 'reserveETH', 'reserveUSD', 'trackedReserveETH', 'token0Price', 'token1Price', 'volumeToken0', 'volumeToken1', 'volumeUSD', 'untrackedVolumeUSD', 'txCount'],\n\n  callback(results) {\n    return results.map(result => ({\n      id: result.id,\n      token0: {\n        id: result.token0.id,\n        name: result.token0.name,\n        symbol: result.token0.symbol,\n        totalSupply: Number(result.token0.totalSupply),\n        derivedETH: Number(result.token0.derivedETH)\n      },\n      token1: {\n        id: result.token1.id,\n        name: result.token1.name,\n        symbol: result.token1.symbol,\n        totalSupply: Number(result.token1.totalSupply),\n        derivedETH: Number(result.token1.derivedETH)\n      },\n      reserve0: Number(result.reserve0),\n      reserve1: Number(result.reserve1),\n      totalSupply: Number(result.totalSupply),\n      reserveETH: Number(result.reserveETH),\n      reserveUSD: Number(result.reserveUSD),\n      trackedReserveETH: Number(result.trackedReserveETH),\n      token0Price: Number(result.token0Price),\n      token1Price: Number(result.token1Price),\n      volumeToken0: Number(result.volumeToken0),\n      volumeToken1: Number(result.volumeToken1),\n      volumeUSD: Number(result.volumeUSD),\n      untrackedVolumeUSD: Number(result.untrackedVolumeUSD),\n      txCount: Number(result.txCount)\n    })).sort((a, b) => b.reserveUSD - a.reserveUSD);\n  },\n\n  callback24h(results, results24h, results48h, ethPriceUSD, ethPriceUSD24ago) {\n    return results.map(result => {\n      const result24h = results24h.find(e => e.id === result.id) || result;\n      const result48h = results48h.find(e => e.id === result.id) || result;\n      return { ...result,\n        trackedReserveUSD: result.trackedReserveETH * ethPriceUSD,\n        trackedReserveUSDChange: result.trackedReserveETH * ethPriceUSD / (result24h.trackedReserveETH * ethPriceUSD24ago) * 100 - 100,\n        trackedReserveUSDChangeCount: result.trackedReserveETH * ethPriceUSD - result24h.trackedReserveETH * ethPriceUSD24ago,\n        trackedReserveETHChange: result.trackedReserveETH / result24h.trackedReserveETH * 100 - 100,\n        trackedReserveETHChangeCount: result.trackedReserveETH - result24h.trackedReserveETH,\n        volumeUSDOneDay: result.volumeUSD - result24h.volumeUSD,\n        volumeUSDChange: (result.volumeUSD - result24h.volumeUSD) / (result24h.volumeUSD - result48h.volumeUSD) * 100 - 100,\n        volumeUSDChangeCount: result.volumeUSD - result24h.volumeUSD - (result24h.volumeUSD - result48h.volumeUSD),\n        untrackedVolumeUSDOneDay: result.untrackedVolumeUSD - result24h.untrackedVolumeUSD,\n        untrackedVolumeUSDChange: (result.untrackedVolumeUSD - result24h.untrackedVolumeUSD) / (result24h.untrackedVolumeUSD - result48h.untrackedVolumeUSD) * 100 - 100,\n        untrackedVolumeUSDChangeCount: result.untrackedVolumeUSD - result24h.untrackedVolumeUSD - (result24h.untrackedVolumeUSD - result48h.untrackedVolumeUSD),\n        txCountOneDay: result.txCount - result24h.txCount,\n        txCountChange: (result.txCount - result24h.txCount) / (result24h.txCount - result48h.txCount) * 100 - 100,\n        txCountChangeCount: result.txCount - result24h.txCount - (result24h.txCount - result48h.txCount)\n      };\n    });\n  },\n\n  callbackHourData(results) {\n    return results.map(result => ({\n      id: result.id,\n      token0: {\n        id: result.token0.id,\n        name: result.token0.name,\n        symbol: result.token0.symbol,\n        totalSupply: Number(result.token0.totalSupply),\n        derivedETH: Number(result.token0.derivedETH)\n      },\n      token1: {\n        id: result.token1.id,\n        name: result.token1.name,\n        symbol: result.token1.symbol,\n        totalSupply: Number(result.token1.totalSupply),\n        derivedETH: Number(result.token1.derivedETH)\n      },\n      reserve0: Number(result.reserve0),\n      reserve1: Number(result.reserve1),\n      totalSupply: Number(result.totalSupply),\n      reserveETH: Number(result.reserveETH),\n      reserveUSD: Number(result.reserveUSD),\n      trackedReserveETH: Number(result.trackedReserveETH),\n      token0Price: Number(result.token0Price),\n      token1Price: Number(result.token1Price),\n      volumeToken0: Number(result.volumeToken0),\n      volumeToken1: Number(result.volumeToken1),\n      volumeUSD: Number(result.volumeUSD),\n      untrackedVolumeUSD: Number(result.untrackedVolumeUSD),\n      txCount: Number(result.txCount),\n      timestamp: result.timestamp\n    }));\n  },\n\n  propertiesDayData: ['id', 'date', 'volumeUSD', 'volumeToken0', 'volumeToken1', 'reserveUSD', 'txCount'],\n\n  callbackDayData(results) {\n    return results.map(result => ({\n      id: result.id,\n      date: new Date(result.date * 1000),\n      timestamp: Number(result.date),\n      volumeUSD: Number(result.volumeUSD),\n      volumeToken0: Number(result.volumeToken0),\n      volumeToken1: Number(result.volumeToken1),\n      liquidityUSD: Number(result.reserveUSD),\n      txCount: Number(result.txCount)\n    }));\n  }\n\n};","map":null,"metadata":{},"sourceType":"script"}