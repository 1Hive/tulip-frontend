{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar isBuffer = require('is-buffer');\n\nvar Shake = require('it-handshake');\n\nvar lp = require('it-length-prefixed');\n\nmodule.exports = function (duplex) {\n  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var shake = Shake(duplex);\n  var lpReader = lp.decode.fromReader(shake.reader, opts);\n  var isDone = false;\n  var W = {\n    read: function () {\n      var _read = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(bytes) {\n        var _yield$shake$reader$n, value, done;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return shake.reader.next(bytes);\n\n              case 2:\n                _yield$shake$reader$n = _context.sent;\n                value = _yield$shake$reader$n.value;\n                done = _yield$shake$reader$n.done;\n\n                if (!(done && value.length < bytes)) {\n                  _context.next = 7;\n                  break;\n                }\n\n                throw new Error('Couldn\\'t read enough bytes');\n\n              case 7:\n                isDone = done;\n\n                if (value) {\n                  _context.next = 10;\n                  break;\n                }\n\n                throw new Error('Value is null');\n\n              case 10:\n                return _context.abrupt(\"return\", value);\n\n              case 11:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function read(_x) {\n        return _read.apply(this, arguments);\n      }\n\n      return read;\n    }(),\n    readLP: function () {\n      var _readLP = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var _yield$lpReader$next, value, done;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return lpReader.next();\n\n              case 2:\n                _yield$lpReader$next = _context2.sent;\n                value = _yield$lpReader$next.value;\n                done = _yield$lpReader$next.done;\n                isDone = done;\n\n                if (value) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                throw new Error('Value is null');\n\n              case 8:\n                return _context2.abrupt(\"return\", value);\n\n              case 9:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function readLP() {\n        return _readLP.apply(this, arguments);\n      }\n\n      return readLP;\n    }(),\n    readPB: function () {\n      var _readPB = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(proto) {\n        var value, buf;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return W.readLP();\n\n              case 2:\n                value = _context3.sent;\n\n                if (value) {\n                  _context3.next = 5;\n                  break;\n                }\n\n                throw new Error('Value is null');\n\n              case 5:\n                // Is this a buffer?\n                buf = isBuffer(value) ? value : value.slice();\n                return _context3.abrupt(\"return\", proto.decode(buf));\n\n              case 7:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      function readPB(_x2) {\n        return _readPB.apply(this, arguments);\n      }\n\n      return readPB;\n    }(),\n    write: function write(data) {\n      // just write\n      shake.writer.push(data);\n    },\n    writeLP: function writeLP(data) {\n      // encode, write\n      W.write(lp.encode.single(data, opts));\n    },\n    writePB: function writePB(data, proto) {\n      // encode, writeLP\n      W.writeLP(proto.encode(data));\n    },\n    pb: function pb(proto) {\n      return {\n        read: function read() {\n          return W.readPB(proto);\n        },\n        write: function write(d) {\n          return W.writePB(d, proto);\n        }\n      };\n    },\n    unwrap: function unwrap() {\n      // returns vanilla duplex again, terminates all reads/writes from this object\n      shake.rest();\n      return shake.stream;\n    }\n  };\n  return W;\n};","map":null,"metadata":{},"sourceType":"script"}