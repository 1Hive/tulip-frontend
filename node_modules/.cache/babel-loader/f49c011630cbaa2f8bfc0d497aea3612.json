{"ast":null,"code":"'use strict';\n\nconst {\n  utils\n} = require('libp2p-pubsub');\n\nconst PeerInfo = require('peer-info');\n\nconst BasicPubsub = require('./pubsub');\n\nconst {\n  MessageCache\n} = require('./messageCache');\n\nconst {\n  rpc\n} = require('./message');\n\nconst constants = require('./constants');\n\nconst Heartbeat = require('./heartbeat');\n\nclass GossipSub extends BasicPubsub {\n  /**\n   * @param {PeerInfo} peerInfo instance of the peer's PeerInfo\n   * @param {Object} registrar\n   * @param {function} registrar.handle\n   * @param {function} registrar.register\n   * @param {function} registrar.unregister\n   * @param {Object} [options]\n   * @param {bool} [options.emitSelf] if publish should emit to self, if subscribed, defaults to false\n   * @param {bool} [options.gossipIncoming] if incoming messages on a subscribed topic should be automatically gossiped, defaults to true\n   * @param {bool} [options.fallbackToFloodsub] if dial should fallback to floodsub, defaults to true\n   * @param {function} [options.msgIdFn] override the default message id function\n   * @param {Object} [options.messageCache] override the default MessageCache\n   * @constructor\n   */\n  constructor(peerInfo, registrar, options = {}) {\n    if (!PeerInfo.isPeerInfo(peerInfo)) {\n      throw new Error('peer info must be an instance of `peer-info`');\n    }\n\n    super({\n      debugName: 'libp2p:gossipsub',\n      multicodec: constants.GossipSubID,\n      peerInfo,\n      registrar,\n      options\n    });\n    /**\n     * Map of topic meshes\n     *\n     * @type {Map<string, Set<Peer>>}\n     */\n\n    this.mesh = new Map();\n    /**\n     * Map of topics to set of peers. These mesh peers are the ones to which we are publishing without a topic membership\n     *\n     * @type {Map<string, Set<Peer>>}\n     */\n\n    this.fanout = new Map();\n    /**\n     * Map of last publish time for fanout topics\n     *\n     * @type {Map<string, Number>}\n     */\n\n    this.lastpub = new Map();\n    /**\n     * Map of pending messages to gossip\n     *\n     * @type {Map<Peer, Array<rpc.RPC.ControlIHave object>> }\n     */\n\n    this.gossip = new Map();\n    /**\n     * Map of control messages\n     *\n     * @type {Map<Peer, rpc.RPC.ControlMessage object>}\n     */\n\n    this.control = new Map();\n    /**\n     * Use the overriden mesgIdFn or the default one.\n     */\n\n    this._msgIdFn = options.msgIdFn || this.defaultMsgIdFn;\n    /**\n     * A message cache that contains the messages for last few hearbeat ticks\n     *\n     */\n\n    this.messageCache = options.messageCache || new MessageCache(constants.GossipSubHistoryGossip, constants.GossipSubHistoryLength, this._msgIdFn);\n    /**\n     * A heartbeat timer that maintains the mesh\n     */\n\n    this.heartbeat = new Heartbeat(this);\n  }\n  /**\n   * Removes a peer from the router\n   * @override\n   * @param {Peer} peer\n   * @returns {PeerInfo}\n   */\n\n\n  _removePeer(peer) {\n    super._removePeer(peer); // Remove this peer from the mesh\n    // eslint-disable-next-line no-unused-vars\n\n\n    for (const [_, peers] of this.mesh.entries()) {\n      peers.delete(peer);\n    } // Remove this peer from the fanout\n    // eslint-disable-next-line no-unused-vars\n\n\n    for (const [_, peers] of this.fanout.entries()) {\n      peers.delete(peer);\n    } // Remove from gossip mapping\n\n\n    this.gossip.delete(peer); // Remove from control mapping\n\n    this.control.delete(peer);\n    return peer;\n  }\n  /**\n   * Handles an rpc control message from a peer\n   * @param {Peer} peer\n   * @param {rpc.RPC} rpc\n   * @returns {void}\n   */\n\n\n  _handleRpcControl(peer, rpc) {\n    const controlMsg = rpc.control;\n\n    if (!controlMsg) {\n      return;\n    }\n\n    const iWant = this._handleIHave(peer, controlMsg.ihave);\n\n    const iHave = this._handleIWant(peer, controlMsg.iwant);\n\n    const prune = this._handleGraft(peer, controlMsg.graft);\n\n    this._handlePrune(peer, controlMsg.prune);\n\n    if (!iWant || !iHave || !prune) {\n      return;\n    }\n\n    const outRpc = this._rpcWithControl(iHave, null, iWant, null, prune);\n\n    this._sendRpc(rpc.from, outRpc);\n  }\n  /**\n   * Process incoming message,\n   * emitting locally and forwarding on to relevant floodsub and gossipsub peers\n   * @param {rpc.RPC.Message} msg\n   */\n\n\n  _processRpcMessage(msg) {\n    super._processRpcMessage(msg);\n\n    const topics = msg.topicIDs; // If options.gossipIncoming is false, do NOT emit incoming messages to peers\n\n    if (!this._options.gossipIncoming) {\n      return;\n    } // Emit to floodsub peers\n\n\n    this.peers.forEach(peer => {\n      if (peer.info.protocols.has(constants.FloodSubID) && peer.info.id.toB58String() !== msg.from && utils.anyMatch(peer.topics, topics) && peer.isWritable) {\n        peer.sendMessages(utils.normalizeOutRpcMessages([msg]));\n        this.log('publish msg on topics - floodsub', topics, peer.info.id.toB58String());\n      }\n    }); // Emit to peers in the mesh\n\n    topics.forEach(topic => {\n      if (!this.mesh.has(topic)) {\n        return;\n      }\n\n      this.mesh.get(topic).forEach(peer => {\n        if (!peer.isWritable || peer.info.id.toB58String() === msg.from) {\n          return;\n        }\n\n        peer.sendMessages(utils.normalizeOutRpcMessages([msg]));\n        this.log('publish msg on topic - meshsub', topic, peer.info.id.toB58String());\n      });\n    });\n  }\n  /**\n   * Handles IHAVE messages\n   * @param {Peer} peer\n   * @param {Array<rpc.RPC.ControlIHave>} ihave\n   * @returns {rpc.RPC.ControlIWant}\n   */\n\n\n  _handleIHave(peer, ihave) {\n    const iwant = new Set();\n    ihave.forEach(({\n      topicID,\n      messageIDs\n    }) => {\n      if (!this.mesh.has(topicID)) {\n        return;\n      }\n\n      messageIDs.forEach(msgID => {\n        if (this.seenCache.has(msgID)) {\n          return;\n        }\n\n        iwant.add(msgID);\n      });\n    });\n\n    if (!iwant.size) {\n      return;\n    }\n\n    this.log('IHAVE: Asking for %d messages from %s', iwant.size, peer.info.id.toB58String());\n    return {\n      messageIDs: Array.from(iwant)\n    };\n  }\n  /**\n   * Handles IWANT messages\n   * Returns messages to send back to peer\n   * @param {Peer} peer\n   * @param {Array<rpc.RPC.ControlIWant>} iwant\n   * @returns {Array<rpc.RPC.Message>}\n   */\n\n\n  _handleIWant(peer, iwant) {\n    // @type {Map<string, rpc.RPC.Message>}\n    const ihave = new Map();\n    iwant.forEach(({\n      messageIDs\n    }) => {\n      messageIDs.forEach(msgID => {\n        const msg = this.messageCache.get(msgID);\n\n        if (msg) {\n          ihave.set(msgID, msg);\n        }\n      });\n    });\n\n    if (!ihave.size) {\n      return;\n    }\n\n    this.log('IWANT: Sending %d messages to %s', ihave.size, peer.info.id.toB58String());\n    return Array.from(ihave.values());\n  }\n  /**\n   * Handles Graft messages\n   * @param {Peer} peer\n   * @param {Array<rpc.RPC.ControlGraft>} graft\n   * @return {Array<rpc.RPC.ControlPrune>}\n   */\n\n\n  _handleGraft(peer, graft) {\n    const prune = [];\n    graft.forEach(({\n      topicID\n    }) => {\n      const peers = this.mesh.get(topicID);\n\n      if (!peers) {\n        prune.push(topicID);\n      } else {\n        this.log('GRAFT: Add mesh link from %s in %s', peer.info.id.toB58String(), topicID);\n        peers.add(peer);\n        peer.topics.add(topicID);\n        this.mesh.set(topicID, peers);\n      }\n    });\n\n    if (!prune.length) {\n      return;\n    }\n\n    const buildCtrlPruneMsg = topic => {\n      return {\n        topicID: topic\n      };\n    };\n\n    return prune.map(buildCtrlPruneMsg);\n  }\n  /**\n   * Handles Prune messages\n   * @param {Peer} peer\n   * @param {Array<rpc.RPC.ControlPrune>} prune\n   * @returns {void}\n   */\n\n\n  _handlePrune(peer, prune) {\n    prune.forEach(({\n      topicID\n    }) => {\n      const peers = this.mesh.get(topicID);\n\n      if (peers) {\n        this.log('PRUNE: Remove mesh link to %s in %s', peer.info.id.toB58String(), topicID);\n        peers.delete(peer);\n        peer.topics.delete(topicID);\n      }\n    });\n  }\n  /**\n   * Mounts the gossipsub protocol onto the libp2p node and sends our\n   * our subscriptions to every peer connected\n   * @override\n   * @returns {Promise}\n   */\n\n\n  async start() {\n    await super.start();\n    this.heartbeat.start();\n  }\n  /**\n   * Unmounts the gossipsub protocol and shuts down every connection\n   * @override\n   * @returns {Promise}\n   */\n\n\n  async stop() {\n    await super.stop();\n    this.heartbeat.stop();\n    this.mesh = new Map();\n    this.fanout = new Map();\n    this.lastpub = new Map();\n    this.gossip = new Map();\n    this.control = new Map();\n  }\n  /**\n   * Join topics\n   * @param {Array<string>|string} topics\n   * @returns {void}\n   */\n\n\n  join(topics) {\n    if (!this.started) {\n      throw new Error('GossipSub has not started');\n    }\n\n    topics = utils.ensureArray(topics);\n    this.log('JOIN %s', topics);\n    topics.forEach(topic => {\n      // Send GRAFT to mesh peers\n      const fanoutPeers = this.fanout.get(topic);\n\n      if (fanoutPeers) {\n        this.mesh.set(topic, fanoutPeers);\n        this.fanout.delete(topic);\n        this.lastpub.delete(topic);\n      } else {\n        const peers = this._getPeers(topic, constants.GossipSubD);\n\n        this.mesh.set(topic, peers);\n      }\n\n      this.mesh.get(topic).forEach(peer => {\n        this.log('JOIN: Add mesh link to %s in %s', peer.info.id.toB58String(), topic);\n\n        this._sendGraft(peer, topic);\n      });\n    });\n  }\n  /**\n   * Leave topics\n   * @param {Array<string>|string} topics\n   * @returns {void}\n   */\n\n\n  leave(topics) {\n    topics = utils.ensureArray(topics);\n    this.log('LEAVE %s', topics);\n    topics.forEach(topic => {\n      // Send PRUNE to mesh peers\n      const meshPeers = this.mesh.get(topic);\n\n      if (meshPeers) {\n        meshPeers.forEach(peer => {\n          this.log('LEAVE: Remove mesh link to %s in %s', peer.info.id.toB58String(), topic);\n\n          this._sendPrune(peer, topic);\n        });\n        this.mesh.delete(topic);\n      }\n    });\n  }\n  /**\n   * Override the default implementation in BasicPubSub.\n   * If we don't provide msgIdFn in constructor option, it's the same.\n   * @override\n   * @param {rpc.RPC.Message} msg the message object\n   * @returns {string} message id as string\n   */\n\n\n  getMsgId(msg) {\n    return this._msgIdFn(msg);\n  }\n\n  _publish(messages) {\n    messages.forEach(msgObj => {\n      this.messageCache.put(msgObj); // @type Set<string>\n\n      const tosend = new Set();\n      msgObj.topicIDs.forEach(topic => {\n        const peersInTopic = this.topics.get(topic);\n\n        if (!peersInTopic) {\n          return;\n        } // floodsub peers\n\n\n        peersInTopic.forEach(peer => {\n          if (peer.info.protocols.has(constants.FloodSubID)) {\n            tosend.add(peer);\n          }\n        }); // Gossipsub peers handling\n\n        let meshPeers = this.mesh.get(topic);\n\n        if (!meshPeers) {\n          // We are not in the mesh for topic, use fanout peers\n          meshPeers = this.fanout.get(topic);\n\n          if (!meshPeers) {\n            // If we are not in the fanout, then pick any peers in topic\n            const peers = this._getPeers(topic, constants.GossipSubD);\n\n            if (peers.size > 0) {\n              meshPeers = peers;\n              this.fanout.set(topic, peers);\n            } else {\n              meshPeers = [];\n            }\n          } // Store the latest publishing time\n\n\n          this.lastpub.set(topic, this._now());\n        }\n\n        meshPeers.forEach(peer => {\n          tosend.add(peer);\n        });\n      }); // Publish messages to peers\n\n      tosend.forEach(peer => {\n        if (peer.info.id.toB58String() === msgObj.from) {\n          return;\n        }\n\n        this._sendRpc(peer, {\n          msgs: [msgObj]\n        });\n      });\n    });\n  }\n  /**\n   * Sends a GRAFT message to a peer\n   * @param {Peer} peer\n   * @param {String} topic\n   * @returns {void}\n   */\n\n\n  _sendGraft(peer, topic) {\n    const graft = [{\n      topicID: topic\n    }];\n\n    const out = this._rpcWithControl(null, null, null, graft, null);\n\n    this._sendRpc(peer, out);\n  }\n  /**\n   * Sends a PRUNE message to a peer\n   * @param {Peer} peer\n   * @param {String} topic\n   * @returns {void}\n   */\n\n\n  _sendPrune(peer, topic) {\n    const prune = [{\n      topicID: topic\n    }];\n\n    const out = this._rpcWithControl(null, null, null, null, prune);\n\n    this._sendRpc(peer, out);\n  }\n\n  _sendRpc(peer, outRpc) {\n    if (!peer || !peer.isWritable) {\n      return;\n    } // piggyback control message retries\n\n\n    const ctrl = this.control.get(peer);\n\n    if (ctrl) {\n      this._piggybackControl(peer, outRpc, ctrl);\n\n      this.control.delete(peer);\n    } // piggyback gossip\n\n\n    const ihave = this.gossip.get(peer);\n\n    if (ihave) {\n      this._piggybackGossip(peer, outRpc, ihave);\n\n      this.gossip.delete(peer);\n    }\n\n    peer.write(rpc.RPC.encode(outRpc));\n  }\n\n  _piggybackControl(peer, outRpc, ctrl) {\n    const tograft = (ctrl.graft || []).filter(({\n      topicID\n    }) => (this.mesh.get(topicID) || new Set()).has(peer));\n    const toprune = (ctrl.prune || []).filter(({\n      topicID\n    }) => !(this.mesh.get(topicID) || new Set()).has(peer));\n\n    if (!tograft.length && !toprune.length) {\n      return;\n    }\n\n    outRpc.control = outRpc.control || {};\n    outRpc.control.graft = (outRpc.control.graft || []).concat(tograft);\n    outRpc.control.prune = (outRpc.control.prune || []).concat(toprune);\n  }\n\n  _piggybackGossip(peer, outRpc, ihave) {\n    outRpc.control = outRpc.control || {};\n    outRpc.control.ihave = ihave;\n  }\n  /**\n   * Send graft and prune messages\n   * @param {Map<Peer, Array<String>>} tograft\n   * @param {Map<Peer, Array<String>>} toprune\n   */\n\n\n  _sendGraftPrune(tograft, toprune) {\n    for (const [p, topics] of tograft) {\n      const graft = topics.map(topicID => ({\n        topicID\n      }));\n      let prune = null; // If a peer also has prunes, process them now\n\n      const pruneMsg = toprune.get(p);\n\n      if (pruneMsg) {\n        prune = pruneMsg.map(topicID => ({\n          topicID\n        }));\n        toprune.delete(p);\n      }\n\n      const outRpc = this._rpcWithControl(null, null, null, graft, prune);\n\n      this._sendRpc(p, outRpc);\n    }\n\n    for (const [p, topics] of toprune) {\n      const prune = topics.map(topicID => ({\n        topicID\n      }));\n\n      const outRpc = this._rpcWithControl(null, null, null, null, prune);\n\n      this._sendRpc(p, outRpc);\n    }\n  }\n  /**\n   * Emits gossip to peers in a particular topic\n   * @param {String} topic\n   * @param {Set<Peer>} peers - peers to exclude\n   * @returns {void}\n   */\n\n\n  _emitGossip(topic, peers) {\n    const messageIDs = this.messageCache.getGossipIDs(topic);\n\n    if (!messageIDs.length) {\n      return;\n    }\n\n    const gossipSubPeers = this._getPeers(topic, constants.GossipSubD);\n\n    gossipSubPeers.forEach(peer => {\n      // skip mesh peers\n      if (!peers.has(peer)) {\n        this._pushGossip(peer, {\n          topicID: topic,\n          messageIDs: messageIDs\n        });\n      }\n    });\n  }\n  /**\n   * Flush gossip and control messages\n   */\n\n\n  _flush() {\n    // send gossip first, which will also piggyback control\n    for (const [peer, ihave] of this.gossip.entries()) {\n      this.gossip.delete(peer);\n\n      const out = this._rpcWithControl(null, ihave, null, null, null);\n\n      this._sendRpc(peer, out);\n    } // send the remaining control messages\n\n\n    for (const [peer, control] of this.control.entries()) {\n      this.control.delete(peer);\n\n      const out = this._rpcWithControl(null, null, null, control.graft, control.prune);\n\n      this._sendRpc(peer, out);\n    }\n  }\n  /**\n   * Adds new IHAVE messages to pending gossip\n   * @param {Peer} peer\n   * @param {Array<rpc.RPC.ControlIHave>} controlIHaveMsgs\n   * @returns {void}\n   */\n\n\n  _pushGossip(peer, controlIHaveMsgs) {\n    this.log('Add gossip to %s', peer.info.id.toB58String());\n    const gossip = this.gossip.get(peer) || [];\n    this.gossip.set(peer, gossip.concat(controlIHaveMsgs));\n  }\n  /**\n   * Returns the current time in milliseconds\n   * @returns {number}\n   */\n\n\n  _now() {\n    return Date.now();\n  }\n\n}\n\nmodule.exports = GossipSub;\nmodule.exports.multicodec = constants.GossipSubID;","map":null,"metadata":{},"sourceType":"script"}