{"ast":null,"code":"'use strict';\n\nconst createLock = require('./utils/create-lock');\n\nconst isIpfs = require('is-ipfs'); // These operations are read-locked at the function level and will execute simultaneously\n\n\nconst readOperations = {\n  stat: require('./stat')\n}; // These operations are locked at the function level and will execute in series\n\nconst writeOperations = {\n  chmod: require('./chmod'),\n  cp: require('./cp'),\n  flush: require('./flush'),\n  mkdir: require('./mkdir'),\n  mv: require('./mv'),\n  rm: require('./rm'),\n  touch: require('./touch')\n}; // These operations are asynchronous and manage their own locking\n\nconst unwrappedOperations = {\n  write: require('./write'),\n  read: require('./read'),\n  ls: require('./ls')\n};\n\nconst wrap = ({\n  options,\n  mfs,\n  operations,\n  lock\n}) => {\n  Object.keys(operations).forEach(key => {\n    mfs[key] = lock(operations[key](options));\n  });\n};\n\nconst defaultOptions = {\n  repoOwner: true,\n  ipld: null,\n  repo: null\n};\n\nfunction createMfs(options) {\n  const {\n    repoOwner\n  } = Object.assign({}, defaultOptions || {}, options);\n  options.repo = {\n    blocks: options.blocks,\n    datastore: options.datastore\n  };\n  const lock = createLock(repoOwner);\n\n  const readLock = operation => {\n    return lock.readLock(operation);\n  };\n\n  const writeLock = operation => {\n    return lock.writeLock(operation);\n  };\n\n  const mfs = {};\n  wrap({\n    options,\n    mfs,\n    operations: readOperations,\n    lock: readLock\n  });\n  wrap({\n    options,\n    mfs,\n    operations: writeOperations,\n    lock: writeLock\n  });\n  Object.keys(unwrappedOperations).forEach(key => {\n    mfs[key] = unwrappedOperations[key](options);\n  });\n  return mfs;\n}\n\nmodule.exports = ({\n  ipld,\n  block,\n  blockService,\n  repo,\n  preload,\n  options: constructorOptions\n}) => {\n  const methods = createMfs({\n    ipld,\n    block,\n    blocks: blockService,\n    datastore: repo.root,\n    repoOwner: constructorOptions.repoOwner\n  });\n\n  const withPreload = fn => (...args) => {\n    const paths = args.filter(arg => isIpfs.ipfsPath(arg) || isIpfs.cid(arg));\n\n    if (paths.length) {\n      const options = args[args.length - 1];\n\n      if (options && options.preload !== false) {\n        paths.forEach(path => preload(path));\n      }\n    }\n\n    return fn(...args);\n  };\n\n  return { ...methods,\n\n    /**\n     * Change file mode\n     *\n     * @param {String} path - The path of the source to modify.\n     * @param {Object} mode - The mode to set the path\n     * @param {Object} [opts] - Options for modification.\n     * @param {boolean} [opts.recursive=false] - Whether to change modes recursively. (default: false)\n     * @param {boolean} [opts.flush=true] - Whether or not to immediately flush MFS changes to disk (default: true).\n     * @param {number} [opts.shardSplitThreshold] - If the modified path has more than this many links it will be turned into a HAMT shard\n     * @returns {Promise<string>}\n     */\n    chmod: methods.chmod,\n\n    /**\n     * Copy files\n     *\n     * @param {String | Array<String>} from - The path(s) of the source to copy.\n     * @param {String} to - The path of the destination to copy to.\n     * @param {Object} [opts] - Options for copy.\n     * @param {boolean} [opts.parents=false] - Whether or not to make the parent directories if they don't exist. (default: false)\n     * @param {String} [opts.format=dag-pb] - Format of nodes to write any newly created directories as. (default: dag-pb)\n     * @param {String} [opts.hashAlg=sha2-256] - Algorithm to use when creating CIDs for newly created directories. (default: sha2-256) {@link https://github.com/multiformats/js-multihash/blob/master/src/constants.js#L5-L343 The list of all possible values}\n     * @param {boolean} [opts.flush=true] - Whether or not to immediately flush MFS changes to disk (default: true).\n     * @returns {Promise<string>}\n     */\n    cp: withPreload(methods.cp),\n\n    /**\n     * Make a directory\n     *\n     * @param {String} path - The path to the directory to make.\n     * @param {Object} [opts] - Options for mkdir.\n     * @param {boolean} [opts.parents=false] - Value to decide whether or not to make the parent directories if they don't exist. (default: false)\n     * @param {String} [opts.format=dag-pb] - Format of nodes to write any newly created directories as. (default: dag-pb).\n     * @param {String} [opts.hashAlg] - Algorithm to use when creating CIDs for newly created directories. (default: sha2-256) {@link https://github.com/multiformats/js-multihash/blob/master/src/constants.js#L5-L343 The list of all possible values}\n     * @param {boolean} [opts.flush=true] - Whether or not to immediately flush MFS changes to disk (default: true).\n     * @returns {Promise<void>}\n     */\n    mkdir: methods.mkdir,\n\n    /**\n     * @typedef {Object} StatOutput\n     * @prop {String} hash - Output hash.\n     * @prop {number} size - File size in bytes.\n     * @prop {number} cumulativeSize - Integer with the size of the DAGNodes making up the file in Bytes.\n     * @prop {string} type - Output type either 'directory' or 'file'.\n     * @prop {number} blocks - If type is directory, this is the number of files in the directory. If it is file it is the number of blocks that make up the file.\n     * @prop {boolean} withLocality - Indicate if locality information is present.\n     * @prop {boolean} local - Indicate if the queried dag is fully present locally.\n     * @prop {number} sizeLocal - Integer indicating the cumulative size of the data present locally.\n     */\n\n    /**\n     * Get file or directory status.\n     *\n     * @param {String} path - Path to the file or directory to stat.\n     * @param {Object} [opts] - Options for stat.\n     * @param {boolean} [opts.hash=false] - Return only the hash. (default: false)\n     * @param {boolean} [opts.size=false] - Return only the size. (default: false)\n     * @param {boolean} [opts.withLocal=false] - Compute the amount of the dag that is local, and if possible the total size. (default: false)\n     * @returns {Promise<StatOutput>}\n     */\n    stat: withPreload(methods.stat),\n\n    /**\n     * Remove a file or directory.\n     *\n     * @param {String | Array<String>} paths - One or more paths to remove.\n     * @param {Object} [opts] - Options for remove.\n     * @param {boolean} [opts.recursive=false] - Whether or not to remove directories recursively. (default: false)\n     * @returns {Promise<void>}\n     */\n    rm: methods.rm,\n\n    /**\n     * @typedef {Object} ReadOptions\n     * @prop {number} [opts.offset=0] - Integer with the byte offset to begin reading from (default: 0).\n     * @prop {number} [opts.length] - Integer with the maximum number of bytes to read (default: Read to the end of stream).\n     */\n\n    /**\n     * Read a file into a Buffer.\n     *\n     * @param {string} path - Path of the file to read and must point to a file (and not a directory).\n     * @param {ReadOptions} [opts] - Object for read.\n     * @returns {AsyncIterable<Buffer>}\n     */\n    read: withPreload(methods.read),\n\n    /**\n     * Update modification time\n     *\n     * @param {String} path - The path of the source to modify.\n     * @param {number} mtime - Time to use as the new modification time in seconds since (+ve) or before (-ve) the Unix Epoch\n     * @param {Object} [opts] - Options for touch.\n     * @param {boolean} [opts.parents=false] - Whether or not to make the parent directories if they don't exist. (default: false)\n     * @param {number} [opts.cidVersion=0] - CID version to use with the newly updated node\n     * @param {number} [opts.shardSplitThreshold] - If the modified path has more than this many links it will be turned into a HAMT shard\n     * @returns {Promise<string>}\n     */\n    touch: methods.touch,\n\n    /**\n     * Write to a file.\n     *\n     * @param {string} path - Path of the file to write.\n     * @param {Buffer | PullStream | ReadableStream | Blob | string} content - Content to write.\n     * @param {Object} opts - Options for write.\n     * @param {number} [opts.offset=0] - Integer with the byte offset to begin writing at. (default: 0)\n     * @param {boolean} [opts.create=false] - Indicate to create the file if it doesn't exist. (default: false)\n     * @param {boolean} [opts.truncate=false] - Indicate if the file should be truncated after writing all the bytes from content. (default: false)\n     * @param {boolena} [opts.parents=false] - Value to decide whether or not to make the parent directories if they don't exist. (default: false)\n     * @param {number} [opts.length] - Maximum number of bytes to read. (default: Read all bytes from content)\n     * @param {boolean} [opts.rawLeaves=false] - If true, DAG leaves will contain raw file data and not be wrapped in a protobuf. (default: false)\n     * @param {number} [opts.cidVersion=0] - The CID version to use when storing the data (storage keys are based on the CID, including its version). (default: 0)\n     * @returns {Promise<void>}\n     */\n    write: methods.write,\n\n    /**\n     * Move files.\n     *\n     * @param {string | Array<string>} from - Path(s) of the source to move.\n     * @param {string} to - Path of the destination to move to.\n     * @param {Object} opts - Options for mv.\n     * @param {boolean} [opts.parents=false] - Value to decide whether or not to make the parent directories if they don't exist. (default: false)\n     * @param {String} [opts.format=dag-pb] - Format of nodes to write any newly created directories as. (default: dag-pb).\n     * @param {String} [opts.hashAlg] - Algorithm to use when creating CIDs for newly created directories. (default: sha2-256) {@link https://github.com/multiformats/js-multihash/blob/master/src/constants.js#L5-L343 The list of all possible values}\n     * @param {boolean} [opts.flush=true] - Value to decide whether or not to immediately flush MFS changes to disk. (default: true)\n     * @returns {Promise<void>}\n     * @description\n     * If from has multiple values then to must be a directory.\n     *\n     * If from has a single value and to exists and is a directory, from will be moved into to.\n     *\n     * If from has a single value and to exists and is a file, from must be a file and the contents of to will be replaced with the contents of from otherwise an error will be returned.\n     *\n     * If from is an IPFS path, and an MFS path exists with the same name, the IPFS path will be chosen.\n     *\n     * All values of from will be removed after the operation is complete unless they are an IPFS path.\n     */\n    mv: withPreload(methods.mv),\n\n    /**\n     * Flush a given path's data to the disk.\n     *\n     * @param {string | Array<string>} [paths] - String paths to flush. (default: /)\n     * @returns {Promise<void>}\n     */\n    flush: methods.flush,\n\n    /**\n     * @typedef {Object} ListOutputFile\n     * @prop {string} name - Which is the file's name.\n     * @prop {string} type - Which is the object's type (directory or file).\n     * @prop {number} size - The size of the file in bytes.\n     * @prop {string} hash - The hash of the file.\n     */\n\n    /**\n     * @typedef {Object} ListOptions\n     * @prop {boolean} [long=false] - Value to decide whether or not to populate type, size and hash. (default: false)\n     * @prop {boolean} [sort=false] - If true entries will be sorted by filename. (default: false)\n     */\n\n    /**\n     * List directories in the local mutable namespace.\n     *\n     * @param {string} [path=\"/\"] - String to show listing for. (default: /)\n     * @param {ListOptions} [opts] - Options for list.\n     * @returns {AsyncIterable<ListOutputFile>}\n     */\n    ls: withPreload(async function* (...args) {\n      for await (const file of methods.ls(...args)) {\n        yield { ...file,\n          size: file.size || 0\n        };\n      }\n    })\n  };\n};","map":null,"metadata":{},"sourceType":"script"}