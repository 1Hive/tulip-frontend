{"ast":null,"code":"/*\nindex.js - Kademlia DHT K-bucket implementation as a binary tree.\n\nThe MIT License (MIT)\n\nCopyright (c) 2013-2021 Tristan Slominski\n\nPermission is hereby granted, free of charge, to any person\nobtaining a copy of this software and associated documentation\nfiles (the \"Software\"), to deal in the Software without\nrestriction, including without limitation the rights to use,\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the\nSoftware is furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\nOTHER DEALINGS IN THE SOFTWARE.\n*/\n'use strict';\n\nconst randomBytes = require('randombytes');\n\nconst {\n  EventEmitter\n} = require('events');\n/**\n * @param  {Uint8Array} array1\n * @param  {Uint8Array} array2\n * @return {Boolean}\n */\n\n\nfunction arrayEquals(array1, array2) {\n  if (array1 === array2) {\n    return true;\n  }\n\n  if (array1.length !== array2.length) {\n    return false;\n  }\n\n  for (let i = 0, length = array1.length; i < length; ++i) {\n    if (array1[i] !== array2[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction createNode() {\n  return {\n    contacts: [],\n    dontSplit: false,\n    left: null,\n    right: null\n  };\n}\n\nfunction ensureInt8(name, val) {\n  if (!(val instanceof Uint8Array)) {\n    throw new TypeError(name + ' is not a Uint8Array');\n  }\n}\n/**\n * Implementation of a Kademlia DHT k-bucket used for storing\n * contact (peer node) information.\n *\n * @extends EventEmitter\n */\n\n\nclass KBucket extends EventEmitter {\n  /**\n   * `options`:\n   *   `distance`: _Function_\n   *     `function (firstId, secondId) { return distance }` An optional\n   *     `distance` function that gets two `id` Uint8Arrays\n   *     and return distance (as number) between them.\n   *   `arbiter`: _Function_ _(Default: vectorClock arbiter)_\n   *     `function (incumbent, candidate) { return contact; }` An optional\n   *     `arbiter` function that givent two `contact` objects with the same `id`\n   *     returns the desired object to be used for updating the k-bucket. For\n   *     more details, see [arbiter function](#arbiter-function).\n   *   `localNodeId`: _Uint8Array_ An optional Uint8Array representing the local node id.\n   *     If not provided, a local node id will be created via `randomBytes(20)`.\n   *     `metadata`: _Object_ _(Default: {})_ Optional satellite data to include\n   *     with the k-bucket. `metadata` property is guaranteed not be altered by,\n   *     it is provided as an explicit container for users of k-bucket to store\n   *     implementation-specific data.\n   *   `numberOfNodesPerKBucket`: _Integer_ _(Default: 20)_ The number of nodes\n   *     that a k-bucket can contain before being full or split.\n   *     `numberOfNodesToPing`: _Integer_ _(Default: 3)_ The number of nodes to\n   *     ping when a bucket that should not be split becomes full. KBucket will\n   *     emit a `ping` event that contains `numberOfNodesToPing` nodes that have\n   *     not been contacted the longest.\n   *\n   * @param {Object=} options optional\n   */\n  constructor(options = {}) {\n    super();\n    this.localNodeId = options.localNodeId || randomBytes(20);\n    this.numberOfNodesPerKBucket = options.numberOfNodesPerKBucket || 20;\n    this.numberOfNodesToPing = options.numberOfNodesToPing || 3;\n    this.distance = options.distance || KBucket.distance; // use an arbiter from options or vectorClock arbiter by default\n\n    this.arbiter = options.arbiter || KBucket.arbiter;\n    this.metadata = Object.assign({}, options.metadata);\n    ensureInt8('option.localNodeId as parameter 1', this.localNodeId);\n    this.root = createNode();\n  }\n  /**\n   * Default arbiter function for contacts with the same id. Uses\n   * contact.vectorClock to select which contact to update the k-bucket with.\n   * Contact with larger vectorClock field will be selected. If vectorClock is\n   * the same, candidat will be selected.\n   *\n   * @param  {Object} incumbent Contact currently stored in the k-bucket.\n   * @param  {Object} candidate Contact being added to the k-bucket.\n   * @return {Object}           Contact to updated the k-bucket with.\n   */\n\n\n  static arbiter(incumbent, candidate) {\n    return incumbent.vectorClock > candidate.vectorClock ? incumbent : candidate;\n  }\n  /**\n   * Default distance function. Finds the XOR\n   * distance between firstId and secondId.\n   *\n   * @param  {Uint8Array} firstId  Uint8Array containing first id.\n   * @param  {Uint8Array} secondId Uint8Array containing second id.\n   * @return {Number}              Integer The XOR distance between firstId\n   *                               and secondId.\n   */\n\n\n  static distance(firstId, secondId) {\n    let distance = 0;\n    let i = 0;\n    const min = Math.min(firstId.length, secondId.length);\n    const max = Math.max(firstId.length, secondId.length);\n\n    for (; i < min; ++i) {\n      distance = distance * 256 + (firstId[i] ^ secondId[i]);\n    }\n\n    for (; i < max; ++i) distance = distance * 256 + 255;\n\n    return distance;\n  }\n  /**\n   * Adds a contact to the k-bucket.\n   *\n   * @param {Object} contact the contact object to add\n   */\n\n\n  add(contact) {\n    ensureInt8('contact.id', (contact || {}).id);\n    let bitIndex = 0;\n    let node = this.root;\n\n    while (node.contacts === null) {\n      // this is not a leaf node but an inner node with 'low' and 'high'\n      // branches; we will check the appropriate bit of the identifier and\n      // delegate to the appropriate node for further processing\n      node = this._determineNode(node, contact.id, bitIndex++);\n    } // check if the contact already exists\n\n\n    const index = this._indexOf(node, contact.id);\n\n    if (index >= 0) {\n      this._update(node, index, contact);\n\n      return this;\n    }\n\n    if (node.contacts.length < this.numberOfNodesPerKBucket) {\n      node.contacts.push(contact);\n      this.emit('added', contact);\n      return this;\n    } // the bucket is full\n\n\n    if (node.dontSplit) {\n      // we are not allowed to split the bucket\n      // we need to ping the first this.numberOfNodesToPing\n      // in order to determine if they are alive\n      // only if one of the pinged nodes does not respond, can the new contact\n      // be added (this prevents DoS flodding with new invalid contacts)\n      this.emit('ping', node.contacts.slice(0, this.numberOfNodesToPing), contact);\n      return this;\n    }\n\n    this._split(node, bitIndex);\n\n    return this.add(contact);\n  }\n  /**\n   * Get the n closest contacts to the provided node id. \"Closest\" here means:\n   * closest according to the XOR metric of the contact node id.\n   *\n   * @param  {Uint8Array} id  Contact node id\n   * @param  {Number=} n      Integer (Default: Infinity) The maximum number of\n   *                          closest contacts to return\n   * @return {Array}          Array Maximum of n closest contacts to the node id\n   */\n\n\n  closest(id, n = Infinity) {\n    ensureInt8('id', id);\n\n    if (!Number.isInteger(n) && n !== Infinity || n <= 0) {\n      throw new TypeError('n is not positive number');\n    }\n\n    let contacts = [];\n\n    for (let nodes = [this.root], bitIndex = 0; nodes.length > 0 && contacts.length < n;) {\n      const node = nodes.pop();\n\n      if (node.contacts === null) {\n        const detNode = this._determineNode(node, id, bitIndex++);\n\n        nodes.push(node.left === detNode ? node.right : node.left);\n        nodes.push(detNode);\n      } else {\n        contacts = contacts.concat(node.contacts);\n      }\n    }\n\n    return contacts.map(a => [this.distance(a.id, id), a]).sort((a, b) => a[0] - b[0]).slice(0, n).map(a => a[1]);\n  }\n  /**\n   * Counts the total number of contacts in the tree.\n   *\n   * @return {Number} The number of contacts held in the tree\n   */\n\n\n  count() {\n    // return this.toArray().length\n    let count = 0;\n\n    for (const nodes = [this.root]; nodes.length > 0;) {\n      const node = nodes.pop();\n      if (node.contacts === null) nodes.push(node.right, node.left);else count += node.contacts.length;\n    }\n\n    return count;\n  }\n  /**\n   * Determines whether the id at the bitIndex is 0 or 1.\n   * Return left leaf if `id` at `bitIndex` is 0, right leaf otherwise\n   *\n   * @param  {Object} node     internal object that has 2 leafs: left and right\n   * @param  {Uint8Array} id   Id to compare localNodeId with.\n   * @param  {Number} bitIndex Integer (Default: 0) The bit index to which bit\n   *                           to check in the id Uint8Array.\n   * @return {Object}          left leaf if id at bitIndex is 0, right leaf otherwise.\n   */\n\n\n  _determineNode(node, id, bitIndex) {\n    // **NOTE** remember that id is a Uint8Array and has granularity of\n    // bytes (8 bits), whereas the bitIndex is the _bit_ index (not byte)\n    // id's that are too short are put in low bucket (1 byte = 8 bits)\n    // (bitIndex >> 3) finds how many bytes the bitIndex describes\n    // bitIndex % 8 checks if we have extra bits beyond byte multiples\n    // if number of bytes is <= no. of bytes described by bitIndex and there\n    // are extra bits to consider, this means id has less bits than what\n    // bitIndex describes, id therefore is too short, and will be put in low\n    // bucket\n    const bytesDescribedByBitIndex = bitIndex >> 3;\n    const bitIndexWithinByte = bitIndex % 8;\n\n    if (id.length <= bytesDescribedByBitIndex && bitIndexWithinByte !== 0) {\n      return node.left;\n    }\n\n    const byteUnderConsideration = id[bytesDescribedByBitIndex]; // byteUnderConsideration is an integer from 0 to 255 represented by 8 bits\n    // where 255 is 11111111 and 0 is 00000000\n    // in order to find out whether the bit at bitIndexWithinByte is set\n    // we construct (1 << (7 - bitIndexWithinByte)) which will consist\n    // of all bits being 0, with only one bit set to 1\n    // for example, if bitIndexWithinByte is 3, we will construct 00010000 by\n    // (1 << (7 - 3)) -> (1 << 4) -> 16\n\n    if (byteUnderConsideration & 1 << 7 - bitIndexWithinByte) {\n      return node.right;\n    }\n\n    return node.left;\n  }\n  /**\n   * Get a contact by its exact ID.\n   * If this is a leaf, loop through the bucket contents and return the correct\n   * contact if we have it or null if not. If this is an inner node, determine\n   * which branch of the tree to traverse and repeat.\n   *\n   * @param  {Uint8Array} id The ID of the contact to fetch.\n   * @return {Object|Null}   The contact if available, otherwise null\n   */\n\n\n  get(id) {\n    ensureInt8('id', id);\n    let bitIndex = 0;\n    let node = this.root;\n\n    while (node.contacts === null) {\n      node = this._determineNode(node, id, bitIndex++);\n    } // index of uses contact id for matching\n\n\n    const index = this._indexOf(node, id);\n\n    return index >= 0 ? node.contacts[index] : null;\n  }\n  /**\n   * Returns the index of the contact with provided\n   * id if it exists, returns -1 otherwise.\n   *\n   * @param  {Object} node    internal object that has 2 leafs: left and right\n   * @param  {Uint8Array} id  Contact node id.\n   * @return {Number}         Integer Index of contact with provided id if it\n   *                          exists, -1 otherwise.\n   */\n\n\n  _indexOf(node, id) {\n    for (let i = 0; i < node.contacts.length; ++i) {\n      if (arrayEquals(node.contacts[i].id, id)) return i;\n    }\n\n    return -1;\n  }\n  /**\n   * Removes contact with the provided id.\n   *\n   * @param  {Uint8Array} id The ID of the contact to remove.\n   * @return {Object}        The k-bucket itself.\n   */\n\n\n  remove(id) {\n    ensureInt8('the id as parameter 1', id);\n    let bitIndex = 0;\n    let node = this.root;\n\n    while (node.contacts === null) {\n      node = this._determineNode(node, id, bitIndex++);\n    }\n\n    const index = this._indexOf(node, id);\n\n    if (index >= 0) {\n      const contact = node.contacts.splice(index, 1)[0];\n      this.emit('removed', contact);\n    }\n\n    return this;\n  }\n  /**\n   * Splits the node, redistributes contacts to the new nodes, and marks the\n   * node that was split as an inner node of the binary tree of nodes by\n   * setting this.root.contacts = null\n   *\n   * @param  {Object} node     node for splitting\n   * @param  {Number} bitIndex the bitIndex to which byte to check in the\n   *                           Uint8Array for navigating the binary tree\n   */\n\n\n  _split(node, bitIndex) {\n    node.left = createNode();\n    node.right = createNode(); // redistribute existing contacts amongst the two newly created nodes\n\n    for (const contact of node.contacts) {\n      this._determineNode(node, contact.id, bitIndex).contacts.push(contact);\n    }\n\n    node.contacts = null; // mark as inner tree node\n    // don't split the \"far away\" node\n    // we check where the local node would end up and mark the other one as\n    // \"dontSplit\" (i.e. \"far away\")\n\n    const detNode = this._determineNode(node, this.localNodeId, bitIndex);\n\n    const otherNode = node.left === detNode ? node.right : node.left;\n    otherNode.dontSplit = true;\n  }\n  /**\n   * Returns all the contacts contained in the tree as an array.\n   * If this is a leaf, return a copy of the bucket. If this is not a leaf,\n   * return the union of the low and high branches (themselves also as arrays).\n   *\n   * @return {Array} All of the contacts in the tree, as an array\n   */\n\n\n  toArray() {\n    let result = [];\n\n    for (const nodes = [this.root]; nodes.length > 0;) {\n      const node = nodes.pop();\n      if (node.contacts === null) nodes.push(node.right, node.left);else result = result.concat(node.contacts);\n    }\n\n    return result;\n  }\n  /**\n   * Similar to `toArray()` but instead of buffering everything up into an\n   * array before returning it, yields contacts as they are encountered while\n   * walking the tree.\n   *\n   * @return {Iterable} All of the contacts in the tree, as an iterable\n   */\n\n\n  *toIterable() {\n    for (const nodes = [this.root]; nodes.length > 0;) {\n      const node = nodes.pop();\n\n      if (node.contacts === null) {\n        nodes.push(node.right, node.left);\n      } else {\n        yield* node.contacts;\n      }\n    }\n  }\n  /**\n   * Updates the contact selected by the arbiter.\n   * If the selection is our old contact and the candidate is some new contact\n   * then the new contact is abandoned (not added).\n   * If the selection is our old contact and the candidate is our old contact\n   * then we are refreshing the contact and it is marked as most recently\n   * contacted (by being moved to the right/end of the bucket array).\n   * If the selection is our new contact, the old contact is removed and the new\n   * contact is marked as most recently contacted.\n   *\n   * @param  {Object} node    internal object that has 2 leafs: left and right\n   * @param  {Number} index   the index in the bucket where contact exists\n   *                          (index has already been computed in a previous\n   *                          calculation)\n   * @param  {Object} contact The contact object to update.\n   */\n\n\n  _update(node, index, contact) {\n    // sanity check\n    if (!arrayEquals(node.contacts[index].id, contact.id)) {\n      throw new Error('wrong index for _update');\n    }\n\n    const incumbent = node.contacts[index];\n    const selection = this.arbiter(incumbent, contact); // if the selection is our old contact and the candidate is some new\n    // contact, then there is nothing to do\n\n    if (selection === incumbent && incumbent !== contact) return;\n    node.contacts.splice(index, 1); // remove old contact\n\n    node.contacts.push(selection); // add more recent contact version\n\n    this.emit('updated', incumbent, selection);\n  }\n\n}\n\nmodule.exports = KBucket;","map":null,"metadata":{},"sourceType":"script"}