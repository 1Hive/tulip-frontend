{"ast":null,"code":"'use strict';\n\nconst loadMfsRoot = require('./with-mfs-root');\n\nconst toPathComponents = require('./to-path-components');\n\nconst exporter = require('ipfs-unixfs-exporter');\n\nconst errCode = require('err-code');\n\nconst IPFS_PREFIX = 'ipfs';\n\nconst toMfsPath = async (context, path) => {\n  const outputArray = Array.isArray(path);\n  let paths = Array.isArray(path) ? path : [path];\n  const root = await loadMfsRoot(context);\n  paths = paths.map(path => {\n    path = (path || '').trim();\n    path = path.replace(/(\\/\\/+)/g, '/');\n\n    if (path.endsWith('/') && path.length > 1) {\n      path = path.substring(0, path.length - 1);\n    }\n\n    if (!path) {\n      throw errCode(new Error('paths must not be empty'), 'ERR_NO_PATH');\n    }\n\n    if (path.substring(0, 1) !== '/') {\n      throw errCode(new Error('paths must start with a leading slash'), 'ERR_INVALID_PATH');\n    }\n\n    if (path.substring(path.length - 1) === '/') {\n      path = path.substring(0, path.length - 1);\n    }\n\n    const pathComponents = toPathComponents(path);\n\n    if (pathComponents[0] === IPFS_PREFIX) {\n      // e.g. /ipfs/QMfoo or /ipfs/Qmfoo/sub/path\n      let mfsDirectory;\n\n      if (pathComponents.length === 2) {\n        mfsDirectory = `/${pathComponents.join('/')}`;\n      } else {\n        mfsDirectory = `/${pathComponents.slice(0, pathComponents.length - 1).join('/')}`;\n      }\n\n      return {\n        type: 'ipfs',\n        depth: pathComponents.length - 2,\n        mfsPath: `/${pathComponents.join('/')}`,\n        mfsDirectory,\n        parts: pathComponents,\n        path: `/${pathComponents.join('/')}`,\n        name: pathComponents[pathComponents.length - 1]\n      };\n    }\n\n    const mfsPath = `/${IPFS_PREFIX}/${root}${pathComponents.length ? '/' + pathComponents.join('/') : ''}`;\n    const mfsDirectory = `/${IPFS_PREFIX}/${root}/${pathComponents.slice(0, pathComponents.length - 1).join('/')}`;\n    return {\n      type: 'mfs',\n      depth: pathComponents.length,\n      mfsDirectory,\n      mfsPath,\n      parts: pathComponents,\n      path: `/${pathComponents.join('/')}`,\n      name: pathComponents[pathComponents.length - 1]\n    };\n  });\n  await Promise.all(paths.map(async path => {\n    const cidPath = path.type === 'mfs' ? path.mfsPath : path.path;\n\n    try {\n      const res = await exporter(cidPath, context.ipld);\n      path.cid = res.cid;\n      path.mfsPath = `/ipfs/${res.path}`;\n      path.unixfs = res.unixfs;\n      path.content = res.content;\n    } catch (err) {\n      if (err.code !== 'ERR_NOT_FOUND') {\n        throw err;\n      }\n    }\n\n    path.exists = Boolean(path.cid);\n  }));\n\n  if (outputArray) {\n    return paths;\n  }\n\n  return paths[0];\n};\n\nmodule.exports = toMfsPath;","map":null,"metadata":{},"sourceType":"script"}