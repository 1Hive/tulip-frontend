{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar errCode = require('err-code');\n\nvar multibase = require('multibase');\n\nvar _require = require('streaming-iterables'),\n    parallelMap = _require.parallelMap,\n    collect = _require.collect;\n\nvar pipe = require('it-pipe');\n\nvar _require2 = require('../../utils'),\n    resolvePath = _require2.resolvePath,\n    withTimeoutOption = _require2.withTimeoutOption;\n\nvar _require3 = require('./pin-manager'),\n    PinTypes = _require3.PinTypes;\n\nvar PIN_RM_CONCURRENCY = 8;\n\nmodule.exports = function (_ref) {\n  var pinManager = _ref.pinManager,\n      gcLock = _ref.gcLock,\n      dag = _ref.dag;\n  return withTimeoutOption( /*#__PURE__*/function () {\n    var _rm = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(paths, options) {\n      var recursive, cids, release, results;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              options = options || {};\n              recursive = options.recursive !== false;\n\n              if (!(options.cidBase && !multibase.names.includes(options.cidBase))) {\n                _context2.next = 4;\n                break;\n              }\n\n              throw errCode(new Error('invalid multibase'), 'ERR_INVALID_MULTIBASE');\n\n            case 4:\n              _context2.next = 6;\n              return resolvePath(dag, paths);\n\n            case 6:\n              cids = _context2.sent;\n              _context2.next = 9;\n              return gcLock.readLock();\n\n            case 9:\n              release = _context2.sent;\n              _context2.prev = 10;\n              _context2.next = 13;\n              return pipe(cids, parallelMap(PIN_RM_CONCURRENCY, /*#__PURE__*/function () {\n                var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(cid) {\n                  var _yield$pinManager$isP, pinned, reason;\n\n                  return _regeneratorRuntime.wrap(function _callee$(_context) {\n                    while (1) {\n                      switch (_context.prev = _context.next) {\n                        case 0:\n                          _context.next = 2;\n                          return pinManager.isPinnedWithType(cid, PinTypes.all);\n\n                        case 2:\n                          _yield$pinManager$isP = _context.sent;\n                          pinned = _yield$pinManager$isP.pinned;\n                          reason = _yield$pinManager$isP.reason;\n\n                          if (pinned) {\n                            _context.next = 7;\n                            break;\n                          }\n\n                          throw new Error(\"\".concat(cid, \" is not pinned\"));\n\n                        case 7:\n                          if (!(reason !== PinTypes.recursive && reason !== PinTypes.direct)) {\n                            _context.next = 9;\n                            break;\n                          }\n\n                          throw new Error(\"\".concat(cid, \" is pinned indirectly under \").concat(reason));\n\n                        case 9:\n                          if (!(reason === PinTypes.recursive && !recursive)) {\n                            _context.next = 11;\n                            break;\n                          }\n\n                          throw new Error(\"\".concat(cid, \" is pinned recursively\"));\n\n                        case 11:\n                          return _context.abrupt(\"return\", cid);\n\n                        case 12:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }\n                  }, _callee);\n                }));\n\n                return function (_x3) {\n                  return _ref2.apply(this, arguments);\n                };\n              }()), collect);\n\n            case 13:\n              results = _context2.sent;\n              // update the pin sets in memory\n              results.forEach(function (cid) {\n                if (recursive && pinManager.recursivePins.has(cid.toString())) {\n                  pinManager.recursivePins.delete(cid.toString());\n                } else {\n                  pinManager.directPins.delete(cid.toString());\n                }\n              }); // persist updated pin sets to datastore\n\n              _context2.next = 17;\n              return pinManager.flushPins();\n\n            case 17:\n              return _context2.abrupt(\"return\", results.map(function (cid) {\n                return {\n                  cid: cid\n                };\n              }));\n\n            case 18:\n              _context2.prev = 18;\n              release();\n              return _context2.finish(18);\n\n            case 21:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[10,, 18, 21]]);\n    }));\n\n    function rm(_x, _x2) {\n      return _rm.apply(this, arguments);\n    }\n\n    return rm;\n  }());\n};","map":null,"metadata":{},"sourceType":"script"}