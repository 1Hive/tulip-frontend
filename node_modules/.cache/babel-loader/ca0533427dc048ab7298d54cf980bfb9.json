{"ast":null,"code":"import { Buffer } from \"buffer\";\nexport const uint16BEEncode = (value, target, offset) => {\n  target = target || Buffer.allocUnsafe(2);\n  target.writeUInt16BE(value, offset);\n  return target;\n};\nuint16BEEncode.bytes = 2;\nexport const uint16BEDecode = data => {\n  if (data.length < 2) throw RangeError('Could not decode int16BE');\n  return data.readUInt16BE(0);\n};\nuint16BEDecode.bytes = 2; // Note: IK and XX encoder usage is opposite (XX uses in stages encode0 where IK uses encode1)\n\nexport function encode0(message) {\n  return Buffer.concat([message.ne, message.ciphertext]);\n}\nexport function encode1(message) {\n  return Buffer.concat([message.ne, message.ns, message.ciphertext]);\n}\nexport function encode2(message) {\n  return Buffer.concat([message.ns, message.ciphertext]);\n}\nexport function decode0(input) {\n  if (input.length < 32) {\n    throw new Error(\"Cannot decode stage 0 MessageBuffer: length less than 32 bytes.\");\n  }\n\n  return {\n    ne: input.slice(0, 32),\n    ciphertext: input.slice(32, input.length),\n    ns: Buffer.alloc(0)\n  };\n}\nexport function decode1(input) {\n  if (input.length < 80) {\n    throw new Error(\"Cannot decode stage 1 MessageBuffer: length less than 80 bytes.\");\n  }\n\n  return {\n    ne: input.slice(0, 32),\n    ns: input.slice(32, 80),\n    ciphertext: input.slice(80, input.length)\n  };\n}\nexport function decode2(input) {\n  if (input.length < 48) {\n    throw new Error(\"Cannot decode stage 2 MessageBuffer: length less than 48 bytes.\");\n  }\n\n  return {\n    ne: Buffer.alloc(0),\n    ns: input.slice(0, 48),\n    ciphertext: input.slice(48, input.length)\n  };\n}","map":null,"metadata":{},"sourceType":"module"}