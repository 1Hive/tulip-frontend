{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst multihashing = require('multihashing-async');\n\nconst mh = require('multihashes');\n\nconst {\n  Key\n} = require('interface-datastore');\n\nconst base32 = require('base32.js');\n\nconst distance = require('xor-distance');\n\nconst pMap = require('p-map');\n\nconst {\n  Record\n} = require('libp2p-record');\n\nconst PeerId = require('peer-id');\n\nconst errcode = require('err-code');\n\nconst {\n  Buffer\n} = require('buffer');\n/**\n * Creates a DHT ID by hashing a given buffer.\n *\n * @param {Buffer} buf\n * @returns {Promise<Buffer>}\n */\n\n\nexports.convertBuffer = buf => {\n  return multihashing.digest(buf, 'sha2-256');\n};\n/**\n * Creates a DHT ID by hashing a Peer ID\n *\n * @param {PeerId} peer\n * @returns {Promise<Buffer>}\n */\n\n\nexports.convertPeerId = peer => {\n  return multihashing.digest(peer.id, 'sha2-256');\n};\n/**\n * Convert a buffer to their SHA2-256 hash.\n *\n * @param {Buffer} buf\n * @returns {Key}\n */\n\n\nexports.bufferToKey = buf => {\n  return new Key('/' + exports.encodeBase32(buf), false);\n};\n/**\n * Generate the key for a public key.\n *\n * @param {PeerId} peer\n * @returns {Buffer}\n */\n\n\nexports.keyForPublicKey = peer => {\n  return Buffer.concat([Buffer.from('/pk/'), peer.id]);\n};\n\nexports.isPublicKeyKey = key => {\n  return key.slice(0, 4).toString() === '/pk/';\n};\n\nexports.fromPublicKeyKey = key => {\n  return new PeerId(key.slice(4));\n};\n/**\n * Get the current time as timestamp.\n *\n * @returns {number}\n */\n\n\nexports.now = () => {\n  return Date.now();\n};\n/**\n * Encode a given buffer into a base32 string.\n * @param {Buffer} buf\n * @returns {string}\n */\n\n\nexports.encodeBase32 = buf => {\n  const enc = new base32.Encoder();\n  return enc.write(buf).finalize();\n};\n/**\n * Decode a given base32 string into a buffer.\n * @param {string} raw\n * @returns {Buffer}\n */\n\n\nexports.decodeBase32 = raw => {\n  const dec = new base32.Decoder();\n  return Buffer.from(dec.write(raw).finalize());\n};\n/**\n * Sort peers by distance to the given `target`.\n *\n * @param {Array<PeerId>} peers\n * @param {Buffer} target\n * @returns {Array<PeerId>}\n */\n\n\nexports.sortClosestPeers = async (peers, target) => {\n  const distances = await pMap(peers, async peer => {\n    const id = await exports.convertPeerId(peer);\n    return {\n      peer: peer,\n      distance: distance(id, target)\n    };\n  });\n  return distances.sort(exports.xorCompare).map(d => d.peer);\n};\n/**\n * Compare function to sort an array of elements which have a distance property which is the xor distance to a given element.\n *\n * @param {Object} a\n * @param {Object} b\n * @returns {number}\n */\n\n\nexports.xorCompare = (a, b) => {\n  return distance.compare(a.distance, b.distance);\n};\n/**\n * Computes how many results to collect on each disjoint path, rounding up.\n * This ensures that we look for at least one result per path.\n *\n * @param {number} resultsWanted\n * @param {number} numPaths - total number of paths\n * @returns {number}\n */\n\n\nexports.pathSize = (resultsWanted, numPaths) => {\n  return Math.ceil(resultsWanted / numPaths);\n};\n/**\n * Create a new put record, encodes and signs it if enabled.\n *\n * @param {Buffer} key\n * @param {Buffer} value\n * @returns {Buffer}\n */\n\n\nexports.createPutRecord = (key, value) => {\n  const timeReceived = new Date();\n  const rec = new Record(key, value, timeReceived);\n  return rec.serialize();\n};\n/**\n * Creates a logger for the given subsystem\n *\n * @param {PeerId} [id]\n * @param {string} [subsystem]\n * @returns {debug}\n *\n * @private\n */\n\n\nexports.logger = (id, subsystem) => {\n  const name = ['libp2p', 'dht'];\n\n  if (subsystem) {\n    name.push(subsystem);\n  }\n\n  if (id) {\n    name.push(`${id.toB58String().slice(0, 8)}`);\n  } // Add a formatter for converting to a base58 string\n\n\n  debug.formatters.b = v => {\n    return mh.toB58String(v);\n  };\n\n  const logger = debug(name.join(':'));\n  logger.error = debug(name.concat(['error']).join(':'));\n  return logger;\n};\n\nexports.TimeoutError = class TimeoutError extends Error {\n  get code() {\n    return 'ETIMEDOUT';\n  }\n\n};\n/**\n * Creates an async function that calls the given `asyncFn` and Errors\n * if it does not resolve within `time` ms\n *\n * @param {Function} [asyncFn]\n * @param {Number} [time]\n * @returns {Function}\n *\n * @private\n */\n\nexports.withTimeout = (asyncFn, time) => {\n  return async (...args) => {\n    // eslint-disable-line require-await\n    return Promise.race([asyncFn(...args), new Promise((resolve, reject) => {\n      setTimeout(() => {\n        reject(errcode(new Error('Async function did not complete before timeout'), 'ETIMEDOUT'));\n      }, time);\n    })]);\n  };\n};","map":null,"metadata":{},"sourceType":"script"}