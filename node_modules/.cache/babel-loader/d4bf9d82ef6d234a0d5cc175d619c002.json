{"ast":null,"code":"'use strict';\n\nconst connect = require('it-ws/client');\n\nconst mafmt = require('mafmt');\n\nconst withIs = require('class-is');\n\nconst toUri = require('multiaddr-to-uri');\n\nconst {\n  AbortError\n} = require('abortable-iterator');\n\nconst log = require('debug')('libp2p:websockets');\n\nconst createListener = require('./listener');\n\nconst toConnection = require('./socket-to-conn');\n\nconst {\n  CODE_CIRCUIT,\n  CODE_P2P\n} = require('./constants');\n/**\n * @class WebSockets\n */\n\n\nclass WebSockets {\n  /**\n   * @constructor\n   * @param {object} options\n   * @param {Upgrader} options.upgrader\n   */\n  constructor({\n    upgrader\n  }) {\n    if (!upgrader) {\n      throw new Error('An upgrader must be provided. See https://github.com/libp2p/interface-transport#upgrader.');\n    }\n\n    this._upgrader = upgrader;\n  }\n  /**\n   * @async\n   * @param {Multiaddr} ma\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] Used to abort dial requests\n   * @returns {Connection} An upgraded Connection\n   */\n\n\n  async dial(ma, options = {}) {\n    log('dialing %s', ma);\n    const socket = await this._connect(ma, options);\n    const maConn = toConnection(socket, {\n      remoteAddr: ma,\n      signal: options.signal\n    });\n    log('new outbound connection %s', maConn.remoteAddr);\n    const conn = await this._upgrader.upgradeOutbound(maConn);\n    log('outbound connection %s upgraded', maConn.remoteAddr);\n    return conn;\n  }\n  /**\n   * @private\n   * @param {Multiaddr} ma\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] Used to abort dial requests\n   * @returns {Promise<WebSocket>} Resolves a extended duplex iterable on top of a WebSocket\n   */\n\n\n  async _connect(ma, options = {}) {\n    if (options.signal && options.signal.aborted) {\n      throw new AbortError();\n    }\n\n    const cOpts = ma.toOptions();\n    log('dialing %s:%s', cOpts.host, cOpts.port);\n    const rawSocket = connect(toUri(ma), Object.assign({\n      binary: true\n    }, options));\n\n    if (!options.signal) {\n      await rawSocket.connected();\n      log('connected %s', ma);\n      return rawSocket;\n    } // Allow abort via signal during connect\n\n\n    let onAbort;\n    const abort = new Promise((resolve, reject) => {\n      onAbort = () => {\n        reject(new AbortError());\n        rawSocket.close();\n      }; // Already aborted?\n\n\n      if (options.signal.aborted) return onAbort();\n      options.signal.addEventListener('abort', onAbort);\n    });\n\n    try {\n      await Promise.race([abort, rawSocket.connected()]);\n    } finally {\n      options.signal.removeEventListener('abort', onAbort);\n    }\n\n    log('connected %s', ma);\n    return rawSocket;\n  }\n  /**\n   * Creates a Websockets listener. The provided `handler` function will be called\n   * anytime a new incoming Connection has been successfully upgraded via\n   * `upgrader.upgradeInbound`.\n   * @param {object} [options]\n   * @param {http.Server} [options.server] A pre-created Node.js HTTP/S server.\n   * @param {function (Connection)} handler\n   * @returns {Listener} A Websockets listener\n   */\n\n\n  createListener(options = {}, handler) {\n    if (typeof options === 'function') {\n      handler = options;\n      options = {};\n    }\n\n    return createListener({\n      handler,\n      upgrader: this._upgrader\n    }, options);\n  }\n  /**\n   * Takes a list of `Multiaddr`s and returns only valid Websockets addresses\n   * @param {Multiaddr[]} multiaddrs\n   * @returns {Multiaddr[]} Valid Websockets multiaddrs\n   */\n\n\n  filter(multiaddrs) {\n    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];\n    return multiaddrs.filter(ma => {\n      if (ma.protoCodes().includes(CODE_CIRCUIT)) {\n        return false;\n      }\n\n      return mafmt.WebSockets.matches(ma.decapsulateCode(CODE_P2P)) || mafmt.WebSocketsSecure.matches(ma.decapsulateCode(CODE_P2P));\n    });\n  }\n\n}\n\nmodule.exports = withIs(WebSockets, {\n  className: 'WebSockets',\n  symbolName: '@libp2p/js-libp2p-websockets/websockets'\n});","map":null,"metadata":{},"sourceType":"script"}