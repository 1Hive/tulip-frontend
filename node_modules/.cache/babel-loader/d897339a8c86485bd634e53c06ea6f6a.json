{"ast":null,"code":"import t, { useMemo as e, useContext as r, useReducer as n, useRef as o, useCallback as i, useEffect as s, createContext as c, useState as a } from \"react\";\nimport { ProvidedConnector as u, UserRejectedRequestError as l } from \"@aragon/provided-connector\";\nimport h, { EventEmitter as f } from \"events\";\nvar d = \"undefined\" != typeof globalThis ? globalThis : \"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : \"undefined\" != typeof self ? self : {};\n\nfunction p() {\n  throw new Error(\"Dynamic requires are not currently supported by @rollup/plugin-commonjs\");\n}\n\nfunction _(t) {\n  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, \"default\") ? t.default : t;\n}\n\nfunction g(t, e) {\n  return t(e = {\n    exports: {}\n  }, e.exports), e.exports;\n}\n\nfunction m(t) {\n  return t && t.default || t;\n}\n/** @license React v16.13.1\n * react-is.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\nvar v = \"function\" == typeof Symbol && Symbol.for,\n    y = v ? Symbol.for(\"react.element\") : 60103,\n    b = v ? Symbol.for(\"react.portal\") : 60106,\n    w = v ? Symbol.for(\"react.fragment\") : 60107,\n    E = v ? Symbol.for(\"react.strict_mode\") : 60108,\n    C = v ? Symbol.for(\"react.profiler\") : 60114,\n    O = v ? Symbol.for(\"react.provider\") : 60109,\n    P = v ? Symbol.for(\"react.context\") : 60110,\n    N = v ? Symbol.for(\"react.async_mode\") : 60111,\n    I = v ? Symbol.for(\"react.concurrent_mode\") : 60111,\n    D = v ? Symbol.for(\"react.forward_ref\") : 60112,\n    S = v ? Symbol.for(\"react.suspense\") : 60113,\n    R = v ? Symbol.for(\"react.suspense_list\") : 60120,\n    A = v ? Symbol.for(\"react.memo\") : 60115,\n    k = v ? Symbol.for(\"react.lazy\") : 60116,\n    T = v ? Symbol.for(\"react.block\") : 60121,\n    j = v ? Symbol.for(\"react.fundamental\") : 60117,\n    x = v ? Symbol.for(\"react.responder\") : 60118,\n    B = v ? Symbol.for(\"react.scope\") : 60119;\n\nfunction M(t) {\n  if (\"object\" == typeof t && null !== t) {\n    var e = t.$$typeof;\n\n    switch (e) {\n      case y:\n        switch (t = t.type) {\n          case N:\n          case I:\n          case w:\n          case C:\n          case E:\n          case S:\n            return t;\n\n          default:\n            switch (t = t && t.$$typeof) {\n              case P:\n              case D:\n              case k:\n              case A:\n              case O:\n                return t;\n\n              default:\n                return e;\n            }\n\n        }\n\n      case b:\n        return e;\n    }\n  }\n}\n\nfunction U(t) {\n  return M(t) === I;\n}\n\nvar L = {\n  AsyncMode: N,\n  ConcurrentMode: I,\n  ContextConsumer: P,\n  ContextProvider: O,\n  Element: y,\n  ForwardRef: D,\n  Fragment: w,\n  Lazy: k,\n  Memo: A,\n  Portal: b,\n  Profiler: C,\n  StrictMode: E,\n  Suspense: S,\n  isAsyncMode: function (t) {\n    return U(t) || M(t) === N;\n  },\n  isConcurrentMode: U,\n  isContextConsumer: function (t) {\n    return M(t) === P;\n  },\n  isContextProvider: function (t) {\n    return M(t) === O;\n  },\n  isElement: function (t) {\n    return \"object\" == typeof t && null !== t && t.$$typeof === y;\n  },\n  isForwardRef: function (t) {\n    return M(t) === D;\n  },\n  isFragment: function (t) {\n    return M(t) === w;\n  },\n  isLazy: function (t) {\n    return M(t) === k;\n  },\n  isMemo: function (t) {\n    return M(t) === A;\n  },\n  isPortal: function (t) {\n    return M(t) === b;\n  },\n  isProfiler: function (t) {\n    return M(t) === C;\n  },\n  isStrictMode: function (t) {\n    return M(t) === E;\n  },\n  isSuspense: function (t) {\n    return M(t) === S;\n  },\n  isValidElementType: function (t) {\n    return \"string\" == typeof t || \"function\" == typeof t || t === w || t === I || t === C || t === E || t === S || t === R || \"object\" == typeof t && null !== t && (t.$$typeof === k || t.$$typeof === A || t.$$typeof === O || t.$$typeof === P || t.$$typeof === D || t.$$typeof === j || t.$$typeof === x || t.$$typeof === B || t.$$typeof === T);\n  },\n  typeOf: M\n},\n    V = g(function (t, e) {\n  \"production\" !== process.env.NODE_ENV && function () {\n    var t = \"function\" == typeof Symbol && Symbol.for,\n        r = t ? Symbol.for(\"react.element\") : 60103,\n        n = t ? Symbol.for(\"react.portal\") : 60106,\n        o = t ? Symbol.for(\"react.fragment\") : 60107,\n        i = t ? Symbol.for(\"react.strict_mode\") : 60108,\n        s = t ? Symbol.for(\"react.profiler\") : 60114,\n        c = t ? Symbol.for(\"react.provider\") : 60109,\n        a = t ? Symbol.for(\"react.context\") : 60110,\n        u = t ? Symbol.for(\"react.async_mode\") : 60111,\n        l = t ? Symbol.for(\"react.concurrent_mode\") : 60111,\n        h = t ? Symbol.for(\"react.forward_ref\") : 60112,\n        f = t ? Symbol.for(\"react.suspense\") : 60113,\n        d = t ? Symbol.for(\"react.suspense_list\") : 60120,\n        p = t ? Symbol.for(\"react.memo\") : 60115,\n        _ = t ? Symbol.for(\"react.lazy\") : 60116,\n        g = t ? Symbol.for(\"react.block\") : 60121,\n        m = t ? Symbol.for(\"react.fundamental\") : 60117,\n        v = t ? Symbol.for(\"react.responder\") : 60118,\n        y = t ? Symbol.for(\"react.scope\") : 60119;\n\n    function b(t) {\n      if (\"object\" == typeof t && null !== t) {\n        var e = t.$$typeof;\n\n        switch (e) {\n          case r:\n            var d = t.type;\n\n            switch (d) {\n              case u:\n              case l:\n              case o:\n              case s:\n              case i:\n              case f:\n                return d;\n\n              default:\n                var g = d && d.$$typeof;\n\n                switch (g) {\n                  case a:\n                  case h:\n                  case _:\n                  case p:\n                  case c:\n                    return g;\n\n                  default:\n                    return e;\n                }\n\n            }\n\n          case n:\n            return e;\n        }\n      }\n    }\n\n    var w = u,\n        E = l,\n        C = a,\n        O = c,\n        P = r,\n        N = h,\n        I = o,\n        D = _,\n        S = p,\n        R = n,\n        A = s,\n        k = i,\n        T = f,\n        j = !1;\n\n    function x(t) {\n      return b(t) === l;\n    }\n\n    e.AsyncMode = w, e.ConcurrentMode = E, e.ContextConsumer = C, e.ContextProvider = O, e.Element = P, e.ForwardRef = N, e.Fragment = I, e.Lazy = D, e.Memo = S, e.Portal = R, e.Profiler = A, e.StrictMode = k, e.Suspense = T, e.isAsyncMode = function (t) {\n      return j || (j = !0, console.warn(\"The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.\")), x(t) || b(t) === u;\n    }, e.isConcurrentMode = x, e.isContextConsumer = function (t) {\n      return b(t) === a;\n    }, e.isContextProvider = function (t) {\n      return b(t) === c;\n    }, e.isElement = function (t) {\n      return \"object\" == typeof t && null !== t && t.$$typeof === r;\n    }, e.isForwardRef = function (t) {\n      return b(t) === h;\n    }, e.isFragment = function (t) {\n      return b(t) === o;\n    }, e.isLazy = function (t) {\n      return b(t) === _;\n    }, e.isMemo = function (t) {\n      return b(t) === p;\n    }, e.isPortal = function (t) {\n      return b(t) === n;\n    }, e.isProfiler = function (t) {\n      return b(t) === s;\n    }, e.isStrictMode = function (t) {\n      return b(t) === i;\n    }, e.isSuspense = function (t) {\n      return b(t) === f;\n    }, e.isValidElementType = function (t) {\n      return \"string\" == typeof t || \"function\" == typeof t || t === o || t === l || t === s || t === i || t === f || t === d || \"object\" == typeof t && null !== t && (t.$$typeof === _ || t.$$typeof === p || t.$$typeof === c || t.$$typeof === a || t.$$typeof === h || t.$$typeof === m || t.$$typeof === v || t.$$typeof === y || t.$$typeof === g);\n    }, e.typeOf = b;\n  }();\n}),\n    F = (V.AsyncMode, V.ConcurrentMode, V.ContextConsumer, V.ContextProvider, V.Element, V.ForwardRef, V.Fragment, V.Lazy, V.Memo, V.Portal, V.Profiler, V.StrictMode, V.Suspense, V.isAsyncMode, V.isConcurrentMode, V.isContextConsumer, V.isContextProvider, V.isElement, V.isForwardRef, V.isFragment, V.isLazy, V.isMemo, V.isPortal, V.isProfiler, V.isStrictMode, V.isSuspense, V.isValidElementType, V.typeOf, g(function (t) {\n  \"production\" === process.env.NODE_ENV ? t.exports = L : t.exports = V;\n})),\n    q = Object.getOwnPropertySymbols,\n    W = Object.prototype.hasOwnProperty,\n    $ = Object.prototype.propertyIsEnumerable;\n\nfunction z(t) {\n  if (null == t) throw new TypeError(\"Object.assign cannot be called with null or undefined\");\n  return Object(t);\n}\n\nvar G = function () {\n  try {\n    if (!Object.assign) return !1;\n    var t = new String(\"abc\");\n    if (t[5] = \"de\", \"5\" === Object.getOwnPropertyNames(t)[0]) return !1;\n\n    for (var e = {}, r = 0; r < 10; r++) e[\"_\" + String.fromCharCode(r)] = r;\n\n    if (\"0123456789\" !== Object.getOwnPropertyNames(e).map(function (t) {\n      return e[t];\n    }).join(\"\")) return !1;\n    var n = {};\n    return \"abcdefghijklmnopqrst\".split(\"\").forEach(function (t) {\n      n[t] = t;\n    }), \"abcdefghijklmnopqrst\" === Object.keys(Object.assign({}, n)).join(\"\");\n  } catch (t) {\n    return !1;\n  }\n}() ? Object.assign : function (t, e) {\n  for (var r, n, o = z(t), i = 1; i < arguments.length; i++) {\n    for (var s in r = Object(arguments[i])) W.call(r, s) && (o[s] = r[s]);\n\n    if (q) {\n      n = q(r);\n\n      for (var c = 0; c < n.length; c++) $.call(r, n[c]) && (o[n[c]] = r[n[c]]);\n    }\n  }\n\n  return o;\n},\n    H = \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\",\n    J = function () {};\n\nif (\"production\" !== process.env.NODE_ENV) {\n  var K = H,\n      X = {},\n      Y = Function.call.bind(Object.prototype.hasOwnProperty);\n\n  J = function (t) {\n    var e = \"Warning: \" + t;\n    \"undefined\" != typeof console && console.error(e);\n\n    try {\n      throw new Error(e);\n    } catch (t) {}\n  };\n}\n\nfunction Q(t, e, r, n, o) {\n  if (\"production\" !== process.env.NODE_ENV) for (var i in t) if (Y(t, i)) {\n    var s;\n\n    try {\n      if (\"function\" != typeof t[i]) {\n        var c = Error((n || \"React class\") + \": \" + r + \" type `\" + i + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof t[i] + \"`.\");\n        throw c.name = \"Invariant Violation\", c;\n      }\n\n      s = t[i](e, i, n, r, null, K);\n    } catch (t) {\n      s = t;\n    }\n\n    if (!s || s instanceof Error || J((n || \"React class\") + \": type specification of \" + r + \" `\" + i + \"` is invalid; the type checker function must return `null` or an `Error` but returned a \" + typeof s + \". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\"), s instanceof Error && !(s.message in X)) {\n      X[s.message] = !0;\n      var a = o ? o() : \"\";\n      J(\"Failed \" + r + \" type: \" + s.message + (null != a ? a : \"\"));\n    }\n  }\n}\n\nQ.resetWarningCache = function () {\n  \"production\" !== process.env.NODE_ENV && (X = {});\n};\n\nvar Z = Q,\n    tt = Function.call.bind(Object.prototype.hasOwnProperty),\n    et = function () {};\n\nfunction rt() {\n  return null;\n}\n\n\"production\" !== process.env.NODE_ENV && (et = function (t) {\n  var e = \"Warning: \" + t;\n  \"undefined\" != typeof console && console.error(e);\n\n  try {\n    throw new Error(e);\n  } catch (t) {}\n});\n\nvar nt = function (t, e) {\n  var r = \"function\" == typeof Symbol && Symbol.iterator;\n  var n = {\n    array: c(\"array\"),\n    bool: c(\"boolean\"),\n    func: c(\"function\"),\n    number: c(\"number\"),\n    object: c(\"object\"),\n    string: c(\"string\"),\n    symbol: c(\"symbol\"),\n    any: s(rt),\n    arrayOf: function (t) {\n      return s(function (e, r, n, o, s) {\n        if (\"function\" != typeof t) return new i(\"Property `\" + s + \"` of component `\" + n + \"` has invalid PropType notation inside arrayOf.\");\n        var c = e[r];\n        if (!Array.isArray(c)) return new i(\"Invalid \" + o + \" `\" + s + \"` of type `\" + u(c) + \"` supplied to `\" + n + \"`, expected an array.\");\n\n        for (var a = 0; a < c.length; a++) {\n          var l = t(c, a, n, o, s + \"[\" + a + \"]\", H);\n          if (l instanceof Error) return l;\n        }\n\n        return null;\n      });\n    },\n    element: s(function (e, r, n, o, s) {\n      var c = e[r];\n      return t(c) ? null : new i(\"Invalid \" + o + \" `\" + s + \"` of type `\" + u(c) + \"` supplied to `\" + n + \"`, expected a single ReactElement.\");\n    }),\n    elementType: s(function (t, e, r, n, o) {\n      var s = t[e];\n      return F.isValidElementType(s) ? null : new i(\"Invalid \" + n + \" `\" + o + \"` of type `\" + u(s) + \"` supplied to `\" + r + \"`, expected a single ReactElement type.\");\n    }),\n    instanceOf: function (t) {\n      return s(function (e, r, n, o, s) {\n        if (!(e[r] instanceof t)) {\n          var c = t.name || \"<<anonymous>>\";\n          return new i(\"Invalid \" + o + \" `\" + s + \"` of type `\" + function (t) {\n            if (!t.constructor || !t.constructor.name) return \"<<anonymous>>\";\n            return t.constructor.name;\n          }(e[r]) + \"` supplied to `\" + n + \"`, expected instance of `\" + c + \"`.\");\n        }\n\n        return null;\n      });\n    },\n    node: s(function (t, e, r, n, o) {\n      return a(t[e]) ? null : new i(\"Invalid \" + n + \" `\" + o + \"` supplied to `\" + r + \"`, expected a ReactNode.\");\n    }),\n    objectOf: function (t) {\n      return s(function (e, r, n, o, s) {\n        if (\"function\" != typeof t) return new i(\"Property `\" + s + \"` of component `\" + n + \"` has invalid PropType notation inside objectOf.\");\n        var c = e[r],\n            a = u(c);\n        if (\"object\" !== a) return new i(\"Invalid \" + o + \" `\" + s + \"` of type `\" + a + \"` supplied to `\" + n + \"`, expected an object.\");\n\n        for (var l in c) if (tt(c, l)) {\n          var h = t(c, l, n, o, s + \".\" + l, H);\n          if (h instanceof Error) return h;\n        }\n\n        return null;\n      });\n    },\n    oneOf: function (t) {\n      if (!Array.isArray(t)) return \"production\" !== process.env.NODE_ENV && (arguments.length > 1 ? et(\"Invalid arguments supplied to oneOf, expected an array, got \" + arguments.length + \" arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).\") : et(\"Invalid argument supplied to oneOf, expected an array.\")), rt;\n\n      function e(e, r, n, s, c) {\n        for (var a = e[r], u = 0; u < t.length; u++) if (o(a, t[u])) return null;\n\n        var h = JSON.stringify(t, function (t, e) {\n          return \"symbol\" === l(e) ? String(e) : e;\n        });\n        return new i(\"Invalid \" + s + \" `\" + c + \"` of value `\" + String(a) + \"` supplied to `\" + n + \"`, expected one of \" + h + \".\");\n      }\n\n      return s(e);\n    },\n    oneOfType: function (t) {\n      if (!Array.isArray(t)) return \"production\" !== process.env.NODE_ENV && et(\"Invalid argument supplied to oneOfType, expected an instance of array.\"), rt;\n\n      for (var e = 0; e < t.length; e++) {\n        var r = t[e];\n        if (\"function\" != typeof r) return et(\"Invalid argument supplied to oneOfType. Expected an array of check functions, but received \" + h(r) + \" at index \" + e + \".\"), rt;\n      }\n\n      return s(function (e, r, n, o, s) {\n        for (var c = 0; c < t.length; c++) {\n          if (null == (0, t[c])(e, r, n, o, s, H)) return null;\n        }\n\n        return new i(\"Invalid \" + o + \" `\" + s + \"` supplied to `\" + n + \"`.\");\n      });\n    },\n    shape: function (t) {\n      return s(function (e, r, n, o, s) {\n        var c = e[r],\n            a = u(c);\n        if (\"object\" !== a) return new i(\"Invalid \" + o + \" `\" + s + \"` of type `\" + a + \"` supplied to `\" + n + \"`, expected `object`.\");\n\n        for (var l in t) {\n          var h = t[l];\n\n          if (h) {\n            var f = h(c, l, n, o, s + \".\" + l, H);\n            if (f) return f;\n          }\n        }\n\n        return null;\n      });\n    },\n    exact: function (t) {\n      return s(function (e, r, n, o, s) {\n        var c = e[r],\n            a = u(c);\n        if (\"object\" !== a) return new i(\"Invalid \" + o + \" `\" + s + \"` of type `\" + a + \"` supplied to `\" + n + \"`, expected `object`.\");\n        var l = G({}, e[r], t);\n\n        for (var h in l) {\n          var f = t[h];\n          if (!f) return new i(\"Invalid \" + o + \" `\" + s + \"` key `\" + h + \"` supplied to `\" + n + \"`.\\nBad object: \" + JSON.stringify(e[r], null, \"  \") + \"\\nValid keys: \" + JSON.stringify(Object.keys(t), null, \"  \"));\n          var d = f(c, h, n, o, s + \".\" + h, H);\n          if (d) return d;\n        }\n\n        return null;\n      });\n    }\n  };\n\n  function o(t, e) {\n    return t === e ? 0 !== t || 1 / t == 1 / e : t != t && e != e;\n  }\n\n  function i(t) {\n    this.message = t, this.stack = \"\";\n  }\n\n  function s(t) {\n    if (\"production\" !== process.env.NODE_ENV) var r = {},\n        n = 0;\n\n    function o(o, s, c, a, u, l, h) {\n      if (a = a || \"<<anonymous>>\", l = l || c, h !== H) {\n        if (e) {\n          var f = new Error(\"Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types\");\n          throw f.name = \"Invariant Violation\", f;\n        }\n\n        if (\"production\" !== process.env.NODE_ENV && \"undefined\" != typeof console) {\n          var d = a + \":\" + c;\n          !r[d] && n < 3 && (et(\"You are manually calling a React.PropTypes validation function for the `\" + l + \"` prop on `\" + a + \"`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details.\"), r[d] = !0, n++);\n        }\n      }\n\n      return null == s[c] ? o ? null === s[c] ? new i(\"The \" + u + \" `\" + l + \"` is marked as required in `\" + a + \"`, but its value is `null`.\") : new i(\"The \" + u + \" `\" + l + \"` is marked as required in `\" + a + \"`, but its value is `undefined`.\") : null : t(s, c, a, u, l);\n    }\n\n    var s = o.bind(null, !1);\n    return s.isRequired = o.bind(null, !0), s;\n  }\n\n  function c(t) {\n    return s(function (e, r, n, o, s, c) {\n      var a = e[r];\n      return u(a) !== t ? new i(\"Invalid \" + o + \" `\" + s + \"` of type `\" + l(a) + \"` supplied to `\" + n + \"`, expected `\" + t + \"`.\") : null;\n    });\n  }\n\n  function a(e) {\n    switch (typeof e) {\n      case \"number\":\n      case \"string\":\n      case \"undefined\":\n        return !0;\n\n      case \"boolean\":\n        return !e;\n\n      case \"object\":\n        if (Array.isArray(e)) return e.every(a);\n        if (null === e || t(e)) return !0;\n\n        var n = function (t) {\n          var e = t && (r && t[r] || t[\"@@iterator\"]);\n          if (\"function\" == typeof e) return e;\n        }(e);\n\n        if (!n) return !1;\n        var o,\n            i = n.call(e);\n\n        if (n !== e.entries) {\n          for (; !(o = i.next()).done;) if (!a(o.value)) return !1;\n        } else for (; !(o = i.next()).done;) {\n          var s = o.value;\n          if (s && !a(s[1])) return !1;\n        }\n\n        return !0;\n\n      default:\n        return !1;\n    }\n  }\n\n  function u(t) {\n    var e = typeof t;\n    return Array.isArray(t) ? \"array\" : t instanceof RegExp ? \"object\" : function (t, e) {\n      return \"symbol\" === t || !!e && (\"Symbol\" === e[\"@@toStringTag\"] || \"function\" == typeof Symbol && e instanceof Symbol);\n    }(e, t) ? \"symbol\" : e;\n  }\n\n  function l(t) {\n    if (null == t) return \"\" + t;\n    var e = u(t);\n\n    if (\"object\" === e) {\n      if (t instanceof Date) return \"date\";\n      if (t instanceof RegExp) return \"regexp\";\n    }\n\n    return e;\n  }\n\n  function h(t) {\n    var e = l(t);\n\n    switch (e) {\n      case \"array\":\n      case \"object\":\n        return \"an \" + e;\n\n      case \"boolean\":\n      case \"date\":\n      case \"regexp\":\n        return \"a \" + e;\n\n      default:\n        return e;\n    }\n  }\n\n  return i.prototype = Error.prototype, n.checkPropTypes = Z, n.resetWarningCache = Z.resetWarningCache, n.PropTypes = n, n;\n};\n\nfunction ot() {}\n\nfunction it() {}\n\nit.resetWarningCache = ot;\nvar st,\n    ct = g(function (t) {\n  if (\"production\" !== process.env.NODE_ENV) {\n    var e = F;\n    t.exports = nt(e.isElement, !0);\n  } else t.exports = function () {\n    function t(t, e, r, n, o, i) {\n      if (i !== H) {\n        var s = new Error(\"Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types\");\n        throw s.name = \"Invariant Violation\", s;\n      }\n    }\n\n    function e() {\n      return t;\n    }\n\n    t.isRequired = t;\n    var r = {\n      array: t,\n      bool: t,\n      func: t,\n      number: t,\n      object: t,\n      string: t,\n      symbol: t,\n      any: t,\n      arrayOf: e,\n      element: t,\n      elementType: t,\n      instanceOf: e,\n      node: t,\n      objectOf: e,\n      oneOf: e,\n      oneOfType: e,\n      shape: e,\n      exact: e,\n      checkPropTypes: it,\n      resetWarningCache: ot\n    };\n    return r.PropTypes = r, r;\n  }();\n}),\n    at = \"production\" === process.env.NODE_ENV;\n\nfunction ut(t, e) {\n  if (!t) {\n    if (at) throw new Error(\"Invariant failed\");\n    throw new Error(\"Invariant failed: \" + (e || \"\"));\n  }\n}\n\n!function (t) {\n  t.Update = \"Web3ReactUpdate\", t.Error = \"Web3ReactError\", t.Deactivate = \"Web3ReactDeactivate\";\n}(st || (st = {}));\nvar lt = \"production\" === process.env.NODE_ENV;\n\nfunction ht(t, e) {\n  if (!lt) {\n    if (t) return;\n    var r = \"Warning: \" + e;\n    \"undefined\" != typeof console && console.warn(r);\n\n    try {\n      throw Error(r);\n    } catch (t) {}\n  }\n}\n\nlet ft = !1,\n    dt = !1;\nconst pt = {\n  debug: 1,\n  default: 2,\n  info: 2,\n  warning: 3,\n  error: 4,\n  off: 5\n};\nlet _t = pt.default,\n    gt = null;\n\nconst mt = function () {\n  try {\n    const t = [];\n    if ([\"NFD\", \"NFC\", \"NFKD\", \"NFKC\"].forEach(e => {\n      try {\n        if (\"test\" !== \"test\".normalize(e)) throw new Error(\"bad normalize\");\n      } catch (r) {\n        t.push(e);\n      }\n    }), t.length) throw new Error(\"missing \" + t.join(\", \"));\n    if (String.fromCharCode(233).normalize(\"NFD\") !== String.fromCharCode(101, 769)) throw new Error(\"broken implementation\");\n  } catch (t) {\n    return t.message;\n  }\n\n  return null;\n}();\n\nclass vt {\n  constructor(t) {\n    Object.defineProperty(this, \"version\", {\n      enumerable: !0,\n      value: t,\n      writable: !1\n    });\n  }\n\n  _log(t, e) {\n    const r = t.toLowerCase();\n    null == pt[r] && this.throwArgumentError(\"invalid log level name\", \"logLevel\", t), _t > pt[r] || console.log.apply(console, e);\n  }\n\n  debug(...t) {\n    this._log(vt.levels.DEBUG, t);\n  }\n\n  info(...t) {\n    this._log(vt.levels.INFO, t);\n  }\n\n  warn(...t) {\n    this._log(vt.levels.WARNING, t);\n  }\n\n  makeError(t, e, r) {\n    if (dt) return this.makeError(\"censored error\", e, {});\n    e || (e = vt.errors.UNKNOWN_ERROR), r || (r = {});\n    const n = [];\n    Object.keys(r).forEach(t => {\n      try {\n        n.push(t + \"=\" + JSON.stringify(r[t]));\n      } catch (e) {\n        n.push(t + \"=\" + JSON.stringify(r[t].toString()));\n      }\n    }), n.push(`code=${e}`), n.push(`version=${this.version}`);\n    const o = t;\n    n.length && (t += \" (\" + n.join(\", \") + \")\");\n    const i = new Error(t);\n    return i.reason = o, i.code = e, Object.keys(r).forEach(function (t) {\n      i[t] = r[t];\n    }), i;\n  }\n\n  throwError(t, e, r) {\n    throw this.makeError(t, e, r);\n  }\n\n  throwArgumentError(t, e, r) {\n    return this.throwError(t, vt.errors.INVALID_ARGUMENT, {\n      argument: e,\n      value: r\n    });\n  }\n\n  checkNormalize(t) {\n    mt && this.throwError(\"platform missing String.prototype.normalize\", vt.errors.UNSUPPORTED_OPERATION, {\n      operation: \"String.prototype.normalize\",\n      form: mt\n    });\n  }\n\n  checkSafeUint53(t, e) {\n    \"number\" == typeof t && (null == e && (e = \"value not safe\"), (t < 0 || t >= 9007199254740991) && this.throwError(e, vt.errors.NUMERIC_FAULT, {\n      operation: \"checkSafeInteger\",\n      fault: \"out-of-safe-range\",\n      value: t\n    }), t % 1 && this.throwError(e, vt.errors.NUMERIC_FAULT, {\n      operation: \"checkSafeInteger\",\n      fault: \"non-integer\",\n      value: t\n    }));\n  }\n\n  checkArgumentCount(t, e, r) {\n    r = r ? \": \" + r : \"\", t < e && this.throwError(\"missing argument\" + r, vt.errors.MISSING_ARGUMENT, {\n      count: t,\n      expectedCount: e\n    }), t > e && this.throwError(\"too many arguments\" + r, vt.errors.UNEXPECTED_ARGUMENT, {\n      count: t,\n      expectedCount: e\n    });\n  }\n\n  checkNew(t, e) {\n    t !== Object && null != t || this.throwError(\"missing new\", vt.errors.MISSING_NEW, {\n      name: e.name\n    });\n  }\n\n  checkAbstract(t, e) {\n    t === e ? this.throwError(\"cannot instantiate abstract class \" + JSON.stringify(e.name) + \" directly; use a sub-class\", vt.errors.UNSUPPORTED_OPERATION, {\n      name: t.name,\n      operation: \"new\"\n    }) : t !== Object && null != t || this.throwError(\"missing new\", vt.errors.MISSING_NEW, {\n      name: e.name\n    });\n  }\n\n  static globalLogger() {\n    return gt || (gt = new vt(\"logger/5.0.0-beta.136\")), gt;\n  }\n\n  static setCensorship(t, e) {\n    if (!t && e && this.globalLogger().throwError(\"cannot permanently disable censorship\", vt.errors.UNSUPPORTED_OPERATION, {\n      operation: \"setCensorship\"\n    }), ft) {\n      if (!t) return;\n      this.globalLogger().throwError(\"error censorship permanent\", vt.errors.UNSUPPORTED_OPERATION, {\n        operation: \"setCensorship\"\n      });\n    }\n\n    dt = !!t, ft = !!e;\n  }\n\n  static setLogLevel(t) {\n    const e = pt[t];\n    null != e ? _t = e : vt.globalLogger().warn(\"invalid log level - \" + t);\n  }\n\n}\n\nvt.errors = {\n  UNKNOWN_ERROR: \"UNKNOWN_ERROR\",\n  NOT_IMPLEMENTED: \"NOT_IMPLEMENTED\",\n  UNSUPPORTED_OPERATION: \"UNSUPPORTED_OPERATION\",\n  NETWORK_ERROR: \"NETWORK_ERROR\",\n  SERVER_ERROR: \"SERVER_ERROR\",\n  TIMEOUT: \"TIMEOUT\",\n  BUFFER_OVERRUN: \"BUFFER_OVERRUN\",\n  NUMERIC_FAULT: \"NUMERIC_FAULT\",\n  MISSING_NEW: \"MISSING_NEW\",\n  INVALID_ARGUMENT: \"INVALID_ARGUMENT\",\n  MISSING_ARGUMENT: \"MISSING_ARGUMENT\",\n  UNEXPECTED_ARGUMENT: \"UNEXPECTED_ARGUMENT\",\n  CALL_EXCEPTION: \"CALL_EXCEPTION\",\n  INSUFFICIENT_FUNDS: \"INSUFFICIENT_FUNDS\",\n  NONCE_EXPIRED: \"NONCE_EXPIRED\",\n  REPLACEMENT_UNDERPRICED: \"REPLACEMENT_UNDERPRICED\",\n  UNPREDICTABLE_GAS_LIMIT: \"UNPREDICTABLE_GAS_LIMIT\"\n}, vt.levels = {\n  DEBUG: \"DEBUG\",\n  INFO: \"INFO\",\n  WARNING: \"WARNING\",\n  ERROR: \"ERROR\",\n  OFF: \"OFF\"\n};\nconst yt = new vt(\"bytes/5.0.0-beta.137\");\n\nfunction bt(t) {\n  return t.slice || (t.slice = function () {\n    const e = Array.prototype.slice.call(arguments);\n    return bt(new Uint8Array(Array.prototype.slice.apply(t, e)));\n  }), t;\n}\n\nfunction wt(t, e) {\n  if (e || (e = {}), \"number\" == typeof t) {\n    yt.checkSafeUint53(t, \"invalid arrayify value\");\n    const e = [];\n\n    for (; t;) e.unshift(255 & t), t = parseInt(String(t / 256));\n\n    return 0 === e.length && e.push(0), bt(new Uint8Array(e));\n  }\n\n  if (e.allowMissingPrefix && \"string\" == typeof t && \"0x\" !== t.substring(0, 2) && (t = \"0x\" + t), function (t) {\n    return !!t.toHexString;\n  }(t) && (t = t.toHexString()), function (t, e) {\n    if (\"string\" != typeof t || !t.match(/^0x[0-9A-Fa-f]*$/)) return !1;\n    if (e && t.length !== 2 + 2 * e) return !1;\n    return !0;\n  }(t)) {\n    let r = t.substring(2);\n    r.length % 2 && (\"left\" === e.hexPad ? r = \"0x0\" + r.substring(2) : \"right\" === e.hexPad ? r += \"0\" : yt.throwArgumentError(\"hex data is odd-length\", \"value\", t));\n    const n = [];\n\n    for (let t = 0; t < r.length; t += 2) n.push(parseInt(r.substring(t, t + 2), 16));\n\n    return bt(new Uint8Array(n));\n  }\n\n  return function (t) {\n    if (null == t) return !1;\n    if (t.constructor === Uint8Array) return !0;\n    if (\"string\" == typeof t) return !1;\n    if (null == t.length) return !1;\n\n    for (let e = 0; e < t.length; e++) {\n      const r = t[e];\n      if (r < 0 || r >= 256 || r % 1) return !1;\n    }\n\n    return !0;\n  }(t) ? bt(new Uint8Array(t)) : yt.throwArgumentError(\"invalid arrayify value\", \"value\", t);\n}\n\nvar Et = g(function (t) {\n  /**\n   * [js-sha3]{@link https://github.com/emn178/js-sha3}\n   *\n   * @version 0.5.7\n   * @author Chen, Yi-Cyuan [emn178@gmail.com]\n   * @copyright Chen, Yi-Cyuan 2015-2016\n   * @license MIT\n   */\n  !function () {\n    var e = \"object\" == typeof window ? window : {};\n    !e.JS_SHA3_NO_NODE_JS && \"object\" == typeof process && process.versions && process.versions.node && (e = d);\n\n    for (var r = !e.JS_SHA3_NO_COMMON_JS && t.exports, n = \"0123456789abcdef\".split(\"\"), o = [0, 8, 16, 24], i = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648], s = [224, 256, 384, 512], c = [\"hex\", \"buffer\", \"arrayBuffer\", \"array\"], a = function (t, e, r) {\n      return function (n) {\n        return new b(t, e, t).update(n)[r]();\n      };\n    }, u = function (t, e, r) {\n      return function (n, o) {\n        return new b(t, e, o).update(n)[r]();\n      };\n    }, l = function (t, e) {\n      var r = a(t, e, \"hex\");\n      r.create = function () {\n        return new b(t, e, t);\n      }, r.update = function (t) {\n        return r.create().update(t);\n      };\n\n      for (var n = 0; n < c.length; ++n) {\n        var o = c[n];\n        r[o] = a(t, e, o);\n      }\n\n      return r;\n    }, h = [{\n      name: \"keccak\",\n      padding: [1, 256, 65536, 16777216],\n      bits: s,\n      createMethod: l\n    }, {\n      name: \"sha3\",\n      padding: [6, 1536, 393216, 100663296],\n      bits: s,\n      createMethod: l\n    }, {\n      name: \"shake\",\n      padding: [31, 7936, 2031616, 520093696],\n      bits: [128, 256],\n      createMethod: function (t, e) {\n        var r = u(t, e, \"hex\");\n        r.create = function (r) {\n          return new b(t, e, r);\n        }, r.update = function (t, e) {\n          return r.create(e).update(t);\n        };\n\n        for (var n = 0; n < c.length; ++n) {\n          var o = c[n];\n          r[o] = u(t, e, o);\n        }\n\n        return r;\n      }\n    }], f = {}, p = [], _ = 0; _ < h.length; ++_) for (var g = h[_], m = g.bits, v = 0; v < m.length; ++v) {\n      var y = g.name + \"_\" + m[v];\n      p.push(y), f[y] = g.createMethod(m[v], g.padding);\n    }\n\n    function b(t, e, r) {\n      this.blocks = [], this.s = [], this.padding = e, this.outputBits = r, this.reset = !0, this.block = 0, this.start = 0, this.blockCount = 1600 - (t << 1) >> 5, this.byteCount = this.blockCount << 2, this.outputBlocks = r >> 5, this.extraBytes = (31 & r) >> 3;\n\n      for (var n = 0; n < 50; ++n) this.s[n] = 0;\n    }\n\n    b.prototype.update = function (t) {\n      var e = \"string\" != typeof t;\n      e && t.constructor === ArrayBuffer && (t = new Uint8Array(t));\n\n      for (var r, n, i = t.length, s = this.blocks, c = this.byteCount, a = this.blockCount, u = 0, l = this.s; u < i;) {\n        if (this.reset) for (this.reset = !1, s[0] = this.block, r = 1; r < a + 1; ++r) s[r] = 0;\n        if (e) for (r = this.start; u < i && r < c; ++u) s[r >> 2] |= t[u] << o[3 & r++];else for (r = this.start; u < i && r < c; ++u) (n = t.charCodeAt(u)) < 128 ? s[r >> 2] |= n << o[3 & r++] : n < 2048 ? (s[r >> 2] |= (192 | n >> 6) << o[3 & r++], s[r >> 2] |= (128 | 63 & n) << o[3 & r++]) : n < 55296 || n >= 57344 ? (s[r >> 2] |= (224 | n >> 12) << o[3 & r++], s[r >> 2] |= (128 | n >> 6 & 63) << o[3 & r++], s[r >> 2] |= (128 | 63 & n) << o[3 & r++]) : (n = 65536 + ((1023 & n) << 10 | 1023 & t.charCodeAt(++u)), s[r >> 2] |= (240 | n >> 18) << o[3 & r++], s[r >> 2] |= (128 | n >> 12 & 63) << o[3 & r++], s[r >> 2] |= (128 | n >> 6 & 63) << o[3 & r++], s[r >> 2] |= (128 | 63 & n) << o[3 & r++]);\n\n        if (this.lastByteIndex = r, r >= c) {\n          for (this.start = r - c, this.block = s[a], r = 0; r < a; ++r) l[r] ^= s[r];\n\n          w(l), this.reset = !0;\n        } else this.start = r;\n      }\n\n      return this;\n    }, b.prototype.finalize = function () {\n      var t = this.blocks,\n          e = this.lastByteIndex,\n          r = this.blockCount,\n          n = this.s;\n      if (t[e >> 2] |= this.padding[3 & e], this.lastByteIndex === this.byteCount) for (t[0] = t[r], e = 1; e < r + 1; ++e) t[e] = 0;\n\n      for (t[r - 1] |= 2147483648, e = 0; e < r; ++e) n[e] ^= t[e];\n\n      w(n);\n    }, b.prototype.toString = b.prototype.hex = function () {\n      this.finalize();\n\n      for (var t, e = this.blockCount, r = this.s, o = this.outputBlocks, i = this.extraBytes, s = 0, c = 0, a = \"\"; c < o;) {\n        for (s = 0; s < e && c < o; ++s, ++c) t = r[s], a += n[t >> 4 & 15] + n[15 & t] + n[t >> 12 & 15] + n[t >> 8 & 15] + n[t >> 20 & 15] + n[t >> 16 & 15] + n[t >> 28 & 15] + n[t >> 24 & 15];\n\n        c % e == 0 && (w(r), s = 0);\n      }\n\n      return i && (t = r[s], i > 0 && (a += n[t >> 4 & 15] + n[15 & t]), i > 1 && (a += n[t >> 12 & 15] + n[t >> 8 & 15]), i > 2 && (a += n[t >> 20 & 15] + n[t >> 16 & 15])), a;\n    }, b.prototype.arrayBuffer = function () {\n      this.finalize();\n      var t,\n          e = this.blockCount,\n          r = this.s,\n          n = this.outputBlocks,\n          o = this.extraBytes,\n          i = 0,\n          s = 0,\n          c = this.outputBits >> 3;\n      t = o ? new ArrayBuffer(n + 1 << 2) : new ArrayBuffer(c);\n\n      for (var a = new Uint32Array(t); s < n;) {\n        for (i = 0; i < e && s < n; ++i, ++s) a[s] = r[i];\n\n        s % e == 0 && w(r);\n      }\n\n      return o && (a[i] = r[i], t = t.slice(0, c)), t;\n    }, b.prototype.buffer = b.prototype.arrayBuffer, b.prototype.digest = b.prototype.array = function () {\n      this.finalize();\n\n      for (var t, e, r = this.blockCount, n = this.s, o = this.outputBlocks, i = this.extraBytes, s = 0, c = 0, a = []; c < o;) {\n        for (s = 0; s < r && c < o; ++s, ++c) t = c << 2, e = n[s], a[t] = 255 & e, a[t + 1] = e >> 8 & 255, a[t + 2] = e >> 16 & 255, a[t + 3] = e >> 24 & 255;\n\n        c % r == 0 && w(n);\n      }\n\n      return i && (t = c << 2, e = n[s], i > 0 && (a[t] = 255 & e), i > 1 && (a[t + 1] = e >> 8 & 255), i > 2 && (a[t + 2] = e >> 16 & 255)), a;\n    };\n\n    var w = function (t) {\n      var e, r, n, o, s, c, a, u, l, h, f, d, p, _, g, m, v, y, b, w, E, C, O, P, N, I, D, S, R, A, k, T, j, x, B, M, U, L, V, F, q, W, $, z, G, H, J, K, X, Y, Q, Z, tt, et, rt, nt, ot, it, st, ct, at, ut, lt;\n\n      for (n = 0; n < 48; n += 2) o = t[0] ^ t[10] ^ t[20] ^ t[30] ^ t[40], s = t[1] ^ t[11] ^ t[21] ^ t[31] ^ t[41], c = t[2] ^ t[12] ^ t[22] ^ t[32] ^ t[42], a = t[3] ^ t[13] ^ t[23] ^ t[33] ^ t[43], u = t[4] ^ t[14] ^ t[24] ^ t[34] ^ t[44], l = t[5] ^ t[15] ^ t[25] ^ t[35] ^ t[45], h = t[6] ^ t[16] ^ t[26] ^ t[36] ^ t[46], f = t[7] ^ t[17] ^ t[27] ^ t[37] ^ t[47], e = (d = t[8] ^ t[18] ^ t[28] ^ t[38] ^ t[48]) ^ (c << 1 | a >>> 31), r = (p = t[9] ^ t[19] ^ t[29] ^ t[39] ^ t[49]) ^ (a << 1 | c >>> 31), t[0] ^= e, t[1] ^= r, t[10] ^= e, t[11] ^= r, t[20] ^= e, t[21] ^= r, t[30] ^= e, t[31] ^= r, t[40] ^= e, t[41] ^= r, e = o ^ (u << 1 | l >>> 31), r = s ^ (l << 1 | u >>> 31), t[2] ^= e, t[3] ^= r, t[12] ^= e, t[13] ^= r, t[22] ^= e, t[23] ^= r, t[32] ^= e, t[33] ^= r, t[42] ^= e, t[43] ^= r, e = c ^ (h << 1 | f >>> 31), r = a ^ (f << 1 | h >>> 31), t[4] ^= e, t[5] ^= r, t[14] ^= e, t[15] ^= r, t[24] ^= e, t[25] ^= r, t[34] ^= e, t[35] ^= r, t[44] ^= e, t[45] ^= r, e = u ^ (d << 1 | p >>> 31), r = l ^ (p << 1 | d >>> 31), t[6] ^= e, t[7] ^= r, t[16] ^= e, t[17] ^= r, t[26] ^= e, t[27] ^= r, t[36] ^= e, t[37] ^= r, t[46] ^= e, t[47] ^= r, e = h ^ (o << 1 | s >>> 31), r = f ^ (s << 1 | o >>> 31), t[8] ^= e, t[9] ^= r, t[18] ^= e, t[19] ^= r, t[28] ^= e, t[29] ^= r, t[38] ^= e, t[39] ^= r, t[48] ^= e, t[49] ^= r, _ = t[0], g = t[1], H = t[11] << 4 | t[10] >>> 28, J = t[10] << 4 | t[11] >>> 28, S = t[20] << 3 | t[21] >>> 29, R = t[21] << 3 | t[20] >>> 29, ct = t[31] << 9 | t[30] >>> 23, at = t[30] << 9 | t[31] >>> 23, W = t[40] << 18 | t[41] >>> 14, $ = t[41] << 18 | t[40] >>> 14, x = t[2] << 1 | t[3] >>> 31, B = t[3] << 1 | t[2] >>> 31, m = t[13] << 12 | t[12] >>> 20, v = t[12] << 12 | t[13] >>> 20, K = t[22] << 10 | t[23] >>> 22, X = t[23] << 10 | t[22] >>> 22, A = t[33] << 13 | t[32] >>> 19, k = t[32] << 13 | t[33] >>> 19, ut = t[42] << 2 | t[43] >>> 30, lt = t[43] << 2 | t[42] >>> 30, et = t[5] << 30 | t[4] >>> 2, rt = t[4] << 30 | t[5] >>> 2, M = t[14] << 6 | t[15] >>> 26, U = t[15] << 6 | t[14] >>> 26, y = t[25] << 11 | t[24] >>> 21, b = t[24] << 11 | t[25] >>> 21, Y = t[34] << 15 | t[35] >>> 17, Q = t[35] << 15 | t[34] >>> 17, T = t[45] << 29 | t[44] >>> 3, j = t[44] << 29 | t[45] >>> 3, P = t[6] << 28 | t[7] >>> 4, N = t[7] << 28 | t[6] >>> 4, nt = t[17] << 23 | t[16] >>> 9, ot = t[16] << 23 | t[17] >>> 9, L = t[26] << 25 | t[27] >>> 7, V = t[27] << 25 | t[26] >>> 7, w = t[36] << 21 | t[37] >>> 11, E = t[37] << 21 | t[36] >>> 11, Z = t[47] << 24 | t[46] >>> 8, tt = t[46] << 24 | t[47] >>> 8, z = t[8] << 27 | t[9] >>> 5, G = t[9] << 27 | t[8] >>> 5, I = t[18] << 20 | t[19] >>> 12, D = t[19] << 20 | t[18] >>> 12, it = t[29] << 7 | t[28] >>> 25, st = t[28] << 7 | t[29] >>> 25, F = t[38] << 8 | t[39] >>> 24, q = t[39] << 8 | t[38] >>> 24, C = t[48] << 14 | t[49] >>> 18, O = t[49] << 14 | t[48] >>> 18, t[0] = _ ^ ~m & y, t[1] = g ^ ~v & b, t[10] = P ^ ~I & S, t[11] = N ^ ~D & R, t[20] = x ^ ~M & L, t[21] = B ^ ~U & V, t[30] = z ^ ~H & K, t[31] = G ^ ~J & X, t[40] = et ^ ~nt & it, t[41] = rt ^ ~ot & st, t[2] = m ^ ~y & w, t[3] = v ^ ~b & E, t[12] = I ^ ~S & A, t[13] = D ^ ~R & k, t[22] = M ^ ~L & F, t[23] = U ^ ~V & q, t[32] = H ^ ~K & Y, t[33] = J ^ ~X & Q, t[42] = nt ^ ~it & ct, t[43] = ot ^ ~st & at, t[4] = y ^ ~w & C, t[5] = b ^ ~E & O, t[14] = S ^ ~A & T, t[15] = R ^ ~k & j, t[24] = L ^ ~F & W, t[25] = V ^ ~q & $, t[34] = K ^ ~Y & Z, t[35] = X ^ ~Q & tt, t[44] = it ^ ~ct & ut, t[45] = st ^ ~at & lt, t[6] = w ^ ~C & _, t[7] = E ^ ~O & g, t[16] = A ^ ~T & P, t[17] = k ^ ~j & N, t[26] = F ^ ~W & x, t[27] = q ^ ~$ & B, t[36] = Y ^ ~Z & z, t[37] = Q ^ ~tt & G, t[46] = ct ^ ~ut & et, t[47] = at ^ ~lt & rt, t[8] = C ^ ~_ & m, t[9] = O ^ ~g & v, t[18] = T ^ ~P & I, t[19] = j ^ ~N & D, t[28] = W ^ ~x & M, t[29] = $ ^ ~B & U, t[38] = Z ^ ~z & H, t[39] = tt ^ ~G & J, t[48] = ut ^ ~et & nt, t[49] = lt ^ ~rt & ot, t[0] ^= i[n], t[1] ^= i[n + 1];\n    };\n\n    if (r) t.exports = f;else for (_ = 0; _ < p.length; ++_) e[p[_]] = f[p[_]];\n  }();\n});\n\nfunction Ct() {\n  return (Ct = Object.assign || function (t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var r = arguments[e];\n\n      for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n]);\n    }\n\n    return t;\n  }).apply(this, arguments);\n}\n\nfunction Ot(t, e) {\n  t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;\n}\n\nfunction Pt(t) {\n  return (Pt = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {\n    return t.__proto__ || Object.getPrototypeOf(t);\n  })(t);\n}\n\nfunction Nt(t, e) {\n  return (Nt = Object.setPrototypeOf || function (t, e) {\n    return t.__proto__ = e, t;\n  })(t, e);\n}\n\nfunction It() {\n  if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n  if (Reflect.construct.sham) return !1;\n  if (\"function\" == typeof Proxy) return !0;\n\n  try {\n    return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0;\n  } catch (t) {\n    return !1;\n  }\n}\n\nfunction Dt(t, e, r) {\n  return (Dt = It() ? Reflect.construct : function (t, e, r) {\n    var n = [null];\n    n.push.apply(n, e);\n    var o = new (Function.bind.apply(t, n))();\n    return r && Nt(o, r.prototype), o;\n  }).apply(null, arguments);\n}\n\nfunction St(t) {\n  var e = \"function\" == typeof Map ? new Map() : void 0;\n  return (St = function (t) {\n    if (null === t || (r = t, -1 === Function.toString.call(r).indexOf(\"[native code]\"))) return t;\n    var r;\n    if (\"function\" != typeof t) throw new TypeError(\"Super expression must either be null or a function\");\n\n    if (void 0 !== e) {\n      if (e.has(t)) return e.get(t);\n      e.set(t, n);\n    }\n\n    function n() {\n      return Dt(t, arguments, Pt(this).constructor);\n    }\n\n    return n.prototype = Object.create(t.prototype, {\n      constructor: {\n        value: n,\n        enumerable: !1,\n        writable: !0,\n        configurable: !0\n      }\n    }), Nt(n, t);\n  })(t);\n}\n\n\"undefined\" != typeof Symbol && (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))), \"undefined\" != typeof Symbol && (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\")));\n\nfunction Rt(t, e) {\n  try {\n    var r = t();\n  } catch (t) {\n    return e(t);\n  }\n\n  return r && r.then ? r.then(void 0, e) : r;\n}\n\nfunction At(t) {\n  if (\"string\" == typeof t) {\n    t = t.replace(/^Ox/, \"0x\");\n    var e = Number.parseInt(t, \"0x\" === t.trim().substring(0, 2) ? 16 : 10);\n    return Number.isNaN(e) && (\"production\" !== process.env.NODE_ENV ? ut(!1, \"chainId \" + t + \" is not an integer\") : ut(!1)), e;\n  }\n\n  return Number.isInteger(t) || (\"production\" !== process.env.NODE_ENV ? ut(!1, \"chainId \" + t + \" is not an integer\") : ut(!1)), t;\n}\n\nfunction kt(t) {\n  \"string\" == typeof t && t.match(/^(0x)?[0-9a-fA-F]{40}$/) || (\"production\" !== process.env.NODE_ENV ? ut(!1, \"Invalid address \" + t) : ut(!1));\n\n  for (var e = \"0x\" === t.substring(0, 2) ? t : \"0x\" + t, r = e.toLowerCase().substring(2).split(\"\"), n = new Uint8Array(40), o = 0; o < 40; o++) n[o] = r[o].charCodeAt(0);\n\n  for (var i, s = wt((i = n, \"0x\" + Et.keccak_256(wt(i)))), c = 0; c < 40; c += 2) s[c >> 1] >> 4 >= 8 && (r[c] = r[c].toUpperCase()), (15 & s[c >> 1]) >= 8 && (r[c + 1] = r[c + 1].toUpperCase());\n\n  var a = \"0x\" + r.join(\"\");\n  return e.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && e !== a && (\"production\" !== process.env.NODE_ENV ? ut(!1, \"Bad address checksum \" + e + \" \" + a) : ut(!1)), a;\n}\n\nvar Tt,\n    jt = function (t, e) {\n  try {\n    var r = function (r) {\n      return Promise.resolve(Promise.all([void 0 === e.chainId ? t.getChainId() : e.chainId, void 0 === e.account ? t.getAccount() : e.account])).then(function (e) {\n        var n = e[0],\n            o = e[1],\n            i = At(n);\n        if (t.supportedChainIds && !t.supportedChainIds.includes(i)) throw new Bt(i, t.supportedChainIds);\n        var s = null === o ? o : kt(o);\n        return {\n          provider: r,\n          chainId: i,\n          account: s\n        };\n      });\n    },\n        n = void 0 === e.provider;\n\n    return Promise.resolve(n ? Promise.resolve(t.getProvider()).then(r) : r(e.provider));\n  } catch (t) {\n    return Promise.reject(t);\n  }\n},\n    xt = function (t) {\n  function e() {\n    var e;\n    return (e = t.call(this) || this).name = e.constructor.name, e;\n  }\n\n  return Ot(e, t), e;\n}(St(Error)),\n    Bt = function (t) {\n  function e(e, r) {\n    var n;\n    return (n = t.call(this) || this).name = n.constructor.name, n.message = \"Unsupported chain id: \" + e + \". Supported chain ids are: \" + r + \".\", n;\n  }\n\n  return Ot(e, t), e;\n}(St(Error));\n\nfunction Mt(t, e) {\n  var r = e.type,\n      n = e.payload;\n\n  switch (r) {\n    case Tt.ACTIVATE_CONNECTOR:\n      return {\n        connector: n.connector,\n        provider: n.provider,\n        chainId: n.chainId,\n        account: n.account,\n        onError: n.onError\n      };\n\n    case Tt.UPDATE:\n      var o = n.provider,\n          i = n.chainId,\n          s = n.account;\n      return Ct({}, t, void 0 === o ? {} : {\n        provider: o\n      }, void 0 === i ? {} : {\n        chainId: i\n      }, void 0 === s ? {} : {\n        account: s\n      });\n\n    case Tt.UPDATE_FROM_ERROR:\n      var c = n.provider,\n          a = n.chainId,\n          u = n.account;\n      return Ct({}, t, void 0 === c ? {} : {\n        provider: c\n      }, void 0 === a ? {} : {\n        chainId: a\n      }, void 0 === u ? {} : {\n        account: u\n      }, {\n        error: void 0\n      });\n\n    case Tt.ERROR:\n      var l = n.error;\n      return {\n        connector: t.connector,\n        error: l,\n        onError: t.onError\n      };\n\n    case Tt.ERROR_FROM_ACTIVATION:\n      return {\n        connector: n.connector,\n        error: n.error\n      };\n\n    case Tt.DEACTIVATE_CONNECTOR:\n      return {};\n  }\n}\n\n!function (t) {\n  t[t.ACTIVATE_CONNECTOR = 0] = \"ACTIVATE_CONNECTOR\", t[t.UPDATE = 1] = \"UPDATE\", t[t.UPDATE_FROM_ERROR = 2] = \"UPDATE_FROM_ERROR\", t[t.ERROR = 3] = \"ERROR\", t[t.ERROR_FROM_ACTIVATION = 4] = \"ERROR_FROM_ACTIVATION\", t[t.DEACTIVATE_CONNECTOR = 5] = \"DEACTIVATE_CONNECTOR\";\n}(Tt || (Tt = {}));\nvar Ut = {};\n\nfunction Lt(r) {\n  Ut[r] && (\"production\" !== process.env.NODE_ENV ? ut(!1, \"A root already exists for provided key \" + r) : ut(!1)), Ut[r] = c({\n    activate: function () {\n      try {\n        return \"production\" !== process.env.NODE_ENV ? ut(!1, \"No <Web3ReactProvider ... /> found.\") : ut(!1), Promise.resolve();\n      } catch (t) {\n        return Promise.reject(t);\n      }\n    },\n    setError: function () {\n      \"production\" !== process.env.NODE_ENV ? ut(!1, \"No <Web3ReactProvider ... /> found.\") : ut(!1);\n    },\n    deactivate: function () {\n      \"production\" !== process.env.NODE_ENV ? ut(!1, \"No <Web3ReactProvider ... /> found.\") : ut(!1);\n    },\n    active: !1\n  }), Ut[r].displayName = \"Web3ReactContext - \" + r;\n  var a = Ut[r].Provider;\n  return function (r) {\n    var c = r.getLibrary,\n        u = r.children,\n        l = function () {\n      var t = n(Mt, {}),\n          e = t[0],\n          r = t[1],\n          c = e.connector,\n          a = e.provider,\n          u = e.chainId,\n          l = e.account,\n          h = e.onError,\n          f = e.error,\n          d = o(-1);\n      d.current += 1;\n\n      var p = i(function (t, e, n) {\n        void 0 === n && (n = !1);\n\n        try {\n          var o = d.current,\n              i = !1;\n          return Promise.resolve(Rt(function () {\n            return Promise.resolve(t.activate().then(function (t) {\n              return i = !0, t;\n            })).then(function (n) {\n              return Promise.resolve(jt(t, n)).then(function (n) {\n                if (d.current > o) throw new xt();\n                r({\n                  type: Tt.ACTIVATE_CONNECTOR,\n                  payload: Ct({\n                    connector: t\n                  }, n, {\n                    onError: e\n                  })\n                });\n              });\n            });\n          }, function (o) {\n            if (o instanceof xt) i && t.deactivate(), \"production\" !== process.env.NODE_ENV && ht(!1, \"Suppressed stale connector activation \" + t);else {\n              if (n) throw i && t.deactivate(), o;\n              e ? (i && t.deactivate(), e(o)) : r({\n                type: Tt.ERROR_FROM_ACTIVATION,\n                payload: {\n                  connector: t,\n                  error: o\n                }\n              });\n            }\n          }));\n        } catch (t) {\n          return Promise.reject(t);\n        }\n      }, []),\n          _ = i(function (t) {\n        r({\n          type: Tt.ERROR,\n          payload: {\n            error: t\n          }\n        });\n      }, []),\n          g = i(function () {\n        r({\n          type: Tt.DEACTIVATE_CONNECTOR\n        });\n      }, []),\n          m = i(function (t) {\n        try {\n          if (!c) throw Error(\"This should never happen, it's just so Typescript stops complaining\");\n          var e = d.current;\n          return Promise.resolve(function () {\n            if (f) return Rt(function () {\n              return Promise.resolve(jt(c, t)).then(function (t) {\n                if (d.current > e) throw new xt();\n                r({\n                  type: Tt.UPDATE_FROM_ERROR,\n                  payload: t\n                });\n              });\n            }, function (e) {\n              e instanceof xt ? \"production\" !== process.env.NODE_ENV && ht(!1, \"Suppressed stale connector update from error state \" + c + \" \" + t) : h ? h(e) : r({\n                type: Tt.ERROR,\n                payload: {\n                  error: e\n                }\n              });\n            });\n            var n = void 0 === t.chainId ? void 0 : At(t.chainId);\n\n            if (void 0 !== n && c.supportedChainIds && !c.supportedChainIds.includes(n)) {\n              var o = new Bt(n, c.supportedChainIds);\n              h ? h(o) : r({\n                type: Tt.ERROR,\n                payload: {\n                  error: o\n                }\n              });\n            } else {\n              var i = \"string\" == typeof t.account ? kt(t.account) : t.account;\n              r({\n                type: Tt.UPDATE,\n                payload: {\n                  provider: t.provider,\n                  chainId: n,\n                  account: i\n                }\n              });\n            }\n          }());\n        } catch (t) {\n          return Promise.reject(t);\n        }\n      }, [c, f, h]),\n          v = i(function (t) {\n        h ? h(t) : r({\n          type: Tt.ERROR,\n          payload: {\n            error: t\n          }\n        });\n      }, [h]),\n          y = i(function () {\n        r({\n          type: Tt.DEACTIVATE_CONNECTOR\n        });\n      }, []);\n\n      return s(function () {\n        return function () {\n          c && c.deactivate();\n        };\n      }, [c]), s(function () {\n        return c && c.on(st.Update, m).on(st.Error, v).on(st.Deactivate, y), function () {\n          c && c.off(st.Update, m).off(st.Error, v).off(st.Deactivate, y);\n        };\n      }, [c, m, v, y]), {\n        connector: c,\n        provider: a,\n        chainId: u,\n        account: l,\n        activate: p,\n        setError: _,\n        deactivate: g,\n        error: f\n      };\n    }(),\n        h = l.connector,\n        f = l.provider,\n        d = l.chainId,\n        p = l.account,\n        _ = l.activate,\n        g = l.setError,\n        m = l.deactivate,\n        v = l.error,\n        y = void 0 !== h && void 0 !== d && void 0 !== p && !v,\n        b = e(function () {\n      return y && void 0 !== d && Number.isInteger(d) && h ? c(f, h) : void 0;\n    }, [y, c, f, h, d]),\n        w = {\n      connector: h,\n      library: b,\n      chainId: d,\n      account: p,\n      activate: _,\n      setError: g,\n      deactivate: m,\n      active: y,\n      error: v\n    };\n\n    return t.createElement(a, {\n      value: w\n    }, u);\n  };\n}\n\nvar Vt = Lt(\"primary\");\n\nfunction Ft(t) {\n  return r(function (t) {\n    return void 0 === t && (t = \"primary\"), Object.keys(Ut).includes(t) || (\"production\" !== process.env.NODE_ENV ? ut(!1, \"Invalid key \" + t) : ut(!1)), Ut[t];\n  }(t));\n}\n\nclass qt extends Array {\n  constructor(t, e) {\n    if (t > qt.__kMaxLength) throw new RangeError(\"Maximum BigInt size exceeded\");\n    super(t), this.sign = e;\n  }\n\n  static BigInt(t) {\n    var e = Math.floor,\n        r = Number.isFinite;\n\n    if (\"number\" == typeof t) {\n      if (0 === t) return qt.__zero();\n      if ((0 | t) === t) return 0 > t ? qt.__oneDigit(-t, !0) : qt.__oneDigit(t, !1);\n      if (!r(t) || e(t) !== t) throw new RangeError(\"The number \" + t + \" cannot be converted to BigInt because it is not an integer\");\n      return qt.__fromDouble(t);\n    }\n\n    if (\"string\" == typeof t) {\n      const e = qt.__fromString(t);\n\n      if (null === e) throw new SyntaxError(\"Cannot convert \" + t + \" to a BigInt\");\n      return e;\n    }\n\n    if (\"boolean\" == typeof t) return !0 === t ? qt.__oneDigit(1, !1) : qt.__zero();\n\n    if (\"object\" == typeof t) {\n      if (t.constructor === qt) return t;\n\n      const e = qt.__toPrimitive(t);\n\n      return qt.BigInt(e);\n    }\n\n    throw new TypeError(\"Cannot convert \" + t + \" to a BigInt\");\n  }\n\n  toDebugString() {\n    const t = [\"BigInt[\"];\n\n    for (const e of this) t.push((e ? (e >>> 0).toString(16) : e) + \", \");\n\n    return t.push(\"]\"), t.join(\"\");\n  }\n\n  toString(t = 10) {\n    if (2 > t || 36 < t) throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n    return 0 === this.length ? \"0\" : 0 == (t & t - 1) ? qt.__toStringBasePowerOfTwo(this, t) : qt.__toStringGeneric(this, t, !1);\n  }\n\n  static toNumber(t) {\n    var e = Math.clz32;\n    const r = t.length;\n    if (0 === r) return 0;\n\n    if (1 === r) {\n      const e = t.__unsignedDigit(0);\n\n      return t.sign ? -e : e;\n    }\n\n    const n = t.__digit(r - 1),\n          o = e(n),\n          i = 32 * r - o;\n\n    if (1024 < i) return t.sign ? -1 / 0 : 1 / 0;\n    let s = i - 1,\n        c = n,\n        a = r - 1;\n    const u = o + 1;\n    let l = 32 === u ? 0 : c << u;\n    l >>>= 12;\n    const h = u - 12;\n    let f = 12 <= u ? 0 : c << 20 + u,\n        d = 20 + u;\n    0 < h && 0 < a && (a--, c = t.__digit(a), l |= c >>> 32 - h, f = c << h, d = h), 0 < d && 0 < a && (a--, c = t.__digit(a), f |= c >>> 32 - d, d -= 32);\n\n    const p = qt.__decideRounding(t, d, a, c);\n\n    if ((1 === p || 0 === p && 1 == (1 & f)) && (f = f + 1 >>> 0, 0 == f && (l++, 0 != l >>> 20 && (l = 0, s++, 1023 < s)))) return t.sign ? -1 / 0 : 1 / 0;\n\n    const _ = t.sign ? -2147483648 : 0;\n\n    return s = s + 1023 << 20, qt.__kBitConversionInts[1] = _ | s | l, qt.__kBitConversionInts[0] = f, qt.__kBitConversionDouble[0];\n  }\n\n  static unaryMinus(t) {\n    if (0 === t.length) return t;\n\n    const e = t.__copy();\n\n    return e.sign = !t.sign, e;\n  }\n\n  static bitwiseNot(t) {\n    return t.sign ? qt.__absoluteSubOne(t).__trim() : qt.__absoluteAddOne(t, !0);\n  }\n\n  static exponentiate(t, e) {\n    if (e.sign) throw new RangeError(\"Exponent must be positive\");\n    if (0 === e.length) return qt.__oneDigit(1, !1);\n    if (0 === t.length) return t;\n    if (1 === t.length && 1 === t.__digit(0)) return t.sign && 0 == (1 & e.__digit(0)) ? qt.unaryMinus(t) : t;\n    if (1 < e.length) throw new RangeError(\"BigInt too big\");\n\n    let r = e.__unsignedDigit(0);\n\n    if (1 === r) return t;\n    if (r >= qt.__kMaxLengthBits) throw new RangeError(\"BigInt too big\");\n\n    if (1 === t.length && 2 === t.__digit(0)) {\n      const e = 1 + (r >>> 5),\n            n = t.sign && 0 != (1 & r),\n            o = new qt(e, n);\n\n      o.__initializeDigits();\n\n      const i = 1 << (31 & r);\n      return o.__setDigit(e - 1, i), o;\n    }\n\n    let n = null,\n        o = t;\n\n    for (0 != (1 & r) && (n = t), r >>= 1; 0 !== r; r >>= 1) o = qt.multiply(o, o), 0 != (1 & r) && (n = null === n ? o : qt.multiply(n, o));\n\n    return n;\n  }\n\n  static multiply(t, e) {\n    if (0 === t.length) return t;\n    if (0 === e.length) return e;\n    let r = t.length + e.length;\n    32 <= t.__clzmsd() + e.__clzmsd() && r--;\n    const n = new qt(r, t.sign !== e.sign);\n\n    n.__initializeDigits();\n\n    for (let r = 0; r < t.length; r++) qt.__multiplyAccumulate(e, t.__digit(r), n, r);\n\n    return n.__trim();\n  }\n\n  static divide(t, e) {\n    if (0 === e.length) throw new RangeError(\"Division by zero\");\n    if (0 > qt.__absoluteCompare(t, e)) return qt.__zero();\n\n    const r = t.sign !== e.sign,\n          n = e.__unsignedDigit(0);\n\n    let o;\n\n    if (1 === e.length && 65535 >= n) {\n      if (1 === n) return r === t.sign ? t : qt.unaryMinus(t);\n      o = qt.__absoluteDivSmall(t, n, null);\n    } else o = qt.__absoluteDivLarge(t, e, !0, !1);\n\n    return o.sign = r, o.__trim();\n  }\n\n  static remainder(t, e) {\n    if (0 === e.length) throw new RangeError(\"Division by zero\");\n    if (0 > qt.__absoluteCompare(t, e)) return t;\n\n    const r = e.__unsignedDigit(0);\n\n    if (1 === e.length && 65535 >= r) {\n      if (1 === r) return qt.__zero();\n\n      const e = qt.__absoluteModSmall(t, r);\n\n      return 0 === e ? qt.__zero() : qt.__oneDigit(e, t.sign);\n    }\n\n    const n = qt.__absoluteDivLarge(t, e, !1, !0);\n\n    return n.sign = t.sign, n.__trim();\n  }\n\n  static add(t, e) {\n    const r = t.sign;\n    return r === e.sign ? qt.__absoluteAdd(t, e, r) : 0 <= qt.__absoluteCompare(t, e) ? qt.__absoluteSub(t, e, r) : qt.__absoluteSub(e, t, !r);\n  }\n\n  static subtract(t, e) {\n    const r = t.sign;\n    return r === e.sign ? 0 <= qt.__absoluteCompare(t, e) ? qt.__absoluteSub(t, e, r) : qt.__absoluteSub(e, t, !r) : qt.__absoluteAdd(t, e, r);\n  }\n\n  static leftShift(t, e) {\n    return 0 === e.length || 0 === t.length ? t : e.sign ? qt.__rightShiftByAbsolute(t, e) : qt.__leftShiftByAbsolute(t, e);\n  }\n\n  static signedRightShift(t, e) {\n    return 0 === e.length || 0 === t.length ? t : e.sign ? qt.__leftShiftByAbsolute(t, e) : qt.__rightShiftByAbsolute(t, e);\n  }\n\n  static unsignedRightShift() {\n    throw new TypeError(\"BigInts have no unsigned right shift; use >> instead\");\n  }\n\n  static lessThan(t, e) {\n    return 0 > qt.__compareToBigInt(t, e);\n  }\n\n  static lessThanOrEqual(t, e) {\n    return 0 >= qt.__compareToBigInt(t, e);\n  }\n\n  static greaterThan(t, e) {\n    return 0 < qt.__compareToBigInt(t, e);\n  }\n\n  static greaterThanOrEqual(t, e) {\n    return 0 <= qt.__compareToBigInt(t, e);\n  }\n\n  static equal(t, e) {\n    if (t.sign !== e.sign) return !1;\n    if (t.length !== e.length) return !1;\n\n    for (let r = 0; r < t.length; r++) if (t.__digit(r) !== e.__digit(r)) return !1;\n\n    return !0;\n  }\n\n  static notEqual(t, e) {\n    return !qt.equal(t, e);\n  }\n\n  static bitwiseAnd(t, e) {\n    var r = Math.max;\n    if (!t.sign && !e.sign) return qt.__absoluteAnd(t, e).__trim();\n\n    if (t.sign && e.sign) {\n      const n = r(t.length, e.length) + 1;\n\n      let o = qt.__absoluteSubOne(t, n);\n\n      const i = qt.__absoluteSubOne(e);\n\n      return o = qt.__absoluteOr(o, i, o), qt.__absoluteAddOne(o, !0, o).__trim();\n    }\n\n    return t.sign && ([t, e] = [e, t]), qt.__absoluteAndNot(t, qt.__absoluteSubOne(e)).__trim();\n  }\n\n  static bitwiseXor(t, e) {\n    var r = Math.max;\n    if (!t.sign && !e.sign) return qt.__absoluteXor(t, e).__trim();\n\n    if (t.sign && e.sign) {\n      const n = r(t.length, e.length),\n            o = qt.__absoluteSubOne(t, n),\n            i = qt.__absoluteSubOne(e);\n\n      return qt.__absoluteXor(o, i, o).__trim();\n    }\n\n    const n = r(t.length, e.length) + 1;\n    t.sign && ([t, e] = [e, t]);\n\n    let o = qt.__absoluteSubOne(e, n);\n\n    return o = qt.__absoluteXor(o, t, o), qt.__absoluteAddOne(o, !0, o).__trim();\n  }\n\n  static bitwiseOr(t, e) {\n    const r = (0, Math.max)(t.length, e.length);\n    if (!t.sign && !e.sign) return qt.__absoluteOr(t, e).__trim();\n\n    if (t.sign && e.sign) {\n      let n = qt.__absoluteSubOne(t, r);\n\n      const o = qt.__absoluteSubOne(e);\n\n      return n = qt.__absoluteAnd(n, o, n), qt.__absoluteAddOne(n, !0, n).__trim();\n    }\n\n    t.sign && ([t, e] = [e, t]);\n\n    let n = qt.__absoluteSubOne(e, r);\n\n    return n = qt.__absoluteAndNot(n, t, n), qt.__absoluteAddOne(n, !0, n).__trim();\n  }\n\n  static asIntN(t, e) {\n    if (0 === e.length) return e;\n    if (0 === t) return qt.__zero();\n    if (t >= qt.__kMaxLengthBits) return e;\n    const r = t + 31 >>> 5;\n    if (e.length < r) return e;\n\n    const n = e.__unsignedDigit(r - 1),\n          o = 1 << (31 & t - 1);\n\n    if (e.length === r && n < o) return e;\n    if ((n & o) !== o) return qt.__truncateToNBits(t, e);\n    if (!e.sign) return qt.__truncateAndSubFromPowerOfTwo(t, e, !0);\n\n    if (0 == (n & o - 1)) {\n      for (let n = r - 2; 0 <= n; n--) if (0 !== e.__digit(n)) return qt.__truncateAndSubFromPowerOfTwo(t, e, !1);\n\n      return e.length === r && n === o ? e : qt.__truncateToNBits(t, e);\n    }\n\n    return qt.__truncateAndSubFromPowerOfTwo(t, e, !1);\n  }\n\n  static asUintN(t, e) {\n    if (0 === e.length) return e;\n    if (0 === t) return qt.__zero();\n\n    if (e.sign) {\n      if (t > qt.__kMaxLengthBits) throw new RangeError(\"BigInt too big\");\n      return qt.__truncateAndSubFromPowerOfTwo(t, e, !1);\n    }\n\n    if (t >= qt.__kMaxLengthBits) return e;\n    const r = t + 31 >>> 5;\n    if (e.length < r) return e;\n    const n = 31 & t;\n\n    if (e.length == r) {\n      if (0 == n) return e;\n      if (0 == e.__digit(r - 1) >>> n) return e;\n    }\n\n    return qt.__truncateToNBits(t, e);\n  }\n\n  static ADD(t, e) {\n    if (t = qt.__toPrimitive(t), e = qt.__toPrimitive(e), \"string\" == typeof t) return \"string\" != typeof e && (e = e.toString()), t + e;\n    if (\"string\" == typeof e) return t.toString() + e;\n    if (t = qt.__toNumeric(t), e = qt.__toNumeric(e), qt.__isBigInt(t) && qt.__isBigInt(e)) return qt.add(t, e);\n    if (\"number\" == typeof t && \"number\" == typeof e) return t + e;\n    throw new TypeError(\"Cannot mix BigInt and other types, use explicit conversions\");\n  }\n\n  static LT(t, e) {\n    return qt.__compare(t, e, 0);\n  }\n\n  static LE(t, e) {\n    return qt.__compare(t, e, 1);\n  }\n\n  static GT(t, e) {\n    return qt.__compare(t, e, 2);\n  }\n\n  static GE(t, e) {\n    return qt.__compare(t, e, 3);\n  }\n\n  static EQ(t, e) {\n    for (;;) {\n      if (qt.__isBigInt(t)) return qt.__isBigInt(e) ? qt.equal(t, e) : qt.EQ(e, t);\n\n      if (\"number\" == typeof t) {\n        if (qt.__isBigInt(e)) return qt.__equalToNumber(e, t);\n        if (\"object\" != typeof e) return t == e;\n        e = qt.__toPrimitive(e);\n      } else if (\"string\" == typeof t) {\n        if (qt.__isBigInt(e)) return null !== (t = qt.__fromString(t)) && qt.equal(t, e);\n        if (\"object\" != typeof e) return t == e;\n        e = qt.__toPrimitive(e);\n      } else if (\"boolean\" == typeof t) {\n        if (qt.__isBigInt(e)) return qt.__equalToNumber(e, +t);\n        if (\"object\" != typeof e) return t == e;\n        e = qt.__toPrimitive(e);\n      } else if (\"symbol\" == typeof t) {\n        if (qt.__isBigInt(e)) return !1;\n        if (\"object\" != typeof e) return t == e;\n        e = qt.__toPrimitive(e);\n      } else {\n        if (\"object\" != typeof t) return t == e;\n        if (\"object\" == typeof e && e.constructor !== qt) return t == e;\n        t = qt.__toPrimitive(t);\n      }\n    }\n  }\n\n  static NE(t, e) {\n    return !qt.EQ(t, e);\n  }\n\n  static __zero() {\n    return new qt(0, !1);\n  }\n\n  static __oneDigit(t, e) {\n    const r = new qt(1, e);\n    return r.__setDigit(0, t), r;\n  }\n\n  __copy() {\n    const t = new qt(this.length, this.sign);\n\n    for (let e = 0; e < this.length; e++) t[e] = this[e];\n\n    return t;\n  }\n\n  __trim() {\n    let t = this.length,\n        e = this[t - 1];\n\n    for (; 0 === e;) t--, e = this[t - 1], this.pop();\n\n    return 0 === t && (this.sign = !1), this;\n  }\n\n  __initializeDigits() {\n    for (let t = 0; t < this.length; t++) this[t] = 0;\n  }\n\n  static __decideRounding(t, e, r, n) {\n    if (0 < e) return -1;\n    let o;\n    if (0 > e) o = -e - 1;else {\n      if (0 === r) return -1;\n      r--, n = t.__digit(r), o = 31;\n    }\n    let i = 1 << o;\n    if (0 == (n & i)) return -1;\n    if (i -= 1, 0 != (n & i)) return 1;\n\n    for (; 0 < r;) if (r--, 0 !== t.__digit(r)) return 1;\n\n    return 0;\n  }\n\n  static __fromDouble(t) {\n    qt.__kBitConversionDouble[0] = t;\n    const e = (2047 & qt.__kBitConversionInts[1] >>> 20) - 1023,\n          r = 1 + (e >>> 5),\n          n = new qt(r, 0 > t);\n    let o = 1048575 & qt.__kBitConversionInts[1] | 1048576,\n        i = qt.__kBitConversionInts[0];\n    const s = 31 & e;\n    let c,\n        a = 0;\n\n    if (s < 20) {\n      const t = 20 - s;\n      a = t + 32, c = o >>> t, o = o << 32 - t | i >>> t, i <<= 32 - t;\n    } else if (20 === s) a = 32, c = o, o = i;else {\n      const t = s - 20;\n      a = 32 - t, c = o << t | i >>> 32 - t, o = i << t;\n    }\n\n    n.__setDigit(r - 1, c);\n\n    for (let t = r - 2; 0 <= t; t--) 0 < a ? (a -= 32, c = o, o = i) : c = 0, n.__setDigit(t, c);\n\n    return n.__trim();\n  }\n\n  static __isWhitespace(t) {\n    return !!(13 >= t && 9 <= t) || (159 >= t ? 32 == t : 131071 >= t ? 160 == t || 5760 == t : 196607 >= t ? 10 >= (t &= 131071) || 40 == t || 41 == t || 47 == t || 95 == t || 4096 == t : 65279 == t);\n  }\n\n  static __fromString(t, e = 0) {\n    let r = 0;\n    const n = t.length;\n    let o = 0;\n    if (o === n) return qt.__zero();\n    let i = t.charCodeAt(o);\n\n    for (; qt.__isWhitespace(i);) {\n      if (++o === n) return qt.__zero();\n      i = t.charCodeAt(o);\n    }\n\n    if (43 === i) {\n      if (++o === n) return null;\n      i = t.charCodeAt(o), r = 1;\n    } else if (45 === i) {\n      if (++o === n) return null;\n      i = t.charCodeAt(o), r = -1;\n    }\n\n    if (0 === e) {\n      if (e = 10, 48 === i) {\n        if (++o === n) return qt.__zero();\n\n        if (i = t.charCodeAt(o), 88 === i || 120 === i) {\n          if (e = 16, ++o === n) return null;\n          i = t.charCodeAt(o);\n        } else if (79 === i || 111 === i) {\n          if (e = 8, ++o === n) return null;\n          i = t.charCodeAt(o);\n        } else if (66 === i || 98 === i) {\n          if (e = 2, ++o === n) return null;\n          i = t.charCodeAt(o);\n        }\n      }\n    } else if (16 === e && 48 === i) {\n      if (++o === n) return qt.__zero();\n\n      if (i = t.charCodeAt(o), 88 === i || 120 === i) {\n        if (++o === n) return null;\n        i = t.charCodeAt(o);\n      }\n    }\n\n    for (; 48 === i;) {\n      if (++o === n) return qt.__zero();\n      i = t.charCodeAt(o);\n    }\n\n    const s = n - o;\n    let c = qt.__kMaxBitsPerChar[e],\n        a = qt.__kBitsPerCharTableMultiplier - 1;\n    if (s > 1073741824 / c) return null;\n    const u = c * s + a >>> qt.__kBitsPerCharTableShift,\n          l = new qt(u + 31 >>> 5, !1),\n          h = 10 > e ? e : 10,\n          f = 10 < e ? e - 10 : 0;\n\n    if (0 == (e & e - 1)) {\n      c >>= qt.__kBitsPerCharTableShift;\n      const e = [],\n            r = [];\n      let s = !1;\n\n      do {\n        let a = 0,\n            u = 0;\n\n        for (;;) {\n          let e;\n          if (i - 48 >>> 0 < h) e = i - 48;else {\n            if (!((32 | i) - 97 >>> 0 < f)) {\n              s = !0;\n              break;\n            }\n\n            e = (32 | i) - 87;\n          }\n\n          if (u += c, a = a << c | e, ++o === n) {\n            s = !0;\n            break;\n          }\n\n          if (i = t.charCodeAt(o), 32 < u + c) break;\n        }\n\n        e.push(a), r.push(u);\n      } while (!s);\n\n      qt.__fillFromParts(l, e, r);\n    } else {\n      l.__initializeDigits();\n\n      let r = !1,\n          s = 0;\n\n      do {\n        let u = 0,\n            d = 1;\n\n        for (;;) {\n          let c;\n          if (i - 48 >>> 0 < h) c = i - 48;else {\n            if (!((32 | i) - 97 >>> 0 < f)) {\n              r = !0;\n              break;\n            }\n\n            c = (32 | i) - 87;\n          }\n          const a = d * e;\n          if (4294967295 < a) break;\n\n          if (d = a, u = u * e + c, s++, ++o === n) {\n            r = !0;\n            break;\n          }\n\n          i = t.charCodeAt(o);\n        }\n\n        a = 32 * qt.__kBitsPerCharTableMultiplier - 1;\n        const p = c * s + a >>> qt.__kBitsPerCharTableShift + 5;\n\n        l.__inplaceMultiplyAdd(d, u, p);\n      } while (!r);\n    }\n\n    if (o !== n) {\n      if (!qt.__isWhitespace(i)) return null;\n\n      for (o++; o < n; o++) if (i = t.charCodeAt(o), !qt.__isWhitespace(i)) return null;\n    }\n\n    return 0 != r && 10 !== e ? null : (l.sign = -1 == r, l.__trim());\n  }\n\n  static __fillFromParts(t, e, r) {\n    let n = 0,\n        o = 0,\n        i = 0;\n\n    for (let s = e.length - 1; 0 <= s; s--) {\n      const c = e[s],\n            a = r[s];\n      o |= c << i, i += a, 32 === i ? (t.__setDigit(n++, o), i = 0, o = 0) : 32 < i && (t.__setDigit(n++, o), i -= 32, o = c >>> a - i);\n    }\n\n    if (0 !== o) {\n      if (n >= t.length) throw new Error(\"implementation bug\");\n\n      t.__setDigit(n++, o);\n    }\n\n    for (; n < t.length; n++) t.__setDigit(n, 0);\n  }\n\n  static __toStringBasePowerOfTwo(t, e) {\n    var r = Math.clz32;\n    const n = t.length;\n    let o = e - 1;\n    o = (85 & o >>> 1) + (85 & o), o = (51 & o >>> 2) + (51 & o), o = (15 & o >>> 4) + (15 & o);\n\n    const i = o,\n          s = e - 1,\n          c = t.__digit(n - 1);\n\n    let a = 0 | (32 * n - r(c) + i - 1) / i;\n    if (t.sign && a++, 268435456 < a) throw new Error(\"string too long\");\n    const u = Array(a);\n    let l = a - 1,\n        h = 0,\n        f = 0;\n\n    for (let e = 0; e < n - 1; e++) {\n      const r = t.__digit(e),\n            n = (h | r << f) & s;\n\n      u[l--] = qt.__kConversionChars[n];\n      const o = i - f;\n\n      for (h = r >>> o, f = 32 - o; f >= i;) u[l--] = qt.__kConversionChars[h & s], h >>>= i, f -= i;\n    }\n\n    const d = (h | c << f) & s;\n\n    for (u[l--] = qt.__kConversionChars[d], h = c >>> i - f; 0 !== h;) u[l--] = qt.__kConversionChars[h & s], h >>>= i;\n\n    if (t.sign && (u[l--] = \"-\"), -1 != l) throw new Error(\"implementation bug\");\n    return u.join(\"\");\n  }\n\n  static __toStringGeneric(t, e, r) {\n    var n = Math.clz32;\n    const o = t.length;\n    if (0 === o) return \"\";\n\n    if (1 === o) {\n      let n = t.__unsignedDigit(0).toString(e);\n\n      return !1 === r && t.sign && (n = \"-\" + n), n;\n    }\n\n    const i = 32 * o - n(t.__digit(o - 1)),\n          s = qt.__kMaxBitsPerChar[e] - 1;\n    let c = i * qt.__kBitsPerCharTableMultiplier;\n    c += s - 1, c = 0 | c / s;\n    const a = c + 1 >> 1,\n          u = qt.exponentiate(qt.__oneDigit(e, !1), qt.__oneDigit(a, !1));\n    let l, h;\n\n    const f = u.__unsignedDigit(0);\n\n    if (1 === u.length && 65535 >= f) {\n      l = new qt(t.length, !1), l.__initializeDigits();\n      let r = 0;\n\n      for (let e = 2 * t.length - 1; 0 <= e; e--) {\n        const n = r << 16 | t.__halfDigit(e);\n\n        l.__setHalfDigit(e, 0 | n / f), r = 0 | n % f;\n      }\n\n      h = r.toString(e);\n    } else {\n      const r = qt.__absoluteDivLarge(t, u, !0, !0);\n\n      l = r.quotient;\n\n      const n = r.remainder.__trim();\n\n      h = qt.__toStringGeneric(n, e, !0);\n    }\n\n    l.__trim();\n\n    let d = qt.__toStringGeneric(l, e, !0);\n\n    for (; h.length < a;) h = \"0\" + h;\n\n    return !1 === r && t.sign && (d = \"-\" + d), d + h;\n  }\n\n  static __unequalSign(t) {\n    return t ? -1 : 1;\n  }\n\n  static __absoluteGreater(t) {\n    return t ? -1 : 1;\n  }\n\n  static __absoluteLess(t) {\n    return t ? 1 : -1;\n  }\n\n  static __compareToBigInt(t, e) {\n    const r = t.sign;\n    if (r !== e.sign) return qt.__unequalSign(r);\n\n    const n = qt.__absoluteCompare(t, e);\n\n    return 0 < n ? qt.__absoluteGreater(r) : 0 > n ? qt.__absoluteLess(r) : 0;\n  }\n\n  static __compareToNumber(t, e) {\n    if (!0 | e) {\n      const r = t.sign,\n            n = 0 > e;\n      if (r !== n) return qt.__unequalSign(r);\n\n      if (0 === t.length) {\n        if (n) throw new Error(\"implementation bug\");\n        return 0 === e ? 0 : -1;\n      }\n\n      if (1 < t.length) return qt.__absoluteGreater(r);\n\n      const o = Math.abs(e),\n            i = t.__unsignedDigit(0);\n\n      return i > o ? qt.__absoluteGreater(r) : i < o ? qt.__absoluteLess(r) : 0;\n    }\n\n    return qt.__compareToDouble(t, e);\n  }\n\n  static __compareToDouble(t, e) {\n    var r = Math.clz32;\n    if (e != e) return e;\n    if (e === 1 / 0) return -1;\n    if (e === -1 / 0) return 1;\n    const n = t.sign;\n    if (n !== 0 > e) return qt.__unequalSign(n);\n    if (0 === e) throw new Error(\"implementation bug: should be handled elsewhere\");\n    if (0 === t.length) return -1;\n    qt.__kBitConversionDouble[0] = e;\n    const o = 2047 & qt.__kBitConversionInts[1] >>> 20;\n    if (2047 == o) throw new Error(\"implementation bug: handled elsewhere\");\n    const i = o - 1023;\n    if (0 > i) return qt.__absoluteGreater(n);\n    const s = t.length;\n\n    let c = t.__digit(s - 1);\n\n    const a = r(c),\n          u = 32 * s - a,\n          l = i + 1;\n    if (u < l) return qt.__absoluteLess(n);\n    if (u > l) return qt.__absoluteGreater(n);\n    let h = 1048576 | 1048575 & qt.__kBitConversionInts[1],\n        f = qt.__kBitConversionInts[0];\n    const d = 31 - a;\n    if (d !== (u - 1) % 31) throw new Error(\"implementation bug\");\n    let p,\n        _ = 0;\n\n    if (20 > d) {\n      const t = 20 - d;\n      _ = t + 32, p = h >>> t, h = h << 32 - t | f >>> t, f <<= 32 - t;\n    } else if (20 === d) _ = 32, p = h, h = f;else {\n      const t = d - 20;\n      _ = 32 - t, p = h << t | f >>> 32 - t, h = f << t;\n    }\n\n    if (c >>>= 0, p >>>= 0, c > p) return qt.__absoluteGreater(n);\n    if (c < p) return qt.__absoluteLess(n);\n\n    for (let e = s - 2; 0 <= e; e--) {\n      0 < _ ? (_ -= 32, p = h >>> 0, h = f, f = 0) : p = 0;\n\n      const r = t.__unsignedDigit(e);\n\n      if (r > p) return qt.__absoluteGreater(n);\n      if (r < p) return qt.__absoluteLess(n);\n    }\n\n    if (0 !== h || 0 !== f) {\n      if (0 === _) throw new Error(\"implementation bug\");\n      return qt.__absoluteLess(n);\n    }\n\n    return 0;\n  }\n\n  static __equalToNumber(t, e) {\n    var r = Math.abs;\n    return e | 0 === e ? 0 === e ? 0 === t.length : 1 === t.length && t.sign === 0 > e && t.__unsignedDigit(0) === r(e) : 0 === qt.__compareToDouble(t, e);\n  }\n\n  static __comparisonResultToBool(t, e) {\n    switch (e) {\n      case 0:\n        return 0 > t;\n\n      case 1:\n        return 0 >= t;\n\n      case 2:\n        return 0 < t;\n\n      case 3:\n        return 0 <= t;\n    }\n\n    throw new Error(\"unreachable\");\n  }\n\n  static __compare(t, e, r) {\n    if (t = qt.__toPrimitive(t), e = qt.__toPrimitive(e), \"string\" == typeof t && \"string\" == typeof e) switch (r) {\n      case 0:\n        return t < e;\n\n      case 1:\n        return t <= e;\n\n      case 2:\n        return t > e;\n\n      case 3:\n        return t >= e;\n    }\n    if (qt.__isBigInt(t) && \"string\" == typeof e) return null !== (e = qt.__fromString(e)) && qt.__comparisonResultToBool(qt.__compareToBigInt(t, e), r);\n    if (\"string\" == typeof t && qt.__isBigInt(e)) return null !== (t = qt.__fromString(t)) && qt.__comparisonResultToBool(qt.__compareToBigInt(t, e), r);\n\n    if (t = qt.__toNumeric(t), e = qt.__toNumeric(e), qt.__isBigInt(t)) {\n      if (qt.__isBigInt(e)) return qt.__comparisonResultToBool(qt.__compareToBigInt(t, e), r);\n      if (\"number\" != typeof e) throw new Error(\"implementation bug\");\n      return qt.__comparisonResultToBool(qt.__compareToNumber(t, e), r);\n    }\n\n    if (\"number\" != typeof t) throw new Error(\"implementation bug\");\n    if (qt.__isBigInt(e)) return qt.__comparisonResultToBool(qt.__compareToNumber(e, t), 2 ^ r);\n    if (\"number\" != typeof e) throw new Error(\"implementation bug\");\n    return 0 === r ? t < e : 1 === r ? t <= e : 2 === r ? t > e : 3 === r ? t >= e : void 0;\n  }\n\n  __clzmsd() {\n    return Math.clz32(this[this.length - 1]);\n  }\n\n  static __absoluteAdd(t, e, r) {\n    if (t.length < e.length) return qt.__absoluteAdd(e, t, r);\n    if (0 === t.length) return t;\n    if (0 === e.length) return t.sign === r ? t : qt.unaryMinus(t);\n    let n = t.length;\n    (0 === t.__clzmsd() || e.length === t.length && 0 === e.__clzmsd()) && n++;\n    const o = new qt(n, r);\n    let i = 0,\n        s = 0;\n\n    for (; s < e.length; s++) {\n      const r = e.__digit(s),\n            n = t.__digit(s),\n            c = (65535 & n) + (65535 & r) + i,\n            a = (n >>> 16) + (r >>> 16) + (c >>> 16);\n\n      i = a >>> 16, o.__setDigit(s, 65535 & c | a << 16);\n    }\n\n    for (; s < t.length; s++) {\n      const e = t.__digit(s),\n            r = (65535 & e) + i,\n            n = (e >>> 16) + (r >>> 16);\n\n      i = n >>> 16, o.__setDigit(s, 65535 & r | n << 16);\n    }\n\n    return s < o.length && o.__setDigit(s, i), o.__trim();\n  }\n\n  static __absoluteSub(t, e, r) {\n    if (0 === t.length) return t;\n    if (0 === e.length) return t.sign === r ? t : qt.unaryMinus(t);\n    const n = new qt(t.length, r);\n    let o = 0,\n        i = 0;\n\n    for (; i < e.length; i++) {\n      const r = t.__digit(i),\n            s = e.__digit(i),\n            c = (65535 & r) - (65535 & s) - o;\n\n      o = 1 & c >>> 16;\n      const a = (r >>> 16) - (s >>> 16) - o;\n      o = 1 & a >>> 16, n.__setDigit(i, 65535 & c | a << 16);\n    }\n\n    for (; i < t.length; i++) {\n      const e = t.__digit(i),\n            r = (65535 & e) - o;\n\n      o = 1 & r >>> 16;\n      const s = (e >>> 16) - o;\n      o = 1 & s >>> 16, n.__setDigit(i, 65535 & r | s << 16);\n    }\n\n    return n.__trim();\n  }\n\n  static __absoluteAddOne(t, e, r = null) {\n    const n = t.length;\n    null === r ? r = new qt(n, e) : r.sign = e;\n    let o = !0;\n\n    for (let e, i = 0; i < n; i++) {\n      e = t.__digit(i);\n      const n = -1 === e;\n      o && (e = 0 | e + 1), o = n, r.__setDigit(i, e);\n    }\n\n    return o && r.__setDigitGrow(n, 1), r;\n  }\n\n  static __absoluteSubOne(t, e) {\n    const r = t.length,\n          n = new qt(e = e || r, !1);\n    let o = !0;\n\n    for (let e, i = 0; i < r; i++) {\n      e = t.__digit(i);\n      const r = 0 === e;\n      o && (e = 0 | e - 1), o = r, n.__setDigit(i, e);\n    }\n\n    for (let t = r; t < e; t++) n.__setDigit(t, 0);\n\n    return n;\n  }\n\n  static __absoluteAnd(t, e, r = null) {\n    let n = t.length,\n        o = e.length,\n        i = o;\n\n    if (n < o) {\n      i = n;\n      const r = t,\n            s = n;\n      t = e, n = o, e = r, o = s;\n    }\n\n    let s = i;\n    null === r ? r = new qt(s, !1) : s = r.length;\n    let c = 0;\n\n    for (; c < i; c++) r.__setDigit(c, t.__digit(c) & e.__digit(c));\n\n    for (; c < s; c++) r.__setDigit(c, 0);\n\n    return r;\n  }\n\n  static __absoluteAndNot(t, e, r = null) {\n    const n = t.length,\n          o = e.length;\n    let i = o;\n    n < o && (i = n);\n    let s = n;\n    null === r ? r = new qt(s, !1) : s = r.length;\n    let c = 0;\n\n    for (; c < i; c++) r.__setDigit(c, t.__digit(c) & ~e.__digit(c));\n\n    for (; c < n; c++) r.__setDigit(c, t.__digit(c));\n\n    for (; c < s; c++) r.__setDigit(c, 0);\n\n    return r;\n  }\n\n  static __absoluteOr(t, e, r = null) {\n    let n = t.length,\n        o = e.length,\n        i = o;\n\n    if (n < o) {\n      i = n;\n      const r = t,\n            s = n;\n      t = e, n = o, e = r, o = s;\n    }\n\n    let s = n;\n    null === r ? r = new qt(s, !1) : s = r.length;\n    let c = 0;\n\n    for (; c < i; c++) r.__setDigit(c, t.__digit(c) | e.__digit(c));\n\n    for (; c < n; c++) r.__setDigit(c, t.__digit(c));\n\n    for (; c < s; c++) r.__setDigit(c, 0);\n\n    return r;\n  }\n\n  static __absoluteXor(t, e, r = null) {\n    let n = t.length,\n        o = e.length,\n        i = o;\n\n    if (n < o) {\n      i = n;\n      const r = t,\n            s = n;\n      t = e, n = o, e = r, o = s;\n    }\n\n    let s = n;\n    null === r ? r = new qt(s, !1) : s = r.length;\n    let c = 0;\n\n    for (; c < i; c++) r.__setDigit(c, t.__digit(c) ^ e.__digit(c));\n\n    for (; c < n; c++) r.__setDigit(c, t.__digit(c));\n\n    for (; c < s; c++) r.__setDigit(c, 0);\n\n    return r;\n  }\n\n  static __absoluteCompare(t, e) {\n    const r = t.length - e.length;\n    if (0 != r) return r;\n    let n = t.length - 1;\n\n    for (; 0 <= n && t.__digit(n) === e.__digit(n);) n--;\n\n    return 0 > n ? 0 : t.__unsignedDigit(n) > e.__unsignedDigit(n) ? 1 : -1;\n  }\n\n  static __multiplyAccumulate(t, e, r, n) {\n    var o = Math.imul;\n    if (0 === e) return;\n    const i = 65535 & e,\n          s = e >>> 16;\n    let c = 0,\n        a = 0,\n        u = 0;\n\n    for (let e = 0; e < t.length; e++, n++) {\n      let l = r.__digit(n),\n          h = 65535 & l,\n          f = l >>> 16;\n\n      const d = t.__digit(e),\n            p = 65535 & d,\n            _ = d >>> 16,\n            g = o(p, i),\n            m = o(p, s),\n            v = o(_, i),\n            y = o(_, s);\n\n      h += a + (65535 & g), f += u + c + (h >>> 16) + (g >>> 16) + (65535 & m) + (65535 & v), c = f >>> 16, a = (m >>> 16) + (v >>> 16) + (65535 & y) + c, c = a >>> 16, a &= 65535, u = y >>> 16, l = 65535 & h | f << 16, r.__setDigit(n, l);\n    }\n\n    for (; 0 != c || 0 !== a || 0 !== u; n++) {\n      let t = r.__digit(n);\n\n      const e = (65535 & t) + a,\n            o = (t >>> 16) + (e >>> 16) + u + c;\n      a = 0, u = 0, c = o >>> 16, t = 65535 & e | o << 16, r.__setDigit(n, t);\n    }\n  }\n\n  static __internalMultiplyAdd(t, e, r, n, o) {\n    var i = Math.imul;\n    let s = r,\n        c = 0;\n\n    for (let r = 0; r < n; r++) {\n      const n = t.__digit(r),\n            a = i(65535 & n, e),\n            u = (65535 & a) + c + s;\n\n      s = u >>> 16;\n      const l = i(n >>> 16, e),\n            h = (65535 & l) + (a >>> 16) + s;\n      s = h >>> 16, c = l >>> 16, o.__setDigit(r, h << 16 | 65535 & u);\n    }\n\n    if (o.length > n) for (o.__setDigit(n++, s + c); n < o.length;) o.__setDigit(n++, 0);else if (0 !== s + c) throw new Error(\"implementation bug\");\n  }\n\n  __inplaceMultiplyAdd(t, e, r) {\n    var n = Math.imul;\n    r > this.length && (r = this.length);\n    const o = 65535 & t,\n          i = t >>> 16;\n    let s = 0,\n        c = 65535 & e,\n        a = e >>> 16;\n\n    for (let t = 0; t < r; t++) {\n      const e = this.__digit(t),\n            r = 65535 & e,\n            u = e >>> 16,\n            l = n(r, o),\n            h = n(r, i),\n            f = n(u, o),\n            d = n(u, i),\n            p = c + (65535 & l),\n            _ = a + s + (p >>> 16) + (l >>> 16) + (65535 & h) + (65535 & f);\n\n      c = (h >>> 16) + (f >>> 16) + (65535 & d) + (_ >>> 16), s = c >>> 16, c &= 65535, a = d >>> 16, this.__setDigit(t, 65535 & p | _ << 16);\n    }\n\n    if (0 != s || 0 !== c || 0 !== a) throw new Error(\"implementation bug\");\n  }\n\n  static __absoluteDivSmall(t, e, r) {\n    null === r && (r = new qt(t.length, !1));\n    let n = 0;\n\n    for (let o, i = 2 * t.length - 1; 0 <= i; i -= 2) {\n      o = (n << 16 | t.__halfDigit(i)) >>> 0;\n      const s = 0 | o / e;\n      n = 0 | o % e, o = (n << 16 | t.__halfDigit(i - 1)) >>> 0;\n      const c = 0 | o / e;\n      n = 0 | o % e, r.__setDigit(i >>> 1, s << 16 | c);\n    }\n\n    return r;\n  }\n\n  static __absoluteModSmall(t, e) {\n    let r = 0;\n\n    for (let n = 2 * t.length - 1; 0 <= n; n--) {\n      r = 0 | ((r << 16 | t.__halfDigit(n)) >>> 0) % e;\n    }\n\n    return r;\n  }\n\n  static __absoluteDivLarge(t, e, r, n) {\n    var o = Math.imul;\n\n    const i = e.__halfDigitLength(),\n          s = e.length,\n          c = t.__halfDigitLength() - i;\n\n    let a = null;\n    r && (a = new qt(c + 2 >>> 1, !1), a.__initializeDigits());\n    const u = new qt(i + 2 >>> 1, !1);\n\n    u.__initializeDigits();\n\n    const l = qt.__clz16(e.__halfDigit(i - 1));\n\n    0 < l && (e = qt.__specialLeftShift(e, l, 0));\n\n    const h = qt.__specialLeftShift(t, l, 1),\n          f = e.__halfDigit(i - 1);\n\n    let d = 0;\n\n    for (let t, n = c; 0 <= n; n--) {\n      t = 65535;\n\n      const c = h.__halfDigit(n + i);\n\n      if (c !== f) {\n        const r = (c << 16 | h.__halfDigit(n + i - 1)) >>> 0;\n        t = 0 | r / f;\n        let s = 0 | r % f;\n\n        const a = e.__halfDigit(i - 2),\n              u = h.__halfDigit(n + i - 2);\n\n        for (; o(t, a) >>> 0 > (s << 16 | u) >>> 0 && (t--, s += f, !(65535 < s)););\n      }\n\n      qt.__internalMultiplyAdd(e, t, 0, s, u);\n\n      let l = h.__inplaceSub(u, n, i + 1);\n\n      0 !== l && (l = h.__inplaceAdd(e, n, i), h.__setHalfDigit(n + i, h.__halfDigit(n + i) + l), t--), r && (1 & n ? d = t << 16 : a.__setDigit(n >>> 1, d | t));\n    }\n\n    return n ? (h.__inplaceRightShift(l), r ? {\n      quotient: a,\n      remainder: h\n    } : h) : r ? a : void 0;\n  }\n\n  static __clz16(t) {\n    return Math.clz32(t) - 16;\n  }\n\n  __inplaceAdd(t, e, r) {\n    let n = 0;\n\n    for (let o = 0; o < r; o++) {\n      const r = this.__halfDigit(e + o) + t.__halfDigit(o) + n;\n      n = r >>> 16, this.__setHalfDigit(e + o, r);\n    }\n\n    return n;\n  }\n\n  __inplaceSub(t, e, r) {\n    let n = 0;\n\n    if (1 & e) {\n      e >>= 1;\n\n      let o = this.__digit(e),\n          i = 65535 & o,\n          s = 0;\n\n      for (; s < r - 1 >>> 1; s++) {\n        const r = t.__digit(s),\n              c = (o >>> 16) - (65535 & r) - n;\n\n        n = 1 & c >>> 16, this.__setDigit(e + s, c << 16 | 65535 & i), o = this.__digit(e + s + 1), i = (65535 & o) - (r >>> 16) - n, n = 1 & i >>> 16;\n      }\n\n      const c = t.__digit(s),\n            a = (o >>> 16) - (65535 & c) - n;\n\n      if (n = 1 & a >>> 16, this.__setDigit(e + s, a << 16 | 65535 & i), e + s + 1 >= this.length) throw new RangeError(\"out of bounds\");\n      0 == (1 & r) && (o = this.__digit(e + s + 1), i = (65535 & o) - (c >>> 16) - n, n = 1 & i >>> 16, this.__setDigit(e + t.length, 4294901760 & o | 65535 & i));\n    } else {\n      e >>= 1;\n      let o = 0;\n\n      for (; o < t.length - 1; o++) {\n        const r = this.__digit(e + o),\n              i = t.__digit(o),\n              s = (65535 & r) - (65535 & i) - n;\n\n        n = 1 & s >>> 16;\n        const c = (r >>> 16) - (i >>> 16) - n;\n        n = 1 & c >>> 16, this.__setDigit(e + o, c << 16 | 65535 & s);\n      }\n\n      const i = this.__digit(e + o),\n            s = t.__digit(o),\n            c = (65535 & i) - (65535 & s) - n;\n\n      n = 1 & c >>> 16;\n      let a = 0;\n      0 == (1 & r) && (a = (i >>> 16) - (s >>> 16) - n, n = 1 & a >>> 16), this.__setDigit(e + o, a << 16 | 65535 & c);\n    }\n\n    return n;\n  }\n\n  __inplaceRightShift(t) {\n    if (0 === t) return;\n    let e = this.__digit(0) >>> t;\n    const r = this.length - 1;\n\n    for (let n = 0; n < r; n++) {\n      const r = this.__digit(n + 1);\n\n      this.__setDigit(n, r << 32 - t | e), e = r >>> t;\n    }\n\n    this.__setDigit(r, e);\n  }\n\n  static __specialLeftShift(t, e, r) {\n    const n = t.length,\n          o = new qt(n + r, !1);\n\n    if (0 === e) {\n      for (let e = 0; e < n; e++) o.__setDigit(e, t.__digit(e));\n\n      return 0 < r && o.__setDigit(n, 0), o;\n    }\n\n    let i = 0;\n\n    for (let r = 0; r < n; r++) {\n      const n = t.__digit(r);\n\n      o.__setDigit(r, n << e | i), i = n >>> 32 - e;\n    }\n\n    return 0 < r && o.__setDigit(n, i), o;\n  }\n\n  static __leftShiftByAbsolute(t, e) {\n    const r = qt.__toShiftAmount(e);\n\n    if (0 > r) throw new RangeError(\"BigInt too big\");\n    const n = r >>> 5,\n          o = 31 & r,\n          i = t.length,\n          s = 0 !== o && 0 != t.__digit(i - 1) >>> 32 - o,\n          c = i + n + (s ? 1 : 0),\n          a = new qt(c, t.sign);\n\n    if (0 === o) {\n      let e = 0;\n\n      for (; e < n; e++) a.__setDigit(e, 0);\n\n      for (; e < c; e++) a.__setDigit(e, t.__digit(e - n));\n    } else {\n      let e = 0;\n\n      for (let t = 0; t < n; t++) a.__setDigit(t, 0);\n\n      for (let r = 0; r < i; r++) {\n        const i = t.__digit(r);\n\n        a.__setDigit(r + n, i << o | e), e = i >>> 32 - o;\n      }\n\n      if (s) a.__setDigit(i + n, e);else if (0 != e) throw new Error(\"implementation bug\");\n    }\n\n    return a.__trim();\n  }\n\n  static __rightShiftByAbsolute(t, e) {\n    const r = t.length,\n          n = t.sign,\n          o = qt.__toShiftAmount(e);\n\n    if (0 > o) return qt.__rightShiftByMaximum(n);\n    const i = o >>> 5,\n          s = 31 & o;\n    let c = r - i;\n    if (0 >= c) return qt.__rightShiftByMaximum(n);\n    let a = !1;\n    if (n) if (0 != (t.__digit(i) & (1 << s) - 1)) a = !0;else for (let e = 0; e < i; e++) if (0 !== t.__digit(e)) {\n      a = !0;\n      break;\n    }\n\n    if (a && 0 === s) {\n      0 == ~t.__digit(r - 1) && c++;\n    }\n\n    let u = new qt(c, n);\n    if (0 === s) for (let e = i; e < r; e++) u.__setDigit(e - i, t.__digit(e));else {\n      let e = t.__digit(i) >>> s;\n      const n = r - i - 1;\n\n      for (let r = 0; r < n; r++) {\n        const n = t.__digit(r + i + 1);\n\n        u.__setDigit(r, n << 32 - s | e), e = n >>> s;\n      }\n\n      u.__setDigit(n, e);\n    }\n    return a && (u = qt.__absoluteAddOne(u, !0, u)), u.__trim();\n  }\n\n  static __rightShiftByMaximum(t) {\n    return t ? qt.__oneDigit(1, !0) : qt.__zero();\n  }\n\n  static __toShiftAmount(t) {\n    if (1 < t.length) return -1;\n\n    const e = t.__unsignedDigit(0);\n\n    return e > qt.__kMaxLengthBits ? -1 : e;\n  }\n\n  static __toPrimitive(t, e = \"default\") {\n    if (\"object\" != typeof t) return t;\n    if (t.constructor === qt) return t;\n    const r = t[Symbol.toPrimitive];\n\n    if (r) {\n      const t = r(e);\n      if (\"object\" != typeof t) return t;\n      throw new TypeError(\"Cannot convert object to primitive value\");\n    }\n\n    const n = t.valueOf;\n\n    if (n) {\n      const e = n.call(t);\n      if (\"object\" != typeof e) return e;\n    }\n\n    const o = t.toString;\n\n    if (o) {\n      const e = o.call(t);\n      if (\"object\" != typeof e) return e;\n    }\n\n    throw new TypeError(\"Cannot convert object to primitive value\");\n  }\n\n  static __toNumeric(t) {\n    return qt.__isBigInt(t) ? t : +t;\n  }\n\n  static __isBigInt(t) {\n    return \"object\" == typeof t && t.constructor === qt;\n  }\n\n  static __truncateToNBits(t, e) {\n    const r = t + 31 >>> 5,\n          n = new qt(r, e.sign),\n          o = r - 1;\n\n    for (let t = 0; t < o; t++) n.__setDigit(t, e.__digit(t));\n\n    let i = e.__digit(o);\n\n    if (0 != (31 & t)) {\n      const e = 32 - (31 & t);\n      i = i << e >>> e;\n    }\n\n    return n.__setDigit(o, i), n.__trim();\n  }\n\n  static __truncateAndSubFromPowerOfTwo(t, e, r) {\n    var n = Math.min;\n    const o = t + 31 >>> 5,\n          i = new qt(o, r);\n    let s = 0;\n    const c = o - 1;\n    let a = 0;\n\n    for (const t = n(c, e.length); s < t; s++) {\n      const t = e.__digit(s),\n            r = 0 - (65535 & t) - a;\n\n      a = 1 & r >>> 16;\n      const n = 0 - (t >>> 16) - a;\n      a = 1 & n >>> 16, i.__setDigit(s, 65535 & r | n << 16);\n    }\n\n    for (; s < c; s++) i.__setDigit(s, 0 | -a);\n\n    let u = c < e.length ? e.__digit(c) : 0;\n    const l = 31 & t;\n    let h;\n\n    if (0 == l) {\n      const t = 0 - (65535 & u) - a;\n      a = 1 & t >>> 16, h = 65535 & t | 0 - (u >>> 16) - a << 16;\n    } else {\n      const t = 32 - l;\n      u = u << t >>> t;\n      const e = 1 << 32 - t,\n            r = (65535 & e) - (65535 & u) - a;\n      a = 1 & r >>> 16, h = 65535 & r | (e >>> 16) - (u >>> 16) - a << 16, h &= e - 1;\n    }\n\n    return i.__setDigit(c, h), i.__trim();\n  }\n\n  __digit(t) {\n    return this[t];\n  }\n\n  __unsignedDigit(t) {\n    return this[t] >>> 0;\n  }\n\n  __setDigit(t, e) {\n    this[t] = 0 | e;\n  }\n\n  __setDigitGrow(t, e) {\n    this[t] = 0 | e;\n  }\n\n  __halfDigitLength() {\n    const t = this.length;\n    return 65535 >= this.__unsignedDigit(t - 1) ? 2 * t - 1 : 2 * t;\n  }\n\n  __halfDigit(t) {\n    return 65535 & this[t >>> 1] >>> ((1 & t) << 4);\n  }\n\n  __setHalfDigit(t, e) {\n    const r = t >>> 1,\n          n = this.__digit(r),\n          o = 1 & t ? 65535 & n | e << 16 : 4294901760 & n | 65535 & e;\n\n    this.__setDigit(r, o);\n  }\n\n  static __digitPow(t, e) {\n    let r = 1;\n\n    for (; 0 < e;) 1 & e && (r *= t), e >>>= 1, t *= t;\n\n    return r;\n  }\n\n}\n\nqt.__kMaxLength = 33554432, qt.__kMaxLengthBits = qt.__kMaxLength << 5, qt.__kMaxBitsPerChar = [0, 0, 32, 51, 64, 75, 83, 90, 96, 102, 107, 111, 115, 119, 122, 126, 128, 131, 134, 136, 139, 141, 143, 145, 147, 149, 151, 153, 154, 156, 158, 159, 160, 162, 163, 165, 166], qt.__kBitsPerCharTableShift = 5, qt.__kBitsPerCharTableMultiplier = 1 << qt.__kBitsPerCharTableShift, qt.__kConversionChars = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"], qt.__kBitConversionBuffer = new ArrayBuffer(8), qt.__kBitConversionDouble = new Float64Array(qt.__kBitConversionBuffer), qt.__kBitConversionInts = new Int32Array(qt.__kBitConversionBuffer);\n\nvar Wt = function (t) {\n  var e, r;\n\n  function n(e) {\n    var r,\n        n = (void 0 === e ? {} : e).supportedChainIds;\n    return (r = t.call(this) || this).supportedChainIds = n, r;\n  }\n\n  r = t, (e = n).prototype = Object.create(r.prototype), e.prototype.constructor = e, e.__proto__ = r;\n  var o = n.prototype;\n  return o.emitUpdate = function (t) {\n    \"production\" !== process.env.NODE_ENV && console.log(\"Emitting '\" + st.Update + \"' with payload\", t), this.emit(st.Update, t);\n  }, o.emitError = function (t) {\n    \"production\" !== process.env.NODE_ENV && console.log(\"Emitting '\" + st.Error + \"' with payload\", t), this.emit(st.Error, t);\n  }, o.emitDeactivate = function () {\n    \"production\" !== process.env.NODE_ENV && console.log(\"Emitting '\" + st.Deactivate + \"'\"), this.emit(st.Deactivate);\n  }, n;\n}(f);\n\nfunction $t() {\n  return ($t = Object.assign || function (t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var r = arguments[e];\n\n      for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n]);\n    }\n\n    return t;\n  }).apply(this, arguments);\n}\n\nvar zt = {\n  1: \"mainnet\",\n  3: \"ropsten\",\n  4: \"rinkeby\",\n  5: \"goerli\",\n  42: \"kovan\"\n},\n    Gt = function (t) {\n  var e, r;\n\n  function n(e) {\n    var r,\n        n = e.chainId,\n        o = e.config,\n        i = void 0 === o ? {} : o;\n    return (r = t.call(this, {\n      supportedChainIds: [n]\n    }) || this).chainId = n, r.config = i, r;\n  }\n\n  r = t, (e = n).prototype = Object.create(r.prototype), e.prototype.constructor = e, e.__proto__ = r;\n  var o = n.prototype;\n  return o.activate = function () {\n    try {\n      var t = function () {\n        return Promise.resolve(e.authereum.getProvider().enable().then(function (t) {\n          return t[0];\n        })).then(function () {\n          return {\n            provider: e.authereum.getProvider()\n          };\n        });\n      },\n          e = this,\n          r = function () {\n        if (!e.authereum) return Promise.resolve(import(\"./index-c6f22609.js\")).then(function (t) {\n          var r = t.default;\n          e.authereum = new r($t({\n            networkName: zt[e.chainId]\n          }, e.config));\n        });\n      }();\n\n      return Promise.resolve(r && r.then ? r.then(t) : t());\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.getProvider = function () {\n    try {\n      return Promise.resolve(this.authereum.getProvider());\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.getChainId = function () {\n    try {\n      return Promise.resolve(this.authereum.getNetworkId());\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.getAccount = function () {\n    try {\n      return Promise.resolve(this.authereum.getAccountAddress());\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.deactivate = function () {}, o.close = function () {\n    try {\n      return this.authereum.logout(), this.emitDeactivate(), Promise.resolve();\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, n;\n}(Wt);\n\nvar Ht = {\n  1: \"mainnet\",\n  3: \"ropsten\",\n  4: \"rinkeby\",\n  42: \"kovan\"\n},\n    Jt = function (t) {\n  var e, r;\n\n  function n(e) {\n    var r,\n        n = e.apiKey,\n        o = e.chainId;\n    return Object.keys(Ht).includes(o.toString()) || (\"production\" !== process.env.NODE_ENV ? ut(!1, \"Unsupported chainId \" + o) : ut(!1)), (r = t.call(this, {\n      supportedChainIds: [o]\n    }) || this).apiKey = n, r.chainId = o, r;\n  }\n\n  r = t, (e = n).prototype = Object.create(r.prototype), e.prototype.constructor = e, e.__proto__ = r;\n  var o = n.prototype;\n  return o.activate = function () {\n    try {\n      var t = function () {\n        return Promise.resolve(e.fortmatic.getProvider().enable().then(function (t) {\n          return t[0];\n        })).then(function (t) {\n          return {\n            provider: e.fortmatic.getProvider(),\n            chainId: e.chainId,\n            account: t\n          };\n        });\n      },\n          e = this,\n          r = function () {\n        if (!e.fortmatic) return Promise.resolve(import(\"./fortmatic-0568efcb.js\")).then(function (t) {\n          var r = t.default;\n          e.fortmatic = new r(e.apiKey, 1 === e.chainId || 4 === e.chainId ? void 0 : Ht[e.chainId]);\n        });\n      }();\n\n      return Promise.resolve(r && r.then ? r.then(t) : t());\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.getProvider = function () {\n    try {\n      return Promise.resolve(this.fortmatic.getProvider());\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.getChainId = function () {\n    try {\n      return Promise.resolve(this.chainId);\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.getAccount = function () {\n    try {\n      return Promise.resolve(this.fortmatic.getProvider().send(\"eth_accounts\").then(function (t) {\n        return t[0];\n      }));\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.deactivate = function () {}, o.close = function () {\n    try {\n      var t = this;\n      return Promise.resolve(t.fortmatic.user.logout()).then(function () {\n        t.emitDeactivate();\n      });\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, n;\n}(Wt);\n\nconst Kt = t => \"injected\" === t ? \"injected\" : t.endsWith(\".ipc\") ? \"ipc\" : t.startsWith(\"wss://\") || t.startsWith(\"ws://\") ? \"ws\" : t.startsWith(\"https://\") || t.startsWith(\"http://\") ? \"http\" : \"\";\n\nvar Xt = class extends h {\n  constructor(t) {\n    super(), this.connected = !1, this.nextId = 0, this.promises = {}, this.subscriptions = [], this.connection = t, this.connection.on(\"connect\", () => this.checkConnection()), this.connection.on(\"close\", () => this.emit(\"close\")), this.connection.on(\"payload\", t => {\n      const {\n        id: e,\n        method: r,\n        error: n,\n        result: o\n      } = t;\n      void 0 !== e ? this.promises[e] && (t.error ? this.promises[e].reject(n) : this.promises[e].resolve(o), delete this.promises[e]) : r && r.indexOf(\"_subscription\") > -1 && (this.emit(t.params.subscription, t.params.result), this.emit(r, t.params), this.emit(\"data\", t));\n    }), this.on(\"newListener\", (t, e) => {\n      \"networkChanged\" === t ? !this.attemptedNetworkSubscription && this.connected && this.startNetworkSubscription() : \"accountsChanged\" === t && !this.attemptedAccountsSubscription && this.connected && this.startAccountsSubscription();\n    });\n  }\n\n  async checkConnection() {\n    try {\n      this.emit(\"connect\", await this._send(\"net_version\")), this.connected = !0, this.listenerCount(\"networkChanged\") && !this.attemptedNetworkSubscription && this.startNetworkSubscription(), this.listenerCount(\"accountsChanged\") && !this.attemptedAccountsSubscription && this.startAccountsSubscription();\n    } catch (t) {\n      this.connected = !1;\n    }\n  }\n\n  async startNetworkSubscription() {\n    this.attemptedNetworkSubscription = !0;\n\n    try {\n      let t = await this.subscribe(\"eth_subscribe\", \"networkChanged\");\n      this.on(t, t => this.emit(\"networkChanged\", t));\n    } catch (t) {\n      console.warn(\"Unable to subscribe to networkChanged\", t);\n    }\n  }\n\n  async startAccountsSubscription() {\n    this.attemptedAccountsSubscription = !0;\n\n    try {\n      let t = await this.subscribe(\"eth_subscribe\", \"accountsChanged\");\n      this.on(t, t => this.emit(\"accountsChanged\", t));\n    } catch (t) {\n      console.warn(\"Unable to subscribe to accountsChanged\", t);\n    }\n  }\n\n  enable() {\n    return new Promise((t, e) => {\n      this._send(\"eth_accounts\").then(r => {\n        if (r.length > 0) this.accounts = r, this.coinbase = r[0], this.emit(\"enable\"), t(r);else {\n          const t = new Error(\"User Denied Full Provider\");\n          t.code = 4001, e(t);\n        }\n      }).catch(e);\n    });\n  }\n\n  _send(t, e = []) {\n    if (!t || \"string\" != typeof t) return new Error(\"Method is not a valid string.\");\n    if (!(e instanceof Array)) return new Error(\"Params is not a valid array.\");\n    const r = {\n      jsonrpc: \"2.0\",\n      id: this.nextId++,\n      method: t,\n      params: e\n    },\n          n = new Promise((t, e) => {\n      this.promises[r.id] = {\n        resolve: t,\n        reject: e\n      };\n    });\n    return this.connection.send(r), n;\n  }\n\n  send(...t) {\n    return this._send(...t);\n  }\n\n  _sendBatch(t) {\n    return Promise.all(t.map(t => this._send(t.method, t.params)));\n  }\n\n  subscribe(t, e, r = []) {\n    return this._send(t, [e, ...r]).then(t => (this.subscriptions.push(t), t));\n  }\n\n  unsubscribe(t, e) {\n    return this._send(t, [e]).then(t => {\n      if (t) return this.subscriptions = this.subscriptions.filter(t => t !== e), this.removeAllListeners(e), t;\n    });\n  }\n\n  sendAsync(t, e) {\n    return e && \"function\" == typeof e ? t ? t instanceof Array ? this.sendAsyncBatch(t, e) : this._send(t.method, t.params).then(r => {\n      e(null, {\n        id: t.id,\n        jsonrpc: t.jsonrpc,\n        result: r\n      });\n    }).catch(t => {\n      e(t);\n    }) : e(new Error(\"Invalid Payload\")) : e(new Error(\"Invalid or undefined callback provided to sendAsync\"));\n  }\n\n  sendAsyncBatch(t, e) {\n    return this._sendBatch(t).then(r => {\n      let n = r.map((e, r) => ({\n        id: t[r].id,\n        jsonrpc: t[r].jsonrpc,\n        result: e\n      }));\n      e(null, n);\n    }).catch(t => {\n      e(t);\n    });\n  }\n\n  isConnected() {\n    return this.connected;\n  }\n\n  close() {\n    this.connection.close(), this.connected = !1;\n    let t = new Error(\"Provider closed, subscription lost, please subscribe again.\");\n    this.subscriptions.forEach(e => this.emit(e, t)), this.subscriptions = [];\n  }\n\n};\nconst Yt = \"development\" === process.env.NODE_ENV;\nvar Qt = class extends h {\n  constructor(t, e, r) {\n    super(), this.targets = e, this.connections = t, this.connected = !1, this.status = \"loading\", this.interval = r.interval || 5e3, this.name = r.name || \"default\", this.inSetup = !0, this.connect();\n  }\n\n  connect(t = 0) {\n    if (Yt && 0 === t && console.log(`\\n\\n\\n\\nA connection cycle started for provider with name: ${this.name}`), this.connection && \"connected\" === this.connection.status && t >= this.connection.index) Yt && console.log(\"Stopping connection cycle becasuse we're already connected to a higher priority provider\");else if (0 === this.targets.length) Yt && console.log(\"No valid targets supplied\");else {\n      const {\n        protocol: e,\n        location: r\n      } = this.targets[t];\n      this.connection = this.connections[e](r), this.connection.on(\"error\", e => this.connected ? this.listenerCount(\"error\") ? this.emit(\"error\", e) : void console.warn(\"eth-provider - Uncaught connection error: \" + e.message) : this.connectionError(t, e)), this.connection.on(\"close\", t => {\n        this.connected = !1, this.emit(\"close\"), this.closing || this.refresh();\n      }), this.connection.on(\"connect\", () => {\n        this.connection.target = this.targets[t], this.connection.index = t, this.targets[t].status = this.connection.status, this.connected = !0, this.inSetup = !1, Yt && console.log(\"Successfully connected to: \" + this.targets[t].location), this.emit(\"connect\");\n      }), this.connection.on(\"data\", t => this.emit(\"data\", t)), this.connection.on(\"payload\", t => this.emit(\"payload\", t));\n    }\n  }\n\n  refresh(t = this.interval) {\n    Yt && console.log(`Reconnect queued for ${(t / 1e3).toFixed(2)}s in the future`), clearTimeout(this.connectTimer), this.connectTimer = setTimeout(() => this.connect(), t);\n  }\n\n  connectionError(t, e) {\n    this.targets[t].status = e, this.targets.length - 1 === t ? (this.inSetup = !1, Yt && console.warn(\"eth-provider unable to connect to any targets, view connection cycle summary: \", this.targets), this.refresh()) : this.connect(++t);\n  }\n\n  close() {\n    this.closing = !0, this.connection ? this.connection.close() : this.emit(\"close\"), clearTimeout(this.connectTimer);\n  }\n\n  error(t, e, r = -1) {\n    this.emit(\"payload\", {\n      id: t.id,\n      jsonrpc: t.jsonrpc,\n      error: {\n        message: e,\n        code: r\n      }\n    });\n  }\n\n  send(t) {\n    this.inSetup ? setTimeout(() => this.send(t), 100) : this.connection.closed ? this.error(t, \"Not connected\") : this.connection.send(t);\n  }\n\n};\n\nconst Zt = t => {\n  function e(e) {\n    t.status = e, t instanceof h && t.emit(\"status\", e);\n  }\n\n  async function r() {\n    if (t.inSetup) return setTimeout(r, 1e3);\n\n    try {\n      (await t.send(\"eth_syncing\")) ? (e(\"syncing\"), setTimeout(() => r(), 5e3)) : e(\"connected\");\n    } catch (t) {\n      e(\"disconnected\");\n    }\n  }\n\n  return e(\"loading\"), r(), t.on(\"connect\", () => r()), t.on(\"close\", () => e(\"disconnected\")), t;\n};\n\nvar te = {\n  injected: [\"injected\"],\n  frame: [\"ws://127.0.0.1:1248\", \"http://127.0.0.1:1248\"],\n  direct: [\"ws://127.0.0.1:8546\", \"http://127.0.0.1:8545\"],\n  infura: [\"wss://mainnet.infura.io/ws/v3/786ade30f36244469480aa5c2bf0743b\", \"https://mainnet.infura.io/v3/786ade30f36244469480aa5c2bf0743b\"],\n  infuraRopsten: [\"wss://ropsten.infura.io/ws/v3/786ade30f36244469480aa5c2bf0743b\", \"https://ropsten.infura.io/v3/786ade30f36244469480aa5c2bf0743b\"],\n  infuraRinkeby: [\"wss://rinkeby.infura.io/ws/v3/786ade30f36244469480aa5c2bf0743b\", \"https://rinkeby.infura.io/v3/786ade30f36244469480aa5c2bf0743b\"],\n  infuraKovan: [\"wss://kovan.infura.io/ws/v3/786ade30f36244469480aa5c2bf0743b\", \"https://kovan.infura.io/v3/786ade30f36244469480aa5c2bf0743b\"]\n};\n\nclass ee extends h {\n  constructor(t, e) {\n    super(), t ? setTimeout(() => this.emit(\"error\", new Error(\"Injected web3 provider is not currently supported\")), 0) : setTimeout(() => this.emit(\"error\", new Error(\"No injected provider found\")), 0);\n  }\n\n}\n\nclass re extends h {\n  constructor(t) {\n    super(), setTimeout(() => this.emit(\"error\", new Error(t)), 0);\n  }\n\n}\n\nlet ne, oe;\nconst ie = \"development\" === process.env.NODE_ENV;\nlet se;\n\nclass ce extends h {\n  constructor(t, e, r) {\n    super(), se = t, setTimeout(() => this.create(e, r), 0);\n  }\n\n  create(t, e) {\n    se || this.emit(\"error\", new Error(\"No WebSocket transport available\"));\n\n    try {\n      this.socket = new se(t);\n    } catch (t) {\n      return this.emit(\"error\", t);\n    }\n\n    this.socket.addEventListener(\"error\", t => this.emit(\"error\", t)), this.socket.addEventListener(\"open\", () => {\n      this.emit(\"connect\"), this.socket.addEventListener(\"message\", t => {\n        ((t, e) => {\n          const r = [];\n          t.replace(/\\}[\\n\\r]?\\{/g, \"}|--|{\").replace(/\\}\\][\\n\\r]?\\[\\{/g, \"}]|--|[{\").replace(/\\}[\\n\\r]?\\[\\{/g, \"}|--|[{\").replace(/\\}\\][\\n\\r]?\\{/g, \"}]|--|{\").split(\"|--|\").forEach(t => {\n            let n;\n            ne && (t = ne + t);\n\n            try {\n              n = JSON.parse(t);\n            } catch (r) {\n              return ne = t, clearTimeout(oe), void (oe = setTimeout(() => e(new Error(\"Parse response timeout\")), 15e3));\n            }\n\n            clearTimeout(oe), ne = null, n && r.push(n);\n          }), e(null, r);\n        })(\"string\" == typeof t.data ? t.data : \"\", (t, e) => {\n          t || e.forEach(t => {\n            Array.isArray(t) ? t.forEach(t => this.emit(\"payload\", t)) : this.emit(\"payload\", t);\n          });\n        });\n      }), this.socket.addEventListener(\"close\", () => this.onClose());\n    });\n  }\n\n  onClose() {\n    this.socket = null, this.closed = !0, ie && console.log(\"Closing WebSocket connection\"), this.emit(\"close\"), this.removeAllListeners();\n  }\n\n  close() {\n    this.socket ? this.socket.close() : this.onClose();\n  }\n\n  error(t, e, r = -1) {\n    this.emit(\"payload\", {\n      id: t.id,\n      jsonrpc: t.jsonrpc,\n      error: {\n        message: e,\n        code: r\n      }\n    });\n  }\n\n  send(t) {\n    this.socket && this.socket.readyState === this.socket.CONNECTING ? setTimeout(e => this.send(t), 10) : !this.socket || this.socket.readyState > 1 ? (this.connected = !1, this.error(t, \"Not connected\")) : this.socket.send(JSON.stringify(t));\n  }\n\n}\n\nfor (var ae = g(function (t) {\n  var e = \"undefined\" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || \"undefined\" != typeof msCrypto && \"function\" == typeof window.msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto);\n\n  if (e) {\n    var r = new Uint8Array(16);\n\n    t.exports = function () {\n      return e(r), r;\n    };\n  } else {\n    var n = new Array(16);\n\n    t.exports = function () {\n      for (var t, e = 0; e < 16; e++) 0 == (3 & e) && (t = 4294967296 * Math.random()), n[e] = t >>> ((3 & e) << 3) & 255;\n\n      return n;\n    };\n  }\n}), ue = [], le = 0; le < 256; ++le) ue[le] = (le + 256).toString(16).substr(1);\n\nvar he = function (t, e) {\n  var r = e || 0,\n      n = ue;\n  return [n[t[r++]], n[t[r++]], n[t[r++]], n[t[r++]], \"-\", n[t[r++]], n[t[r++]], \"-\", n[t[r++]], n[t[r++]], \"-\", n[t[r++]], n[t[r++]], \"-\", n[t[r++]], n[t[r++]], n[t[r++]], n[t[r++]], n[t[r++]], n[t[r++]]].join(\"\");\n};\n\nvar fe = function (t, e, r) {\n  var n = e && r || 0;\n  \"string\" == typeof t && (e = \"binary\" === t ? new Array(16) : null, t = null);\n  var o = (t = t || {}).random || (t.rng || ae)();\n  if (o[6] = 15 & o[6] | 64, o[8] = 63 & o[8] | 128, e) for (var i = 0; i < 16; ++i) e[n + i] = o[i];\n  return e || he(o);\n};\n\nconst de = \"development\" === process.env.NODE_ENV;\nlet pe;\n\nclass _e extends h {\n  constructor(t, e, r) {\n    super(), pe = t, this.connected = !1, this.subscriptions = !1, this.status = \"loading\", this.url = e, this.pollId = fe(), setTimeout(() => this.create(), 0);\n  }\n\n  create() {\n    if (!pe) return this.emit(\"error\", new Error(\"No HTTP transport available\"));\n    this.on(\"error\", () => {\n      this.connected && this.close();\n    }), this.init();\n  }\n\n  init() {\n    this.send({\n      jsonrpc: \"2.0\",\n      method: \"eth_syncing\",\n      params: [],\n      id: 1\n    }, (t, e) => {\n      if (t) return this.emit(\"error\", t);\n      this.send({\n        jsonrpc: \"2.0\",\n        id: 1,\n        method: \"eth_pollSubscriptions\",\n        params: [this.pollId, \"immediate\"]\n      }, (t, e) => {\n        t || (this.subscriptions = !0, this.pollSubscriptions()), this.connected = !0, this.emit(\"connect\");\n      });\n    });\n  }\n\n  pollSubscriptions() {\n    this.send({\n      jsonrpc: \"2.0\",\n      id: 1,\n      method: \"eth_pollSubscriptions\",\n      params: [this.pollId]\n    }, (t, e) => {\n      if (t) return this.subscriptionTimeout = setTimeout(() => this.pollSubscriptions(), 1e4), this.emit(\"error\", t);\n      this.closed || (this.subscriptionTimeout = this.pollSubscriptions()), e && e.map(t => {\n        let e;\n\n        try {\n          e = JSON.parse(t);\n        } catch (t) {\n          e = !1;\n        }\n\n        return e;\n      }).filter(t => t).forEach(t => this.emit(\"payload\", t));\n    });\n  }\n\n  close() {\n    de && console.log(\"Closing HTTP connection\"), this.closed = !0, this.emit(\"close\"), clearTimeout(this.subscriptionTimeout), this.removeAllListeners();\n  }\n\n  filterStatus(t) {\n    if (t.status >= 200 && t.status < 300) return t;\n    const e = new Error(t.statusText);\n    throw e.res = t, e.message;\n  }\n\n  error(t, e, r = -1) {\n    this.emit(\"payload\", {\n      id: t.id,\n      jsonrpc: t.jsonrpc,\n      error: {\n        message: e,\n        code: r\n      }\n    });\n  }\n\n  send(t, e) {\n    if (this.closed) return this.error(t, \"Not connected\");\n\n    if (\"eth_subscribe\" === t.method) {\n      if (!this.subscriptions) return this.error(t, \"Subscriptions are not supported by this HTTP endpoint\");\n      t.pollId = this.pollId;\n    }\n\n    const r = new pe();\n    let n = !1;\n\n    const o = (o, i) => {\n      if (!n) if (r.abort(), n = !0, e) e(o, i);else {\n        const {\n          id: e,\n          jsonrpc: r\n        } = t,\n              n = o ? {\n          id: e,\n          jsonrpc: r,\n          error: {\n            message: o.message,\n            code: o.code\n          }\n        } : {\n          id: e,\n          jsonrpc: r,\n          result: i\n        };\n        this.emit(\"payload\", n);\n      }\n    };\n\n    r.open(\"POST\", this.url, !0), r.setRequestHeader(\"Content-Type\", \"application/json\"), r.timeout = 6e4, r.onerror = o, r.ontimeout = o, r.onreadystatechange = () => {\n      if (4 === r.readyState) try {\n        const t = JSON.parse(r.responseText);\n        o(t.error, t.result);\n      } catch (t) {\n        o(t);\n      }\n    }, r.send(JSON.stringify(t));\n  }\n\n}\n\nconst ge = {\n  ethereum: \"undefined\" != typeof window && void 0 !== window.ethereum ? window.ethereum : null,\n  web3: \"undefined\" != typeof window && void 0 !== window.web3 ? window.web3.currentProvider : null\n},\n      me = \"undefined\" != typeof window && void 0 !== window.WebSocket ? window.WebSocket : null,\n      ve = \"undefined\" != typeof window && void 0 !== window.XMLHttpRequest ? window.XMLHttpRequest : null;\nge.ethereum && (ge.ethereum.__isProvider = !0);\nconst ye = {\n  injected: ge.ethereum || (t => e => new ee(t, e))(ge.web3),\n  ipc: (be = \"IPC connections are unavliable in the browser\", () => new re(be)),\n  ws: (t => (e, r) => new ce(t, e, r))(me),\n  http: (t => (e, r) => new _e(t, e, r))(ve)\n};\n\nvar be,\n    we = (t = [\"injected\", \"frame\"], e = {}) => ((t, e, r) => {\n  if (t.injected.__isProvider && e.map(t => t.type).indexOf(\"injected\") > -1) return delete t.injected.__isProvider, Zt(t.injected);\n  const n = new Xt(new Qt(t, e, r));\n  return n.setMaxListeners(128), Zt(n);\n})(ye, ((t, e) => [].concat(...[].concat(t).map(t => e[t] ? e[t].map(e => ({\n  type: t,\n  location: e,\n  protocol: Kt(e)\n})) : {\n  type: \"custom\",\n  location: t,\n  protocol: Kt(t)\n})).filter(t => !(!t.protocol && \"injected\" !== t.type) || (console.log('eth-provider | Invalid provider preset/location: \"' + t.location + '\"'), !1)))(t, te), e);\n\nfunction Ee(t, e) {\n  t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;\n}\n\nfunction Ce(t) {\n  return (Ce = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {\n    return t.__proto__ || Object.getPrototypeOf(t);\n  })(t);\n}\n\nfunction Oe(t, e) {\n  return (Oe = Object.setPrototypeOf || function (t, e) {\n    return t.__proto__ = e, t;\n  })(t, e);\n}\n\nfunction Pe() {\n  if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n  if (Reflect.construct.sham) return !1;\n  if (\"function\" == typeof Proxy) return !0;\n\n  try {\n    return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0;\n  } catch (t) {\n    return !1;\n  }\n}\n\nfunction Ne(t, e, r) {\n  return (Ne = Pe() ? Reflect.construct : function (t, e, r) {\n    var n = [null];\n    n.push.apply(n, e);\n    var o = new (Function.bind.apply(t, n))();\n    return r && Oe(o, r.prototype), o;\n  }).apply(null, arguments);\n}\n\nfunction Ie(t) {\n  var e = \"function\" == typeof Map ? new Map() : void 0;\n  return (Ie = function (t) {\n    if (null === t || (r = t, -1 === Function.toString.call(r).indexOf(\"[native code]\"))) return t;\n    var r;\n    if (\"function\" != typeof t) throw new TypeError(\"Super expression must either be null or a function\");\n\n    if (void 0 !== e) {\n      if (e.has(t)) return e.get(t);\n      e.set(t, n);\n    }\n\n    function n() {\n      return Ne(t, arguments, Ce(this).constructor);\n    }\n\n    return n.prototype = Object.create(t.prototype, {\n      constructor: {\n        value: n,\n        enumerable: !1,\n        writable: !0,\n        configurable: !0\n      }\n    }), Oe(n, t);\n  })(t);\n}\n\nfunction De(t) {\n  if (void 0 === t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return t;\n}\n\nvar Se = function (t) {\n  function e() {\n    var e;\n    return (e = t.call(this) || this).name = e.constructor.name, e.message = \"The user rejected the request.\", e;\n  }\n\n  return Ee(e, t), e;\n}(Ie(Error)),\n    Re = function (t) {\n  function e(e) {\n    var r;\n    return 1 !== e.supportedChainIds.length && (\"production\" !== process.env.NODE_ENV ? ut(!1, \"This connector only supports 1 chainId at the moment.\") : ut(!1)), (r = t.call(this, e) || this).handleNetworkChanged = r.handleNetworkChanged.bind(De(r)), r.handleChainChanged = r.handleChainChanged.bind(De(r)), r.handleAccountsChanged = r.handleAccountsChanged.bind(De(r)), r.handleClose = r.handleClose.bind(De(r)), r;\n  }\n\n  Ee(e, t);\n  var r = e.prototype;\n  return r.handleNetworkChanged = function (t) {\n    \"production\" !== process.env.NODE_ENV && console.log(\"Handling 'networkChanged' event with payload\", t), this.emitUpdate({\n      provider: this.provider,\n      chainId: t\n    });\n  }, r.handleChainChanged = function (t) {\n    \"production\" !== process.env.NODE_ENV && console.log(\"Handling 'chainChanged' event with payload\", t), this.emitUpdate({\n      chainId: t\n    });\n  }, r.handleAccountsChanged = function (t) {\n    \"production\" !== process.env.NODE_ENV && console.log(\"Handling 'accountsChanged' event with payload\", t), this.emitUpdate({\n      account: 0 === t.length ? null : t[0]\n    });\n  }, r.handleClose = function (t, e) {\n    \"production\" !== process.env.NODE_ENV && console.log(\"Handling 'close' event with payload\", t, e), this.emitDeactivate();\n  }, r.activate = function () {\n    try {\n      var t = this;\n      return t.provider || (t.provider = we(\"frame\")), t.provider.on(\"networkChanged\", t.handleNetworkChanged).on(\"chainChanged\", t.handleChainChanged).on(\"accountsChanged\", t.handleAccountsChanged).on(\"close\", t.handleClose), Promise.resolve(t.provider.enable().then(function (t) {\n        return t[0];\n      }).catch(function (t) {\n        throw t && 4001 === t.code ? new Se() : t;\n      })).then(function (e) {\n        return {\n          provider: t.provider,\n          account: e\n        };\n      });\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, r.getProvider = function () {\n    try {\n      return Promise.resolve(this.provider);\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, r.getChainId = function () {\n    try {\n      return Promise.resolve(this.provider.send(\"eth_chainId\"));\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, r.getAccount = function () {\n    try {\n      return Promise.resolve(this.provider.send(\"eth_accounts\").then(function (t) {\n        return t[0];\n      }));\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, r.deactivate = function () {\n    this.provider.removeListener(\"networkChanged\", this.handleNetworkChanged).removeListener(\"chainChanged\", this.handleChainChanged).removeListener(\"accountsChanged\", this.handleAccountsChanged).removeListener(\"close\", this.handleClose);\n  }, e;\n}(Wt);\n\nfunction Ae() {\n  return (Ae = Object.assign || function (t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var r = arguments[e];\n\n      for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n]);\n    }\n\n    return t;\n  }).apply(this, arguments);\n}\n\nfunction ke(t, e) {\n  t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;\n}\n\nfunction Te(t) {\n  return (Te = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {\n    return t.__proto__ || Object.getPrototypeOf(t);\n  })(t);\n}\n\nfunction je(t, e) {\n  return (je = Object.setPrototypeOf || function (t, e) {\n    return t.__proto__ = e, t;\n  })(t, e);\n}\n\nfunction xe() {\n  if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n  if (Reflect.construct.sham) return !1;\n  if (\"function\" == typeof Proxy) return !0;\n\n  try {\n    return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0;\n  } catch (t) {\n    return !1;\n  }\n}\n\nfunction Be(t, e, r) {\n  return (Be = xe() ? Reflect.construct : function (t, e, r) {\n    var n = [null];\n    n.push.apply(n, e);\n    var o = new (Function.bind.apply(t, n))();\n    return r && je(o, r.prototype), o;\n  }).apply(null, arguments);\n}\n\nfunction Me(t) {\n  var e = \"function\" == typeof Map ? new Map() : void 0;\n  return (Me = function (t) {\n    if (null === t || (r = t, -1 === Function.toString.call(r).indexOf(\"[native code]\"))) return t;\n    var r;\n    if (\"function\" != typeof t) throw new TypeError(\"Super expression must either be null or a function\");\n\n    if (void 0 !== e) {\n      if (e.has(t)) return e.get(t);\n      e.set(t, n);\n    }\n\n    function n() {\n      return Be(t, arguments, Te(this).constructor);\n    }\n\n    return n.prototype = Object.create(t.prototype, {\n      constructor: {\n        value: n,\n        enumerable: !1,\n        writable: !0,\n        configurable: !0\n      }\n    }), je(n, t);\n  })(t);\n}\n\nfunction Ue(t) {\n  if (void 0 === t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return t;\n}\n\n\"undefined\" != typeof Symbol && (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))), \"undefined\" != typeof Symbol && (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\")));\n\nfunction Le(t, e) {\n  try {\n    var r = t();\n  } catch (t) {\n    return e(t);\n  }\n\n  return r && r.then ? r.then(void 0, e) : r;\n}\n\nfunction Ve(t) {\n  return t.hasOwnProperty(\"result\") ? t.result : t;\n}\n\nvar Fe = function (t) {\n  function e() {\n    var e;\n    return (e = t.call(this) || this).name = e.constructor.name, e.message = \"No Ethereum provider was found on window.ethereum.\", e;\n  }\n\n  return ke(e, t), e;\n}(Me(Error)),\n    qe = function (t) {\n  function e() {\n    var e;\n    return (e = t.call(this) || this).name = e.constructor.name, e.message = \"The user rejected the request.\", e;\n  }\n\n  return ke(e, t), e;\n}(Me(Error)),\n    We = function (t) {\n  function e(e) {\n    var r;\n    return (r = t.call(this, e) || this).handleNetworkChanged = r.handleNetworkChanged.bind(Ue(r)), r.handleChainChanged = r.handleChainChanged.bind(Ue(r)), r.handleAccountsChanged = r.handleAccountsChanged.bind(Ue(r)), r.handleClose = r.handleClose.bind(Ue(r)), r;\n  }\n\n  ke(e, t);\n  var r = e.prototype;\n  return r.handleChainChanged = function (t) {\n    \"production\" !== process.env.NODE_ENV && console.log(\"Handling 'chainChanged' event with payload\", t), this.emitUpdate({\n      chainId: t,\n      provider: window.ethereum\n    });\n  }, r.handleAccountsChanged = function (t) {\n    \"production\" !== process.env.NODE_ENV && console.log(\"Handling 'accountsChanged' event with payload\", t), 0 === t.length ? this.emitDeactivate() : this.emitUpdate({\n      account: t[0]\n    });\n  }, r.handleClose = function (t, e) {\n    \"production\" !== process.env.NODE_ENV && console.log(\"Handling 'close' event with payload\", t, e), this.emitDeactivate();\n  }, r.handleNetworkChanged = function (t) {\n    \"production\" !== process.env.NODE_ENV && console.log(\"Handling 'networkChanged' event with payload\", t), this.emitUpdate({\n      chainId: t,\n      provider: window.ethereum\n    });\n  }, r.activate = function () {\n    try {\n      var t,\n          e = function (e) {\n        if (r) return e;\n\n        function n() {\n          return Ae({\n            provider: window.ethereum\n          }, t ? {\n            account: t\n          } : {});\n        }\n\n        var o = function () {\n          if (!t) return Promise.resolve(window.ethereum.enable().then(function (t) {\n            return t && Ve(t)[0];\n          })).then(function (e) {\n            t = e;\n          });\n        }();\n\n        return o && o.then ? o.then(n) : n();\n      },\n          r = !1;\n\n      if (!window.ethereum) throw new Fe();\n      window.ethereum.on && (window.ethereum.on(\"chainChanged\", this.handleChainChanged), window.ethereum.on(\"accountsChanged\", this.handleAccountsChanged), window.ethereum.on(\"close\", this.handleClose), window.ethereum.on(\"networkChanged\", this.handleNetworkChanged)), window.ethereum.isMetaMask && (window.ethereum.autoRefreshOnNetworkChange = !1);\n      var n = Le(function () {\n        return Promise.resolve(window.ethereum.send(\"eth_requestAccounts\").then(function (t) {\n          return Ve(t)[0];\n        })).then(function (e) {\n          t = e;\n        });\n      }, function (t) {\n        if (4001 === t.code) throw new qe();\n        \"production\" !== process.env.NODE_ENV && ht(!1, \"eth_requestAccounts was unsuccessful, falling back to enable\");\n      });\n      return Promise.resolve(n && n.then ? n.then(e) : e(n));\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, r.getProvider = function () {\n    try {\n      return Promise.resolve(window.ethereum);\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, r.getChainId = function () {\n    try {\n      var t,\n          e = function () {\n        function e() {\n          if (!t) try {\n            t = Ve(window.ethereum.send({\n              method: \"net_version\"\n            }));\n          } catch (t) {\n            \"production\" !== process.env.NODE_ENV && ht(!1, \"net_version v2 was unsuccessful, falling back to manual matches and static properties\");\n          }\n          return t || (t = window.ethereum.isDapper ? Ve(window.ethereum.cachedResults.net_version) : window.ethereum.chainId || window.ethereum.netVersion || window.ethereum.networkVersion || window.ethereum._chainId), t;\n        }\n\n        var r = function () {\n          if (!t) {\n            var e = Le(function () {\n              return Promise.resolve(window.ethereum.send(\"net_version\").then(Ve)).then(function (e) {\n                t = e;\n              });\n            }, function () {\n              \"production\" !== process.env.NODE_ENV && ht(!1, \"net_version was unsuccessful, falling back to net version v2\");\n            });\n            if (e && e.then) return e.then(function () {});\n          }\n        }();\n\n        return r && r.then ? r.then(e) : e();\n      };\n\n      if (!window.ethereum) throw new Fe();\n      var r = Le(function () {\n        return Promise.resolve(window.ethereum.send(\"eth_chainId\").then(Ve)).then(function (e) {\n          t = e;\n        });\n      }, function () {\n        \"production\" !== process.env.NODE_ENV && ht(!1, \"eth_chainId was unsuccessful, falling back to net_version\");\n      });\n      return Promise.resolve(r && r.then ? r.then(e) : e());\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, r.getAccount = function () {\n    try {\n      var t,\n          e = function () {\n        function e() {\n          return t || (t = Ve(window.ethereum.send({\n            method: \"eth_accounts\"\n          }))[0]), t;\n        }\n\n        var r = function () {\n          if (!t) {\n            var e = Le(function () {\n              return Promise.resolve(window.ethereum.enable().then(function (t) {\n                return Ve(t)[0];\n              })).then(function (e) {\n                t = e;\n              });\n            }, function () {\n              \"production\" !== process.env.NODE_ENV && ht(!1, \"enable was unsuccessful, falling back to eth_accounts v2\");\n            });\n            if (e && e.then) return e.then(function () {});\n          }\n        }();\n\n        return r && r.then ? r.then(e) : e();\n      };\n\n      if (!window.ethereum) throw new Fe();\n      var r = Le(function () {\n        return Promise.resolve(window.ethereum.send(\"eth_accounts\").then(function (t) {\n          return Ve(t)[0];\n        })).then(function (e) {\n          t = e;\n        });\n      }, function () {\n        \"production\" !== process.env.NODE_ENV && ht(!1, \"eth_accounts was unsuccessful, falling back to enable\");\n      });\n      return Promise.resolve(r && r.then ? r.then(e) : e());\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, r.deactivate = function () {\n    window.ethereum && window.ethereum.removeListener && (window.ethereum.removeListener(\"chainChanged\", this.handleChainChanged), window.ethereum.removeListener(\"accountsChanged\", this.handleAccountsChanged), window.ethereum.removeListener(\"close\", this.handleClose), window.ethereum.removeListener(\"networkChanged\", this.handleNetworkChanged));\n  }, r.isAuthorized = function () {\n    try {\n      return window.ethereum ? Promise.resolve(Le(function () {\n        return Promise.resolve(window.ethereum.send(\"eth_accounts\").then(function (t) {\n          return Ve(t).length > 0;\n        }));\n      }, function () {\n        return !1;\n      })) : Promise.resolve(!1);\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, e;\n}(Wt);\n\nfunction $e(t) {\n  if (void 0 === t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return t;\n}\n\nvar ze = {\n  1: \"mainnet\",\n  3: \"ropsten\",\n  4: \"rinkeby\",\n  5: \"goerli\",\n  42: \"kovan\",\n  100: \"xdai\",\n  30: \"orchid\",\n  31: \"orchidTestnet\",\n  99: \"core\",\n  77: \"sokol\",\n  61: \"classic\",\n  8: \"ubiq\",\n  108: \"thundercore\",\n  18: \"thundercoreTestnet\",\n  163: \"lightstreams\",\n  122: \"fuse\",\n  15001: \"maticTestnet\"\n},\n    Ge = function (t) {\n  var e, r;\n\n  function n(e) {\n    var r,\n        n = e.dAppId,\n        o = e.networks,\n        i = e.config,\n        s = void 0 === i ? {} : i,\n        c = o.map(function (t) {\n      return \"number\" == typeof t ? t : Number(t.chainId);\n    });\n    return c.every(function (t) {\n      return !!ze[t];\n    }) || (\"production\" !== process.env.NODE_ENV ? ut(!1, \"One or more unsupported networks \" + o) : ut(!1)), (r = t.call(this, {\n      supportedChainIds: c\n    }) || this).dAppId = n, r.networks = o, r.config = s, r.handleOnLogout = r.handleOnLogout.bind($e(r)), r.handleOnActiveWalletChanged = r.handleOnActiveWalletChanged.bind($e(r)), r.handleOnError = r.handleOnError.bind($e(r)), r;\n  }\n\n  r = t, (e = n).prototype = Object.create(r.prototype), e.prototype.constructor = e, e.__proto__ = r;\n  var o = n.prototype;\n  return o.handleOnLogout = function () {\n    \"production\" !== process.env.NODE_ENV && console.log(\"Handling 'onLogout' event\"), this.emitDeactivate();\n  }, o.handleOnActiveWalletChanged = function (t) {\n    \"production\" !== process.env.NODE_ENV && console.log(\"Handling 'onActiveWalletChanged' event with payload\", t), this.emitUpdate({\n      account: t\n    });\n  }, o.handleOnError = function (t) {\n    \"production\" !== process.env.NODE_ENV && console.log(\"Handling 'onError' event\"), this.emitError(t);\n  }, o.activate = function () {\n    try {\n      var t = function () {\n        return e.portis.onLogout(e.handleOnLogout), e.portis.onActiveWalletChanged(e.handleOnActiveWalletChanged), e.portis.onError(e.handleOnError), Promise.resolve(e.portis.provider.enable().then(function (t) {\n          return t[0];\n        })).then(function (t) {\n          return {\n            provider: e.portis.provider,\n            account: t\n          };\n        });\n      },\n          e = this,\n          r = function () {\n        if (!e.portis) return Promise.resolve(import(\"./index-b6b58529.js\")).then(function (t) {\n          var r = t.default;\n          e.portis = new r(e.dAppId, \"number\" == typeof e.networks[0] ? ze[e.networks[0]] : e.networks[0], e.config);\n        });\n      }();\n\n      return Promise.resolve(r && r.then ? r.then(t) : t());\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.getProvider = function () {\n    try {\n      return Promise.resolve(this.portis.provider);\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.getChainId = function () {\n    try {\n      return Promise.resolve(this.portis.provider.send(\"eth_chainId\"));\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.getAccount = function () {\n    try {\n      return Promise.resolve(this.portis.provider.send(\"eth_accounts\").then(function (t) {\n        return t[0];\n      }));\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.deactivate = function () {\n    this.portis.onLogout(function () {}), this.portis.onActiveWalletChanged(function () {}), this.portis.onError(function () {});\n  }, o.changeNetwork = function (t, e) {\n    try {\n      return \"number\" == typeof t ? (ze[t] || (\"production\" !== process.env.NODE_ENV ? ut(!1, \"Invalid chainId \" + t) : ut(!1)), this.portis.changeNetwork(ze[t], e), this.emitUpdate({\n        chainId: t\n      })) : (this.portis.changeNetwork(t, e), this.emitUpdate({\n        chainId: Number(t.chainId)\n      })), Promise.resolve();\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.close = function () {\n    try {\n      var t = this;\n      return Promise.resolve(t.portis.logout()).then(function () {\n        t.emitDeactivate();\n      });\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, n;\n}(Wt);\n\nvar He = {\n  1: \"mainnet\",\n  3: \"ropsten\",\n  4: \"rinkeby\",\n  5: \"goerli\",\n  42: \"kovan\",\n  100: \"xdai\"\n},\n    Je = function (t) {\n  var e, r;\n\n  function n(e) {\n    var r,\n        n = e.clientId,\n        o = e.networks,\n        i = e.options,\n        s = void 0 === i ? {} : i,\n        c = o.map(function (t) {\n      return \"number\" == typeof t ? t : t.chainId;\n    });\n    return c.every(function (t) {\n      return !!He[t];\n    }) || (\"production\" !== process.env.NODE_ENV ? ut(!1, \"One or more unsupported networks \" + o) : ut(!1)), (r = t.call(this, {\n      supportedChainIds: c\n    }) || this).clientId = n, r.networks = o, r.options = s, r;\n  }\n\n  r = t, (e = n).prototype = Object.create(r.prototype), e.prototype.constructor = e, e.__proto__ = r;\n  var o = n.prototype;\n  return o.activate = function () {\n    try {\n      var t = function () {\n        return Promise.resolve(e.squarelink.getProvider()).then(function (t) {\n          return Promise.resolve(t.enable().then(function (t) {\n            return t[0];\n          })).then(function (e) {\n            return {\n              provider: t,\n              account: e\n            };\n          });\n        });\n      },\n          e = this,\n          r = function () {\n        if (!e.squarelink) return Promise.resolve(import(\"squarelink\")).then(function (t) {\n          var r = t.default;\n          e.squarelink = new r(e.clientId, \"number\" == typeof e.networks[0] ? He[e.networks[0]] : e.networks[0], e.options);\n        });\n      }();\n\n      return Promise.resolve(r && r.then ? r.then(t) : t());\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.getProvider = function () {\n    try {\n      return Promise.resolve(this.squarelink.getProvider());\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.getChainId = function () {\n    try {\n      return Promise.resolve(this.squarelink.getProvider().then(function (t) {\n        return t.send(\"eth_chainId\");\n      }));\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.getAccount = function () {\n    try {\n      return Promise.resolve(this.squarelink.getProvider().then(function (t) {\n        return t.send(\"eth_accounts\").then(function (t) {\n          return t[0];\n        });\n      }));\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.deactivate = function () {}, n;\n}(Wt);\n\nfunction Ke() {\n  return (Ke = Object.assign || function (t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var r = arguments[e];\n\n      for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n]);\n    }\n\n    return t;\n  }).apply(this, arguments);\n}\n\nvar Xe = function (t) {\n  var e, r;\n\n  function n(e) {\n    var r,\n        n = e.url,\n        o = e.appName,\n        i = e.appLogoUrl,\n        s = e.darkMode;\n    return (r = t.call(this, {\n      supportedChainIds: [1]\n    }) || this).url = n, r.appName = o, r.appLogoUrl = i, r.darkMode = s || !1, r;\n  }\n\n  r = t, (e = n).prototype = Object.create(r.prototype), e.prototype.constructor = e, e.__proto__ = r;\n  var o = n.prototype;\n  return o.activate = function () {\n    try {\n      var t = function () {\n        return Promise.resolve(e.provider.send(\"eth_requestAccounts\").then(function (t) {\n          return t[0];\n        })).then(function (t) {\n          return {\n            provider: e.provider,\n            chainId: 1,\n            account: t\n          };\n        });\n      },\n          e = this,\n          r = function () {\n        if (!e.walletLink) return Promise.resolve(import(\"./index-a004146a.js\")).then(function (t) {\n          var r = t.default;\n          e.walletLink = new r(Ke({\n            appName: e.appName,\n            darkMode: e.darkMode\n          }, e.appLogoUrl ? {\n            appLogoUrl: e.appLogoUrl\n          } : {})), e.provider = e.walletLink.makeWeb3Provider(e.url, 1);\n        });\n      }();\n\n      return Promise.resolve(r && r.then ? r.then(t) : t());\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.getProvider = function () {\n    try {\n      return Promise.resolve(this.provider);\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.getChainId = function () {\n    return Promise.resolve(1);\n  }, o.getAccount = function () {\n    try {\n      return Promise.resolve(this.provider.send(\"eth_accounts\").then(function (t) {\n        return t[0];\n      }));\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.deactivate = function () {}, o.close = function () {\n    try {\n      return this.provider.close(), this.emitDeactivate(), Promise.resolve();\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, n;\n}(Wt);\n\nconst Ye = new Map([[\"1\", \"Mainnet\"], [\"2\", \"Expanse\"], [\"3\", \"Ropsten\"], [\"4\", \"Rinkeby\"], [\"5\", \"Goerli\"], [\"42\", \"Kovan\"], [\"100\", \"xDai\"], [\"1337\", \"Local\"], [\"5777\", \"Ganache\"]]);\n\nfunction Qe(t) {\n  return t = String(t), Ye.get(t) || \"Unknown\";\n}\n\nfunction Ze(t) {\n  if (\"object\" == typeof t && \"jsonrpc\" in t) {\n    if (t.error) throw new Error(t.error);\n    return t.result || null;\n  }\n\n  return t || null;\n}\n\nasync function tr(t, e, r) {\n  return t.sendAsync && t.selectedAddress ? new Promise((n, o) => {\n    t.sendAsync({\n      method: e,\n      params: r,\n      from: t.selectedAddress,\n      jsonrpc: \"2.0\",\n      id: 0\n    }, (t, e) => {\n      t ? o(t) : n(e);\n    });\n  }).then(Ze) : t.send(e, r).then(Ze);\n}\n\nfunction er(t, e) {\n  let r = -1,\n      n = !1;\n\n  const o = async (t, i) => {\n    const s = await t();\n    n || (i(s), r = setTimeout(o.bind(null, t, i), e));\n  };\n\n  return (...e) => {\n    const {\n      request: i,\n      onResult: s\n    } = t(...e);\n    return n = !1, o(i, s), () => {\n      n = !0, clearTimeout(r);\n    };\n  };\n}\n\nclass rr extends Error {\n  constructor(t, e, ...r) {\n    super(...r), this.name = \"ChainUnsupportedError\", this.message = `Unsupported chain: ${Qe(t)}${-1 === t ? \"\" : ` (Chain ID: ${t})`}. ` + `Required chain: ${Qe(e)} (Chain ID: ${e}).`;\n  }\n\n}\n\nclass nr extends Error {\n  constructor(t, ...e) {\n    super(...e), this.name = \"ConnectorUnsupportedError\", this.message = `Unsupported connector: ${t}.`;\n  }\n\n}\n\nclass or extends Error {\n  constructor(...t) {\n    super(...t), this.name = \"ConnectionRejectedError\", this.message = \"The activation has been rejected by the provider.\";\n  }\n\n}\n\nclass ir extends Error {\n  constructor(...t) {\n    super(...t), this.name = \"ConnectorConfigError\";\n  }\n\n}\n\nvar sr;\n!function (t) {\n  t.Update = \"Web3ReactUpdate\", t.Error = \"Web3ReactError\", t.Deactivate = \"Web3ReactDeactivate\";\n}(sr || (sr = {}));\n\nvar cr = function (t) {\n  var e, r;\n\n  function n(e) {\n    var r,\n        n = (void 0 === e ? {} : e).supportedChainIds;\n    return (r = t.call(this) || this).supportedChainIds = n, r;\n  }\n\n  r = t, (e = n).prototype = Object.create(r.prototype), e.prototype.constructor = e, e.__proto__ = r;\n  var o = n.prototype;\n  return o.emitUpdate = function (t) {\n    \"production\" !== process.env.NODE_ENV && console.log(\"Emitting '\" + sr.Update + \"' with payload\", t), this.emit(sr.Update, t);\n  }, o.emitError = function (t) {\n    \"production\" !== process.env.NODE_ENV && console.log(\"Emitting '\" + sr.Error + \"' with payload\", t), this.emit(sr.Error, t);\n  }, o.emitDeactivate = function () {\n    \"production\" !== process.env.NODE_ENV && console.log(\"Emitting '\" + sr.Deactivate + \"'\"), this.emit(sr.Deactivate);\n  }, n;\n}(f),\n    ar = \"production\" === process.env.NODE_ENV;\n\nfunction ur(t, e) {\n  if (!t) {\n    if (ar) throw new Error(\"Invariant failed\");\n    throw new Error(\"Invariant failed: \" + (e || \"\"));\n  }\n}\n\nfunction lr(t, e) {\n  t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e;\n}\n\nfunction hr(t) {\n  return (hr = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) {\n    return t.__proto__ || Object.getPrototypeOf(t);\n  })(t);\n}\n\nfunction fr(t, e) {\n  return (fr = Object.setPrototypeOf || function (t, e) {\n    return t.__proto__ = e, t;\n  })(t, e);\n}\n\nfunction dr() {\n  if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n  if (Reflect.construct.sham) return !1;\n  if (\"function\" == typeof Proxy) return !0;\n\n  try {\n    return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0;\n  } catch (t) {\n    return !1;\n  }\n}\n\nfunction pr(t, e, r) {\n  return (pr = dr() ? Reflect.construct : function (t, e, r) {\n    var n = [null];\n    n.push.apply(n, e);\n    var o = new (Function.bind.apply(t, n))();\n    return r && fr(o, r.prototype), o;\n  }).apply(null, arguments);\n}\n\nfunction _r(t) {\n  var e = \"function\" == typeof Map ? new Map() : void 0;\n  return (_r = function (t) {\n    if (null === t || (r = t, -1 === Function.toString.call(r).indexOf(\"[native code]\"))) return t;\n    var r;\n    if (\"function\" != typeof t) throw new TypeError(\"Super expression must either be null or a function\");\n\n    if (void 0 !== e) {\n      if (e.has(t)) return e.get(t);\n      e.set(t, n);\n    }\n\n    function n() {\n      return pr(t, arguments, hr(this).constructor);\n    }\n\n    return n.prototype = Object.create(t.prototype, {\n      constructor: {\n        value: n,\n        enumerable: !1,\n        writable: !0,\n        configurable: !0\n      }\n    }), fr(n, t);\n  })(t);\n}\n\nfunction gr(t) {\n  if (void 0 === t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return t;\n}\n\nvar mr = function (t) {\n  function e() {\n    var e;\n    return (e = t.call(this) || this).name = e.constructor.name, e.message = \"The user rejected the request.\", e;\n  }\n\n  return lr(e, t), e;\n}(_r(Error)),\n    vr = function (t) {\n  function e(e) {\n    var r,\n        n = e.rpc,\n        o = e.bridge,\n        i = e.qrcode,\n        s = e.pollingInterval;\n    return 1 !== Object.keys(n).length && (\"production\" !== process.env.NODE_ENV ? ur(!1, \"@walletconnect/web3-provider is broken with >1 chainId, please use 1\") : ur(!1)), (r = t.call(this, {\n      supportedChainIds: Object.keys(n).map(function (t) {\n        return Number(t);\n      })\n    }) || this).rpc = n, r.bridge = o, r.qrcode = i, r.pollingInterval = s, r.handleChainChanged = r.handleChainChanged.bind(gr(r)), r.handleAccountsChanged = r.handleAccountsChanged.bind(gr(r)), r.handleDisconnect = r.handleDisconnect.bind(gr(r)), r;\n  }\n\n  lr(e, t);\n  var r = e.prototype;\n  return r.handleChainChanged = function (t) {\n    \"production\" !== process.env.NODE_ENV && console.log(\"Handling 'chainChanged' event with payload\", t), this.emitUpdate({\n      chainId: t\n    });\n  }, r.handleAccountsChanged = function (t) {\n    \"production\" !== process.env.NODE_ENV && console.log(\"Handling 'accountsChanged' event with payload\", t), this.emitUpdate({\n      account: t[0]\n    });\n  }, r.handleDisconnect = function () {\n    \"production\" !== process.env.NODE_ENV && console.log(\"Handling 'disconnect' event\"), this.emitDeactivate(), this.walletConnectProvider && (this.walletConnectProvider.stop(), this.walletConnectProvider.removeListener(\"chainChanged\", this.handleChainChanged), this.walletConnectProvider.removeListener(\"accountsChanged\", this.handleAccountsChanged), this.walletConnectProvider = void 0), this.emitDeactivate();\n  }, r.activate = function () {\n    try {\n      var t = function () {\n        function t() {\n          return Promise.resolve(e.walletConnectProvider.enable().then(function (t) {\n            return t[0];\n          }).catch(function (t) {\n            if (\"User closed modal\" === t.message) throw new mr();\n            throw t;\n          })).then(function (t) {\n            return e.walletConnectProvider.on(\"disconnect\", e.handleDisconnect), e.walletConnectProvider.on(\"chainChanged\", e.handleChainChanged), e.walletConnectProvider.on(\"accountsChanged\", e.handleAccountsChanged), {\n              provider: e.walletConnectProvider,\n              account: t\n            };\n          });\n        }\n\n        var r = function () {\n          if (!e.walletConnectProvider.wc.connected) return Promise.resolve(e.walletConnectProvider.wc.createSession({\n            chainId: Number(Object.keys(e.rpc)[0])\n          })).then(function () {\n            e.emit(\"URI_AVAILABLE\", e.walletConnectProvider.wc.uri);\n          });\n        }();\n\n        return r && r.then ? r.then(t) : t();\n      },\n          e = this,\n          r = function () {\n        if (!e.walletConnectProvider) return Promise.resolve(import(\"./index-1d2649b8.js\").then(function (t) {\n          var e;\n          return null != (e = null == t ? void 0 : t.default) ? e : t;\n        })).then(function (t) {\n          e.walletConnectProvider = new t({\n            bridge: e.bridge,\n            rpc: e.rpc,\n            qrcode: e.qrcode,\n            pollingInterval: e.pollingInterval\n          });\n        });\n      }();\n\n      return Promise.resolve(r && r.then ? r.then(t) : t());\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, r.getProvider = function () {\n    try {\n      return Promise.resolve(this.walletConnectProvider);\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, r.getChainId = function () {\n    try {\n      return Promise.resolve(this.walletConnectProvider.send(\"eth_chainId\"));\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, r.getAccount = function () {\n    try {\n      return Promise.resolve(this.walletConnectProvider.send(\"eth_accounts\").then(function (t) {\n        return t[0];\n      }));\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, r.deactivate = function () {\n    this.walletConnectProvider && (this.walletConnectProvider.stop(), this.walletConnectProvider.removeListener(\"disconnect\", this.handleDisconnect), this.walletConnectProvider.removeListener(\"chainChanged\", this.handleChainChanged), this.walletConnectProvider.removeListener(\"accountsChanged\", this.handleAccountsChanged));\n  }, r.close = function () {\n    try {\n      var t;\n      return Promise.resolve(null == (t = this.walletConnectProvider) ? void 0 : t.close()).then(function () {});\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, e;\n}(cr);\n\nvar yr = function (t) {\n  var e, r;\n\n  function n(e) {\n    var r,\n        n = e.chainId,\n        o = e.initOptions,\n        i = void 0 === o ? {} : o,\n        s = e.constructorOptions,\n        c = void 0 === s ? {} : s,\n        a = e.loginOptions,\n        u = void 0 === a ? {} : a;\n    return (r = t.call(this, {\n      supportedChainIds: [n]\n    }) || this).chainId = n, r.initOptions = i, r.constructorOptions = c, r.loginOptions = u, r;\n  }\n\n  r = t, (e = n).prototype = Object.create(r.prototype), e.prototype.constructor = e, e.__proto__ = r;\n  var o = n.prototype;\n  return o.activate = function () {\n    try {\n      var t = function () {\n        return Promise.resolve(e.torus.login(e.loginOptions).then(function (t) {\n          return t[0];\n        })).then(function (t) {\n          return {\n            provider: e.torus.provider,\n            account: t\n          };\n        });\n      },\n          e = this,\n          r = function () {\n        if (!e.torus) return Promise.resolve(import(\"./torus.cjs-c0df7a64.js\")).then(function (t) {\n          var r = t.default;\n          return e.torus = new r(e.constructorOptions), Promise.resolve(e.torus.init(e.initOptions)).then(function () {});\n        });\n      }();\n\n      return Promise.resolve(r && r.then ? r.then(t) : t());\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.getProvider = function () {\n    try {\n      return Promise.resolve(this.torus.provider);\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.getChainId = function () {\n    try {\n      return Promise.resolve(this.chainId);\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.getAccount = function () {\n    try {\n      return Promise.resolve(this.torus.ethereum.send(\"eth_accounts\").then(function (t) {\n        return t[0];\n      }));\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.deactivate = function () {\n    try {\n      var t = this;\n      return Promise.resolve(t.torus.cleanUp()).then(function () {\n        t.torus = void 0;\n      });\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, o.close = function () {\n    try {\n      var t = this;\n      return Promise.resolve(t.torus.logout()).then(function () {\n        t.emitDeactivate();\n      });\n    } catch (t) {\n      return Promise.reject(t);\n    }\n  }, n;\n}(Wt);\n\nconst br = t.createContext(null);\n\nfunction wr() {\n  const t = r(br);\n  if (null === t) throw new Error(\"useWallet() can only be used inside of <UseWalletProvider />, please declare it at a higher level.\");\n\n  const n = function () {\n    const t = r(br),\n          [e, n] = a(null),\n          c = o(!1),\n          u = i(() => (c.current = !0, t.addBlockNumberListener(n), e), [t, e]);\n    return s(() => {\n      if (c.current) return t.addBlockNumberListener(n), () => {\n        t.removeBlockNumberListener(n);\n      };\n    }, [c, t]), u;\n  }(),\n        {\n    wallet: c\n  } = t;\n\n  return e(() => ({ ...c,\n    getBlockNumber: n\n  }), [n, c]);\n}\n\nfunction Er({\n  account: t,\n  ethereum: e,\n  pollBalanceInterval: r\n}) {\n  const [n, o] = a(\"-1\");\n  return s(() => {\n    if (!t || !e) return;\n    let n = !1;\n    const i = er((t, e, r) => {\n      let o = \"-1\";\n      return {\n        request: async () => async function (t, e) {\n          return tr(t, \"eth_getBalance\", [e, \"latest\"]);\n        }(e, t).then(t => t ? qt.BigInt(t).toString() : \"-1\").catch(() => \"-1\"),\n\n        onResult(t) {\n          n || t === o || (o = t, r(t));\n        }\n\n      };\n    }, r)(t, e, o);\n    return () => {\n      n = !0, i(), o(\"-1\");\n    };\n  }, [t, e, r]), n;\n}\n\nfunction Cr({\n  ethereum: t,\n  pollBlockNumberInterval: e\n}) {\n  const r = o(null),\n        n = o(new Set()),\n        c = i(t => {\n    n.current.has(t) || (t(r.current), n.current.add(t));\n  }, []),\n        a = i(t => {\n    n.current.delete(t);\n  }, []),\n        u = i(t => {\n    r.current !== t && (r.current = t, n.current.forEach(e => e(t)));\n  }, []);\n  return s(() => {\n    if (!t) return void u(null);\n    let r = !1;\n    const n = er(() => ({\n      request: () => async function (t) {\n        return tr(t, \"eth_blockNumber\", []);\n      }(t),\n      onResult: t => {\n        r || u(null === t ? null : qt.BigInt(t).toString());\n      }\n    }), e)();\n    return () => {\n      r = !0, n();\n    };\n  }, [t, e, u]), {\n    addBlockNumberListener: c,\n    removeBlockNumberListener: a\n  };\n}\n\nfunction Or({\n  chainId: n,\n  children: c,\n  connectors: h,\n  pollBalanceInterval: f,\n  pollBlockNumberInterval: d\n}) {\n  if (null !== r(br)) throw new Error(\"<UseWalletProvider /> has already been declared.\");\n  const [p, _] = a(null),\n        [g, m] = a(null),\n        [v, y] = a(null),\n        [b, w] = a(\"disconnected\"),\n        E = Ft(),\n        C = o(0),\n        {\n    account: O,\n    library: P\n  } = E,\n        N = Er({\n    account: O,\n    ethereum: P,\n    pollBalanceInterval: f\n  }),\n        {\n    addBlockNumberListener: I,\n    removeBlockNumberListener: D\n  } = Cr({\n    ethereum: P,\n    pollBlockNumberInterval: d\n  }),\n        S = e(() => function (t, e = {}) {\n    const [r, n] = Object.entries(e).reduce(([t, e], [r, n]) => \"function\" == typeof n.web3ReactConnector ? [{ ...t,\n      [r]: n\n    }, e] : [t, [...e, [r, n]]], [{}, []]),\n          o = {\n      injected: {\n        web3ReactConnector: ({\n          chainId: t\n        }) => new We({\n          supportedChainIds: [t]\n        }),\n\n        handleActivationError(t) {\n          if (t instanceof qe) return new or();\n        }\n\n      },\n      frame: {\n        web3ReactConnector: ({\n          chainId: t\n        }) => new Re({\n          supportedChainIds: [t]\n        }),\n        handleActivationError: t => t instanceof Se ? new or() : t.message.startsWith(\"JSON.parse\") ? new Error(\"There seems to be an issue when trying to connect to Frame.\") : void 0\n      },\n      fortmatic: {\n        web3ReactConnector({\n          chainId: t,\n          apiKey: e\n        }) {\n          if (!e) throw new ir(\"The Fortmatic connector requires apiKey to be set.\");\n          return new Jt({\n            apiKey: e,\n            chainId: t\n          });\n        }\n\n      },\n      portis: {\n        web3ReactConnector({\n          chainId: t,\n          dAppId: e\n        }) {\n          if (!e) throw new ir(\"The Portis connector requires dAppId to be set.\");\n          return new Ge({\n            dAppId: e,\n            networks: [t]\n          });\n        }\n\n      },\n      provided: {\n        web3ReactConnector: ({\n          chainId: t,\n          provider: e\n        }) => new u({\n          provider: e,\n          supportedChainIds: [t]\n        }),\n\n        handleActivationError(t) {\n          if (t instanceof l) return new or();\n        }\n\n      },\n      authereum: {\n        web3ReactConnector: ({\n          chainId: t\n        }) => new Gt({\n          chainId: t\n        })\n      },\n      squarelink: {\n        web3ReactConnector: ({\n          chainId: t,\n          clientId: e,\n          options: r\n        }) => new Je({\n          clientId: e,\n          networks: [t],\n          options: r\n        })\n      },\n      torus: {\n        web3ReactConnector: ({\n          chainId: t,\n          initOptions: e,\n          constructorOptions: r\n        }) => new yr({\n          chainId: t,\n          constructorOptions: r,\n          initOptions: e\n        })\n      },\n      walletconnect: {\n        web3ReactConnector({\n          chainId: t,\n          rpcUrl: e,\n          bridge: r,\n          pollingInterval: n\n        }) {\n          if (!e) throw new ir(\"The WalletConnect connector requires rpcUrl to be set.\");\n          if (!/^https?:\\/\\//.test(e)) throw new ir(\"The WalletConnect connector requires rpcUrl to be an HTTP URL.\");\n          return new vr({\n            bridge: r,\n            pollingInterval: n,\n            qrcode: !0,\n            rpc: {\n              [t]: e\n            }\n          });\n        },\n\n        handleActivationError(t) {\n          if (t instanceof mr) return new or();\n        }\n\n      },\n      walletlink: {\n        web3ReactConnector({\n          chainId: t,\n          url: e,\n          appName: r,\n          appLogoUrl: n\n        }) {\n          if (1 !== t) throw new ir(\"The WalletLink connector requires chainId to be 1.\");\n          if (!/^https?:\\/\\//.test(e)) throw new ir(\"The WalletLink connector requires url to be an HTTP URL.\");\n          return new Xe({\n            url: e,\n            appName: r,\n            appLogoUrl: n\n          });\n        }\n\n      },\n      ...r\n    };\n\n    for (const [t, e] of n) o[t] && (o[t].config = e);\n\n    return o;\n  }(0, h), [n, h]),\n        R = i(() => {\n    E.active && E.deactivate(), _(null), m(null), w(\"disconnected\");\n  }, [E]),\n        A = i(async (t = \"injected\") => {\n    const e = ++C.current;\n    if (R(), e !== C.current) return;\n    if (!S[t]) return w(\"error\"), void m(new nr(t));\n    w(\"connecting\");\n    const r = S[t],\n          o = r && r.web3ReactConnector && r.web3ReactConnector({\n      chainId: n,\n      ...(r.config || {})\n    });\n    if (!o) return w(\"error\"), void m(new nr(t));\n\n    try {\n      _(t), await E.activate(o, null, !0), w(\"connected\");\n    } catch (t) {\n      if (e !== C.current) return;\n      if (_(null), w(\"error\"), t instanceof Bt) return void m(new rr(-1, n));\n\n      if (r.handleActivationError) {\n        const e = r.handleActivationError(t);\n        if (e) return void m(e);\n      }\n\n      m(t);\n    }\n  }, [n, S, R, E]);\n  s(() => {\n    if (!O || !P) return;\n    let t = !1;\n    return y(null), async function (t, e) {\n      try {\n        return \"0x\" !== (await tr(t, \"eth_getCode\", [e]));\n      } catch (t) {\n        return !1;\n      }\n    }(P, O).then(e => {\n      t || (w(\"connected\"), y(e ? \"contract\" : \"normal\"));\n    }), () => {\n      t = !0, w(\"disconnected\"), y(null);\n    };\n  }, [O, P]);\n  const k = e(() => ({\n    _web3ReactContext: E,\n    account: O || null,\n    balance: N,\n    chainId: n,\n    connect: A,\n    connector: p,\n    connectors: S,\n    error: g,\n    ethereum: P,\n    networkName: Qe(n),\n    reset: R,\n    status: b,\n    type: v\n  }), [O, N, n, A, p, S, g, P, v, R, b, E]);\n  return t.createElement(br.Provider, {\n    value: {\n      addBlockNumberListener: I,\n      pollBalanceInterval: f,\n      pollBlockNumberInterval: d,\n      removeBlockNumberListener: D,\n      wallet: k\n    }\n  }, c);\n}\n\nfunction Pr(e) {\n  return t.createElement(Vt, {\n    getLibrary: t => t\n  }, t.createElement(Or, e));\n}\n\nOr.propTypes = {\n  chainId: ct.number,\n  children: ct.node,\n  connectors: ct.objectOf(ct.object),\n  pollBalanceInterval: ct.number,\n  pollBlockNumberInterval: ct.number\n}, Or.defaultProps = {\n  chainId: 1,\n  connectors: {},\n  pollBalanceInterval: 2e3,\n  pollBlockNumberInterval: 5e3\n}, Pr.propTypes = Or.propTypes, Pr.defaultProps = Or.defaultProps;\nexport { or as C, Pr as U, rr as a, nr as b, wr as c, g as d, _ as e, d as f, p as g, m as h, h as r, wr as u };","map":null,"metadata":{},"sourceType":"module"}