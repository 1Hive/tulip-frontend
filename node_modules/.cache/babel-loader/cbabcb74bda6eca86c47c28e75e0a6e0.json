{"ast":null,"code":"'use strict';\n\nconst multiaddr = require('multiaddr');\n\nfunction cleanUrlSIO(ma) {\n  const maStrSplit = ma.toString().split('/');\n  const tcpProto = ma.protos()[1].name;\n  const wsProto = ma.protos()[2].name;\n  const tcpPort = ma.stringTuples()[1][1];\n\n  if (tcpProto !== 'tcp' || wsProto !== 'ws' && wsProto !== 'wss') {\n    throw new Error('invalid multiaddr: ' + ma.toString());\n  }\n\n  if (!multiaddr.isName(ma)) {\n    return 'http://' + maStrSplit[2] + ':' + maStrSplit[4];\n  }\n\n  if (wsProto === 'ws') {\n    return 'http://' + maStrSplit[2] + (tcpPort === 80 ? '' : ':' + tcpPort);\n  }\n\n  if (wsProto === 'wss') {\n    return 'https://' + maStrSplit[2] + (tcpPort === 443 ? '' : ':' + tcpPort);\n  }\n}\n\nfunction cleanMultiaddr(maStr) {\n  const legacy = '/libp2p-webrtc-star';\n\n  if (maStr.indexOf(legacy) !== -1) {\n    maStr = maStr.substring(legacy.length, maStr.length);\n    let ma = multiaddr(maStr);\n    const tuppleIPFS = ma.stringTuples().filter(tupple => {\n      return tupple[0] === 421; // ipfs code\n    })[0];\n    ma = ma.decapsulate('p2p');\n    ma = ma.encapsulate('/p2p-webrtc-star');\n    ma = ma.encapsulate(`/p2p/${tuppleIPFS[1]}`);\n    maStr = ma.toString();\n  }\n\n  return maStr;\n}\n\nexports = module.exports;\nexports.cleanUrlSIO = cleanUrlSIO;\nexports.cleanMultiaddr = cleanMultiaddr;","map":null,"metadata":{},"sourceType":"script"}