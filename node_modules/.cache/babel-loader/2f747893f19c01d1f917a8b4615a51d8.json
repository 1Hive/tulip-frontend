{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst tweetnacl_1 = __importDefault(require(\"tweetnacl\"));\n\nconst tweetnacl_util_1 = __importDefault(require(\"tweetnacl-util\"));\n\nconst hdnode_1 = require(\"@ethersproject/hdnode\");\n\nconst wallet_1 = require(\"@ethersproject/wallet\");\n\nconst did_jwt_1 = require(\"did-jwt\");\n\nconst js_sha256_1 = require(\"js-sha256\");\n\nconst elliptic_1 = require(\"elliptic\");\n\nconst crypto_1 = require(\"./crypto\");\n\nconst utils_1 = require(\"./utils\");\n\nconst ec = new elliptic_1.ec('secp256k1');\nconst BASE_PATH = \"m/51073068'/0'\";\nconst ROOT_STORE_PATH = \"0'/0'/0'/0'/0'/0'/0'/0'\";\nconst BASE_PATH_LEGACY = \"m/7696500'/0'/0'\";\nconst AUTH_PATH_WALLET = BASE_PATH + '/' + ROOT_STORE_PATH + '/0';\nconst AUTH_PATH_ENCRYPTION = BASE_PATH + '/' + ROOT_STORE_PATH + '/3';\n\nconst ensure0x = str => {\n  return (str.startsWith('0x') ? '' : '0x') + str;\n};\n\nclass Keyring {\n  constructor(seed, migratedKeys) {\n    this._spaceKeys = {};\n    this._migratedKeys = false;\n\n    if (seed) {\n      this._seed = seed;\n      this._baseNode = hdnode_1.HDNode.fromSeed(this._seed).derivePath(BASE_PATH);\n\n      const rootNode = this._baseNode.derivePath(ROOT_STORE_PATH);\n\n      this._rootKeys = this._deriveRootKeySet(rootNode);\n    }\n\n    if (migratedKeys) {\n      this._migratedKeys = true;\n\n      this._importMigratedKeys(migratedKeys);\n    }\n\n    if (!(seed || migratedKeys)) throw new Error('One or both of seed or migratedKeys required');\n  }\n\n  _importMigratedKeys(migratedKeysString) {\n    const migratedKeys = JSON.parse(migratedKeysString);\n\n    const getHDNode = seed => {\n      const seedNode = hdnode_1.HDNode.fromSeed(seed);\n      return seedNode.derivePath(BASE_PATH_LEGACY);\n    };\n\n    const rootNode = getHDNode(migratedKeys.seed);\n    this._rootKeys = this._deriveRootKeySet(rootNode);\n    this._rootKeys.managementAddress = migratedKeys.managementAddress;\n    this._rootKeys.managementKey = {\n      address: migratedKeys.managementAddress\n    };\n    Object.keys(migratedKeys.spaceSeeds).map(name => {\n      const spaceNode = getHDNode(migratedKeys.spaceSeeds[name]);\n      this._spaceKeys[name] = this._deriveKeySet(spaceNode);\n    });\n  }\n\n  _deriveKeySet(hdNode) {\n    return {\n      signingKey: hdNode.derivePath('0'),\n      asymEncryptionKey: tweetnacl_1.default.box.keyPair.fromSecretKey(new Uint8Array(Buffer.from(hdNode.derivePath('2').privateKey.slice(2), 'hex'))),\n      symEncryptionKey: utils_1.hexToUint8Array(hdNode.derivePath('3').privateKey.slice(2))\n    };\n  }\n\n  _deriveRootKeySet(hdNode) {\n    return Object.assign(Object.assign({}, this._deriveKeySet(hdNode)), {\n      managementKey: hdNode.derivePath('1')\n    });\n  }\n\n  _deriveSpaceKeys(space) {\n    var _a, _b;\n\n    const spaceHash = js_sha256_1.sha256(`${space}.3box`);\n    const spacePath = (_b = (_a = spaceHash.match(/.{1,12}/g)) === null || _a === void 0 ? void 0 : _a.map(n => parseInt(n, 16).toString(2)).map(n => `${n.length === 47 ? '0' : ''}${n}`).join('').match(/.{1,31}/g)) === null || _b === void 0 ? void 0 : _b.map(n => parseInt(n, 2)).join(\"'/\");\n\n    const spaceNode = this._baseNode.derivePath(`${spacePath}'`);\n\n    this._spaceKeys[space] = this._deriveKeySet(spaceNode);\n  }\n\n  _getKeys(space) {\n    if (!space) {\n      return this._rootKeys;\n    } else if (!this._spaceKeys[space]) {\n      if (this._migratedKeys) throw new Error('Can not derive space keys, not given in migrated keys');\n\n      this._deriveSpaceKeys(space);\n    }\n\n    return this._spaceKeys[space];\n  }\n\n  asymEncrypt(msg, toPublic, {\n    nonce\n  } = {}) {\n    return crypto_1.asymEncrypt(msg, toPublic, nonce);\n  }\n\n  asymDecrypt(ciphertext, fromPublic, nonce, {\n    space,\n    toBuffer\n  } = {}) {\n    const key = this._getKeys(space).asymEncryptionKey.secretKey;\n\n    return crypto_1.asymDecrypt(ciphertext, fromPublic, key, nonce, toBuffer);\n  }\n\n  symEncrypt(msg, {\n    space,\n    nonce\n  } = {}) {\n    return crypto_1.symEncryptBase(msg, this._getKeys(space).symEncryptionKey, nonce);\n  }\n\n  symDecrypt(ciphertext, nonce, {\n    space,\n    toBuffer\n  } = {}) {\n    return crypto_1.symDecryptBase(ciphertext, this._getKeys(space).symEncryptionKey, nonce, toBuffer);\n  }\n\n  managementPersonalSign(message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const wallet = this.managementWallet();\n      return yield wallet.signMessage(message);\n    });\n  }\n\n  managementWallet() {\n    const node = this._rootKeys.managementKey;\n    return new wallet_1.Wallet(node.privateKey);\n  }\n\n  getJWTSigner(space, useMgmt) {\n    const pubkeys = this._getKeys(space);\n\n    const key = useMgmt ? pubkeys.managementKey : pubkeys.signingKey;\n    return did_jwt_1.EllipticSigner(key.privateKey.slice(2));\n  }\n\n  getRootSigner(keyId) {\n    var _a, _b;\n\n    const key = keyId === 'managementKey' ? (_a = this._rootKeys) === null || _a === void 0 ? void 0 : _a.managementKey : (_b = this._rootKeys) === null || _b === void 0 ? void 0 : _b.signingKey;\n\n    if (key == null || !(key instanceof hdnode_1.HDNode)) {\n      throw new Error('Invalid key');\n    }\n\n    return did_jwt_1.EllipticSigner(key.privateKey.slice(2));\n  }\n\n  getDBSalt(space) {\n    return js_sha256_1.sha256(this._getKeys(space).signingKey.derivePath('0').privateKey.slice(2));\n  }\n\n  getPublicKeys({\n    space,\n    uncompressed,\n    mgmtPub\n  } = {}) {\n    const keys = this._getKeys(space);\n\n    let signingKey = keys.signingKey.publicKey.slice(2);\n    const managementKey = space ? null : mgmtPub && keys.managementKey.publicKey ? keys.managementKey.publicKey.slice(2) : keys.managementKey.address;\n\n    if (uncompressed) {\n      signingKey = ec.keyFromPublic(Buffer.from(signingKey, 'hex')).getPublic(false, 'hex');\n    }\n\n    return {\n      signingKey,\n      managementKey,\n      asymEncryptionKey: tweetnacl_util_1.default.encodeBase64(keys.asymEncryptionKey.publicKey)\n    };\n  }\n\n  serialize() {\n    return this._seed;\n  }\n\n  static encryptWithAuthSecret(message, authSecret) {\n    const node = hdnode_1.HDNode.fromSeed(ensure0x(authSecret)).derivePath(AUTH_PATH_ENCRYPTION);\n    const key = utils_1.hexToUint8Array(node.privateKey.slice(2));\n    return crypto_1.symEncryptBase(message, key);\n  }\n\n  static decryptWithAuthSecret(ciphertext, nonce, authSecret) {\n    const node = hdnode_1.HDNode.fromSeed(ensure0x(authSecret)).derivePath(AUTH_PATH_ENCRYPTION);\n    const key = utils_1.hexToUint8Array(node.privateKey.slice(2));\n    return crypto_1.symDecryptBase(ciphertext, key, nonce);\n  }\n\n  static walletForAuthSecret(authSecret) {\n    const node = hdnode_1.HDNode.fromSeed(ensure0x(authSecret)).derivePath(AUTH_PATH_WALLET);\n    return new wallet_1.Wallet(node.privateKey);\n  }\n\n}\n\nexports.default = Keyring;","map":null,"metadata":{},"sourceType":"script"}