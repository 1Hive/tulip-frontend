{"ast":null,"code":"'use strict';\n\nconst defer = require('p-defer');\n\nconst {\n  NotStartedError,\n  AlreadyInitializedError\n} = require('../errors');\n\nconst Components = require('./');\n\nconst {\n  withTimeoutOption\n} = require('../utils');\n\nmodule.exports = ({\n  apiManager,\n  options: constructorOptions,\n  bitswap,\n  blockService,\n  gcLock,\n  initOptions,\n  ipld,\n  ipns,\n  keychain,\n  libp2p,\n  mfsPreload,\n  peerInfo,\n  pinManager,\n  preload,\n  print,\n  repo\n}) => withTimeoutOption(async function stop() {\n  const stopPromise = defer();\n  const {\n    cancel\n  } = apiManager.update({\n    stop: () => stopPromise.promise\n  });\n\n  try {\n    blockService.unsetExchange();\n    bitswap.stop();\n    preload.stop();\n    await Promise.all([ipns.republisher.stop(), mfsPreload.stop(), libp2p.stop(), repo.close()]); // Clear our addresses so we can start clean\n\n    peerInfo.multiaddrs.clear();\n    const api = createApi({\n      apiManager,\n      constructorOptions,\n      blockService,\n      gcLock,\n      initOptions,\n      ipld,\n      keychain,\n      peerInfo,\n      pinManager,\n      preload,\n      print,\n      repo\n    });\n    apiManager.update(api, () => {\n      throw new NotStartedError();\n    });\n  } catch (err) {\n    cancel();\n    stopPromise.reject(err);\n    throw err;\n  }\n\n  stopPromise.resolve();\n});\n\nfunction createApi({\n  apiManager,\n  constructorOptions,\n  blockService,\n  gcLock,\n  initOptions,\n  ipld,\n  keychain,\n  peerInfo,\n  pinManager,\n  preload,\n  print,\n  repo\n}) {\n  const dag = {\n    get: Components.dag.get({\n      ipld,\n      preload\n    }),\n    resolve: Components.dag.resolve({\n      ipld,\n      preload\n    }),\n    tree: Components.dag.tree({\n      ipld,\n      preload\n    })\n  };\n  const object = {\n    data: Components.object.data({\n      ipld,\n      preload\n    }),\n    get: Components.object.get({\n      ipld,\n      preload\n    }),\n    links: Components.object.links({\n      dag\n    }),\n    new: Components.object.new({\n      ipld,\n      preload\n    }),\n    patch: {\n      addLink: Components.object.patch.addLink({\n        ipld,\n        gcLock,\n        preload\n      }),\n      appendData: Components.object.patch.appendData({\n        ipld,\n        gcLock,\n        preload\n      }),\n      rmLink: Components.object.patch.rmLink({\n        ipld,\n        gcLock,\n        preload\n      }),\n      setData: Components.object.patch.setData({\n        ipld,\n        gcLock,\n        preload\n      })\n    },\n    put: Components.object.put({\n      ipld,\n      gcLock,\n      preload\n    }),\n    stat: Components.object.stat({\n      ipld,\n      preload\n    })\n  };\n  const pin = {\n    add: Components.pin.add({\n      pinManager,\n      gcLock,\n      dag\n    }),\n    ls: Components.pin.ls({\n      pinManager,\n      dag\n    }),\n    rm: Components.pin.rm({\n      pinManager,\n      gcLock,\n      dag\n    })\n  }; // FIXME: resolve this circular dependency\n\n  dag.put = Components.dag.put({\n    ipld,\n    pin,\n    gcLock,\n    preload\n  });\n  const block = {\n    get: Components.block.get({\n      blockService,\n      preload\n    }),\n    put: Components.block.put({\n      blockService,\n      pin,\n      gcLock,\n      preload\n    }),\n    rm: Components.block.rm({\n      blockService,\n      gcLock,\n      pinManager\n    }),\n    stat: Components.block.stat({\n      blockService,\n      preload\n    })\n  };\n  const add = Components.add({\n    block,\n    preload,\n    pin,\n    gcLock,\n    options: constructorOptions\n  });\n  const resolve = Components.resolve({\n    ipld\n  });\n  const refs = Components.refs({\n    ipld,\n    resolve,\n    preload\n  });\n  refs.local = Components.refs.local({\n    repo\n  });\n\n  const notStarted = async () => {\n    // eslint-disable-line require-await\n    throw new NotStartedError();\n  };\n\n  const api = {\n    add,\n    bitswap: {\n      stat: notStarted,\n      unwant: notStarted,\n      wantlist: notStarted\n    },\n    block,\n    bootstrap: {\n      add: Components.bootstrap.add({\n        repo\n      }),\n      list: Components.bootstrap.list({\n        repo\n      }),\n      rm: Components.bootstrap.rm({\n        repo\n      })\n    },\n    cat: Components.cat({\n      ipld,\n      preload\n    }),\n    config: Components.config({\n      repo\n    }),\n    dag,\n    dns: Components.dns(),\n    files: Components.files({\n      ipld,\n      block,\n      blockService,\n      repo,\n      preload,\n      options: constructorOptions\n    }),\n    get: Components.get({\n      ipld,\n      preload\n    }),\n    id: Components.id({\n      peerInfo\n    }),\n    init: async () => {\n      // eslint-disable-line require-await\n      throw new AlreadyInitializedError();\n    },\n    isOnline: Components.isOnline({}),\n    key: {\n      export: Components.key.export({\n        keychain\n      }),\n      gen: Components.key.gen({\n        keychain\n      }),\n      import: Components.key.import({\n        keychain\n      }),\n      info: Components.key.info({\n        keychain\n      }),\n      list: Components.key.list({\n        keychain\n      }),\n      rename: Components.key.rename({\n        keychain\n      }),\n      rm: Components.key.rm({\n        keychain\n      })\n    },\n    ls: Components.ls({\n      ipld,\n      preload\n    }),\n    object,\n    pin,\n    refs,\n    repo: {\n      gc: Components.repo.gc({\n        gcLock,\n        pin,\n        pinManager,\n        refs,\n        repo\n      }),\n      stat: Components.repo.stat({\n        repo\n      }),\n      version: Components.repo.version({\n        repo\n      })\n    },\n    resolve,\n    start: Components.start({\n      apiManager,\n      options: constructorOptions,\n      blockService,\n      gcLock,\n      initOptions,\n      ipld,\n      keychain,\n      peerInfo,\n      pinManager,\n      preload,\n      print,\n      repo\n    }),\n    stats: {\n      bitswap: notStarted,\n      bw: notStarted,\n      repo: Components.repo.stat({\n        repo\n      })\n    },\n    stop: () => {},\n    swarm: {\n      addrs: notStarted,\n      connect: notStarted,\n      disconnect: notStarted,\n      localAddrs: Components.swarm.localAddrs({\n        peerInfo\n      }),\n      peers: notStarted\n    },\n    version: Components.version({\n      repo\n    })\n  };\n  return api;\n}","map":null,"metadata":{},"sourceType":"script"}