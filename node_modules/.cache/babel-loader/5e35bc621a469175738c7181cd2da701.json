{"ast":null,"code":"'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst ip = require('./ip');\n\nconst protocols = require('./protocols-table');\n\nconst CID = require('cids');\n\nconst multibase = require('multibase');\n\nconst varint = require('varint');\n\nmodule.exports = Convert; // converts (serializes) addresses\n\nfunction Convert(proto, a) {\n  if (a instanceof Buffer) {\n    return Convert.toString(proto, a);\n  } else {\n    return Convert.toBuffer(proto, a);\n  }\n}\n\nConvert.toString = function convertToString(proto, buf) {\n  proto = protocols(proto);\n\n  switch (proto.code) {\n    case 4: // ipv4\n\n    case 41:\n      // ipv6\n      return buf2ip(buf);\n\n    case 6: // tcp\n\n    case 273: // udp\n\n    case 33: // dccp\n\n    case 132:\n      // sctp\n      return buf2port(buf);\n\n    case 53: // dns\n\n    case 54: // dns4\n\n    case 55: // dns6\n\n    case 56: // dnsaddr\n\n    case 400: // unix\n\n    case 777:\n      // memory\n      return buf2str(buf);\n\n    case 421:\n      // ipfs\n      return buf2mh(buf);\n\n    case 444:\n      // onion\n      return buf2onion(buf);\n\n    case 445:\n      // onion3\n      return buf2onion(buf);\n\n    default:\n      return buf.toString('hex');\n    // no clue. convert to hex\n  }\n};\n\nConvert.toBuffer = function convertToBuffer(proto, str) {\n  proto = protocols(proto);\n\n  switch (proto.code) {\n    case 4:\n      // ipv4\n      return ip2buf(str);\n\n    case 41:\n      // ipv6\n      return ip2buf(str);\n\n    case 6: // tcp\n\n    case 273: // udp\n\n    case 33: // dccp\n\n    case 132:\n      // sctp\n      return port2buf(parseInt(str, 10));\n\n    case 53: // dns\n\n    case 54: // dns4\n\n    case 55: // dns6\n\n    case 56: // dnsaddr\n\n    case 400: // unix\n\n    case 777:\n      // memory\n      return str2buf(str);\n\n    case 421:\n      // ipfs\n      return mh2buf(str);\n\n    case 444:\n      // onion\n      return onion2buf(str);\n\n    case 445:\n      // onion3\n      return onion32buf(str);\n\n    default:\n      return Buffer.from(str, 'hex');\n    // no clue. convert from hex\n  }\n};\n\nfunction ip2buf(ipString) {\n  if (!ip.isIP(ipString)) {\n    throw new Error('invalid ip address');\n  }\n\n  return ip.toBuffer(ipString);\n}\n\nfunction buf2ip(ipBuff) {\n  const ipString = ip.toString(ipBuff);\n\n  if (!ipString || !ip.isIP(ipString)) {\n    throw new Error('invalid ip address');\n  }\n\n  return ipString;\n}\n\nfunction port2buf(port) {\n  const buf = Buffer.alloc(2);\n  buf.writeUInt16BE(port, 0);\n  return buf;\n}\n\nfunction buf2port(buf) {\n  return buf.readUInt16BE(0);\n}\n\nfunction str2buf(str) {\n  const buf = Buffer.from(str);\n  const size = Buffer.from(varint.encode(buf.length));\n  return Buffer.concat([size, buf]);\n}\n\nfunction buf2str(buf) {\n  const size = varint.decode(buf);\n  buf = buf.slice(varint.decode.bytes);\n\n  if (buf.length !== size) {\n    throw new Error('inconsistent lengths');\n  }\n\n  return buf.toString();\n}\n\nfunction mh2buf(hash) {\n  // the address is a varint prefixed multihash string representation\n  const mh = new CID(hash).multihash;\n  const size = Buffer.from(varint.encode(mh.length));\n  return Buffer.concat([size, mh]);\n}\n\nfunction buf2mh(buf) {\n  const size = varint.decode(buf);\n  const address = buf.slice(varint.decode.bytes);\n\n  if (address.length !== size) {\n    throw new Error('inconsistent lengths');\n  }\n\n  return multibase.encode('base58btc', address).toString().slice(1);\n}\n\nfunction onion2buf(str) {\n  const addr = str.split(':');\n\n  if (addr.length !== 2) {\n    throw new Error('failed to parse onion addr: ' + addr + ' does not contain a port number');\n  }\n\n  if (addr[0].length !== 16) {\n    throw new Error('failed to parse onion addr: ' + addr[0] + ' not a Tor onion address.');\n  } // onion addresses do not include the multibase prefix, add it before decoding\n\n\n  const buf = multibase.decode('b' + addr[0]); // onion port number\n\n  const port = parseInt(addr[1], 10);\n\n  if (port < 1 || port > 65536) {\n    throw new Error('Port number is not in range(1, 65536)');\n  }\n\n  const portBuf = port2buf(port);\n  return Buffer.concat([buf, portBuf]);\n}\n\nfunction onion32buf(str) {\n  const addr = str.split(':');\n\n  if (addr.length !== 2) {\n    throw new Error('failed to parse onion addr: ' + addr + ' does not contain a port number');\n  }\n\n  if (addr[0].length !== 56) {\n    throw new Error('failed to parse onion addr: ' + addr[0] + ' not a Tor onion3 address.');\n  } // onion addresses do not include the multibase prefix, add it before decoding\n\n\n  const buf = multibase.decode('b' + addr[0]); // onion port number\n\n  const port = parseInt(addr[1], 10);\n\n  if (port < 1 || port > 65536) {\n    throw new Error('Port number is not in range(1, 65536)');\n  }\n\n  const portBuf = port2buf(port);\n  return Buffer.concat([buf, portBuf]);\n}\n\nfunction buf2onion(buf) {\n  const addrBytes = buf.slice(0, buf.length - 2);\n  const portBytes = buf.slice(buf.length - 2);\n  const addr = multibase.encode('base32', addrBytes).toString().slice(1);\n  const port = buf2port(portBytes);\n  return addr + ':' + port;\n}","map":null,"metadata":{},"sourceType":"script"}