{"ast":null,"code":"'use strict';\n\nconst ipns = require('ipns');\n\nconst crypto = require('libp2p-crypto');\n\nconst PeerId = require('peer-id');\n\nconst errcode = require('err-code');\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst debug = require('debug');\n\nconst log = debug('ipfs:ipns:republisher');\nlog.error = debug('ipfs:ipns:republisher:error');\nconst minute = 60 * 1000;\nconst hour = 60 * minute;\nconst defaultBroadcastInterval = 4 * hour;\nconst defaultRecordLifetime = 24 * hour;\n\nclass IpnsRepublisher {\n  constructor(publisher, datastore, peerInfo, keychain, options) {\n    this._publisher = publisher;\n    this._datastore = datastore;\n    this._peerInfo = peerInfo;\n    this._keychain = keychain;\n    this._options = options || {};\n    this._republishHandle = null;\n  }\n\n  async start() {\n    // eslint-disable-line require-await\n    if (this._republishHandle) {\n      throw errcode(new Error('republisher is already running'), 'ERR_REPUBLISH_ALREADY_RUNNING');\n    } // TODO: this handler should be isolated in another module\n\n\n    const republishHandle = {\n      _task: null,\n      _inflightTask: null,\n      _timeoutId: null,\n      runPeriodically: period => {\n        republishHandle._timeoutId = setTimeout(async () => {\n          republishHandle._timeoutId = null;\n\n          try {\n            republishHandle._inflightTask = republishHandle._task();\n            await republishHandle._inflightTask; // Schedule next\n\n            if (republishHandle._task) {\n              republishHandle.runPeriodically(period);\n            }\n          } catch (err) {\n            log.error(err);\n          }\n        }, period());\n      },\n      cancel: async () => {\n        // do not run again\n        clearTimeout(republishHandle._timeoutId);\n        republishHandle._task = null; // wait for the currently in flight task to complete\n\n        await republishHandle._inflightTask;\n      }\n    };\n    const {\n      privKey\n    } = this._peerInfo.id;\n    const {\n      pass\n    } = this._options;\n    let firstRun = true;\n\n    republishHandle._task = () => this._republishEntries(privKey, pass);\n\n    republishHandle.runPeriodically(() => {\n      if (firstRun) {\n        firstRun = false;\n        return this._options.initialBroadcastInterval || minute;\n      }\n\n      return this._options.broadcastInterval || defaultBroadcastInterval;\n    });\n    this._republishHandle = republishHandle;\n  }\n\n  async stop() {\n    const republishHandle = this._republishHandle;\n\n    if (!republishHandle) {\n      throw errcode(new Error('republisher is not running'), 'ERR_REPUBLISH_NOT_RUNNING');\n    }\n\n    this._republishHandle = null;\n    await republishHandle.cancel();\n  }\n\n  async _republishEntries(privateKey, pass) {\n    // TODO: Should use list of published entries.\n    // We can't currently *do* that because go uses this method for now.\n    try {\n      await this._republishEntry(privateKey);\n    } catch (err) {\n      const errMsg = 'cannot republish entry for the node\\'s private key';\n      log.error(errMsg);\n      return;\n    } // keychain needs pass to get the cryptographic keys\n\n\n    if (pass) {\n      try {\n        const keys = await this._keychain.listKeys();\n\n        for (const key of keys) {\n          const pem = await this._keychain.exportKey(key.name, pass);\n          const privKey = await crypto.keys.import(pem, pass);\n          await this._republishEntry(privKey);\n        }\n      } catch (err) {\n        log.error(err);\n      }\n    }\n  }\n\n  async _republishEntry(privateKey) {\n    if (!privateKey || !privateKey.bytes) {\n      throw errcode(new Error('invalid private key'), 'ERR_INVALID_PRIVATE_KEY');\n    }\n\n    try {\n      const peerId = await PeerId.createFromPrivKey(privateKey.bytes);\n      const value = await this._getPreviousValue(peerId);\n      await this._publisher.publishWithEOL(privateKey, value, defaultRecordLifetime);\n    } catch (err) {\n      if (err.code === 'ERR_NO_ENTRY_FOUND') {\n        return;\n      }\n\n      throw err;\n    }\n  }\n\n  async _getPreviousValue(peerId) {\n    if (!PeerId.isPeerId(peerId)) {\n      throw errcode(new Error('invalid peer ID'), 'ERR_INVALID_PEER_ID');\n    }\n\n    try {\n      const dsVal = await this._datastore.get(ipns.getLocalKey(peerId.id));\n\n      if (!Buffer.isBuffer(dsVal)) {\n        throw errcode(new Error(\"found ipns record that we couldn't process\"), 'ERR_INVALID_IPNS_RECORD');\n      } // unmarshal data\n\n\n      try {\n        const record = ipns.unmarshal(dsVal);\n        return record.value;\n      } catch (err) {\n        log.error(err);\n        throw errcode(new Error('found ipns record that we couldn\\'t convert to a value'), 'ERR_INVALID_IPNS_RECORD');\n      }\n    } catch (err) {\n      // error handling\n      // no need to republish\n      if (err && err.notFound) {\n        throw errcode(new Error(`no previous entry for record with id: ${peerId.id}`), 'ERR_NO_ENTRY_FOUND');\n      }\n\n      throw err;\n    }\n  }\n\n}\n\nexports = module.exports = IpnsRepublisher;","map":null,"metadata":{},"sourceType":"script"}