{"ast":null,"code":"'use strict';\n\nconst path = require('path');\n\nconst EventStore = require('orbit-db-eventstore');\n\nconst FeedStore = require('orbit-db-feedstore');\n\nconst KeyValueStore = require('orbit-db-kvstore');\n\nconst CounterStore = require('orbit-db-counterstore');\n\nconst DocumentStore = require('orbit-db-docstore');\n\nconst Pubsub = require('orbit-db-pubsub');\n\nconst Cache = require('orbit-db-cache');\n\nconst Keystore = require('orbit-db-keystore');\n\nconst Identities = require('orbit-db-identity-provider');\n\nlet AccessControllers = require('orbit-db-access-controllers');\n\nconst OrbitDBAddress = require('./orbit-db-address');\n\nconst createDBManifest = require('./db-manifest');\n\nconst exchangeHeads = require('./exchange-heads');\n\nconst {\n  isDefined,\n  io\n} = require('./utils');\n\nconst Storage = require('orbit-db-storage-adapter');\n\nconst migrations = require('./migrations');\n\nconst Logger = require('logplease');\n\nconst logger = Logger.create('orbit-db');\nLogger.setLogLevel('ERROR'); // Mapping for 'database type' -> Class\n\nconst databaseTypes = {\n  counter: CounterStore,\n  eventlog: EventStore,\n  feed: FeedStore,\n  docstore: DocumentStore,\n  keyvalue: KeyValueStore\n};\n\nclass OrbitDB {\n  constructor(ipfs, identity, options = {}) {\n    if (!isDefined(ipfs)) {\n      throw new Error('IPFS is a required argument. See https://github.com/orbitdb/orbit-db/blob/master/API.md#createinstance');\n    }\n\n    if (!isDefined(identity)) {\n      throw new Error('identity is a required argument. See https://github.com/orbitdb/orbit-db/blob/master/API.md#createinstance');\n    }\n\n    this._ipfs = ipfs;\n    this.identity = identity;\n    this.id = options.peerId;\n    this._pubsub = !options.offline ? options.broker ? new options.broker(this._ipfs) // eslint-disable-line\n    : new Pubsub(this._ipfs, this.id) : null;\n    this.directory = options.directory || './orbitdb';\n    this.storage = options.storage;\n    this._directConnections = {};\n    this.caches = {};\n    this.caches[this.directory] = {\n      cache: options.cache,\n      handlers: new Set()\n    };\n    this.keystore = options.keystore;\n    this.stores = {}; // AccessControllers module can be passed in to enable\n    // testing with orbit-db-access-controller\n\n    AccessControllers = options.AccessControllers || AccessControllers;\n  }\n\n  static get Pubsub() {\n    return Pubsub;\n  }\n\n  static get Cache() {\n    return Cache;\n  }\n\n  static get Keystore() {\n    return Keystore;\n  }\n\n  static get Identities() {\n    return Identities;\n  }\n\n  static get AccessControllers() {\n    return AccessControllers;\n  }\n\n  static get Storage() {\n    return Storage;\n  }\n\n  static get OrbitDBAddress() {\n    return OrbitDBAddress;\n  }\n\n  static get EventStore() {\n    return EventStore;\n  }\n\n  static get FeedStore() {\n    return FeedStore;\n  }\n\n  static get KeyValueStore() {\n    return KeyValueStore;\n  }\n\n  static get CounterStore() {\n    return CounterStore;\n  }\n\n  static get DocumentStore() {\n    return DocumentStore;\n  }\n\n  get cache() {\n    return this.caches[this.directory].cache;\n  }\n\n  static async createInstance(ipfs, options = {}) {\n    if (!isDefined(ipfs)) {\n      throw new Error('IPFS is a required argument. See https://github.com/orbitdb/orbit-db/blob/master/API.md#createinstance');\n    }\n\n    if (options.offline === undefined) {\n      options.offline = false;\n    }\n\n    if (options.offline && !options.id) {\n      throw new Error('Offline mode requires passing an `id` in the options');\n    }\n\n    const {\n      id\n    } = options.offline ? {\n      id: options.id\n    } : await ipfs.id();\n\n    if (!options.directory) {\n      options.directory = './orbitdb';\n    }\n\n    if (!options.storage) {\n      const storageOptions = {}; // Create default `level` store\n\n      options.storage = Storage(null, storageOptions);\n    }\n\n    if (options.identity && options.identity.provider.keystore) {\n      options.keystore = options.identity.provider.keystore;\n    }\n\n    if (!options.keystore) {\n      const keystorePath = path.join(options.directory, id, '/keystore');\n      const keyStorage = await options.storage.createStore(keystorePath);\n      options.keystore = new Keystore(keyStorage);\n    }\n\n    if (!options.identity) {\n      options.identity = await Identities.createIdentity({\n        id: options.id || id,\n        keystore: options.keystore\n      });\n    }\n\n    if (!options.cache) {\n      const cachePath = path.join(options.directory, id, '/cache');\n      const cacheStorage = await options.storage.createStore(cachePath);\n      options.cache = new Cache(cacheStorage);\n    }\n\n    const finalOptions = Object.assign({}, options, {\n      peerId: id\n    });\n    return new OrbitDB(ipfs, options.identity, finalOptions);\n  }\n  /* Databases */\n\n\n  async feed(address, options = {}) {\n    options = Object.assign({\n      create: true,\n      type: 'feed'\n    }, options);\n    return this.open(address, options);\n  }\n\n  async log(address, options = {}) {\n    options = Object.assign({\n      create: true,\n      type: 'eventlog'\n    }, options);\n    return this.open(address, options);\n  }\n\n  async eventlog(address, options = {}) {\n    return this.log(address, options);\n  }\n\n  async keyvalue(address, options = {}) {\n    options = Object.assign({\n      create: true,\n      type: 'keyvalue'\n    }, options);\n    return this.open(address, options);\n  }\n\n  async kvstore(address, options = {}) {\n    return this.keyvalue(address, options);\n  }\n\n  async counter(address, options = {}) {\n    options = Object.assign({\n      create: true,\n      type: 'counter'\n    }, options);\n    return this.open(address, options);\n  }\n\n  async docs(address, options = {}) {\n    options = Object.assign({\n      create: true,\n      type: 'docstore'\n    }, options);\n    return this.open(address, options);\n  }\n\n  async docstore(address, options = {}) {\n    return this.docs(address, options);\n  }\n\n  async disconnect() {\n    // close keystore\n    await this.keystore.close(); // Close all open databases\n\n    const databases = Object.values(this.stores);\n\n    for (const db of databases) {\n      await db.close();\n      delete this.stores[db.address.toString()];\n    }\n\n    const caches = Object.keys(this.caches);\n\n    for (const directory of caches) {\n      await this.caches[directory].cache.close();\n      delete this.caches[directory];\n    } // Close a direct connection and remove it from internal state\n\n\n    const removeDirectConnect = e => {\n      this._directConnections[e].close();\n\n      delete this._directConnections[e];\n    }; // Close all direct connections to peers\n\n\n    Object.keys(this._directConnections).forEach(removeDirectConnect); // Disconnect from pubsub\n\n    if (this._pubsub) {\n      await this._pubsub.disconnect();\n    } // Remove all databases from the state\n\n\n    this.stores = {};\n  } // Alias for disconnect()\n\n\n  async stop() {\n    await this.disconnect();\n  }\n\n  async _createCache(path) {\n    const cacheStorage = await this.storage.createStore(path);\n    return new Cache(cacheStorage);\n  }\n  /* Private methods */\n\n\n  async _createStore(type, address, options) {\n    // Get the type -> class mapping\n    const Store = databaseTypes[type];\n\n    if (!Store) {\n      throw new Error(`Invalid database type '${type}'`);\n    }\n\n    let accessController;\n\n    if (options.accessControllerAddress) {\n      accessController = await AccessControllers.resolve(this, options.accessControllerAddress, options.accessController);\n    }\n\n    const opts = Object.assign({\n      replicate: true\n    }, options, {\n      accessController: accessController,\n      cache: options.cache,\n      onClose: this._onClose.bind(this),\n      onDrop: this._onDrop.bind(this),\n      onLoad: this._onLoad.bind(this)\n    });\n    const identity = options.identity || this.identity;\n    const store = new Store(this._ipfs, identity, address, opts);\n    store.events.on('write', this._onWrite.bind(this)); // ID of the store is the address as a string\n\n    const addr = address.toString();\n    this.stores[addr] = store; // Subscribe to pubsub to get updates from peers,\n    // this is what hooks us into the message propagation layer\n    // and the p2p network\n\n    if (opts.replicate && this._pubsub) {\n      await this._pubsub.subscribe(addr, this._onMessage.bind(this), this._onPeerConnected.bind(this));\n    }\n\n    return store;\n  } // Callback for local writes to the database. We the update to pubsub.\n\n\n  _onWrite(address, entry, heads) {\n    if (!heads) throw new Error(\"'heads' not defined\");\n    if (this._pubsub) this._pubsub.publish(address, heads);\n  } // Callback for receiving a message from the network\n\n\n  async _onMessage(address, heads, peer) {\n    const store = this.stores[address];\n\n    try {\n      logger.debug(`Received ${heads.length} heads for '${address}':\\n`, JSON.stringify(heads.map(e => e.hash), null, 2));\n\n      if (store && heads) {\n        if (heads.length > 0) {\n          await store.sync(heads);\n        }\n\n        store.events.emit('peer.exchanged', peer, address, heads);\n      }\n    } catch (e) {\n      logger.error(e);\n    }\n  } // Callback for when a peer connected to a database\n\n\n  async _onPeerConnected(address, peer) {\n    logger.debug(`New peer '${peer}' connected to '${address}'`);\n\n    const getStore = address => this.stores[address];\n\n    const getDirectConnection = peer => this._directConnections[peer];\n\n    const onChannelCreated = channel => {\n      this._directConnections[channel._receiverID] = channel;\n    };\n\n    const onMessage = (address, heads) => this._onMessage(address, heads, peer);\n\n    await exchangeHeads(this._ipfs, address, peer, getStore, getDirectConnection, onMessage, onChannelCreated);\n\n    if (getStore(address)) {\n      getStore(address).events.emit('peer', peer);\n    }\n  } // Callback when database was closed\n\n\n  async _onClose(db) {\n    const address = db.address.toString();\n    logger.debug(`Close ${address}`); // Unsubscribe from pubsub\n\n    if (this._pubsub) {\n      await this._pubsub.unsubscribe(address);\n    }\n\n    const store = this.stores[address];\n    const dir = store && store.options.directory ? store.options.directory : this.directory;\n    const cache = this.caches[dir];\n\n    if (cache && cache.handlers.has(address)) {\n      cache.handlers.delete(address);\n      if (!cache.handlers.size) await cache.cache.close();\n    }\n\n    delete this.stores[address];\n  }\n\n  async _onDrop(db) {\n    const address = db.address.toString();\n    const dir = db && db.options.directory ? db.options.directory : this.directory;\n    await this._requestCache(address, dir, db._cache);\n    this.stores[address] = db;\n  }\n\n  async _onLoad(db) {\n    const address = db.address.toString();\n    const dir = db && db.options.directory ? db.options.directory : this.directory;\n    await this._requestCache(address, dir, db._cache);\n    this.stores[address] = db;\n  }\n\n  async _determineAddress(name, type, options = {}) {\n    if (!OrbitDB.isValidType(type)) {\n      throw new Error(`Invalid database type '${type}'`);\n    }\n\n    if (OrbitDBAddress.isValid(name)) {\n      throw new Error('Given database name is an address. Please give only the name of the database!');\n    } // Create an AccessController, use IPFS AC as the default\n\n\n    options.accessController = Object.assign({}, {\n      name: name,\n      type: 'ipfs'\n    }, options.accessController);\n    const accessControllerAddress = await AccessControllers.create(this, options.accessController.type, options.accessController || {}); // Save the manifest to IPFS\n\n    const manifestHash = await createDBManifest(this._ipfs, name, type, accessControllerAddress, options); // Create the database address\n\n    return OrbitDBAddress.parse(OrbitDBAddress.join(manifestHash, name));\n  }\n  /* Create and Open databases */\n\n  /*\n    options = {\n      accessController: { write: [] } // array of keys that can write to this database\n      overwrite: false, // whether we should overwrite the existing database if it exists\n    }\n  */\n\n\n  async create(name, type, options = {}) {\n    logger.debug('create()');\n    logger.debug(`Creating database '${name}' as ${type}`); // Create the database address\n\n    const dbAddress = await this._determineAddress(name, type, options);\n    options.cache = await this._requestCache(dbAddress.toString(), options.directory); // Check if we have the database locally\n\n    const haveDB = await this._haveLocalData(options.cache, dbAddress);\n\n    if (haveDB && !options.overwrite) {\n      throw new Error(`Database '${dbAddress}' already exists!`);\n    }\n\n    await this._migrate(options, dbAddress); // Save the database locally\n\n    await this._addManifestToCache(options.cache, dbAddress);\n    logger.debug(`Created database '${dbAddress}'`); // Open the database\n\n    return this.open(dbAddress, options);\n  }\n\n  async determineAddress(name, type, options = {}) {\n    const opts = Object.assign({}, {\n      onlyHash: true\n    }, options);\n    return this._determineAddress(name, type, opts);\n  }\n\n  async _requestCache(address, directory, existingCache) {\n    const dir = directory || this.directory;\n\n    if (!this.caches[dir]) {\n      const newCache = existingCache || (await this._createCache(dir));\n      this.caches[dir] = {\n        cache: newCache,\n        handlers: new Set()\n      };\n    }\n\n    this.caches[dir].handlers.add(address);\n    const cache = this.caches[dir].cache; // \"Wake up\" the caches if they need it\n\n    if (cache) await cache.open();\n    return cache;\n  }\n  /*\n      options = {\n        localOnly: false // if set to true, throws an error if database can't be found locally\n        create: false // whether to create the database\n        type: TODO\n        overwrite: TODO\n       }\n   */\n\n\n  async open(address, options = {}) {\n    logger.debug('open()');\n    options = Object.assign({\n      localOnly: false,\n      create: false\n    }, options);\n    logger.debug(`Open database '${address}'`); // If address is just the name of database, check the options to crate the database\n\n    if (!OrbitDBAddress.isValid(address)) {\n      if (!options.create) {\n        throw new Error('\\'options.create\\' set to \\'false\\'. If you want to create a database, set \\'options.create\\' to \\'true\\'.');\n      } else if (options.create && !options.type) {\n        throw new Error(`Database type not provided! Provide a type with 'options.type' (${OrbitDB.databaseTypes.join('|')})`);\n      } else {\n        logger.warn(`Not a valid OrbitDB address '${address}', creating the database`);\n        options.overwrite = options.overwrite ? options.overwrite : true;\n        return this.create(address, options.type, options);\n      }\n    } // Parse the database address\n\n\n    const dbAddress = OrbitDBAddress.parse(address);\n    options.cache = await this._requestCache(dbAddress.toString(), options.directory); // Check if we have the database\n\n    const haveDB = await this._haveLocalData(options.cache, dbAddress);\n    logger.debug((haveDB ? 'Found' : 'Didn\\'t find') + ` database '${dbAddress}'`); // If we want to try and open the database local-only, throw an error\n    // if we don't have the database locally\n\n    if (options.localOnly && !haveDB) {\n      logger.warn(`Database '${dbAddress}' doesn't exist!`);\n      throw new Error(`Database '${dbAddress}' doesn't exist!`);\n    }\n\n    logger.debug(`Loading Manifest for '${dbAddress}'`); // Get the database manifest from IPFS\n\n    const manifest = await io.read(this._ipfs, dbAddress.root);\n    logger.debug(`Manifest for '${dbAddress}':\\n${JSON.stringify(manifest, null, 2)}`); // Make sure the type from the manifest matches the type that was given as an option\n\n    if (manifest.name !== dbAddress.path) {\n      throw new Error(`Manifest '${manifest.name}' cannot be opened as '${dbAddress.path}'`);\n    }\n\n    if (options.type && manifest.type !== options.type) {\n      throw new Error(`Database '${dbAddress}' is type '${manifest.type}' but was opened as '${options.type}'`);\n    } // Save the database locally\n\n\n    await this._addManifestToCache(options.cache, dbAddress); // Open the the database\n\n    options = Object.assign({}, options, {\n      accessControllerAddress: manifest.accessController,\n      meta: manifest.meta\n    });\n    return this._createStore(manifest.type, dbAddress, options);\n  } // Save the database locally\n\n\n  async _addManifestToCache(cache, dbAddress) {\n    await cache.set(path.join(dbAddress.toString(), '_manifest'), dbAddress.root);\n    logger.debug(`Saved manifest to IPFS as '${dbAddress.root}'`);\n  }\n  /**\n   * Check if we have the database, or part of it, saved locally\n   * @param  {[Cache]} cache [The OrbitDBCache instance containing the local data]\n   * @param  {[OrbitDBAddress]} dbAddress [Address of the database to check]\n   * @return {[Boolean]} [Returns true if we have cached the db locally, false if not]\n   */\n\n\n  async _haveLocalData(cache, dbAddress) {\n    if (!cache) {\n      return false;\n    }\n\n    const addr = dbAddress.toString();\n    const data = await cache.get(path.join(addr, '_manifest'));\n    return data !== undefined && data !== null;\n  }\n  /**\n   * Runs all migrations inside the src/migration folder\n   * @param Object options  Options to pass into the migration\n   * @param OrbitDBAddress dbAddress Address of database in OrbitDBAddress format\n   */\n\n\n  async _migrate(options, dbAddress) {\n    await migrations.run(this, options, dbAddress);\n  }\n  /**\n   * Returns supported database types as an Array of strings\n   * Eg. [ 'counter', 'eventlog', 'feed', 'docstore', 'keyvalue']\n   * @return {[Array]} [Supported database types]\n   */\n\n\n  static get databaseTypes() {\n    return Object.keys(databaseTypes);\n  }\n\n  static isValidType(type) {\n    return Object.keys(databaseTypes).includes(type);\n  }\n\n  static addDatabaseType(type, store) {\n    if (databaseTypes[type]) throw new Error(`Type already exists: ${type}`);\n    databaseTypes[type] = store;\n  }\n\n  static getDatabaseTypes() {\n    return databaseTypes;\n  }\n\n  static isValidAddress(address) {\n    return OrbitDBAddress.isValid(address);\n  }\n\n  static parseAddress(address) {\n    return OrbitDBAddress.parse(address);\n  }\n\n}\n\nOrbitDB.prototype.AccessControllers = AccessControllers;\nOrbitDB.prototype.Identities = Identities;\nOrbitDB.prototype.Keystore = Keystore;\nmodule.exports = OrbitDB;","map":null,"metadata":{},"sourceType":"script"}