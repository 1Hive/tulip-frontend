{"ast":null,"code":"'use strict';\n\nconst isIpfs = require('is-ipfs');\n\nconst CID = require('cids');\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst TimeoutController = require('timeout-abort-controller');\n\nconst anySignal = require('any-signal');\n\nconst parseDuration = require('parse-duration');\n\nconst Key = require('interface-datastore').Key;\n\nconst {\n  TimeoutError\n} = require('./errors');\n\nconst ERR_BAD_PATH = 'ERR_BAD_PATH';\nexports.OFFLINE_ERROR = 'This command must be run in online mode. Try running \\'ipfs daemon\\' first.';\nexports.MFS_FILE_TYPES = {\n  file: 0,\n  directory: 1,\n  'hamt-sharded-directory': 1\n};\nexports.MFS_ROOT_KEY = new Key('/local/filesroot');\nexports.MFS_MAX_CHUNK_SIZE = 262144;\nexports.MFS_MAX_LINKS = 174;\n/**\n * Break an ipfs-path down into it's hash and an array of links.\n *\n * examples:\n *  b58Hash -> { hash: 'b58Hash', links: [] }\n *  b58Hash/mercury/venus -> { hash: 'b58Hash', links: ['mercury', 'venus']}\n *  /ipfs/b58Hash/links/by/name -> { hash: 'b58Hash', links: ['links', 'by', 'name'] }\n *\n * @param  {String} ipfsPath An ipfs-path\n * @return {Object}            { hash: base58 string, links: [string], ?err: Error }\n * @throws on an invalid @param ipfsPath\n */\n\nfunction parseIpfsPath(ipfsPath) {\n  ipfsPath = ipfsPath.replace(/^\\/ipfs\\//, '');\n  const matched = ipfsPath.match(/([^/]+(?:\\/[^/]+)*)\\/?$/);\n\n  if (!matched) {\n    throw new Error('invalid ipfs ref path');\n  }\n\n  const [hash, ...links] = matched[1].split('/'); // check that a CID can be constructed with the hash\n\n  if (isIpfs.cid(hash)) {\n    return {\n      hash,\n      links\n    };\n  } else {\n    throw new Error('invalid ipfs ref path');\n  }\n}\n/**\n * Returns a well-formed ipfs Path.\n * The returned path will always be prefixed with /ipfs/ or /ipns/.\n *\n * @param  {String} pathStr An ipfs-path, or ipns-path or a cid\n * @return {String} ipfs-path or ipns-path\n * @throws on an invalid @param ipfsPath\n */\n\n\nconst normalizePath = pathStr => {\n  if (isIpfs.cid(pathStr)) {\n    return `/ipfs/${new CID(pathStr)}`;\n  } else if (isIpfs.path(pathStr)) {\n    return pathStr;\n  } else {\n    throw Object.assign(new Error(`invalid path: ${pathStr}`), {\n      code: ERR_BAD_PATH\n    });\n  }\n}; // TODO: do we need both normalizePath and normalizeCidPath?\n\n\nconst normalizeCidPath = path => {\n  if (Buffer.isBuffer(path)) {\n    return new CID(path).toString();\n  }\n\n  if (CID.isCID(path)) {\n    return path.toString();\n  }\n\n  if (path.indexOf('/ipfs/') === 0) {\n    path = path.substring('/ipfs/'.length);\n  }\n\n  if (path.charAt(path.length - 1) === '/') {\n    path = path.substring(0, path.length - 1);\n  }\n\n  return path;\n};\n/**\n * Resolve various styles of an ipfs-path to the hash of the target node.\n * Follows links in the path.\n *\n * Accepts formats:\n *  - <base58 string>\n *  - <base58 string>/link/to/venus\n *  - /ipfs/<base58 string>/link/to/pluto\n *  - multihash Buffer\n *  - Arrays of the above\n *\n * @param {Dag} dag The IPFS dag api\n * @param {Array<CID|string>} ipfsPaths A single or collection of ipfs-paths\n * @param {Object} [options] Optional options passed directly to dag.resolve\n * @return {Promise<Array<CID>>}\n */\n\n\nconst resolvePath = async function (dag, ipfsPaths, options) {\n  options = options || {};\n\n  if (!Array.isArray(ipfsPaths)) {\n    ipfsPaths = [ipfsPaths];\n  }\n\n  const cids = [];\n\n  for (const path of ipfsPaths) {\n    if (isIpfs.cid(path)) {\n      cids.push(new CID(path));\n      continue;\n    }\n\n    const {\n      hash,\n      links\n    } = parseIpfsPath(path);\n\n    if (!links.length) {\n      cids.push(new CID(hash));\n      continue;\n    }\n\n    let cid = new CID(hash);\n\n    try {\n      for await (const {\n        value\n      } of dag.resolve(path, options)) {\n        if (CID.isCID(value)) {\n          cid = value;\n        }\n      }\n    } catch (err) {\n      // TODO: add error codes to IPLD\n      if (err.message.startsWith('Object has no property')) {\n        const linkName = err.message.replace('Object has no property \\'', '').slice(0, -1);\n        err.message = `no link named \"${linkName}\" under ${cid}`;\n        err.code = 'ERR_NO_LINK';\n      }\n\n      throw err;\n    }\n\n    cids.push(cid);\n  }\n\n  return cids;\n};\n\nconst mapFile = (file, options) => {\n  options = options || {};\n  const output = {\n    cid: file.cid,\n    path: file.path,\n    name: file.name,\n    depth: file.path.split('/').length,\n    size: 0,\n    type: 'dir'\n  };\n\n  if (file.unixfs) {\n    if (file.unixfs.type === 'file') {\n      output.size = file.unixfs.fileSize();\n      output.type = 'file';\n\n      if (options.includeContent) {\n        output.content = file.content();\n      }\n    }\n\n    output.mode = file.unixfs.mode;\n    output.mtime = file.unixfs.mtime;\n  }\n\n  return output;\n};\n\nfunction withTimeoutOption(fn, optionsArgIndex) {\n  return (...args) => {\n    const options = args[optionsArgIndex == null ? args.length - 1 : optionsArgIndex];\n    if (!options || !options.timeout) return fn(...args);\n    const timeout = typeof options.timeout === 'string' ? parseDuration(options.timeout) : options.timeout;\n    const controller = new TimeoutController(timeout);\n    options.signal = anySignal([options.signal, controller.signal]);\n    const fnRes = fn(...args);\n    const timeoutPromise = new Promise((resolve, reject) => {\n      controller.signal.addEventListener('abort', () => {\n        reject(new TimeoutError());\n      });\n    });\n    const start = Date.now();\n\n    const maybeThrowTimeoutError = () => {\n      if (controller.signal.aborted) {\n        throw new TimeoutError();\n      }\n\n      const timeTaken = Date.now() - start; // if we have starved the event loop by adding microtasks, we could have\n      // timed out already but the TimeoutController will never know because it's\n      // setTimeout will not fire until we stop adding microtasks\n\n      if (timeTaken > timeout) {\n        controller.abort();\n        throw new TimeoutError();\n      }\n    };\n\n    if (fnRes[Symbol.asyncIterator]) {\n      return async function* () {\n        const it = fnRes[Symbol.asyncIterator]();\n\n        try {\n          while (true) {\n            const {\n              value,\n              done\n            } = await Promise.race([it.next(), timeoutPromise]);\n\n            if (done) {\n              break;\n            }\n\n            maybeThrowTimeoutError();\n            yield value;\n          }\n        } catch (err) {\n          maybeThrowTimeoutError();\n          throw err;\n        } finally {\n          controller.clear();\n\n          if (it.return) {\n            it.return();\n          }\n        }\n      }();\n    }\n\n    return (async () => {\n      try {\n        const res = await Promise.race([fnRes, timeoutPromise]);\n        maybeThrowTimeoutError();\n        return res;\n      } catch (err) {\n        maybeThrowTimeoutError();\n        throw err;\n      } finally {\n        controller.clear();\n      }\n    })();\n  };\n}\n\nexports.normalizePath = normalizePath;\nexports.normalizeCidPath = normalizeCidPath;\nexports.parseIpfsPath = parseIpfsPath;\nexports.resolvePath = resolvePath;\nexports.mapFile = mapFile;\nexports.withTimeoutOption = withTimeoutOption;","map":null,"metadata":{},"sourceType":"script"}