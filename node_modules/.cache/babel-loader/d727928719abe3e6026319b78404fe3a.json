{"ast":null,"code":"'use strict';\n\nconst cache = require('hashlru');\n\nconst varint = require('varint');\n\nconst PeerId = require('peer-id');\n\nconst {\n  Key\n} = require('interface-datastore');\n\nconst {\n  default: Queue\n} = require('p-queue');\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst c = require('./constants');\n\nconst utils = require('./utils');\n/**\n * This class manages known providers.\n * A provider is a peer that we know to have the content for a given CID.\n *\n * Every `cleanupInterval` providers are checked if they\n * are still valid, i.e. younger than the `provideValidity`.\n * If they are not, they are deleted.\n *\n * To ensure the list survives restarts of the daemon,\n * providers are stored in the datastore, but to ensure\n * access is fast there is an LRU cache in front of that.\n */\n\n\nclass Providers {\n  /**\n   * @param {Object} datastore\n   * @param {PeerId} [self]\n   * @param {number} [cacheSize=256]\n   */\n  constructor(datastore, self, cacheSize) {\n    this.datastore = datastore;\n    this._log = utils.logger(self, 'providers');\n    /**\n     * How often invalid records are cleaned. (in seconds)\n     *\n     * @type {number}\n     */\n\n    this.cleanupInterval = c.PROVIDERS_CLEANUP_INTERVAL;\n    /**\n     * How long is a provider valid for. (in seconds)\n     *\n     * @type {number}\n     */\n\n    this.provideValidity = c.PROVIDERS_VALIDITY;\n    /**\n     * LRU cache size\n     *\n     * @type {number}\n     */\n\n    this.lruCacheSize = cacheSize || c.PROVIDERS_LRU_CACHE_SIZE;\n    this.providers = cache(this.lruCacheSize);\n    this.syncQueue = new Queue({\n      concurrency: 1\n    });\n  }\n  /**\n   * Release any resources.\n   *\n   * @returns {void}\n   */\n\n\n  stop() {\n    if (this._cleaner) {\n      clearInterval(this._cleaner);\n      this._cleaner = null;\n    }\n  }\n  /**\n   * Check all providers if they are still valid, and if not delete them.\n   *\n   * @returns {Promise<void>}\n   * @private\n   */\n\n\n  _cleanup() {\n    return this.syncQueue.add(async () => {\n      this._log('start cleanup');\n\n      const start = Date.now();\n      let count = 0;\n      let deleteCount = 0;\n      const deleted = new Map();\n      const batch = this.datastore.batch(); // Get all provider entries from the datastore\n\n      const query = this.datastore.query({\n        prefix: c.PROVIDERS_KEY_PREFIX\n      });\n\n      for await (const entry of query) {\n        try {\n          // Add a delete to the batch for each expired entry\n          const {\n            cid,\n            peerId\n          } = parseProviderKey(entry.key);\n          const time = readTime(entry.value);\n          const now = Date.now();\n          const delta = now - time;\n          const expired = delta > this.provideValidity;\n\n          this._log('comparing: %d - %d = %d > %d %s', now, time, delta, this.provideValidity, expired ? '(expired)' : '');\n\n          if (expired) {\n            deleteCount++;\n            batch.delete(entry.key);\n            const peers = deleted.get(cid) || new Set();\n            peers.add(peerId);\n            deleted.set(cid, peers);\n          }\n\n          count++;\n        } catch (err) {\n          this._log.error(err.message);\n        }\n      }\n\n      this._log('deleting %d / %d entries', deleteCount, count); // Commit the deletes to the datastore\n\n\n      if (deleted.size) {\n        await batch.commit();\n      } // Clear expired entries from the cache\n\n\n      for (const [cid, peers] of deleted) {\n        const key = makeProviderKey(cid);\n        const provs = this.providers.get(key);\n\n        if (provs) {\n          for (const peerId of peers) {\n            provs.delete(peerId);\n          }\n\n          if (provs.size === 0) {\n            this.providers.remove(key);\n          } else {\n            this.providers.set(key, provs);\n          }\n        }\n      }\n\n      this._log('Cleanup successful (%dms)', Date.now() - start);\n    });\n  }\n  /**\n   * Get the currently known provider peer ids for a given CID.\n   *\n   * @param {CID} cid\n   * @returns {Promise<Map<String, Date>>}\n   *\n   * @private\n   */\n\n\n  async _getProvidersMap(cid) {\n    const cacheKey = makeProviderKey(cid);\n    let provs = this.providers.get(cacheKey);\n\n    if (!provs) {\n      provs = await loadProviders(this.datastore, cid);\n      this.providers.set(cacheKey, provs);\n    }\n\n    return provs;\n  }\n\n  get cleanupInterval() {\n    return this._cleanupInterval;\n  }\n\n  set cleanupInterval(val) {\n    this._cleanupInterval = val;\n\n    if (this._cleaner) {\n      clearInterval(this._cleaner);\n    }\n\n    this._cleaner = setInterval(() => this._cleanup(), this.cleanupInterval);\n  }\n  /**\n   * Add a new provider for the given CID.\n   *\n   * @param {CID} cid\n   * @param {PeerId} provider\n   * @returns {Promise<void>}\n   */\n\n\n  async addProvider(cid, provider) {\n    // eslint-disable-line require-await\n    return this.syncQueue.add(async () => {\n      this._log('addProvider %s', cid.toBaseEncodedString());\n\n      const provs = await this._getProvidersMap(cid);\n\n      this._log('loaded %s provs', provs.size);\n\n      const now = Date.now();\n      provs.set(utils.encodeBase32(provider.id), now);\n      const dsKey = makeProviderKey(cid);\n      this.providers.set(dsKey, provs);\n      return writeProviderEntry(this.datastore, cid, provider, now);\n    });\n  }\n  /**\n   * Get a list of providers for the given CID.\n   *\n   * @param {CID} cid\n   * @returns {Promise<Array<PeerId>>}\n   */\n\n\n  async getProviders(cid) {\n    // eslint-disable-line require-await\n    return this.syncQueue.add(async () => {\n      this._log('getProviders %s', cid.toBaseEncodedString());\n\n      const provs = await this._getProvidersMap(cid);\n      return [...provs.keys()].map(base32PeerId => {\n        return new PeerId(utils.decodeBase32(base32PeerId));\n      });\n    });\n  }\n\n}\n/**\n * Encode the given key its matching datastore key.\n *\n * @param {CID|string} cid - cid or base32 encoded string\n * @returns {string}\n *\n * @private\n */\n\n\nfunction makeProviderKey(cid) {\n  cid = typeof cid === 'string' ? cid : utils.encodeBase32(cid.buffer);\n  return c.PROVIDERS_KEY_PREFIX + cid;\n}\n/**\n * Write a provider into the given store.\n *\n * @param {Datastore} store\n * @param {CID} cid\n * @param {PeerId} peer\n * @param {number} time\n * @returns {Promise<void>}\n *\n * @private\n */\n\n\nasync function writeProviderEntry(store, cid, peer, time) {\n  // eslint-disable-line require-await\n  const dsKey = [makeProviderKey(cid), '/', utils.encodeBase32(peer.id)].join('');\n  const key = new Key(dsKey);\n  const buffer = Buffer.from(varint.encode(time));\n  return store.put(key, buffer);\n}\n/**\n * Parse the CID and provider peer id from the key\n *\n * @param {DKey} key\n * @returns {Object} object with peer id and cid\n *\n * @private\n */\n\n\nfunction parseProviderKey(key) {\n  const parts = key.toString().split('/');\n\n  if (parts.length !== 4) {\n    throw new Error('incorrectly formatted provider entry key in datastore: ' + key);\n  }\n\n  return {\n    cid: parts[2],\n    peerId: parts[3]\n  };\n}\n/**\n * Load providers for the given CID from the store.\n *\n * @param {Datastore} store\n * @param {CID} cid\n * @returns {Promise<Map<PeerId, Date>>}\n *\n * @private\n */\n\n\nasync function loadProviders(store, cid) {\n  const providers = new Map();\n  const query = store.query({\n    prefix: makeProviderKey(cid)\n  });\n\n  for await (const entry of query) {\n    const {\n      peerId\n    } = parseProviderKey(entry.key);\n    providers.set(peerId, readTime(entry.value));\n  }\n\n  return providers;\n}\n\nfunction readTime(buf) {\n  return varint.decode(buf);\n}\n\nmodule.exports = Providers;","map":null,"metadata":{},"sourceType":"script"}