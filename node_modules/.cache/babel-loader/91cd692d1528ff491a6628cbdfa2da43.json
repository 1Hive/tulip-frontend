{"ast":null,"code":"/*!\n * sha256.js - SHA256 implementation for bcrypto\n * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Parts of this software are based on indutny/hash.js:\n *   Copyright (c) 2014, Fedor Indutny (MIT License).\n *   https://github.com/indutny/hash.js\n *\n * Resources:\n *   https://en.wikipedia.org/wiki/SHA-2\n *   https://tools.ietf.org/html/rfc4634\n *   https://github.com/indutny/hash.js/blob/master/lib/hash/sha/256.js\n */\n'use strict';\n\nconst assert = require('../internal/assert');\n\nconst HMAC = require('../internal/hmac');\n/*\n * Constants\n */\n\n\nconst FINALIZED = -1;\nconst DESC = Buffer.alloc(8, 0x00);\nconst PADDING = Buffer.alloc(64, 0x00);\nPADDING[0] = 0x80;\nconst K = new Uint32Array([0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]);\n/**\n * SHA256\n */\n\nclass SHA256 {\n  constructor() {\n    this.state = new Uint32Array(8);\n    this.msg = new Uint32Array(64);\n    this.block = Buffer.allocUnsafe(64);\n    this.size = FINALIZED;\n  }\n\n  init() {\n    this.state[0] = 0x6a09e667;\n    this.state[1] = 0xbb67ae85;\n    this.state[2] = 0x3c6ef372;\n    this.state[3] = 0xa54ff53a;\n    this.state[4] = 0x510e527f;\n    this.state[5] = 0x9b05688c;\n    this.state[6] = 0x1f83d9ab;\n    this.state[7] = 0x5be0cd19;\n    this.size = 0;\n    return this;\n  }\n\n  update(data) {\n    assert(Buffer.isBuffer(data));\n\n    this._update(data, data.length);\n\n    return this;\n  }\n\n  final() {\n    return this._final(Buffer.allocUnsafe(32));\n  }\n\n  _update(data, len) {\n    assert(this.size !== FINALIZED, 'Context is not initialized.');\n    let pos = this.size & 63;\n    let off = 0;\n    this.size += len;\n\n    if (pos > 0) {\n      let want = 64 - pos;\n      if (want > len) want = len;\n      data.copy(this.block, pos, off, off + want);\n      pos += want;\n      len -= want;\n      off += want;\n      if (pos < 64) return;\n\n      this._transform(this.block, 0);\n    }\n\n    while (len >= 64) {\n      this._transform(data, off);\n\n      off += 64;\n      len -= 64;\n    }\n\n    if (len > 0) data.copy(this.block, 0, off, off + len);\n  }\n\n  _final(out) {\n    assert(this.size !== FINALIZED, 'Context is not initialized.');\n    const pos = this.size & 63;\n    const len = this.size * 8;\n    writeU32(DESC, len * (1 / 0x100000000) >>> 0, 0);\n    writeU32(DESC, len >>> 0, 4);\n\n    this._update(PADDING, 1 + (119 - pos & 63));\n\n    this._update(DESC, 8);\n\n    for (let i = 0; i < 8; i++) {\n      writeU32(out, this.state[i], i * 4);\n      this.state[i] = 0;\n    }\n\n    for (let i = 0; i < 64; i++) this.msg[i] = 0;\n\n    for (let i = 0; i < 64; i++) this.block[i] = 0;\n\n    this.size = FINALIZED;\n    return out;\n  }\n\n  _transform(chunk, pos) {\n    const W = this.msg;\n    let a = this.state[0];\n    let b = this.state[1];\n    let c = this.state[2];\n    let d = this.state[3];\n    let e = this.state[4];\n    let f = this.state[5];\n    let g = this.state[6];\n    let h = this.state[7];\n    let i = 0;\n\n    for (; i < 16; i++) W[i] = readU32(chunk, pos + i * 4);\n\n    for (; i < 64; i++) W[i] = sigma1(W[i - 2]) + W[i - 7] + sigma0(W[i - 15]) + W[i - 16];\n\n    for (i = 0; i < 64; i++) {\n      const t1 = h + Sigma1(e) + Ch(e, f, g) + K[i] + W[i];\n      const t2 = Sigma0(a) + Maj(a, b, c);\n      h = g;\n      g = f;\n      f = e;\n      e = d + t1 >>> 0;\n      d = c;\n      c = b;\n      b = a;\n      a = t1 + t2 >>> 0;\n    }\n\n    this.state[0] += a;\n    this.state[1] += b;\n    this.state[2] += c;\n    this.state[3] += d;\n    this.state[4] += e;\n    this.state[5] += f;\n    this.state[6] += g;\n    this.state[7] += h;\n  }\n\n  static hash() {\n    return new SHA256();\n  }\n\n  static hmac() {\n    return new HMAC(SHA256, 64);\n  }\n\n  static digest(data) {\n    return SHA256.ctx.init().update(data).final();\n  }\n\n  static root(left, right) {\n    assert(Buffer.isBuffer(left) && left.length === 32);\n    assert(Buffer.isBuffer(right) && right.length === 32);\n    return SHA256.ctx.init().update(left).update(right).final();\n  }\n\n  static multi(x, y, z) {\n    const {\n      ctx\n    } = SHA256;\n    ctx.init();\n    ctx.update(x);\n    ctx.update(y);\n    if (z) ctx.update(z);\n    return ctx.final();\n  }\n\n  static mac(data, key) {\n    return SHA256.hmac().init(key).update(data).final();\n  }\n\n}\n/*\n * Static\n */\n\n\nSHA256.native = 0;\nSHA256.id = 'SHA256';\nSHA256.size = 32;\nSHA256.bits = 256;\nSHA256.blockSize = 64;\nSHA256.zero = Buffer.alloc(32, 0x00);\nSHA256.ctx = new SHA256();\n/*\n * Helpers\n */\n\nfunction Sigma0(x) {\n  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);\n}\n\nfunction Sigma1(x) {\n  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);\n}\n\nfunction sigma0(x) {\n  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;\n}\n\nfunction sigma1(x) {\n  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;\n}\n\nfunction Ch(x, y, z) {\n  return z ^ x & (y ^ z);\n}\n\nfunction Maj(x, y, z) {\n  return x & y | z & (x | y);\n}\n\nfunction readU32(data, off) {\n  return data[off++] * 0x1000000 + data[off++] * 0x10000 + data[off++] * 0x100 + data[off];\n}\n\nfunction writeU32(data, num, off) {\n  data[off++] = num >>> 24;\n  data[off++] = num >>> 16;\n  data[off++] = num >>> 8;\n  data[off++] = num;\n  return off;\n}\n/*\n * Expose\n */\n\n\nmodule.exports = SHA256;","map":null,"metadata":{},"sourceType":"script"}