{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _awaitAsyncGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _wrapAsyncGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar _asyncIterator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar _require = require('streaming-iterables'),\n    map = _require.map;\n\nvar errcode = require('err-code');\n/**\n * BlockService is a hybrid block datastore. It stores data in a local\n * datastore and may retrieve data from a remote Exchange.\n * It uses an internal `datastore.Datastore` instance to store values.\n */\n\n\nvar BlockService = /*#__PURE__*/function () {\n  /**\n   * Create a new BlockService\n   *\n   * @param {IPFSRepo} ipfsRepo\n   */\n  function BlockService(ipfsRepo) {\n    _classCallCheck(this, BlockService);\n\n    this._repo = ipfsRepo;\n    this._bitswap = null;\n  }\n  /**\n   * Add a bitswap instance that communicates with the\n   * network to retreive blocks that are not in the local store.\n   *\n   * If the node is online all requests for blocks first\n   * check locally and afterwards ask the network for the blocks.\n   *\n   * @param {Bitswap} bitswap\n   * @returns {void}\n   */\n\n\n  _createClass(BlockService, [{\n    key: \"setExchange\",\n    value: function setExchange(bitswap) {\n      this._bitswap = bitswap;\n    }\n    /**\n     * Go offline, i.e. drop the reference to bitswap.\n     *\n     * @returns {void}\n     */\n\n  }, {\n    key: \"unsetExchange\",\n    value: function unsetExchange() {\n      this._bitswap = null;\n    }\n    /**\n     * Is the blockservice online, i.e. is bitswap present.\n     *\n     * @returns {bool}\n     */\n\n  }, {\n    key: \"hasExchange\",\n    value: function hasExchange() {\n      return this._bitswap != null;\n    }\n    /**\n     * Put a block to the underlying datastore.\n     *\n     * @param {Block} block\n     * @param {Object} [options] -  Options is an object with the following properties\n     * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"put\",\n    value: function put(block, options) {\n      if (this.hasExchange()) {\n        return this._bitswap.put(block, options);\n      } else {\n        return this._repo.blocks.put(block, options);\n      }\n    }\n    /**\n     * Put a multiple blocks to the underlying datastore.\n     *\n     * @param {AsyncIterator<Block>} blocks\n     * @param {Object} [options] -  Options is an object with the following properties\n     * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"putMany\",\n    value: function putMany(blocks, options) {\n      if (this.hasExchange()) {\n        return this._bitswap.putMany(blocks, options);\n      } else {\n        return this._repo.blocks.putMany(blocks, options);\n      }\n    }\n    /**\n     * Get a block by cid.\n     *\n     * @param {CID} cid\n     * @param {Object} [options] -  Options is an object with the following properties\n     * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation\n     * @returns {Promise<Block>}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(cid, options) {\n      if (this.hasExchange()) {\n        return this._bitswap.get(cid, options);\n      } else {\n        return this._repo.blocks.get(cid, options);\n      }\n    }\n    /**\n     * Get multiple blocks back from an array of cids.\n     *\n     * @param {AsyncIterator<CID>} cids\n     * @param {Object} [options] -  Options is an object with the following properties\n     * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation\n     * @returns {AsyncIterator<Block>}\n     */\n\n  }, {\n    key: \"getMany\",\n    value: function getMany(cids, options) {\n      var _this = this;\n\n      if (!Array.isArray(cids)) {\n        throw new Error('first arg must be an array of cids');\n      }\n\n      if (this.hasExchange()) {\n        return this._bitswap.getMany(cids, options);\n      } else {\n        var getRepoBlocks = map(function (cid) {\n          return _this._repo.blocks.get(cid, options);\n        });\n        return getRepoBlocks(cids);\n      }\n    }\n    /**\n     * Delete a block from the blockstore.\n     *\n     * @param {CID} cid\n     * @param {Object} [options] -  Options is an object with the following properties\n     * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"delete\",\n    value: function () {\n      var _delete2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(cid, options) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this._repo.blocks.has(cid);\n\n              case 2:\n                if (_context.sent) {\n                  _context.next = 4;\n                  break;\n                }\n\n                throw errcode(new Error('blockstore: block not found'), 'ERR_BLOCK_NOT_FOUND');\n\n              case 4:\n                return _context.abrupt(\"return\", this._repo.blocks.delete(cid, options));\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function _delete(_x, _x2) {\n        return _delete2.apply(this, arguments);\n      }\n\n      return _delete;\n    }()\n    /**\n     * Delete multiple blocks from the blockstore.\n     *\n     * @param {AsyncIterator<CID>} cids\n     * @param {Object} [options] -  Options is an object with the following properties\n     * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"deleteMany\",\n    value: function deleteMany(cids, options) {\n      var repo = this._repo;\n      return this._repo.blocks.deleteMany(_wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, cid;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _iteratorNormalCompletion = true;\n                _didIteratorError = false;\n                _context2.prev = 2;\n                _iterator = _asyncIterator(cids);\n\n              case 4:\n                _context2.next = 6;\n                return _awaitAsyncGenerator(_iterator.next());\n\n              case 6:\n                _step = _context2.sent;\n                _iteratorNormalCompletion = _step.done;\n                _context2.next = 10;\n                return _awaitAsyncGenerator(_step.value);\n\n              case 10:\n                _value = _context2.sent;\n\n                if (_iteratorNormalCompletion) {\n                  _context2.next = 22;\n                  break;\n                }\n\n                cid = _value;\n                _context2.next = 15;\n                return _awaitAsyncGenerator(repo.blocks.has(cid));\n\n              case 15:\n                if (_context2.sent) {\n                  _context2.next = 17;\n                  break;\n                }\n\n                throw errcode(new Error('blockstore: block not found'), 'ERR_BLOCK_NOT_FOUND');\n\n              case 17:\n                _context2.next = 19;\n                return cid;\n\n              case 19:\n                _iteratorNormalCompletion = true;\n                _context2.next = 4;\n                break;\n\n              case 22:\n                _context2.next = 28;\n                break;\n\n              case 24:\n                _context2.prev = 24;\n                _context2.t0 = _context2[\"catch\"](2);\n                _didIteratorError = true;\n                _iteratorError = _context2.t0;\n\n              case 28:\n                _context2.prev = 28;\n                _context2.prev = 29;\n\n                if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                  _context2.next = 33;\n                  break;\n                }\n\n                _context2.next = 33;\n                return _awaitAsyncGenerator(_iterator.return());\n\n              case 33:\n                _context2.prev = 33;\n\n                if (!_didIteratorError) {\n                  _context2.next = 36;\n                  break;\n                }\n\n                throw _iteratorError;\n\n              case 36:\n                return _context2.finish(33);\n\n              case 37:\n                return _context2.finish(28);\n\n              case 38:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, null, [[2, 24, 28, 38], [29,, 33, 37]]);\n      }))(), options);\n    }\n  }]);\n\n  return BlockService;\n}();\n\nmodule.exports = BlockService;","map":null,"metadata":{},"sourceType":"script"}