{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar KeyValueStore = require('./keyValueStore');\n\nvar Thread = require('./thread');\n\nvar GhostThread = require('./ghost');\n\nvar API = require('./api');\n\nvar _require = require('./utils'),\n    throwIfUndefined = _require.throwIfUndefined,\n    throwIfNotEqualLenArrays = _require.throwIfNotEqualLenArrays;\n\nvar OrbitDBAddress = require('orbit-db/src/orbit-db-address');\n\nvar nameToSpaceName = function nameToSpaceName(name) {\n  return \"3box.space.\".concat(name, \".keyvalue\");\n};\n\nvar namesTothreadName = function namesTothreadName(spaceName, threadName) {\n  return \"3box.thread.\".concat(spaceName, \".\").concat(threadName);\n};\n\nvar namesToChatName = function namesToChatName(spaceName, chatName) {\n  return \"3box.ghost.\".concat(spaceName, \".\").concat(chatName);\n};\n/** Class representing a user. */\n\n\nvar User = /*#__PURE__*/function () {\n  function User(spaceName, threeId, resolver) {\n    (0, _classCallCheck2[\"default\"])(this, User);\n    this._name = spaceName;\n    this._3id = threeId;\n    this._resolver = resolver;\n  }\n  /**\n   * @property {String} DID            the DID of the user\n   */\n\n\n  (0, _createClass2[\"default\"])(User, [{\n    key: \"signClaim\",\n\n    /**\n     * Sign a JWT claim\n     *\n     * @param     {Object}    payload                 The payload to sign\n     * @param     {Object}    opts                    Optional parameters\n     *\n     * @return    {String}                            The signed JWT\n     */\n    value: function () {\n      var _signClaim = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee(payload) {\n        var opts,\n            _args = arguments;\n        return _regenerator[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                opts = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n                return _context.abrupt(\"return\", this._3id.signJWT(payload, Object.assign(opts, {\n                  space: this._name\n                })));\n\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function signClaim(_x) {\n        return _signClaim.apply(this, arguments);\n      }\n\n      return signClaim;\n    }()\n    /**\n     * Encrypt a message. By default encrypts messages symmetrically\n     * with the users private key. If the `to` parameter is used,\n     * the message will be asymmetrically encrypted to the recipient.\n     *\n     * @param     {String}    message                 The message to encrypt\n     * @param     {Object}    opts                    Optional parameters\n     * @param     {String}    to                      The receiver of the message, a DID or an ethereum address\n     *\n     * @return    {Object}                            An object containing the encrypted payload\n     */\n\n  }, {\n    key: \"encrypt\",\n    value: function () {\n      var _encrypt = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee2(message) {\n        var _ref,\n            to,\n            toPubkey,\n            _args2 = arguments;\n\n        return _regenerator[\"default\"].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _ref = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {}, to = _ref.to;\n\n                if (!to) {\n                  _context2.next = 5;\n                  break;\n                }\n\n                _context2.next = 4;\n                return this._findSpacePubKey(to, this._name);\n\n              case 4:\n                toPubkey = _context2.sent;\n\n              case 5:\n                return _context2.abrupt(\"return\", this._3id.encrypt(message, this._name, toPubkey));\n\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function encrypt(_x2) {\n        return _encrypt.apply(this, arguments);\n      }\n\n      return encrypt;\n    }()\n    /**\n     * Decrypts a message if the user owns the correct key to decrypt it.\n     *\n     * @param     {Object}    encryptedObject         The encrypted message to decrypt (as encoded by the `encrypt` method\n     *\n     * @return    {String}                            The clear text message\n     */\n\n  }, {\n    key: \"decrypt\",\n    value: function () {\n      var _decrypt = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee3(encryptedObject, toBuffer) {\n        return _regenerator[\"default\"].wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", this._3id.decrypt(encryptedObject, this._name, toBuffer));\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function decrypt(_x3, _x4) {\n        return _decrypt.apply(this, arguments);\n      }\n\n      return decrypt;\n    }()\n  }, {\n    key: \"_findSpacePubKey\",\n    value: function () {\n      var _findSpacePubKey2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee4(did, spaceName) {\n        var doc, pubkey;\n        return _regenerator[\"default\"].wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!did.startsWith('0x')) {\n                  _context4.next = 4;\n                  break;\n                }\n\n                _context4.next = 3;\n                return API.getSpaceDID(did, spaceName);\n\n              case 3:\n                did = _context4.sent;\n\n              case 4:\n                _context4.next = 6;\n                return this._resolver.resolve(did);\n\n              case 6:\n                doc = _context4.sent;\n                pubkey = doc.publicKey.find(function (key) {\n                  return key.id.includes('#subEncryptionKey');\n                });\n\n                if (pubkey) {\n                  _context4.next = 16;\n                  break;\n                }\n\n                _context4.next = 11;\n                return API.getSpaceDID(did, spaceName);\n\n              case 11:\n                did = _context4.sent;\n                _context4.next = 14;\n                return this._resolver.resolve(did);\n\n              case 14:\n                doc = _context4.sent;\n                pubkey = doc.publicKey.find(function (key) {\n                  return key.id.includes('#subEncryptionKey');\n                });\n\n              case 16:\n                return _context4.abrupt(\"return\", pubkey.publicKeyBase64);\n\n              case 17:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function _findSpacePubKey(_x5, _x6) {\n        return _findSpacePubKey2.apply(this, arguments);\n      }\n\n      return _findSpacePubKey;\n    }()\n  }, {\n    key: \"DID\",\n    get: function get() {\n      return this._3id.getSubDID(this._name);\n    }\n  }]);\n  return User;\n}();\n\nvar Space = /*#__PURE__*/function () {\n  /**\n   * Please use **box.openSpace** to get the instance of this class\n   */\n  function Space(name, replicator) {\n    (0, _classCallCheck2[\"default\"])(this, Space);\n    this._name = name;\n    this._replicator = replicator;\n    this._store = new KeyValueStore(nameToSpaceName(this._name), this._replicator);\n    this._activeThreads = {};\n    /**\n     * @property {KeyValueStore} public         access the profile store of the space\n     */\n\n    this[\"public\"] = null;\n    /**\n     * @property {KeyValueStore} private        access the private store of the space\n     */\n\n    this[\"private\"] = null;\n    /**\n     * @property {Promise}       syncDone       A promise that is resolved when the space data is synced\n     */\n\n    this.syncDone = null;\n  }\n\n  (0, _createClass2[\"default\"])(Space, [{\n    key: \"open\",\n    value: function () {\n      var _open = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee6(threeId) {\n        var _this = this;\n\n        var opts,\n            authenticated,\n            syncSpace,\n            _args6 = arguments;\n        return _regenerator[\"default\"].wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                opts = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : {};\n\n                if (this.isOpen) {\n                  _context6.next = 18;\n                  break;\n                } // store is not loaded opened yet\n\n\n                this._3id = threeId;\n                _context6.next = 5;\n                return this._3id.isAuthenticated([this._name]);\n\n              case 5:\n                authenticated = _context6.sent;\n\n                if (authenticated) {\n                  _context6.next = 9;\n                  break;\n                }\n\n                _context6.next = 9;\n                return this._3id.authenticate([this._name], opts);\n\n              case 9:\n                if (opts.consentCallback) opts.consentCallback(!authenticated, this._name);\n                _context6.next = 12;\n                return this._store._load(this._3id);\n\n              case 12:\n                syncSpace = /*#__PURE__*/function () {\n                  var _ref2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee5() {\n                    return _regenerator[\"default\"].wrap(function _callee5$(_context5) {\n                      while (1) {\n                        switch (_context5.prev = _context5.next) {\n                          case 0:\n                            _context5.next = 2;\n                            return _this._store._sync();\n\n                          case 2:\n                            if (opts.onSyncDone) opts.onSyncDone();\n\n                          case 3:\n                          case \"end\":\n                            return _context5.stop();\n                        }\n                      }\n                    }, _callee5);\n                  }));\n\n                  return function syncSpace() {\n                    return _ref2.apply(this, arguments);\n                  };\n                }();\n\n                this.syncDone = syncSpace();\n                this[\"public\"] = publicStoreReducer(this._store);\n                this[\"private\"] = privateStoreReducer(this._store, this._3id, this._name); // make sure we're authenticated to all threads\n\n                _context6.next = 18;\n                return this._authThreads(this._3id);\n\n              case 18:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function open(_x7) {\n        return _open.apply(this, arguments);\n      }\n\n      return open;\n    }()\n  }, {\n    key: \"_authThreads\",\n    value: function () {\n      var _authThreads2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee7(threeId) {\n        var odbIdentity;\n        return _regenerator[\"default\"].wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.next = 2;\n                return threeId.getOdbId(this._name);\n\n              case 2:\n                odbIdentity = _context7.sent;\n                Object.values(this._activeThreads).forEach(function (thread) {\n                  if (thread.isGhost) {\n                    thread._set3id(threeId);\n                  } else {\n                    thread._setIdentity(odbIdentity);\n                  }\n                });\n\n              case 4:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function _authThreads(_x8) {\n        return _authThreads2.apply(this, arguments);\n      }\n\n      return _authThreads;\n    }()\n    /**\n     * Join a thread. Use this to start receiving updates from, and to post in threads\n     *\n     * @param     {String}    name                    The name of the thread\n     * @param     {Object}    opts                    Optional parameters\n     * @param     {String}    opts.firstModerator     DID of first moderator of a thread, by default, user is first moderator\n     * @param     {Boolean}   opts.members            join a members only thread, which only members can post in, defaults to open thread\n     * @param     {Boolean}   opts.confidential       create a confidential thread with true or join existing confidential thread with an encKeyId string\n     * @param     {Boolean}   opts.noAutoSub          Disable auto subscription to the thread when posting to it (default false)\n     * @param     {Boolean}   opts.ghost              Enable ephemeral messaging via Ghost Thread\n     * @param     {String}    opts.ghostPinbot        MultiAddress of a Ghost Pinbot node\n     * @param     {Number}    opts.ghostBacklogLimit  The number of posts to maintain in the ghost backlog\n     * @param     {Array<Function>} opts.ghostFilters Array of functions for filtering messages\n     *\n     * @return    {Thread}                  An instance of the thread class for the joined thread\n     */\n\n  }, {\n    key: \"joinThread\",\n    value: function () {\n      var _joinThread = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee8(name) {\n        var opts,\n            ghostAddress,\n            subscribeFn,\n            user,\n            thread,\n            address,\n            _args8 = arguments;\n        return _regenerator[\"default\"].wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                opts = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : {};\n\n                if (!opts.ghost) {\n                  _context8.next = 8;\n                  break;\n                }\n\n                ghostAddress = namesToChatName(this._name, name);\n\n                if (!this._activeThreads[ghostAddress]) {\n                  this._activeThreads[ghostAddress] = new GhostThread(ghostAddress, this._replicator, this._3id, opts);\n                }\n\n                if (this._3id) {\n                  this._activeThreads[ghostAddress]._set3id(this._3id);\n                }\n\n                return _context8.abrupt(\"return\", this._activeThreads[ghostAddress]);\n\n              case 8:\n                subscribeFn = opts.noAutoSub ? function () {} : this.subscribeThread.bind(this);\n\n                if (!opts.confidential) {\n                  _context8.next = 12;\n                  break;\n                }\n\n                if (this._3id) {\n                  _context8.next = 12;\n                  break;\n                }\n\n                throw new Error('confidential threads require user to be authenticated');\n\n              case 12:\n                if (opts.firstModerator) {\n                  _context8.next = 16;\n                  break;\n                }\n\n                if (this._3id) {\n                  _context8.next = 15;\n                  break;\n                }\n\n                throw new Error('firstModerator required if not authenticated');\n\n              case 15:\n                opts.firstModerator = this._3id.getSubDID(this._name);\n\n              case 16:\n                user = this._3id ? this.user : {};\n                thread = new Thread(namesTothreadName(this._name, name), this._replicator, opts.members, opts.firstModerator, opts.confidential, user, subscribeFn);\n                _context8.next = 20;\n                return thread._getThreadAddress();\n\n              case 20:\n                address = _context8.sent;\n\n                if (!this._activeThreads[address]) {\n                  _context8.next = 23;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\", this._activeThreads[address]);\n\n              case 23:\n                _context8.next = 25;\n                return thread._load();\n\n              case 25:\n                if (!this._3id) {\n                  _context8.next = 32;\n                  break;\n                }\n\n                _context8.t0 = thread;\n                _context8.next = 29;\n                return this._3id.getOdbId(this._name);\n\n              case 29:\n                _context8.t1 = _context8.sent;\n                _context8.next = 32;\n                return _context8.t0._setIdentity.call(_context8.t0, _context8.t1);\n\n              case 32:\n                this._activeThreads[address] = thread;\n                return _context8.abrupt(\"return\", thread);\n\n              case 34:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function joinThread(_x9) {\n        return _joinThread.apply(this, arguments);\n      }\n\n      return joinThread;\n    }()\n    /**\n     * Create a confidential thread\n     *\n     * @param     {String}    name          The name of the thread\n     *\n     * @return    {Thread}                  An instance of the thread class for the created thread\n     */\n\n  }, {\n    key: \"createConfidentialThread\",\n    value: function () {\n      var _createConfidentialThread = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee9(name) {\n        return _regenerator[\"default\"].wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                return _context9.abrupt(\"return\", this.joinThread(name, {\n                  confidential: true\n                }));\n\n              case 1:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function createConfidentialThread(_x10) {\n        return _createConfidentialThread.apply(this, arguments);\n      }\n\n      return createConfidentialThread;\n    }()\n    /**\n     * Join a thread by full thread address. Use this to start receiving updates from, and to post in threads\n     *\n     * @param     {String}    address                 The full address of the thread\n     * @param     {Object}    opts                    Optional parameters\n     * @param     {Boolean}   opts.noAutoSub          Disable auto subscription to the thread when posting to it (default false)\n     *\n     * @return    {Thread}                            An instance of the thread class for the joined thread\n     */\n\n  }, {\n    key: \"joinThreadByAddress\",\n    value: function () {\n      var _joinThreadByAddress = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee10(address) {\n        var opts,\n            threadSpace,\n            threadName,\n            subscribeFn,\n            user,\n            thread,\n            _args10 = arguments;\n        return _regenerator[\"default\"].wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                opts = _args10.length > 1 && _args10[1] !== undefined ? _args10[1] : {};\n\n                if (OrbitDBAddress.isValid(address)) {\n                  _context10.next = 3;\n                  break;\n                }\n\n                throw new Error('joinThreadByAddress: valid orbitdb address required');\n\n              case 3:\n                if (this.isOpen) {\n                  _context10.next = 5;\n                  break;\n                }\n\n                throw new Error('joinThreadByAddress requires space to be open');\n\n              case 5:\n                threadSpace = address.split('.')[2];\n                threadName = address.split('.')[3];\n\n                if (!(threadSpace !== this._name)) {\n                  _context10.next = 9;\n                  break;\n                }\n\n                throw new Error('joinThreadByAddress: attempting to open thread from different space, must open within same space');\n\n              case 9:\n                if (!this._activeThreads[address]) {\n                  _context10.next = 11;\n                  break;\n                }\n\n                return _context10.abrupt(\"return\", this._activeThreads[address]);\n\n              case 11:\n                subscribeFn = opts.noAutoSub ? function () {} : this.subscribeThread.bind(this);\n                user = this._3id ? this.user : {};\n                thread = new Thread(namesTothreadName(this._name, threadName), this._replicator, undefined, undefined, undefined, user, subscribeFn);\n                _context10.next = 16;\n                return thread._load(address);\n\n              case 16:\n                if (!this._3id) {\n                  _context10.next = 23;\n                  break;\n                }\n\n                _context10.t0 = thread;\n                _context10.next = 20;\n                return this._3id.getOdbId(this._name);\n\n              case 20:\n                _context10.t1 = _context10.sent;\n                _context10.next = 23;\n                return _context10.t0._setIdentity.call(_context10.t0, _context10.t1);\n\n              case 23:\n                this._activeThreads[address] = thread;\n                return _context10.abrupt(\"return\", thread);\n\n              case 25:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function joinThreadByAddress(_x11) {\n        return _joinThreadByAddress.apply(this, arguments);\n      }\n\n      return joinThreadByAddress;\n    }()\n    /**\n     * Subscribe to the given thread, if not already subscribed\n     *\n     * @param     {String}    address                The address of the thread\n     * @param     {Object}    config                configuration and thread meta data\n     * @param     {String}    opts.name             Name of thread\n     * @param     {String}    opts.firstModerator   DID of the first moderator\n     * @param     {String}    opts.members          Boolean string, true if a members only thread\n     */\n\n  }, {\n    key: \"subscribeThread\",\n    value: function () {\n      var _subscribeThread = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee11(address) {\n        var config,\n            threadKey,\n            _args11 = arguments;\n        return _regenerator[\"default\"].wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                config = _args11.length > 1 && _args11[1] !== undefined ? _args11[1] : {};\n\n                if (OrbitDBAddress.isValid(address)) {\n                  _context11.next = 3;\n                  break;\n                }\n\n                throw new Error('subscribeThread: must subscribe to valid thread/orbitdb address');\n\n              case 3:\n                if (this.isOpen) {\n                  _context11.next = 5;\n                  break;\n                }\n\n                return _context11.abrupt(\"return\");\n\n              case 5:\n                // we can't subscribe if space isn't open\n                threadKey = \"thread-\".concat(address);\n                _context11.next = 8;\n                return this.syncDone;\n\n              case 8:\n                _context11.next = 10;\n                return this[\"public\"].get(threadKey);\n\n              case 10:\n                if (_context11.sent) {\n                  _context11.next = 13;\n                  break;\n                }\n\n                _context11.next = 13;\n                return this[\"public\"].set(threadKey, Object.assign({}, config, {\n                  address: address\n                }));\n\n              case 13:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function subscribeThread(_x12) {\n        return _subscribeThread.apply(this, arguments);\n      }\n\n      return subscribeThread;\n    }()\n    /**\n     * Unsubscribe from the given thread, if subscribed\n     *\n     * @param     {String}    address     The address of the thread\n     */\n\n  }, {\n    key: \"unsubscribeThread\",\n    value: function () {\n      var _unsubscribeThread = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee12(address) {\n        var threadKey;\n        return _regenerator[\"default\"].wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                if (this.isOpen) {\n                  _context12.next = 2;\n                  break;\n                }\n\n                throw new Error('unsubscribeThread requires space to be open');\n\n              case 2:\n                threadKey = \"thread-\".concat(address);\n                _context12.next = 5;\n                return this[\"public\"].get(threadKey);\n\n              case 5:\n                if (!_context12.sent) {\n                  _context12.next = 8;\n                  break;\n                }\n\n                _context12.next = 8;\n                return this[\"public\"].remove(threadKey);\n\n              case 8:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function unsubscribeThread(_x13) {\n        return _unsubscribeThread.apply(this, arguments);\n      }\n\n      return unsubscribeThread;\n    }()\n    /**\n     * Get a list of all the threads subscribed to in this space\n     *\n     * @return    {Array<Objects>}    A list of thread objects as { address, firstModerator, members, name}\n     */\n\n  }, {\n    key: \"subscribedThreads\",\n    value: function () {\n      var _subscribedThreads = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee13() {\n        var allEntries;\n        return _regenerator[\"default\"].wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                if (this.isOpen) {\n                  _context13.next = 2;\n                  break;\n                }\n\n                throw new Error('subscribedThreads requires space to be open');\n\n              case 2:\n                _context13.next = 4;\n                return this[\"public\"].all();\n\n              case 4:\n                allEntries = _context13.sent;\n                return _context13.abrupt(\"return\", Object.keys(allEntries).reduce(function (threads, key) {\n                  if (key.startsWith('thread')) {\n                    // ignores experimental threads (v1)\n                    var address = key.split('thread-')[1];\n\n                    if (OrbitDBAddress.isValid(address)) {\n                      threads.push(allEntries[key]);\n                    }\n                  }\n\n                  return threads;\n                }, []));\n\n              case 6:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function subscribedThreads() {\n        return _subscribedThreads.apply(this, arguments);\n      }\n\n      return subscribedThreads;\n    }()\n  }, {\n    key: \"DID\",\n    get: function get() {\n      return this.user.DID;\n    }\n    /**\n     * @property {User} user            access the user object to encrypt data and sign claims\n     */\n\n  }, {\n    key: \"user\",\n    get: function get() {\n      if (!this._3id) throw new Error('user is not authenticated');\n      this._user = this._user || new User(this._name, this._3id, this._replicator.resolver);\n      return this._user;\n    }\n  }, {\n    key: \"isOpen\",\n    get: function get() {\n      return Boolean(this._store._db);\n    }\n  }]);\n  return Space;\n}();\n\nmodule.exports = Space;\n\nvar publicStoreReducer = function publicStoreReducer(store) {\n  var PREFIX = 'pub_';\n  return {\n    get: function () {\n      var _get = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee14(key) {\n        var opts,\n            _args14 = arguments;\n        return _regenerator[\"default\"].wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                opts = _args14.length > 1 && _args14[1] !== undefined ? _args14[1] : {};\n                return _context14.abrupt(\"return\", store.get(PREFIX + key, opts));\n\n              case 2:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14);\n      }));\n\n      function get(_x14) {\n        return _get.apply(this, arguments);\n      }\n\n      return get;\n    }(),\n    getMetadata: function () {\n      var _getMetadata = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee15(key) {\n        return _regenerator[\"default\"].wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                return _context15.abrupt(\"return\", store.getMetadata(PREFIX + key));\n\n              case 1:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15);\n      }));\n\n      function getMetadata(_x15) {\n        return _getMetadata.apply(this, arguments);\n      }\n\n      return getMetadata;\n    }(),\n    set: function () {\n      var _set = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee16(key, value) {\n        return _regenerator[\"default\"].wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                throwIfUndefined(key, 'key');\n                return _context16.abrupt(\"return\", store.set(PREFIX + key, value));\n\n              case 2:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16);\n      }));\n\n      function set(_x16, _x17) {\n        return _set.apply(this, arguments);\n      }\n\n      return set;\n    }(),\n    setMultiple: function () {\n      var _setMultiple = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee17(keys, values) {\n        var prefixedKeys;\n        return _regenerator[\"default\"].wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                throwIfNotEqualLenArrays(keys, values);\n                prefixedKeys = keys.map(function (key) {\n                  return PREFIX + key;\n                });\n                return _context17.abrupt(\"return\", store.setMultiple(prefixedKeys, values));\n\n              case 3:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17);\n      }));\n\n      function setMultiple(_x18, _x19) {\n        return _setMultiple.apply(this, arguments);\n      }\n\n      return setMultiple;\n    }(),\n    remove: function () {\n      var _remove = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee18(key) {\n        return _regenerator[\"default\"].wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                throwIfUndefined(key, 'key');\n                return _context18.abrupt(\"return\", store.remove(PREFIX + key));\n\n              case 2:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee18);\n      }));\n\n      function remove(_x20) {\n        return _remove.apply(this, arguments);\n      }\n\n      return remove;\n    }(),\n    log: function log() {\n      return (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee19() {\n        return _regenerator[\"default\"].wrap(function _callee19$(_context19) {\n          while (1) {\n            switch (_context19.prev = _context19.next) {\n              case 0:\n                _context19.next = 2;\n                return store.log();\n\n              case 2:\n                return _context19.abrupt(\"return\", _context19.sent.reduce(function (newLog, entry) {\n                  if (entry.key.startsWith(PREFIX)) {\n                    entry.key = entry.key.slice(4);\n                    newLog.push(entry);\n                  }\n\n                  return newLog;\n                }, []));\n\n              case 3:\n              case \"end\":\n                return _context19.stop();\n            }\n          }\n        }, _callee19);\n      }))();\n    },\n    all: function () {\n      var _all = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee20(opts) {\n        var entries;\n        return _regenerator[\"default\"].wrap(function _callee20$(_context20) {\n          while (1) {\n            switch (_context20.prev = _context20.next) {\n              case 0:\n                _context20.next = 2;\n                return store.all(opts);\n\n              case 2:\n                entries = _context20.sent;\n                return _context20.abrupt(\"return\", Object.keys(entries).reduce(function (newAll, key) {\n                  if (key.startsWith(PREFIX)) {\n                    newAll[key.slice(4)] = entries[key];\n                  }\n\n                  return newAll;\n                }, {}));\n\n              case 4:\n              case \"end\":\n                return _context20.stop();\n            }\n          }\n        }, _callee20);\n      }));\n\n      function all(_x21) {\n        return _all.apply(this, arguments);\n      }\n\n      return all;\n    }()\n  };\n};\n\nvar privateStoreReducer = function privateStoreReducer(store, threeId, spaceName) {\n  var PREFIX = 'priv_';\n\n  var dbKey = /*#__PURE__*/function () {\n    var _ref3 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee21(key) {\n      return _regenerator[\"default\"].wrap(function _callee21$(_context21) {\n        while (1) {\n          switch (_context21.prev = _context21.next) {\n            case 0:\n              throwIfUndefined(key, 'key');\n              _context21.t0 = PREFIX;\n              _context21.next = 4;\n              return threeId.hashDBKey(key, spaceName);\n\n            case 4:\n              _context21.t1 = _context21.sent;\n              return _context21.abrupt(\"return\", _context21.t0 + _context21.t1);\n\n            case 6:\n            case \"end\":\n              return _context21.stop();\n          }\n        }\n      }, _callee21);\n    }));\n\n    return function dbKey(_x22) {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n\n  var encryptEntry = /*#__PURE__*/function () {\n    var _ref4 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee22(entry) {\n      return _regenerator[\"default\"].wrap(function _callee22$(_context22) {\n        while (1) {\n          switch (_context22.prev = _context22.next) {\n            case 0:\n              return _context22.abrupt(\"return\", threeId.encrypt(JSON.stringify(entry), spaceName));\n\n            case 1:\n            case \"end\":\n              return _context22.stop();\n          }\n        }\n      }, _callee22);\n    }));\n\n    return function encryptEntry(_x23) {\n      return _ref4.apply(this, arguments);\n    };\n  }();\n\n  var decryptEntry = /*#__PURE__*/function () {\n    var _ref5 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee23(encObj) {\n      return _regenerator[\"default\"].wrap(function _callee23$(_context23) {\n        while (1) {\n          switch (_context23.prev = _context23.next) {\n            case 0:\n              _context23.t0 = JSON;\n              _context23.next = 3;\n              return threeId.decrypt(encObj, spaceName);\n\n            case 3:\n              _context23.t1 = _context23.sent;\n              return _context23.abrupt(\"return\", _context23.t0.parse.call(_context23.t0, _context23.t1));\n\n            case 5:\n            case \"end\":\n              return _context23.stop();\n          }\n        }\n      }, _callee23);\n    }));\n\n    return function decryptEntry(_x24) {\n      return _ref5.apply(this, arguments);\n    };\n  }();\n\n  return {\n    get: function () {\n      var _get2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee24(key) {\n        var opts,\n            entry,\n            _args24 = arguments;\n        return _regenerator[\"default\"].wrap(function _callee24$(_context24) {\n          while (1) {\n            switch (_context24.prev = _context24.next) {\n              case 0:\n                opts = _args24.length > 1 && _args24[1] !== undefined ? _args24[1] : {};\n                _context24.t0 = store;\n                _context24.next = 4;\n                return dbKey(key);\n\n              case 4:\n                _context24.t1 = _context24.sent;\n                _context24.t2 = opts;\n                _context24.next = 8;\n                return _context24.t0.get.call(_context24.t0, _context24.t1, _context24.t2);\n\n              case 8:\n                entry = _context24.sent;\n\n                if (entry) {\n                  _context24.next = 11;\n                  break;\n                }\n\n                return _context24.abrupt(\"return\", null);\n\n              case 11:\n                if (!opts.metadata) {\n                  _context24.next = 20;\n                  break;\n                }\n\n                _context24.t3 = _objectSpread;\n                _context24.t4 = _objectSpread({}, entry);\n                _context24.t5 = {};\n                _context24.next = 17;\n                return decryptEntry(entry.value);\n\n              case 17:\n                _context24.t6 = _context24.sent.value;\n                _context24.t7 = {\n                  value: _context24.t6\n                };\n                return _context24.abrupt(\"return\", (0, _context24.t3)(_context24.t4, _context24.t5, _context24.t7));\n\n              case 20:\n                _context24.next = 22;\n                return decryptEntry(entry);\n\n              case 22:\n                return _context24.abrupt(\"return\", _context24.sent.value);\n\n              case 23:\n              case \"end\":\n                return _context24.stop();\n            }\n          }\n        }, _callee24);\n      }));\n\n      function get(_x25) {\n        return _get2.apply(this, arguments);\n      }\n\n      return get;\n    }(),\n    getMetadata: function () {\n      var _getMetadata2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee25(key) {\n        return _regenerator[\"default\"].wrap(function _callee25$(_context25) {\n          while (1) {\n            switch (_context25.prev = _context25.next) {\n              case 0:\n                _context25.t0 = store;\n                _context25.next = 3;\n                return dbKey(key);\n\n              case 3:\n                _context25.t1 = _context25.sent;\n                return _context25.abrupt(\"return\", _context25.t0.getMetadata.call(_context25.t0, _context25.t1));\n\n              case 5:\n              case \"end\":\n                return _context25.stop();\n            }\n          }\n        }, _callee25);\n      }));\n\n      function getMetadata(_x26) {\n        return _getMetadata2.apply(this, arguments);\n      }\n\n      return getMetadata;\n    }(),\n    set: function () {\n      var _set2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee26(key, value) {\n        return _regenerator[\"default\"].wrap(function _callee26$(_context26) {\n          while (1) {\n            switch (_context26.prev = _context26.next) {\n              case 0:\n                _context26.t0 = store;\n                _context26.next = 3;\n                return dbKey(key);\n\n              case 3:\n                _context26.t1 = _context26.sent;\n                _context26.next = 6;\n                return encryptEntry({\n                  key: key,\n                  value: value\n                });\n\n              case 6:\n                _context26.t2 = _context26.sent;\n                return _context26.abrupt(\"return\", _context26.t0.set.call(_context26.t0, _context26.t1, _context26.t2));\n\n              case 8:\n              case \"end\":\n                return _context26.stop();\n            }\n          }\n        }, _callee26);\n      }));\n\n      function set(_x27, _x28) {\n        return _set2.apply(this, arguments);\n      }\n\n      return set;\n    }(),\n    setMultiple: function () {\n      var _setMultiple2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee27(keys, values) {\n        var dbKeys, encryptedEntries;\n        return _regenerator[\"default\"].wrap(function _callee27$(_context27) {\n          while (1) {\n            switch (_context27.prev = _context27.next) {\n              case 0:\n                throwIfNotEqualLenArrays(keys, values);\n                _context27.next = 3;\n                return Promise.all(keys.map(dbKey));\n\n              case 3:\n                dbKeys = _context27.sent;\n                _context27.next = 6;\n                return Promise.all(values.map(function (value, index) {\n                  return encryptEntry({\n                    key: keys[index],\n                    value: value\n                  });\n                }));\n\n              case 6:\n                encryptedEntries = _context27.sent;\n                return _context27.abrupt(\"return\", store.setMultiple(dbKeys, encryptedEntries));\n\n              case 8:\n              case \"end\":\n                return _context27.stop();\n            }\n          }\n        }, _callee27);\n      }));\n\n      function setMultiple(_x29, _x30) {\n        return _setMultiple2.apply(this, arguments);\n      }\n\n      return setMultiple;\n    }(),\n    remove: function () {\n      var _remove2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee28(key) {\n        return _regenerator[\"default\"].wrap(function _callee28$(_context28) {\n          while (1) {\n            switch (_context28.prev = _context28.next) {\n              case 0:\n                _context28.t0 = store;\n                _context28.next = 3;\n                return dbKey(key);\n\n              case 3:\n                _context28.t1 = _context28.sent;\n                return _context28.abrupt(\"return\", _context28.t0.remove.call(_context28.t0, _context28.t1));\n\n              case 5:\n              case \"end\":\n                return _context28.stop();\n            }\n          }\n        }, _callee28);\n      }));\n\n      function remove(_x31) {\n        return _remove2.apply(this, arguments);\n      }\n\n      return remove;\n    }(),\n    log: function log() {\n      return (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee29() {\n        var log, privLog, _iterator, _step, entry, decEntry;\n\n        return _regenerator[\"default\"].wrap(function _callee29$(_context29) {\n          while (1) {\n            switch (_context29.prev = _context29.next) {\n              case 0:\n                _context29.next = 2;\n                return store.log();\n\n              case 2:\n                log = _context29.sent;\n                privLog = [];\n                _iterator = _createForOfIteratorHelper(log);\n                _context29.prev = 5;\n\n                _iterator.s();\n\n              case 7:\n                if ((_step = _iterator.n()).done) {\n                  _context29.next = 18;\n                  break;\n                }\n\n                entry = _step.value;\n\n                if (!entry.key.startsWith(PREFIX)) {\n                  _context29.next = 16;\n                  break;\n                }\n\n                _context29.next = 12;\n                return decryptEntry(entry.value);\n\n              case 12:\n                decEntry = _context29.sent;\n                entry.key = decEntry.key;\n                entry.value = decEntry.value;\n                privLog.push(entry);\n\n              case 16:\n                _context29.next = 7;\n                break;\n\n              case 18:\n                _context29.next = 23;\n                break;\n\n              case 20:\n                _context29.prev = 20;\n                _context29.t0 = _context29[\"catch\"](5);\n\n                _iterator.e(_context29.t0);\n\n              case 23:\n                _context29.prev = 23;\n\n                _iterator.f();\n\n                return _context29.finish(23);\n\n              case 26:\n                return _context29.abrupt(\"return\", privLog);\n\n              case 27:\n              case \"end\":\n                return _context29.stop();\n            }\n          }\n        }, _callee29, null, [[5, 20, 23, 26]]);\n      }))();\n    },\n    all: function () {\n      var _all2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee30() {\n        var opts,\n            entries,\n            privEntries,\n            key,\n            entry,\n            decEntry,\n            _decEntry,\n            _args30 = arguments;\n\n        return _regenerator[\"default\"].wrap(function _callee30$(_context30) {\n          while (1) {\n            switch (_context30.prev = _context30.next) {\n              case 0:\n                opts = _args30.length > 0 && _args30[0] !== undefined ? _args30[0] : {};\n                _context30.next = 3;\n                return store.all(opts);\n\n              case 3:\n                entries = _context30.sent;\n                privEntries = {};\n                _context30.t0 = _regenerator[\"default\"].keys(entries);\n\n              case 6:\n                if ((_context30.t1 = _context30.t0()).done) {\n                  _context30.next = 23;\n                  break;\n                }\n\n                key = _context30.t1.value;\n\n                if (!key.startsWith(PREFIX)) {\n                  _context30.next = 21;\n                  break;\n                }\n\n                entry = entries[key];\n\n                if (!opts.metadata) {\n                  _context30.next = 17;\n                  break;\n                }\n\n                _context30.next = 13;\n                return decryptEntry(entry.value);\n\n              case 13:\n                decEntry = _context30.sent;\n                privEntries[decEntry.key] = _objectSpread(_objectSpread({}, entry), {}, {\n                  value: decEntry.value\n                });\n                _context30.next = 21;\n                break;\n\n              case 17:\n                _context30.next = 19;\n                return decryptEntry(entry);\n\n              case 19:\n                _decEntry = _context30.sent;\n                privEntries[_decEntry.key] = _decEntry.value;\n\n              case 21:\n                _context30.next = 6;\n                break;\n\n              case 23:\n                return _context30.abrupt(\"return\", privEntries);\n\n              case 24:\n              case \"end\":\n                return _context30.stop();\n            }\n          }\n        }, _callee30);\n      }));\n\n      function all() {\n        return _all2.apply(this, arguments);\n      }\n\n      return all;\n    }()\n  };\n};","map":null,"metadata":{},"sourceType":"script"}