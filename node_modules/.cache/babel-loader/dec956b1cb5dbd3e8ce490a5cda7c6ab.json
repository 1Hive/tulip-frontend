{"ast":null,"code":"import { useMemo } from 'react';\nimport { Contract as EthersContract, providers as Providers } from 'ethers';\nimport { useWallet } from './providers/Wallet'; // import { defaultEthNode } from './endpoints'\n\nimport { InvalidNetworkType } from './errors'; // const DEFAULT_PROVIDER = new Providers.JsonRpcProvider(defaultEthNode)\n\nlet DEFAULT_PROVIDER;\n\nif (!window.web3 || window.web3.currentProvider.networkVersion !== '4') {\n  const error = new InvalidNetworkType();\n  console.log(error);\n} else {\n  DEFAULT_PROVIDER = new Providers.Web3Provider(window.web3.currentProvider);\n}\n\nexport function useContract(address, abi, signer = true) {\n  const {\n    account,\n    ethers\n  } = useWallet();\n  return useMemo(() => {\n    // Apparently .getSigner() returns a new object every time, so we use the\n    // connected account as memo dependency.\n    if (!address || !ethers || !account) {\n      return null;\n    }\n\n    return getContract(address, abi, signer ? ethers.getSigner() : ethers);\n  }, [abi, account, address, ethers, signer]);\n}\nexport function useContractReadOnly(address, abi) {\n  return useMemo(() => {\n    if (!address) {\n      return null;\n    }\n\n    return getContract(address, abi);\n  }, [abi, address]);\n}\nexport function getContract(address, abi, provider = DEFAULT_PROVIDER) {\n  console.log(abi, typeof abi);\n  return new EthersContract(address, abi, provider);\n}","map":{"version":3,"sources":["/Users/fabianmolina/Documents/1hive/tulip-frontend/src/web3-contracts.js"],"names":["useMemo","Contract","EthersContract","providers","Providers","useWallet","InvalidNetworkType","DEFAULT_PROVIDER","window","web3","currentProvider","networkVersion","error","console","log","Web3Provider","useContract","address","abi","signer","account","ethers","getContract","getSigner","useContractReadOnly","provider"],"mappings":"AAAA,SAASA,OAAT,QAAwB,OAAxB;AACA,SAASC,QAAQ,IAAIC,cAArB,EAAqCC,SAAS,IAAIC,SAAlD,QAAmE,QAAnE;AACA,SAASC,SAAT,QAA0B,oBAA1B,C,CACA;;AACA,SAASC,kBAAT,QAAmC,UAAnC,C,CACA;;AACA,IAAIC,gBAAJ;;AACA,IAAI,CAACC,MAAM,CAACC,IAAR,IAAgBD,MAAM,CAACC,IAAP,CAAYC,eAAZ,CAA4BC,cAA5B,KAA+C,GAAnE,EAAwE;AACtE,QAAMC,KAAK,GAAG,IAAIN,kBAAJ,EAAd;AACAO,EAAAA,OAAO,CAACC,GAAR,CAAYF,KAAZ;AACD,CAHD,MAGO;AACLL,EAAAA,gBAAgB,GAAG,IAAIH,SAAS,CAACW,YAAd,CAA2BP,MAAM,CAACC,IAAP,CAAYC,eAAvC,CAAnB;AACD;;AAED,OAAO,SAASM,WAAT,CAAqBC,OAArB,EAA8BC,GAA9B,EAAmCC,MAAM,GAAG,IAA5C,EAAkD;AACvD,QAAM;AAAEC,IAAAA,OAAF;AAAWC,IAAAA;AAAX,MAAsBhB,SAAS,EAArC;AAEA,SAAOL,OAAO,CAAC,MAAM;AACnB;AACA;AAEA,QAAI,CAACiB,OAAD,IAAY,CAACI,MAAb,IAAuB,CAACD,OAA5B,EAAqC;AACnC,aAAO,IAAP;AACD;;AAED,WAAOE,WAAW,CAACL,OAAD,EAAUC,GAAV,EAAeC,MAAM,GAAGE,MAAM,CAACE,SAAP,EAAH,GAAwBF,MAA7C,CAAlB;AACD,GATa,EASX,CAACH,GAAD,EAAME,OAAN,EAAeH,OAAf,EAAwBI,MAAxB,EAAgCF,MAAhC,CATW,CAAd;AAUD;AAED,OAAO,SAASK,mBAAT,CAA6BP,OAA7B,EAAsCC,GAAtC,EAA2C;AAChD,SAAOlB,OAAO,CAAC,MAAM;AACnB,QAAI,CAACiB,OAAL,EAAc;AACZ,aAAO,IAAP;AACD;;AACD,WAAOK,WAAW,CAACL,OAAD,EAAUC,GAAV,CAAlB;AACD,GALa,EAKX,CAACA,GAAD,EAAMD,OAAN,CALW,CAAd;AAMD;AAED,OAAO,SAASK,WAAT,CAAqBL,OAArB,EAA8BC,GAA9B,EAAmCO,QAAQ,GAAGlB,gBAA9C,EAAgE;AACrEM,EAAAA,OAAO,CAACC,GAAR,CAAYI,GAAZ,EAAiB,OAAOA,GAAxB;AACA,SAAO,IAAIhB,cAAJ,CAAmBe,OAAnB,EAA4BC,GAA5B,EAAiCO,QAAjC,CAAP;AACD","sourcesContent":["import { useMemo } from 'react'\nimport { Contract as EthersContract, providers as Providers } from 'ethers'\nimport { useWallet } from './providers/Wallet'\n// import { defaultEthNode } from './endpoints'\nimport { InvalidNetworkType } from './errors'\n// const DEFAULT_PROVIDER = new Providers.JsonRpcProvider(defaultEthNode)\nlet DEFAULT_PROVIDER\nif (!window.web3 || window.web3.currentProvider.networkVersion !== '4') {\n  const error = new InvalidNetworkType()\n  console.log(error)\n} else {\n  DEFAULT_PROVIDER = new Providers.Web3Provider(window.web3.currentProvider)\n}\n\nexport function useContract(address, abi, signer = true) {\n  const { account, ethers } = useWallet()\n\n  return useMemo(() => {\n    // Apparently .getSigner() returns a new object every time, so we use the\n    // connected account as memo dependency.\n\n    if (!address || !ethers || !account) {\n      return null\n    }\n\n    return getContract(address, abi, signer ? ethers.getSigner() : ethers)\n  }, [abi, account, address, ethers, signer])\n}\n\nexport function useContractReadOnly(address, abi) {\n  return useMemo(() => {\n    if (!address) {\n      return null\n    }\n    return getContract(address, abi)\n  }, [abi, address])\n}\n\nexport function getContract(address, abi, provider = DEFAULT_PROVIDER) {\n  console.log(abi, typeof abi)\n  return new EthersContract(address, abi, provider)\n}\n"]},"metadata":{},"sourceType":"module"}