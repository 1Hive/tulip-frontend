{"ast":null,"code":"'use strict';\n\nconst {\n  filter,\n  sortAll,\n  take,\n  map\n} = require('./utils');\n\nconst drain = require('it-drain');\n\nclass InterfaceDatastoreAdapter {\n  async open() {// eslint-disable-line require-await\n  }\n\n  async close() {// eslint-disable-line require-await\n  }\n  /**\n   * Store the passed value under the passed key\n   *\n   * @param {Key} key\n   * @param {Buffer} val\n   * @param {Object} options\n   * @returns {Promise<void>}\n   */\n\n\n  async put(key, val, options = {}) {// eslint-disable-line require-await\n  }\n  /**\n   * Store the given key/value pairs\n   *\n   * @param {AsyncIterator<{ key: Key, value: Buffer }>} source\n   * @param {Object} options\n   * @returns {AsyncIterator<{ key: Key, value: Buffer }>}\n   */\n\n\n  async *putMany(source, options = {}) {\n    for await (const {\n      key,\n      value\n    } of source) {\n      await this.put(key, value, options);\n      yield {\n        key,\n        value\n      };\n    }\n  }\n  /**\n   * Retrieve the value for the passed key\n   *\n   * @param {Key} key\n   * @param {Object} options\n   * @returns {Promise<Buffer>}\n   */\n\n\n  async get(key, options = {}) {// eslint-disable-line require-await\n  }\n  /**\n   * Retrieve values for the passed keys\n   *\n   * @param {AsyncIterator<Key>} source\n   * @param {Object} options\n   * @returns {AsyncIterator<Buffer>}\n   */\n\n\n  async *getMany(source, options = {}) {\n    for await (const key of source) {\n      yield this.get(key, options);\n    }\n  }\n  /**\n   * Check for the existence of a value for the passed key\n   *\n   * @param {Key} key\n   * @returns {Promise<bool>}\n   */\n\n\n  async has(key) {// eslint-disable-line require-await\n  }\n  /**\n   * Remove the record for the passed key\n   *\n   * @param {Key} key\n   * @param {Object} options\n   * @returns {Promise<void>}\n   */\n\n\n  async delete(key, options = {}) {// eslint-disable-line require-await\n  }\n  /**\n   * Remove values for the passed keys\n   *\n   * @param {AsyncIterator<Key>} source\n   * @param {Object} options\n   * @returns {AsyncIterator<Key>}\n   */\n\n\n  async *deleteMany(source, options = {}) {\n    for await (const key of source) {\n      await this.delete(key, options);\n      yield key;\n    }\n  }\n  /**\n   * Create a new batch object.\n   *\n   * @returns {Object}\n   */\n\n\n  batch() {\n    let puts = [];\n    let dels = [];\n    return {\n      put(key, value) {\n        puts.push({\n          key,\n          value\n        });\n      },\n\n      delete(key) {\n        dels.push(key);\n      },\n\n      commit: async options => {\n        await drain(this.putMany(puts, options));\n        puts = [];\n        await drain(this.deleteMany(dels, options));\n        dels = [];\n      }\n    };\n  }\n  /**\n   * Yield all datastore values\n   *\n   * @param {Object} q\n   * @param {Object} options\n   * @returns {AsyncIterable<{ key: Key, value: Buffer }>}\n   */\n\n\n  async *_all(q, options) {// eslint-disable-line require-await\n  }\n  /**\n   * Query the store.\n   *\n   * @param {Object} q\n   * @param {Object} options\n   * @returns {AsyncIterable<Buffer>}\n   */\n\n\n  async *query(q, options) {\n    // eslint-disable-line require-await\n    let it = this._all(q, options);\n\n    if (q.prefix != null) {\n      it = filter(it, e => e.key.toString().startsWith(q.prefix));\n    }\n\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it);\n    }\n\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sortAll(it, f), it);\n    }\n\n    if (q.offset != null) {\n      let i = 0;\n      it = filter(it, () => i++ >= q.offset);\n    }\n\n    if (q.limit != null) {\n      it = take(it, q.limit);\n    }\n\n    if (q.keysOnly === true) {\n      it = map(it, e => ({\n        key: e.key\n      }));\n    }\n\n    yield* it;\n  }\n\n}\n\nmodule.exports = InterfaceDatastoreAdapter;","map":null,"metadata":{},"sourceType":"script"}