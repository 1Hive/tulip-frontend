{"ast":null,"code":"function _awaitAsyncGenerator(value) {\n  return new _AwaitValue(value);\n}\n\nfunction _wrapAsyncGenerator(fn) {\n  return function () {\n    return new _AsyncGenerator(fn.apply(this, arguments));\n  };\n}\n\nfunction _AsyncGenerator(gen) {\n  var front, back;\n\n  function send(key, arg) {\n    return new Promise(function (resolve, reject) {\n      var request = {\n        key: key,\n        arg: arg,\n        resolve: resolve,\n        reject: reject,\n        next: null\n      };\n\n      if (back) {\n        back = back.next = request;\n      } else {\n        front = back = request;\n        resume(key, arg);\n      }\n    });\n  }\n\n  function resume(key, arg) {\n    try {\n      var result = gen[key](arg);\n      var value = result.value;\n      var wrappedAwait = value instanceof _AwaitValue;\n      Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) {\n        if (wrappedAwait) {\n          resume(key === \"return\" ? \"return\" : \"next\", arg);\n          return;\n        }\n\n        settle(result.done ? \"return\" : \"normal\", arg);\n      }, function (err) {\n        resume(\"throw\", err);\n      });\n    } catch (err) {\n      settle(\"throw\", err);\n    }\n  }\n\n  function settle(type, value) {\n    switch (type) {\n      case \"return\":\n        front.resolve({\n          value: value,\n          done: true\n        });\n        break;\n\n      case \"throw\":\n        front.reject(value);\n        break;\n\n      default:\n        front.resolve({\n          value: value,\n          done: false\n        });\n        break;\n    }\n\n    front = front.next;\n\n    if (front) {\n      resume(front.key, front.arg);\n    } else {\n      back = null;\n    }\n  }\n\n  this._invoke = send;\n\n  if (typeof gen.return !== \"function\") {\n    this.return = undefined;\n  }\n}\n\nif (typeof Symbol === \"function\" && Symbol.asyncIterator) {\n  _AsyncGenerator.prototype[Symbol.asyncIterator] = function () {\n    return this;\n  };\n}\n\n_AsyncGenerator.prototype.next = function (arg) {\n  return this._invoke(\"next\", arg);\n};\n\n_AsyncGenerator.prototype.throw = function (arg) {\n  return this._invoke(\"throw\", arg);\n};\n\n_AsyncGenerator.prototype.return = function (arg) {\n  return this._invoke(\"return\", arg);\n};\n\nfunction _AwaitValue(value) {\n  this.wrapped = value;\n}\n\nfunction _asyncIterator(iterable) {\n  var method;\n\n  if (typeof Symbol !== \"undefined\") {\n    if (Symbol.asyncIterator) {\n      method = iterable[Symbol.asyncIterator];\n      if (method != null) return method.call(iterable);\n    }\n\n    if (Symbol.iterator) {\n      method = iterable[Symbol.iterator];\n      if (method != null) return method.call(iterable);\n    }\n  }\n\n  throw new TypeError(\"Object is not async iterable\");\n}\n\nimport { Buffer } from \"buffer\";\nimport { NOISE_MSG_MAX_LENGTH_BYTES, NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG } from \"./constants\"; // Returns generator that encrypts payload from the user\n\nexport function encryptStream(handshake) {\n  return /*#__PURE__*/function () {\n    var _ref = _wrapAsyncGenerator(function* (source) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n\n      var _iteratorError;\n\n      try {\n        for (var _iterator = _asyncIterator(source), _step, _value; _step = yield _awaitAsyncGenerator(_iterator.next()), _iteratorNormalCompletion = _step.done, _value = yield _awaitAsyncGenerator(_step.value), !_iteratorNormalCompletion; _iteratorNormalCompletion = true) {\n          const chunk = _value;\n          const chunkBuffer = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.length);\n\n          for (let i = 0; i < chunkBuffer.length; i += NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {\n            let end = i + NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;\n\n            if (end > chunkBuffer.length) {\n              end = chunkBuffer.length;\n            }\n\n            const data = handshake.encrypt(chunkBuffer.slice(i, end), handshake.session);\n            yield data;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            yield _awaitAsyncGenerator(_iterator.return());\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    });\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n} // Decrypt received payload to the user\n\nexport function decryptStream(handshake) {\n  return /*#__PURE__*/function () {\n    var _ref2 = _wrapAsyncGenerator(function* (source) {\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n\n      var _iteratorError2;\n\n      try {\n        for (var _iterator2 = _asyncIterator(source), _step2, _value2; _step2 = yield _awaitAsyncGenerator(_iterator2.next()), _iteratorNormalCompletion2 = _step2.done, _value2 = yield _awaitAsyncGenerator(_step2.value), !_iteratorNormalCompletion2; _iteratorNormalCompletion2 = true) {\n          const chunk = _value2;\n          const chunkBuffer = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.length);\n\n          for (let i = 0; i < chunkBuffer.length; i += NOISE_MSG_MAX_LENGTH_BYTES) {\n            let end = i + NOISE_MSG_MAX_LENGTH_BYTES;\n\n            if (end > chunkBuffer.length) {\n              end = chunkBuffer.length;\n            }\n\n            const chunk = chunkBuffer.slice(i, end);\n            const {\n              plaintext: decrypted,\n              valid\n            } = yield _awaitAsyncGenerator(handshake.decrypt(chunk, handshake.session));\n\n            if (!valid) {\n              throw new Error(\"Failed to validate decrypted chunk\");\n            }\n\n            yield decrypted;\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            yield _awaitAsyncGenerator(_iterator2.return());\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    });\n\n    return function (_x2) {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n}","map":null,"metadata":{},"sourceType":"module"}