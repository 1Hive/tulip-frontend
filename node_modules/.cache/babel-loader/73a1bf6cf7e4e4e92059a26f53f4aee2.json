{"ast":null,"code":"const pageResults = require('graph-results-pager');\n\nconst {\n  graphAPIEndpoints\n} = require('./../constants');\n\nconst {\n  timestampToBlock\n} = require('./../utils');\n\nmodule.exports = {\n  async queuedTxs({\n    minTimestamp = undefined,\n    maxTimestamp = undefined,\n    minBlock = undefined,\n    maxBlock = undefined,\n    max = undefined\n  } = {}) {\n    return pageResults({\n      api: graphAPIEndpoints.timelock,\n      query: {\n        entity: 'timelocks',\n        selection: {\n          where: {\n            isCanceled: false,\n            isExecuted: false,\n            createdBlock_gte: minBlock || (minTimestamp ? await timestampToBlock(minTimestamp) : undefined),\n            createdBlock_lte: maxBlock || (maxTimestamp ? await timestampToBlock(maxTimestamp) : undefined)\n          }\n        },\n        properties: queuedTxs.properties\n      },\n      max\n    }).then(results => queuedTxs.callback(results)).catch(err => console.log(err));\n  },\n\n  async canceledTxs({\n    minTimestamp = undefined,\n    maxTimestamp = undefined,\n    minBlock = undefined,\n    maxBlock = undefined,\n    max = undefined\n  } = {}) {\n    return pageResults({\n      api: graphAPIEndpoints.timelock,\n      query: {\n        entity: 'timelocks',\n        selection: {\n          where: {\n            isCanceled: true,\n            createdBlock_gte: minBlock || (minTimestamp ? await timestampToBlock(minTimestamp) : undefined),\n            createdBlock_lte: maxBlock || (maxTimestamp ? await timestampToBlock(maxTimestamp) : undefined)\n          }\n        },\n        properties: canceledTxs.properties\n      },\n      max\n    }).then(results => canceledTxs.callback(results)).catch(err => console.log(err));\n  },\n\n  async executedTxs({\n    minTimestamp = undefined,\n    maxTimestamp = undefined,\n    minBlock = undefined,\n    maxBlock = undefined,\n    max = undefined\n  } = {}) {\n    return pageResults({\n      api: graphAPIEndpoints.timelock,\n      query: {\n        entity: 'timelocks',\n        selection: {\n          where: {\n            isExecuted: true,\n            createdBlock_gte: minBlock || (minTimestamp ? await timestampToBlock(minTimestamp) : undefined),\n            createdBlock_lte: maxBlock || (maxTimestamp ? await timestampToBlock(maxTimestamp) : undefined)\n          }\n        },\n        properties: executedTxs.properties\n      },\n      max\n    }).then(results => executedTxs.callback(results)).catch(err => console.log(err));\n  },\n\n  async allTxs({\n    minTimestamp = undefined,\n    maxTimestamp = undefined,\n    minBlock = undefined,\n    maxBlock = undefined,\n    max = undefined\n  } = {}) {\n    return pageResults({\n      api: graphAPIEndpoints.timelock,\n      query: {\n        entity: 'timelocks',\n        selection: {\n          where: {\n            createdBlock_gte: minBlock || (minTimestamp ? await timestampToBlock(minTimestamp) : undefined),\n            createdBlock_lte: maxBlock || (maxTimestamp ? await timestampToBlock(maxTimestamp) : undefined)\n          }\n        },\n        properties: allTxs.properties\n      },\n      max\n    }).then(results => allTxs.callback(results)).catch(err => console.log(err));\n  }\n\n};\nconst queuedTxs = {\n  properties: ['id', 'description', 'value', 'eta', 'functionName', 'data', 'targetAddress', 'createdBlock', 'createdTs', 'expiresTs', 'createdTx'],\n\n  callback(results) {\n    return results.map(({\n      id,\n      description,\n      value,\n      eta,\n      functionName,\n      data,\n      targetAddress,\n      createdBlock,\n      createdTs,\n      expiresTs,\n      createdTx\n    }) => ({\n      txHash: id,\n      description: description,\n      value: Number(value),\n      etaTs: Number(eta * 1000),\n      etaDate: new Date(eta * 1000),\n      functionName: functionName,\n      data: data,\n      targetAddress: targetAddress,\n      createdBlock: Number(createdBlock),\n      createdTs: Number(createdTs * 1000),\n      createdDate: new Date(createdTs * 1000),\n      expiresTs: Number(expiresTs * 1000),\n      expiresDate: new Date(expiresTs * 1000),\n      createdTx: createdTx\n    })).sort((a, b) => b.createdBlock - a.createdBlock);\n  }\n\n};\nconst canceledTxs = {\n  properties: ['id', 'description', 'value', 'eta', 'functionName', 'data', 'targetAddress', 'createdBlock', 'createdTs', 'expiresTs', 'canceledBlock', 'canceledTs', 'createdTx', 'canceledTx'],\n\n  callback(results) {\n    return results.map(({\n      id,\n      description,\n      value,\n      eta,\n      functionName,\n      data,\n      targetAddress,\n      createdBlock,\n      createdTs,\n      expiresTs,\n      canceledBlock,\n      canceledTs,\n      createdTx,\n      canceledTx\n    }) => ({\n      txHash: id,\n      description: description,\n      value: Number(value),\n      etaTs: Number(eta * 1000),\n      etaDate: new Date(eta * 1000),\n      functionName: functionName,\n      data: data,\n      targetAddress: targetAddress,\n      createdBlock: Number(createdBlock),\n      createdTs: Number(createdTs * 1000),\n      createdDate: new Date(createdTs * 1000),\n      expiresTs: Number(expiresTs * 1000),\n      expiresDate: new Date(expiresTs * 1000),\n      canceledBlock: canceledTx ? Number(canceledBlock) : null,\n      canceledTs: canceledTx ? Number(canceledTs * 1000) : null,\n      canceledDate: canceledTx ? new Date(canceledTs * 1000) : null,\n      createdTx: createdTx,\n      canceledTx: canceledTx\n    })).sort((a, b) => b.createdBlock - a.createdBlock);\n  }\n\n};\nconst executedTxs = {\n  properties: ['id', 'description', 'value', 'eta', 'functionName', 'data', 'targetAddress', 'createdBlock', 'createdTs', 'expiresTs', 'executedBlock', 'executedTs', 'createdTx', 'executedTx'],\n\n  callback(results) {\n    return results.map(({\n      id,\n      description,\n      value,\n      eta,\n      functionName,\n      data,\n      targetAddress,\n      createdBlock,\n      createdTs,\n      expiresTs,\n      executedBlock,\n      executedTs,\n      createdTx,\n      executedTx\n    }) => ({\n      txHash: id,\n      description: description,\n      value: Number(value),\n      etaTs: Number(eta * 1000),\n      etaDate: new Date(eta * 1000),\n      functionName: functionName,\n      data: data,\n      targetAddress: targetAddress,\n      createdBlock: Number(createdBlock),\n      createdTs: Number(createdTs * 1000),\n      createdDate: new Date(createdTs * 1000),\n      expiresTs: Number(expiresTs * 1000),\n      expiresDate: new Date(expiresTs * 1000),\n      executedBlock: executedTx ? Number(executedBlock) : null,\n      executedTs: executedTx ? Number(executedTs * 1000) : null,\n      executedDate: executedTx ? new Date(executedTs * 1000) : null,\n      createdTx: createdTx,\n      executedTx: executedTx\n    })).sort((a, b) => b.createdBlock - a.createdBlock);\n    ;\n  }\n\n};\nconst allTxs = {\n  properties: ['id', 'description', 'value', 'eta', 'functionName', 'data', 'targetAddress', 'isCanceled', 'isExecuted', 'createdBlock', 'createdTs', 'expiresTs', 'canceledBlock', 'canceledTs', 'executedBlock', 'executedTs', 'createdTx', 'canceledTx', 'executedTx'],\n\n  callback(results) {\n    return results.map(({\n      id,\n      description,\n      value,\n      eta,\n      functionName,\n      data,\n      targetAddress,\n      isCanceled,\n      isExecuted,\n      createdBlock,\n      createdTs,\n      expiresTs,\n      canceledBlock,\n      canceledTs,\n      executedBlock,\n      executedTs,\n      createdTx,\n      canceledTx,\n      executedTx\n    }) => ({\n      txHash: id,\n      description: description,\n      value: Number(value),\n      etaTs: Number(eta * 1000),\n      etaDate: new Date(eta * 1000),\n      functionName: functionName,\n      data: data,\n      targetAddress: targetAddress,\n      isCanceled: isCanceled,\n      isExecuted: isExecuted,\n      createdBlock: Number(createdBlock),\n      createdTs: Number(createdTs * 1000),\n      createdDate: new Date(createdTs * 1000),\n      expiresTs: Number(expiresTs * 1000),\n      expiresDate: new Date(expiresTs * 1000),\n      canceledBlock: canceledTx ? Number(canceledBlock) : null,\n      canceledTs: canceledTx ? Number(canceledTs * 1000) : null,\n      canceledDate: canceledTx ? new Date(canceledTs * 1000) : null,\n      executedTs: executedTx ? Number(executedTs * 1000) : null,\n      executedDate: executedTx ? new Date(executedTs * 1000) : null,\n      createdTx: createdTx,\n      canceledTx: canceledTx,\n      executedTx: executedTx\n    })).sort((a, b) => b.createdBlock - a.createdBlock);\n  }\n\n};","map":null,"metadata":{},"sourceType":"script"}