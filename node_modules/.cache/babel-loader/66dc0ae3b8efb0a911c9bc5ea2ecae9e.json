{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _slicedToArray = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:secio');\nlog.error = debug('libp2p:secio:error');\n\nvar DuplexPair = require('it-pair/duplex');\n\nvar pipe = require('it-pipe');\n\nvar lp = require('it-length-prefixed');\n\nvar Wrap = require('it-pb-rpc');\n\nvar int32BEEncode = lp.int32BEEncode,\n    int32BEDecode = lp.int32BEDecode; // Maximum length of the data section of the message\n// 8MB, https://github.com/libp2p/specs/blob/94ad1bd/secio/README.md#message-framing\n\nvar MAX_DATA_LENGTH = 0x800000;\n\nvar etm = require('../etm');\n\nvar crypto = require('./crypto'); // step 3. Finish\n// -- send expected message to verify encryption works (send local nonce)\n\n\nmodule.exports = /*#__PURE__*/function () {\n  var _finish = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(state, wrapped) {\n    var proto, _DuplexPair, _DuplexPair2, secure, user, network, shake, nonceBack;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            log('3. finish - start');\n            proto = state.protocols;\n            _DuplexPair = DuplexPair(), _DuplexPair2 = _slicedToArray(_DuplexPair, 2), secure = _DuplexPair2[0], user = _DuplexPair2[1];\n            network = wrapped.unwrap();\n            pipe(secure, // this is FROM the user\n            etm.createBoxStream(proto.local.cipher, proto.local.mac), lp.encode({\n              lengthEncoder: int32BEEncode\n            }), network, // and gets piped INTO and FROM the network\n            lp.decode({\n              lengthDecoder: int32BEDecode,\n              maxDataLength: MAX_DATA_LENGTH\n            }), etm.createUnboxStream(proto.remote.cipher, proto.remote.mac), secure // and gets piped TO the user\n            ).catch(function (err) {\n              log.error('an error occurred in the crypto stream', err);\n            }); // Exchange nonces over the encrypted stream for final verification\n\n            shake = Wrap(user);\n            shake.write(state.proposal.in.rand);\n            _context.next = 9;\n            return shake.read(state.proposal.in.rand.length);\n\n          case 9:\n            nonceBack = _context.sent;\n            crypto.verifyNonce(state, nonceBack.slice());\n            log('3. finish - finish'); // Awesome that's all folks.\n\n            state.secure = shake.unwrap();\n\n          case 13:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  function finish(_x, _x2) {\n    return _finish.apply(this, arguments);\n  }\n\n  return finish;\n}();","map":null,"metadata":{},"sourceType":"script"}