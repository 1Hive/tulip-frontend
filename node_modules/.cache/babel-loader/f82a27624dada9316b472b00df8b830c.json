{"ast":null,"code":"import { Buffer } from 'buffer';\nimport { generateKeypair, isValidPublicKey } from '../utils';\nimport { AbstractHandshake } from \"./abstract-handshake\";\nexport class XX extends AbstractHandshake {\n  initializeInitiator(prologue, s, rs, psk) {\n    const name = \"Noise_XX_25519_ChaChaPoly_SHA256\";\n    const ss = this.initializeSymmetric(name);\n    this.mixHash(ss, prologue);\n    const re = Buffer.alloc(32);\n    return {\n      ss,\n      s,\n      rs,\n      psk,\n      re\n    };\n  }\n\n  initializeResponder(prologue, s, rs, psk) {\n    const name = \"Noise_XX_25519_ChaChaPoly_SHA256\";\n    const ss = this.initializeSymmetric(name);\n    this.mixHash(ss, prologue);\n    const re = Buffer.alloc(32);\n    return {\n      ss,\n      s,\n      rs,\n      psk,\n      re\n    };\n  }\n\n  writeMessageA(hs, payload, e) {\n    const ns = Buffer.alloc(0);\n\n    if (e) {\n      hs.e = e;\n    } else {\n      hs.e = generateKeypair();\n    }\n\n    const ne = hs.e.publicKey;\n    this.mixHash(hs.ss, ne);\n    const ciphertext = this.encryptAndHash(hs.ss, payload);\n    return {\n      ne,\n      ns,\n      ciphertext\n    };\n  }\n\n  writeMessageB(hs, payload) {\n    hs.e = generateKeypair();\n    const ne = hs.e.publicKey;\n    this.mixHash(hs.ss, ne);\n    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));\n    const spk = Buffer.from(hs.s.publicKey);\n    const ns = this.encryptAndHash(hs.ss, spk);\n    this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));\n    const ciphertext = this.encryptAndHash(hs.ss, payload);\n    return {\n      ne,\n      ns,\n      ciphertext\n    };\n  }\n\n  writeMessageC(hs, payload) {\n    const spk = Buffer.from(hs.s.publicKey);\n    const ns = this.encryptAndHash(hs.ss, spk);\n    this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));\n    const ciphertext = this.encryptAndHash(hs.ss, payload);\n    const ne = this.createEmptyKey();\n    const messageBuffer = {\n      ne,\n      ns,\n      ciphertext\n    };\n    const {\n      cs1,\n      cs2\n    } = this.split(hs.ss);\n    return {\n      h: hs.ss.h,\n      messageBuffer,\n      cs1,\n      cs2\n    };\n  }\n\n  readMessageA(hs, message) {\n    if (isValidPublicKey(message.ne)) {\n      hs.re = message.ne;\n    }\n\n    this.mixHash(hs.ss, hs.re);\n    return this.decryptAndHash(hs.ss, message.ciphertext);\n  }\n\n  readMessageB(hs, message) {\n    if (isValidPublicKey(message.ne)) {\n      hs.re = message.ne;\n    }\n\n    this.mixHash(hs.ss, hs.re);\n\n    if (!hs.e) {\n      throw new Error(\"Handshake state `e` param is missing.\");\n    }\n\n    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));\n    const {\n      plaintext: ns,\n      valid: valid1\n    } = this.decryptAndHash(hs.ss, message.ns);\n\n    if (valid1 && ns.length === 32 && isValidPublicKey(ns)) {\n      hs.rs = ns;\n    }\n\n    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));\n    const {\n      plaintext,\n      valid: valid2\n    } = this.decryptAndHash(hs.ss, message.ciphertext);\n    return {\n      plaintext,\n      valid: valid1 && valid2\n    };\n  }\n\n  readMessageC(hs, message) {\n    const {\n      plaintext: ns,\n      valid: valid1\n    } = this.decryptAndHash(hs.ss, message.ns);\n\n    if (valid1 && ns.length === 32 && isValidPublicKey(ns)) {\n      hs.rs = ns;\n    }\n\n    if (!hs.e) {\n      throw new Error(\"Handshake state `e` param is missing.\");\n    }\n\n    this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));\n    const {\n      plaintext,\n      valid: valid2\n    } = this.decryptAndHash(hs.ss, message.ciphertext);\n    const {\n      cs1,\n      cs2\n    } = this.split(hs.ss);\n    return {\n      h: hs.ss.h,\n      plaintext,\n      valid: valid1 && valid2,\n      cs1,\n      cs2\n    };\n  }\n\n  initSession(initiator, prologue, s) {\n    const psk = this.createEmptyKey();\n    const rs = Buffer.alloc(32); // no static key yet\n\n    let hs;\n\n    if (initiator) {\n      hs = this.initializeInitiator(prologue, s, rs, psk);\n    } else {\n      hs = this.initializeResponder(prologue, s, rs, psk);\n    }\n\n    return {\n      hs,\n      i: initiator,\n      mc: 0\n    };\n  }\n\n  sendMessage(session, message, ephemeral) {\n    let messageBuffer;\n\n    if (session.mc === 0) {\n      messageBuffer = this.writeMessageA(session.hs, message, ephemeral);\n    } else if (session.mc === 1) {\n      messageBuffer = this.writeMessageB(session.hs, message);\n    } else if (session.mc === 2) {\n      const {\n        h,\n        messageBuffer: resultingBuffer,\n        cs1,\n        cs2\n      } = this.writeMessageC(session.hs, message);\n      messageBuffer = resultingBuffer;\n      session.h = h;\n      session.cs1 = cs1;\n      session.cs2 = cs2;\n    } else if (session.mc > 2) {\n      if (session.i) {\n        if (!session.cs1) {\n          throw new Error(\"CS1 (cipher state) is not defined\");\n        }\n\n        messageBuffer = this.writeMessageRegular(session.cs1, message);\n      } else {\n        if (!session.cs2) {\n          throw new Error(\"CS2 (cipher state) is not defined\");\n        }\n\n        messageBuffer = this.writeMessageRegular(session.cs2, message);\n      }\n    } else {\n      throw new Error(\"Session invalid.\");\n    }\n\n    session.mc++;\n    return messageBuffer;\n  }\n\n  recvMessage(session, message) {\n    let plaintext = Buffer.alloc(0);\n    let valid = false;\n\n    if (session.mc === 0) {\n      ({\n        plaintext,\n        valid\n      } = this.readMessageA(session.hs, message));\n    } else if (session.mc === 1) {\n      ({\n        plaintext,\n        valid\n      } = this.readMessageB(session.hs, message));\n    } else if (session.mc === 2) {\n      const {\n        h,\n        plaintext: resultingPlaintext,\n        valid: resultingValid,\n        cs1,\n        cs2\n      } = this.readMessageC(session.hs, message);\n      plaintext = resultingPlaintext;\n      valid = resultingValid;\n      session.h = h;\n      session.cs1 = cs1;\n      session.cs2 = cs2;\n    }\n\n    session.mc++;\n    return {\n      plaintext,\n      valid\n    };\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}