{"ast":null,"code":"import { useMemo } from 'react';\nimport { Contract as EthersContract, providers as Providers } from 'ethers';\nimport { useWallet } from './providers/Wallet';\nimport { defaultEthNode } from './endpoints';\nconst DEFAULT_PROVIDER = new Providers.JsonRpcProvider(defaultEthNode);\nexport function useContract(address, abi, signer = true) {\n  const {\n    account,\n    ethers\n  } = useWallet();\n  return useMemo(() => {\n    // Apparently .getSigner() returns a new object every time, so we use the\n    // connected account as memo dependency.\n    if (!address || !ethers || !account) {\n      return null;\n    }\n\n    return getContract(address, abi, signer ? ethers.getSigner() : ethers);\n  }, [abi, account, address, ethers, signer]);\n}\nexport function useContractReadOnly(address, abi) {\n  return useMemo(() => {\n    if (!address) {\n      return null;\n    }\n\n    return getContract(address, abi);\n  }, [abi, address]);\n}\nexport function getContract(address, abi, provider = DEFAULT_PROVIDER) {\n  console.log(abi, typeof abi);\n  return new EthersContract(address, abi, provider);\n}","map":{"version":3,"sources":["/Users/fabianmolina/Documents/1hive/tulip-frontend/src/web3-contracts.js"],"names":["useMemo","Contract","EthersContract","providers","Providers","useWallet","defaultEthNode","DEFAULT_PROVIDER","JsonRpcProvider","useContract","address","abi","signer","account","ethers","getContract","getSigner","useContractReadOnly","provider","console","log"],"mappings":"AAAA,SAASA,OAAT,QAAwB,OAAxB;AACA,SAASC,QAAQ,IAAIC,cAArB,EAAqCC,SAAS,IAAIC,SAAlD,QAAmE,QAAnE;AACA,SAASC,SAAT,QAA0B,oBAA1B;AACA,SAASC,cAAT,QAA+B,aAA/B;AAEA,MAAMC,gBAAgB,GAAG,IAAIH,SAAS,CAACI,eAAd,CAA8BF,cAA9B,CAAzB;AAEA,OAAO,SAASG,WAAT,CAAqBC,OAArB,EAA8BC,GAA9B,EAAmCC,MAAM,GAAG,IAA5C,EAAkD;AACvD,QAAM;AAAEC,IAAAA,OAAF;AAAWC,IAAAA;AAAX,MAAsBT,SAAS,EAArC;AAEA,SAAOL,OAAO,CAAC,MAAM;AACnB;AACA;AAEA,QAAI,CAACU,OAAD,IAAY,CAACI,MAAb,IAAuB,CAACD,OAA5B,EAAqC;AACnC,aAAO,IAAP;AACD;;AAED,WAAOE,WAAW,CAACL,OAAD,EAAUC,GAAV,EAAeC,MAAM,GAAGE,MAAM,CAACE,SAAP,EAAH,GAAwBF,MAA7C,CAAlB;AACD,GATa,EASX,CAACH,GAAD,EAAME,OAAN,EAAeH,OAAf,EAAwBI,MAAxB,EAAgCF,MAAhC,CATW,CAAd;AAUD;AAED,OAAO,SAASK,mBAAT,CAA6BP,OAA7B,EAAsCC,GAAtC,EAA2C;AAChD,SAAOX,OAAO,CAAC,MAAM;AACnB,QAAI,CAACU,OAAL,EAAc;AACZ,aAAO,IAAP;AACD;;AACD,WAAOK,WAAW,CAACL,OAAD,EAAUC,GAAV,CAAlB;AACD,GALa,EAKX,CAACA,GAAD,EAAMD,OAAN,CALW,CAAd;AAMD;AAED,OAAO,SAASK,WAAT,CAAqBL,OAArB,EAA8BC,GAA9B,EAAmCO,QAAQ,GAAGX,gBAA9C,EAAgE;AACrEY,EAAAA,OAAO,CAACC,GAAR,CAAYT,GAAZ,EAAiB,OAAOA,GAAxB;AACA,SAAO,IAAIT,cAAJ,CAAmBQ,OAAnB,EAA4BC,GAA5B,EAAiCO,QAAjC,CAAP;AACD","sourcesContent":["import { useMemo } from 'react'\r\nimport { Contract as EthersContract, providers as Providers } from 'ethers'\r\nimport { useWallet } from './providers/Wallet'\r\nimport { defaultEthNode } from './endpoints'\r\n\r\nconst DEFAULT_PROVIDER = new Providers.JsonRpcProvider(defaultEthNode)\r\n\r\nexport function useContract(address, abi, signer = true) {\r\n  const { account, ethers } = useWallet()\r\n\r\n  return useMemo(() => {\r\n    // Apparently .getSigner() returns a new object every time, so we use the\r\n    // connected account as memo dependency.\r\n\r\n    if (!address || !ethers || !account) {\r\n      return null\r\n    }\r\n\r\n    return getContract(address, abi, signer ? ethers.getSigner() : ethers)\r\n  }, [abi, account, address, ethers, signer])\r\n}\r\n\r\nexport function useContractReadOnly(address, abi) {\r\n  return useMemo(() => {\r\n    if (!address) {\r\n      return null\r\n    }\r\n    return getContract(address, abi)\r\n  }, [abi, address])\r\n}\r\n\r\nexport function getContract(address, abi, provider = DEFAULT_PROVIDER) {\r\n  console.log(abi, typeof abi)\r\n  return new EthersContract(address, abi, provider)\r\n}\r\n"]},"metadata":{},"sourceType":"module"}