{"ast":null,"code":"'use strict';\n\nconst abortable = require('abortable-iterator');\n\nconst AbortController = require('abort-controller');\n\nconst log = require('debug')('libp2p:mplex:stream');\n\nconst pushable = require('it-pushable');\n\nconst BufferList = require('bl/BufferList');\n\nconst {\n  MAX_MSG_SIZE\n} = require('./restrict-size');\n\nconst {\n  InitiatorMessageTypes,\n  ReceiverMessageTypes\n} = require('./message-types');\n/**\n * @param {object} options\n * @param {number} options.id\n * @param {string} options.name\n * @param {function(*)} options.send Called to send data through the stream\n * @param {function(Error)} [options.onEnd] Called whenever the stream ends\n * @param {string} [options.type] One of ['initiator','receiver']. Defaults to 'initiator'\n * @param {number} [options.maxMsgSize] Max size of an mplex message in bytes. Writes > size are automatically split. Defaults to 1MB\n * @returns {*} A muxed stream\n */\n\n\nmodule.exports = ({\n  id,\n  name,\n  send,\n  onEnd = () => {},\n  type = 'initiator',\n  maxMsgSize = MAX_MSG_SIZE\n}) => {\n  const abortController = new AbortController();\n  const resetController = new AbortController();\n  const Types = type === 'initiator' ? InitiatorMessageTypes : ReceiverMessageTypes;\n  const externalId = type === 'initiator' ? `i${id}` : `r${id}`;\n  name = String(name == null ? id : name);\n  let sourceEnded = false;\n  let sinkEnded = false;\n  let endErr;\n\n  const onSourceEnd = err => {\n    sourceEnded = true;\n    log('%s stream %s source end', type, name, err);\n    if (err && !endErr) endErr = err;\n\n    if (sinkEnded) {\n      stream.timeline.close = Date.now();\n      onEnd(endErr);\n    }\n  };\n\n  const onSinkEnd = err => {\n    sinkEnded = true;\n    log('%s stream %s sink end', type, name, err);\n    if (err && !endErr) endErr = err;\n\n    if (sourceEnded) {\n      stream.timeline.close = Date.now();\n      onEnd(endErr);\n    }\n  };\n\n  const stream = {\n    // Close for reading\n    close: () => stream.source.end(),\n    // Close for reading and writing (local error)\n    abort: err => {\n      log('%s stream %s abort', type, name, err); // End the source with the passed error\n\n      stream.source.end(err);\n      abortController.abort();\n    },\n    // Close immediately for reading and writing (remote error)\n    reset: () => resetController.abort(),\n    sink: async source => {\n      source = abortable(source, [{\n        signal: abortController.signal,\n        options: {\n          abortMessage: 'stream aborted',\n          abortCode: 'ERR_MPLEX_STREAM_ABORT'\n        }\n      }, {\n        signal: resetController.signal,\n        options: {\n          abortMessage: 'stream reset',\n          abortCode: 'ERR_MPLEX_STREAM_RESET'\n        }\n      }]);\n\n      if (type === 'initiator') {\n        // If initiator, open a new stream\n        send({\n          id,\n          type: Types.NEW_STREAM,\n          data: name\n        });\n      }\n\n      try {\n        for await (let data of source) {\n          while (data.length) {\n            if (data.length <= maxMsgSize) {\n              send({\n                id,\n                type: Types.MESSAGE,\n                data\n              });\n              break;\n            }\n\n            data = BufferList.isBufferList(data) ? data : new BufferList(data);\n            send({\n              id,\n              type: Types.MESSAGE,\n              data: data.shallowSlice(0, maxMsgSize)\n            });\n            data.consume(maxMsgSize);\n          }\n        }\n      } catch (err) {\n        // Send no more data if this stream was remotely reset\n        if (err.code === 'ERR_MPLEX_STREAM_RESET') {\n          log('%s stream %s reset', type, name);\n        } else {\n          log('%s stream %s error', type, name, err);\n          send({\n            id,\n            type: Types.RESET\n          });\n        }\n\n        stream.source.end(err);\n        return onSinkEnd(err);\n      }\n\n      send({\n        id,\n        type: Types.CLOSE\n      });\n      onSinkEnd();\n    },\n    source: pushable(onSourceEnd),\n    timeline: {\n      open: Date.now(),\n      close: null\n    },\n    id: externalId\n  };\n  return stream;\n};","map":null,"metadata":{},"sourceType":"script"}