{"ast":null,"code":"'use strict';\n\nconst pMapSeries = require('p-map-series');\n\nconst AccessController = require('./access-controller-interface');\n\nconst ensureAddress = require('./utils/ensure-ac-address');\n\nconst type = 'orbitdb';\n\nclass OrbitDBAccessController extends AccessController {\n  constructor(orbitdb, options) {\n    super();\n    this._orbitdb = orbitdb;\n    this._db = null;\n    this._options = options || {};\n  } // Returns the type of the access controller\n\n\n  static get type() {\n    return type;\n  } // Returns the address of the OrbitDB used as the AC\n\n\n  get address() {\n    return this._db.address;\n  } // Return true if entry is allowed to be added to the database\n\n\n  async canAppend(entry, identityProvider) {\n    // Write keys and admins keys are allowed\n    const access = new Set([...this.get('write'), ...this.get('admin')]); // If the ACL contains the writer's public key or it contains '*'\n\n    if (access.has(entry.identity.id) || access.has('*')) {\n      const verifiedIdentity = await identityProvider.verifyIdentity(entry.identity); // Allow access if identity verifies\n\n      return verifiedIdentity;\n    }\n\n    return false;\n  }\n\n  get capabilities() {\n    if (this._db) {\n      const capabilities = this._db.index;\n\n      const toSet = e => {\n        const key = e[0];\n        capabilities[key] = new Set([...(capabilities[key] || []), ...e[1]]);\n      }; // Merge with the access controller of the database\n      // and make sure all values are Sets\n\n\n      Object.entries({ ...capabilities,\n        // Add the root access controller's 'write' access list\n        // as admins on this controller\n        ...{\n          admin: new Set([...(capabilities.admin || []), ...this._db.access.write])\n        }\n      }).forEach(toSet);\n      return capabilities;\n    }\n\n    return {};\n  }\n\n  get(capability) {\n    return this.capabilities[capability] || new Set([]);\n  }\n\n  async close() {\n    await this._db.close();\n  }\n\n  async load(address) {\n    if (this._db) {\n      await this._db.close();\n    } // Force '<address>/_access' naming for the database\n\n\n    this._db = await this._orbitdb.keyvalue(ensureAddress(address), {\n      // use ipfs controller as a immutable \"root controller\"\n      accessController: {\n        type: 'ipfs',\n        write: this._options.admin || [this._orbitdb.identity.id]\n      },\n      sync: true\n    });\n\n    this._db.events.on('ready', this._onUpdate.bind(this));\n\n    this._db.events.on('write', this._onUpdate.bind(this));\n\n    this._db.events.on('replicated', this._onUpdate.bind(this));\n\n    await this._db.load();\n  }\n\n  async save() {\n    // return the manifest data\n    return {\n      address: this._db.address.toString()\n    };\n  }\n\n  async grant(capability, key) {\n    // Merge current keys with the new key\n    const capabilities = new Set([...(this._db.get(capability) || []), ...[key]]);\n    await this._db.put(capability, Array.from(capabilities.values()));\n  }\n\n  async revoke(capability, key) {\n    const capabilities = new Set(this._db.get(capability) || []);\n    capabilities.delete(key);\n\n    if (capabilities.size > 0) {\n      await this._db.put(capability, Array.from(capabilities.values()));\n    } else {\n      await this._db.del(capability);\n    }\n  }\n  /* Private methods */\n\n\n  _onUpdate() {\n    this.emit('updated');\n  }\n  /* Factory */\n\n\n  static async create(orbitdb, options = {}) {\n    const ac = new OrbitDBAccessController(orbitdb, options);\n    await ac.load(options.address || options.name || 'default-access-controller'); // Add write access from options\n\n    if (options.write && !options.address) {\n      await pMapSeries(options.write, async e => ac.grant('write', e));\n    }\n\n    return ac;\n  }\n\n}\n\nmodule.exports = OrbitDBAccessController;","map":null,"metadata":{},"sourceType":"script"}