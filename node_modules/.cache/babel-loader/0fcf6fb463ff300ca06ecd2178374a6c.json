{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\n\nconst Big = require('bignumber.js');\n\nconst MovingAverage = require('moving-average');\n\nconst retimer = require('retimer');\n/**\n * A queue based manager for stat processing\n *\n * @param {Array<string>} initialCounters\n * @param {any} options\n */\n\n\nclass Stats extends EventEmitter {\n  constructor(initialCounters, options) {\n    super();\n    this._options = options;\n    this._queue = [];\n    this._stats = {};\n    this._frequencyLastTime = Date.now();\n    this._frequencyAccumulators = {};\n    this._movingAverages = {};\n    this._update = this._update.bind(this);\n    const intervals = this._options.movingAverageIntervals;\n\n    for (var i = 0; i < initialCounters.length; i++) {\n      var key = initialCounters[i];\n      this._stats[key] = Big(0);\n      this._movingAverages[key] = {};\n\n      for (var k = 0; k < intervals.length; k++) {\n        var interval = intervals[k];\n        var ma = this._movingAverages[key][interval] = MovingAverage(interval);\n        ma.push(this._frequencyLastTime, 0);\n      }\n    }\n  }\n  /**\n   * Initializes the internal timer if there are items in the queue. This\n   * should only need to be called if `Stats.stop` was previously called, as\n   * `Stats.push` will also start the processing.\n   *\n   * @returns {void}\n   */\n\n\n  start() {\n    if (this._queue.length) {\n      this._resetComputeTimeout();\n    }\n  }\n  /**\n   * Stops processing and computing of stats by clearing the internal\n   * timer.\n   *\n   * @returns {void}\n   */\n\n\n  stop() {\n    if (this._timeout) {\n      this._timeout.clear();\n\n      this._timeout = null;\n    }\n  }\n  /**\n   * Returns a clone of the current stats.\n   *\n   * @returns {Map<string, Stat>}\n   */\n\n\n  get snapshot() {\n    return Object.assign({}, this._stats);\n  }\n  /**\n   * Returns a clone of the internal movingAverages\n   *\n   * @returns {Array<MovingAverage>}\n   */\n\n\n  get movingAverages() {\n    return Object.assign({}, this._movingAverages);\n  }\n  /**\n   * Returns a plain JSON object of the stats\n   *\n   * @returns {*}\n   */\n\n\n  toJSON() {\n    const snapshot = this.snapshot;\n    const movingAverages = this.movingAverages;\n    const data = {\n      dataReceived: snapshot.dataReceived.toString(),\n      dataSent: snapshot.dataSent.toString(),\n      movingAverages: {}\n    };\n    const counters = Object.keys(movingAverages);\n\n    for (const key of counters) {\n      data.movingAverages[key] = {};\n\n      for (const interval of Object.keys(movingAverages[key])) {\n        data.movingAverages[key][interval] = movingAverages[key][interval].movingAverage();\n      }\n    }\n\n    return data;\n  }\n  /**\n   * Pushes the given operation data to the queue, along with the\n   * current Timestamp, then resets the update timer.\n   *\n   * @param {string} counter\n   * @param {number} inc\n   * @returns {void}\n   */\n\n\n  push(counter, inc) {\n    this._queue.push([counter, inc, Date.now()]);\n\n    this._resetComputeTimeout();\n  }\n  /**\n   * Resets the timeout for triggering updates.\n   *\n   * @private\n   * @returns {void}\n   */\n\n\n  _resetComputeTimeout() {\n    if (this._timeout) {\n      this._timeout.reschedule(this._nextTimeout());\n    } else {\n      this._timeout = retimer(this._update, this._nextTimeout());\n    }\n  }\n  /**\n   * Calculates and returns the timeout for the next update based on\n   * the urgency of the update.\n   *\n   * @private\n   * @returns {number}\n   */\n\n\n  _nextTimeout() {\n    // calculate the need for an update, depending on the queue length\n    const urgency = this._queue.length / this._options.computeThrottleMaxQueueSize;\n    const timeout = Math.max(this._options.computeThrottleTimeout * (1 - urgency), 0);\n    return timeout;\n  }\n  /**\n   * If there are items in the queue, they will will be processed and\n   * the frequency for all items will be updated based on the Timestamp\n   * of the last item in the queue. The `update` event will also be emitted\n   * with the latest stats.\n   *\n   * If there are no items in the queue, no action is taken.\n   *\n   * @private\n   * @returns {void}\n   */\n\n\n  _update() {\n    this._timeout = null;\n\n    if (this._queue.length) {\n      let last;\n\n      for (last of this._queue) {\n        this._applyOp(last);\n      }\n\n      this._queue = [];\n\n      this._updateFrequency(last[2]); // contains timestamp of last op\n\n\n      this.emit('update', this._stats);\n    }\n  }\n  /**\n   * For each key in the stats, the frequency and moving averages\n   * will be updated via Stats._updateFrequencyFor based on the time\n   * difference between calls to this method.\n   *\n   * @private\n   * @param {Timestamp} latestTime\n   * @returns {void}\n   */\n\n\n  _updateFrequency(latestTime) {\n    const timeDiff = latestTime - this._frequencyLastTime;\n    Object.keys(this._stats).forEach(key => {\n      this._updateFrequencyFor(key, timeDiff, latestTime);\n    });\n    this._frequencyLastTime = latestTime;\n  }\n  /**\n   * Updates the `movingAverages` for the given `key` and also\n   * resets the `frequencyAccumulator` for the `key`.\n   *\n   * @private\n   * @param {string} key\n   * @param {number} timeDiffMS Time in milliseconds\n   * @param {Timestamp} latestTime Time in ticks\n   * @returns {void}\n   */\n\n\n  _updateFrequencyFor(key, timeDiffMS, latestTime) {\n    const count = this._frequencyAccumulators[key] || 0;\n    this._frequencyAccumulators[key] = 0; // if `timeDiff` is zero, `hz` becomes Infinity, so we fallback to 1ms\n\n    const safeTimeDiff = timeDiffMS || 1;\n    const hz = count / safeTimeDiff * 1000;\n    let movingAverages = this._movingAverages[key];\n\n    if (!movingAverages) {\n      movingAverages = this._movingAverages[key] = {};\n    }\n\n    const intervals = this._options.movingAverageIntervals;\n\n    for (var i = 0; i < intervals.length; i++) {\n      var movingAverageInterval = intervals[i];\n      var movingAverage = movingAverages[movingAverageInterval];\n\n      if (!movingAverage) {\n        movingAverage = movingAverages[movingAverageInterval] = MovingAverage(movingAverageInterval);\n      }\n\n      movingAverage.push(latestTime, hz);\n    }\n  }\n  /**\n   * For the given operation, `op`, the stats and `frequencyAccumulator`\n   * will be updated or initialized if they don't already exist.\n   *\n   * @private\n   * @param {Array<string, number>} op\n   * @throws {InvalidNumber}\n   * @returns {void}\n   */\n\n\n  _applyOp(op) {\n    const key = op[0];\n    const inc = op[1];\n\n    if (typeof inc !== 'number') {\n      throw new Error('invalid increment number:', inc);\n    }\n\n    let n;\n\n    if (!Object.prototype.hasOwnProperty.call(this._stats, key)) {\n      n = this._stats[key] = Big(0);\n    } else {\n      n = this._stats[key];\n    }\n\n    this._stats[key] = n.plus(inc);\n\n    if (!this._frequencyAccumulators[key]) {\n      this._frequencyAccumulators[key] = 0;\n    }\n\n    this._frequencyAccumulators[key] += inc;\n  }\n\n}\n\nmodule.exports = Stats;","map":null,"metadata":{},"sourceType":"script"}