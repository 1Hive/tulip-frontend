{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:upgrader');\nlog.error = debug('libp2p:upgrader:error');\n\nvar Multistream = require('multistream-select');\n\nvar _require = require('libp2p-interfaces/src/connection'),\n    Connection = _require.Connection;\n\nvar PeerId = require('peer-id');\n\nvar pipe = require('it-pipe');\n\nvar errCode = require('err-code');\n\nvar mutableProxy = require('mutable-proxy');\n\nvar _require2 = require('./errors'),\n    codes = _require2.codes;\n/**\n * @typedef MultiaddrConnection\n * @property {function} sink\n * @property {AsyncIterator} source\n * @property {*} conn\n * @property {Multiaddr} remoteAddr\n */\n\n/**\n * @typedef CryptoResult\n * @property {*} conn A duplex iterable\n * @property {PeerId} remotePeer\n * @property {string} protocol\n */\n\n\nvar Upgrader = /*#__PURE__*/function () {\n  /**\n   * @param {object} options\n   * @param {PeerId} options.localPeer\n   * @param {Metrics} options.metrics\n   * @param {Map<string, Crypto>} options.cryptos\n   * @param {Map<string, Muxer>} options.muxers\n   * @param {function(Connection)} options.onConnection Called when a connection is upgraded\n   * @param {function(Connection)} options.onConnectionEnd\n   */\n  function Upgrader(_ref) {\n    var localPeer = _ref.localPeer,\n        metrics = _ref.metrics,\n        cryptos = _ref.cryptos,\n        muxers = _ref.muxers,\n        _ref$onConnectionEnd = _ref.onConnectionEnd,\n        onConnectionEnd = _ref$onConnectionEnd === void 0 ? function () {} : _ref$onConnectionEnd,\n        _ref$onConnection = _ref.onConnection,\n        onConnection = _ref$onConnection === void 0 ? function () {} : _ref$onConnection;\n\n    _classCallCheck(this, Upgrader);\n\n    this.localPeer = localPeer;\n    this.metrics = metrics;\n    this.cryptos = cryptos || new Map();\n    this.muxers = muxers || new Map();\n    this.protector = null;\n    this.protocols = new Map();\n    this.onConnection = onConnection;\n    this.onConnectionEnd = onConnectionEnd;\n  }\n  /**\n   * Upgrades an inbound connection\n   * @async\n   * @param {MultiaddrConnection} maConn\n   * @returns {Promise<Connection>}\n   */\n\n\n  _createClass(Upgrader, [{\n    key: \"upgradeInbound\",\n    value: function () {\n      var _upgradeInbound = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(maConn) {\n        var encryptedConn, remotePeer, upgradedConn, Muxer, cryptoProtocol, setPeer, proxyPeer, _mutableProxy, idString, protectedConn, _yield$this$_encryptI, _yield$this$_multiple;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (this.metrics) {\n                  _mutableProxy = mutableProxy();\n                  setPeer = _mutableProxy.setTarget;\n                  proxyPeer = _mutableProxy.proxy;\n                  idString = parseInt(Math.random() * 1e9).toString(36) + Date.now();\n                  setPeer({\n                    toB58String: function toB58String() {\n                      return idString;\n                    }\n                  });\n                  maConn = this.metrics.trackStream({\n                    stream: maConn,\n                    remotePeer: proxyPeer\n                  });\n                }\n\n                log('Starting the inbound connection upgrade'); // Protect\n\n                protectedConn = maConn;\n\n                if (!this.protector) {\n                  _context.next = 7;\n                  break;\n                }\n\n                _context.next = 6;\n                return this.protector.protect(maConn);\n\n              case 6:\n                protectedConn = _context.sent;\n\n              case 7:\n                _context.prev = 7;\n                _context.next = 10;\n                return this._encryptInbound(this.localPeer, protectedConn, this.cryptos);\n\n              case 10:\n                _yield$this$_encryptI = _context.sent;\n                encryptedConn = _yield$this$_encryptI.conn;\n                remotePeer = _yield$this$_encryptI.remotePeer;\n                cryptoProtocol = _yield$this$_encryptI.protocol;\n\n                if (!this.muxers.size) {\n                  _context.next = 22;\n                  break;\n                }\n\n                _context.next = 17;\n                return this._multiplexInbound(encryptedConn, this.muxers);\n\n              case 17:\n                _yield$this$_multiple = _context.sent;\n                upgradedConn = _yield$this$_multiple.stream;\n                Muxer = _yield$this$_multiple.Muxer;\n                _context.next = 23;\n                break;\n\n              case 22:\n                upgradedConn = encryptedConn;\n\n              case 23:\n                _context.next = 31;\n                break;\n\n              case 25:\n                _context.prev = 25;\n                _context.t0 = _context[\"catch\"](7);\n                log.error('Failed to upgrade inbound connection', _context.t0);\n                _context.next = 30;\n                return maConn.close(_context.t0);\n\n              case 30:\n                throw _context.t0;\n\n              case 31:\n                if (this.metrics) {\n                  this.metrics.updatePlaceholder(proxyPeer, remotePeer);\n                  setPeer(remotePeer);\n                }\n\n                log('Successfully upgraded inbound connection');\n                return _context.abrupt(\"return\", this._createConnection({\n                  cryptoProtocol: cryptoProtocol,\n                  direction: 'inbound',\n                  maConn: maConn,\n                  upgradedConn: upgradedConn,\n                  Muxer: Muxer,\n                  remotePeer: remotePeer\n                }));\n\n              case 34:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[7, 25]]);\n      }));\n\n      function upgradeInbound(_x) {\n        return _upgradeInbound.apply(this, arguments);\n      }\n\n      return upgradeInbound;\n    }()\n    /**\n     * Upgrades an outbound connection\n     * @async\n     * @param {MultiaddrConnection} maConn\n     * @returns {Promise<Connection>}\n     */\n\n  }, {\n    key: \"upgradeOutbound\",\n    value: function () {\n      var _upgradeOutbound = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(maConn) {\n        var remotePeerId, encryptedConn, remotePeer, upgradedConn, cryptoProtocol, Muxer, setPeer, proxyPeer, _mutableProxy2, idString, protectedConn, _yield$this$_encryptO, _yield$this$_multiple2;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                try {\n                  remotePeerId = PeerId.createFromB58String(maConn.remoteAddr.getPeerId());\n                } catch (err) {\n                  log.error('multiaddr did not contain a valid peer id', err);\n                }\n\n                if (this.metrics) {\n                  _mutableProxy2 = mutableProxy();\n                  setPeer = _mutableProxy2.setTarget;\n                  proxyPeer = _mutableProxy2.proxy;\n                  idString = parseInt(Math.random() * 1e9).toString(36) + Date.now();\n                  setPeer({\n                    toB58String: function toB58String() {\n                      return idString;\n                    }\n                  });\n                  maConn = this.metrics.trackStream({\n                    stream: maConn,\n                    remotePeer: proxyPeer\n                  });\n                }\n\n                log('Starting the outbound connection upgrade'); // Protect\n\n                protectedConn = maConn;\n\n                if (!this.protector) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                _context2.next = 7;\n                return this.protector.protect(maConn);\n\n              case 7:\n                protectedConn = _context2.sent;\n\n              case 8:\n                _context2.prev = 8;\n                _context2.next = 11;\n                return this._encryptOutbound(this.localPeer, protectedConn, remotePeerId, this.cryptos);\n\n              case 11:\n                _yield$this$_encryptO = _context2.sent;\n                encryptedConn = _yield$this$_encryptO.conn;\n                remotePeer = _yield$this$_encryptO.remotePeer;\n                cryptoProtocol = _yield$this$_encryptO.protocol;\n\n                if (!this.muxers.size) {\n                  _context2.next = 23;\n                  break;\n                }\n\n                _context2.next = 18;\n                return this._multiplexOutbound(encryptedConn, this.muxers);\n\n              case 18:\n                _yield$this$_multiple2 = _context2.sent;\n                upgradedConn = _yield$this$_multiple2.stream;\n                Muxer = _yield$this$_multiple2.Muxer;\n                _context2.next = 24;\n                break;\n\n              case 23:\n                upgradedConn = encryptedConn;\n\n              case 24:\n                _context2.next = 32;\n                break;\n\n              case 26:\n                _context2.prev = 26;\n                _context2.t0 = _context2[\"catch\"](8);\n                log.error('Failed to upgrade outbound connection', _context2.t0);\n                _context2.next = 31;\n                return maConn.close(_context2.t0);\n\n              case 31:\n                throw _context2.t0;\n\n              case 32:\n                if (this.metrics) {\n                  this.metrics.updatePlaceholder(proxyPeer, remotePeer);\n                  setPeer(remotePeer);\n                }\n\n                log('Successfully upgraded outbound connection');\n                return _context2.abrupt(\"return\", this._createConnection({\n                  cryptoProtocol: cryptoProtocol,\n                  direction: 'outbound',\n                  maConn: maConn,\n                  upgradedConn: upgradedConn,\n                  Muxer: Muxer,\n                  remotePeer: remotePeer\n                }));\n\n              case 35:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[8, 26]]);\n      }));\n\n      function upgradeOutbound(_x2) {\n        return _upgradeOutbound.apply(this, arguments);\n      }\n\n      return upgradeOutbound;\n    }()\n    /**\n     * A convenience method for generating a new `Connection`\n     * @private\n     * @param {object} options\n     * @param {string} cryptoProtocol The crypto protocol that was negotiated\n     * @param {string} direction One of ['inbound', 'outbound']\n     * @param {MultiaddrConnection} maConn The transport layer connection\n     * @param {*} upgradedConn A duplex connection returned from multiplexer and/or crypto selection\n     * @param {Muxer} Muxer The muxer to be used for muxing\n     * @param {PeerId} remotePeer The peer the connection is with\n     * @returns {Connection}\n     */\n\n  }, {\n    key: \"_createConnection\",\n    value: function _createConnection(_ref2) {\n      var _this = this;\n\n      var cryptoProtocol = _ref2.cryptoProtocol,\n          direction = _ref2.direction,\n          maConn = _ref2.maConn,\n          upgradedConn = _ref2.upgradedConn,\n          Muxer = _ref2.Muxer,\n          remotePeer = _ref2.remotePeer;\n      var muxer;\n      var newStream; // eslint-disable-next-line prefer-const\n\n      var connection;\n\n      if (Muxer) {\n        // Create the muxer\n        muxer = new Muxer({\n          // Run anytime a remote stream is created\n          onStream: function () {\n            var _onStream2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(muxedStream) {\n              var mss, _yield$mss$handle, stream, protocol;\n\n              return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                while (1) {\n                  switch (_context3.prev = _context3.next) {\n                    case 0:\n                      mss = new Multistream.Listener(muxedStream);\n                      _context3.prev = 1;\n                      _context3.next = 4;\n                      return mss.handle(Array.from(_this.protocols.keys()));\n\n                    case 4:\n                      _yield$mss$handle = _context3.sent;\n                      stream = _yield$mss$handle.stream;\n                      protocol = _yield$mss$handle.protocol;\n                      log('%s: incoming stream opened on %s', direction, protocol);\n                      if (_this.metrics) _this.metrics.trackStream({\n                        stream: stream,\n                        remotePeer: remotePeer,\n                        protocol: protocol\n                      });\n                      connection.addStream(muxedStream, {\n                        protocol: protocol\n                      });\n\n                      _this._onStream({\n                        connection: connection,\n                        stream: stream,\n                        protocol: protocol\n                      });\n\n                      _context3.next = 16;\n                      break;\n\n                    case 13:\n                      _context3.prev = 13;\n                      _context3.t0 = _context3[\"catch\"](1);\n                      log.error(_context3.t0);\n\n                    case 16:\n                    case \"end\":\n                      return _context3.stop();\n                  }\n                }\n              }, _callee3, null, [[1, 13]]);\n            }));\n\n            function onStream(_x3) {\n              return _onStream2.apply(this, arguments);\n            }\n\n            return onStream;\n          }(),\n          // Run anytime a stream closes\n          onStreamEnd: function onStreamEnd(muxedStream) {\n            connection.removeStream(muxedStream.id);\n          }\n        });\n\n        newStream = /*#__PURE__*/function () {\n          var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(protocols) {\n            var muxedStream, mss, _yield$mss$select, stream, protocol;\n\n            return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n              while (1) {\n                switch (_context4.prev = _context4.next) {\n                  case 0:\n                    log('%s: starting new stream on %s', direction, protocols);\n                    muxedStream = muxer.newStream();\n                    mss = new Multistream.Dialer(muxedStream);\n                    _context4.prev = 3;\n                    _context4.next = 6;\n                    return mss.select(protocols);\n\n                  case 6:\n                    _yield$mss$select = _context4.sent;\n                    stream = _yield$mss$select.stream;\n                    protocol = _yield$mss$select.protocol;\n                    if (_this.metrics) _this.metrics.trackStream({\n                      stream: stream,\n                      remotePeer: remotePeer,\n                      protocol: protocol\n                    });\n                    return _context4.abrupt(\"return\", {\n                      stream: _objectSpread(_objectSpread({}, muxedStream), stream),\n                      protocol: protocol\n                    });\n\n                  case 13:\n                    _context4.prev = 13;\n                    _context4.t0 = _context4[\"catch\"](3);\n                    log.error('could not create new stream', _context4.t0);\n                    throw errCode(_context4.t0, codes.ERR_UNSUPPORTED_PROTOCOL);\n\n                  case 17:\n                  case \"end\":\n                    return _context4.stop();\n                }\n              }\n            }, _callee4, null, [[3, 13]]);\n          }));\n\n          return function newStream(_x4) {\n            return _ref3.apply(this, arguments);\n          };\n        }(); // Pipe all data through the muxer\n\n\n        pipe(upgradedConn, muxer, upgradedConn).catch(log.error);\n      }\n\n      var _timeline = maConn.timeline;\n      maConn.timeline = new Proxy(_timeline, {\n        set: function set() {\n          if (connection && (arguments.length <= 1 ? undefined : arguments[1]) === 'close' && (arguments.length <= 2 ? undefined : arguments[2]) && !_timeline.close) {\n            connection.stat.status = 'closed';\n\n            _this.onConnectionEnd(connection);\n          }\n\n          return Reflect.set.apply(Reflect, arguments);\n        }\n      });\n      maConn.timeline.upgraded = Date.now();\n\n      var errConnectionNotMultiplexed = function errConnectionNotMultiplexed() {\n        throw errCode(new Error('connection is not multiplexed'), 'ERR_CONNECTION_NOT_MULTIPLEXED');\n      }; // Create the connection\n\n\n      connection = new Connection({\n        localAddr: maConn.localAddr,\n        remoteAddr: maConn.remoteAddr,\n        localPeer: this.localPeer,\n        remotePeer: remotePeer,\n        stat: {\n          direction: direction,\n          timeline: maConn.timeline,\n          multiplexer: Muxer && Muxer.multicodec,\n          encryption: cryptoProtocol\n        },\n        newStream: newStream || errConnectionNotMultiplexed,\n        getStreams: function getStreams() {\n          return muxer ? muxer.streams : errConnectionNotMultiplexed;\n        },\n        close: function close(err) {\n          return maConn.close(err);\n        }\n      });\n      this.onConnection(connection);\n      return connection;\n    }\n    /**\n     * Routes incoming streams to the correct handler\n     * @private\n     * @param {object} options\n     * @param {Connection} options.connection The connection the stream belongs to\n     * @param {Stream} options.stream\n     * @param {string} options.protocol\n     */\n\n  }, {\n    key: \"_onStream\",\n    value: function _onStream(_ref4) {\n      var connection = _ref4.connection,\n          stream = _ref4.stream,\n          protocol = _ref4.protocol;\n      var handler = this.protocols.get(protocol);\n      handler({\n        connection: connection,\n        stream: stream,\n        protocol: protocol\n      });\n    }\n    /**\n     * Attempts to encrypt the incoming `connection` with the provided `cryptos`.\n     * @private\n     * @async\n     * @param {PeerId} localPeer The initiators PeerInfo\n     * @param {*} connection\n     * @param {Map<string, Crypto>} cryptos\n     * @returns {CryptoResult} An encrypted connection, remote peer `PeerId` and the protocol of the `Crypto` used\n     */\n\n  }, {\n    key: \"_encryptInbound\",\n    value: function () {\n      var _encryptInbound2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(localPeer, connection, cryptos) {\n        var mss, protocols, _yield$mss$handle2, stream, protocol, crypto;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                mss = new Multistream.Listener(connection);\n                protocols = Array.from(cryptos.keys());\n                log('handling inbound crypto protocol selection', protocols);\n                _context5.prev = 3;\n                _context5.next = 6;\n                return mss.handle(protocols);\n\n              case 6:\n                _yield$mss$handle2 = _context5.sent;\n                stream = _yield$mss$handle2.stream;\n                protocol = _yield$mss$handle2.protocol;\n                crypto = cryptos.get(protocol);\n                log('encrypting inbound connection...');\n                _context5.t0 = _objectSpread;\n                _context5.t1 = _objectSpread;\n                _context5.t2 = {};\n                _context5.next = 16;\n                return crypto.secureInbound(localPeer, stream);\n\n              case 16:\n                _context5.t3 = _context5.sent;\n                _context5.t4 = (0, _context5.t1)(_context5.t2, _context5.t3);\n                _context5.t5 = {};\n                _context5.t6 = {\n                  protocol: protocol\n                };\n                return _context5.abrupt(\"return\", (0, _context5.t0)(_context5.t4, _context5.t5, _context5.t6));\n\n              case 23:\n                _context5.prev = 23;\n                _context5.t7 = _context5[\"catch\"](3);\n                throw errCode(_context5.t7, codes.ERR_ENCRYPTION_FAILED);\n\n              case 26:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, null, [[3, 23]]);\n      }));\n\n      function _encryptInbound(_x5, _x6, _x7) {\n        return _encryptInbound2.apply(this, arguments);\n      }\n\n      return _encryptInbound;\n    }()\n    /**\n     * Attempts to encrypt the given `connection` with the provided `cryptos`.\n     * The first `Crypto` module to succeed will be used\n     * @private\n     * @async\n     * @param {PeerId} localPeer The initiators PeerInfo\n     * @param {*} connection\n     * @param {PeerId} remotePeerId\n     * @param {Map<string, Crypto>} cryptos\n     * @returns {CryptoResult} An encrypted connection, remote peer `PeerId` and the protocol of the `Crypto` used\n     */\n\n  }, {\n    key: \"_encryptOutbound\",\n    value: function () {\n      var _encryptOutbound2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(localPeer, connection, remotePeerId, cryptos) {\n        var mss, protocols, _yield$mss$select2, stream, protocol, crypto;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                mss = new Multistream.Dialer(connection);\n                protocols = Array.from(cryptos.keys());\n                log('selecting outbound crypto protocol', protocols);\n                _context6.prev = 3;\n                _context6.next = 6;\n                return mss.select(protocols);\n\n              case 6:\n                _yield$mss$select2 = _context6.sent;\n                stream = _yield$mss$select2.stream;\n                protocol = _yield$mss$select2.protocol;\n                crypto = cryptos.get(protocol);\n                log('encrypting outbound connection to %j', remotePeerId);\n                _context6.t0 = _objectSpread;\n                _context6.t1 = _objectSpread;\n                _context6.t2 = {};\n                _context6.next = 16;\n                return crypto.secureOutbound(localPeer, stream, remotePeerId);\n\n              case 16:\n                _context6.t3 = _context6.sent;\n                _context6.t4 = (0, _context6.t1)(_context6.t2, _context6.t3);\n                _context6.t5 = {};\n                _context6.t6 = {\n                  protocol: protocol\n                };\n                return _context6.abrupt(\"return\", (0, _context6.t0)(_context6.t4, _context6.t5, _context6.t6));\n\n              case 23:\n                _context6.prev = 23;\n                _context6.t7 = _context6[\"catch\"](3);\n                throw errCode(_context6.t7, codes.ERR_ENCRYPTION_FAILED);\n\n              case 26:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, null, [[3, 23]]);\n      }));\n\n      function _encryptOutbound(_x8, _x9, _x10, _x11) {\n        return _encryptOutbound2.apply(this, arguments);\n      }\n\n      return _encryptOutbound;\n    }()\n    /**\n     * Selects one of the given muxers via multistream-select. That\n     * muxer will be used for all future streams on the connection.\n     * @private\n     * @async\n     * @param {*} connection A basic duplex connection to multiplex\n     * @param {Map<string, Muxer>} muxers The muxers to attempt multiplexing with\n     * @returns {*} A muxed connection\n     */\n\n  }, {\n    key: \"_multiplexOutbound\",\n    value: function () {\n      var _multiplexOutbound2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(connection, muxers) {\n        var dialer, protocols, _yield$dialer$select, stream, protocol, Muxer;\n\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                dialer = new Multistream.Dialer(connection);\n                protocols = Array.from(muxers.keys());\n                log('outbound selecting muxer %s', protocols);\n                _context7.prev = 3;\n                _context7.next = 6;\n                return dialer.select(protocols);\n\n              case 6:\n                _yield$dialer$select = _context7.sent;\n                stream = _yield$dialer$select.stream;\n                protocol = _yield$dialer$select.protocol;\n                log('%s selected as muxer protocol', protocol);\n                Muxer = muxers.get(protocol);\n                return _context7.abrupt(\"return\", {\n                  stream: stream,\n                  Muxer: Muxer\n                });\n\n              case 14:\n                _context7.prev = 14;\n                _context7.t0 = _context7[\"catch\"](3);\n                throw errCode(_context7.t0, codes.ERR_MUXER_UNAVAILABLE);\n\n              case 17:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, null, [[3, 14]]);\n      }));\n\n      function _multiplexOutbound(_x12, _x13) {\n        return _multiplexOutbound2.apply(this, arguments);\n      }\n\n      return _multiplexOutbound;\n    }()\n    /**\n     * Registers support for one of the given muxers via multistream-select. The\n     * selected muxer will be used for all future streams on the connection.\n     * @private\n     * @async\n     * @param {*} connection A basic duplex connection to multiplex\n     * @param {Map<string, Muxer>} muxers The muxers to attempt multiplexing with\n     * @returns {*} A muxed connection\n     */\n\n  }, {\n    key: \"_multiplexInbound\",\n    value: function () {\n      var _multiplexInbound2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(connection, muxers) {\n        var listener, protocols, _yield$listener$handl, stream, protocol, Muxer;\n\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                listener = new Multistream.Listener(connection);\n                protocols = Array.from(muxers.keys());\n                log('inbound handling muxers %s', protocols);\n                _context8.prev = 3;\n                _context8.next = 6;\n                return listener.handle(protocols);\n\n              case 6:\n                _yield$listener$handl = _context8.sent;\n                stream = _yield$listener$handl.stream;\n                protocol = _yield$listener$handl.protocol;\n                Muxer = muxers.get(protocol);\n                return _context8.abrupt(\"return\", {\n                  stream: stream,\n                  Muxer: Muxer\n                });\n\n              case 13:\n                _context8.prev = 13;\n                _context8.t0 = _context8[\"catch\"](3);\n                throw errCode(_context8.t0, codes.ERR_MUXER_UNAVAILABLE);\n\n              case 16:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, null, [[3, 13]]);\n      }));\n\n      function _multiplexInbound(_x14, _x15) {\n        return _multiplexInbound2.apply(this, arguments);\n      }\n\n      return _multiplexInbound;\n    }()\n  }]);\n\n  return Upgrader;\n}();\n\nmodule.exports = Upgrader;","map":null,"metadata":{},"sourceType":"script"}