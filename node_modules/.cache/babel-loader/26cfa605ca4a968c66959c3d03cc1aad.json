{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar crypto = require('libp2p-crypto');\n\nvar multibase = require('multibase');\n\nexports = module.exports;\n/**\n * Generatea random sequence number.\n *\n * @returns {Buffer}\n * @private\n */\n\nexports.randomSeqno = function () {\n  return crypto.randomBytes(8);\n};\n/**\n * Generate a message id, based on the `from` and `seqno`.\n *\n * @param {string} from\n * @param {Buffer} seqno\n * @returns {string}\n * @private\n */\n\n\nexports.msgId = function (from, seqno) {\n  return from + seqno.toString('hex');\n};\n/**\n * Check if any member of the first set is also a member\n * of the second set.\n *\n * @param {Set|Array} a\n * @param {Set|Array} b\n * @returns {boolean}\n * @private\n */\n\n\nexports.anyMatch = function (a, b) {\n  var bHas;\n\n  if (Array.isArray(b)) {\n    bHas = function bHas(val) {\n      return b.indexOf(val) > -1;\n    };\n  } else {\n    bHas = function bHas(val) {\n      return b.has(val);\n    };\n  }\n\n  var _iterator = _createForOfIteratorHelper(a),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var val = _step.value;\n\n      if (bHas(val)) {\n        return true;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return false;\n};\n/**\n * Make everything an array.\n *\n * @param {any} maybeArray\n * @returns {Array}\n * @private\n */\n\n\nexports.ensureArray = function (maybeArray) {\n  if (!Array.isArray(maybeArray)) {\n    return [maybeArray];\n  }\n\n  return maybeArray;\n};\n/**\n * Ensures `message.from` is base58 encoded\n * @param {Object} message\n * @param {Buffer|String} message.from\n * @return {Object}\n */\n\n\nexports.normalizeInRpcMessage = function (message) {\n  var m = Object.assign({}, message);\n\n  if (Buffer.isBuffer(message.from)) {\n    m.from = multibase.encode('base58btc', message.from).toString().slice(1);\n  }\n\n  return m;\n};\n/**\n * The same as `normalizeInRpcMessage`, but performed on an array of messages\n * @param {Object[]} messages\n * @return {Object[]}\n */\n\n\nexports.normalizeInRpcMessages = function (messages) {\n  if (!messages) {\n    return messages;\n  }\n\n  return messages.map(exports.normalizeInRpcMessage);\n};\n\nexports.normalizeOutRpcMessage = function (message) {\n  var m = Object.assign({}, message);\n\n  if (typeof message.from === 'string' || message.from instanceof String) {\n    m.from = multibase.decode('z' + message.from);\n  }\n\n  return m;\n};\n\nexports.normalizeOutRpcMessages = function (messages) {\n  if (!messages) {\n    return messages;\n  }\n\n  return messages.map(exports.normalizeOutRpcMessage);\n};","map":null,"metadata":{},"sourceType":"script"}