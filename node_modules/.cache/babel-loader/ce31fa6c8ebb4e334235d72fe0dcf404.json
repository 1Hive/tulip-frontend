{"ast":null,"code":"'use strict';\n\nconst errcode = require('err-code');\n\nconst pTimeout = require('p-timeout');\n\nconst libp2pRecord = require('libp2p-record');\n\nconst c = require('../constants');\n\nconst Query = require('../query');\n\nconst utils = require('../utils');\n\nconst Record = libp2pRecord.Record;\n\nmodule.exports = dht => {\n  const putLocal = async (key, rec) => {\n    // eslint-disable-line require-await\n    return dht.datastore.put(utils.bufferToKey(key), rec);\n  };\n  /**\n   * Attempt to retrieve the value for the given key from\n   * the local datastore.\n   *\n   * @param {Buffer} key\n   * @returns {Promise<Record>}\n   *\n   * @private\n   */\n\n\n  const getLocal = async key => {\n    dht._log('getLocal %b', key);\n\n    const raw = await dht.datastore.get(utils.bufferToKey(key));\n\n    dht._log('found %b in local datastore', key);\n\n    const rec = Record.deserialize(raw);\n    await dht._verifyRecordLocally(rec);\n    return rec;\n  };\n  /**\n   * Send the best record found to any peers that have an out of date record.\n   *\n   * @param {Buffer} key\n   * @param {Array<Object>} vals - values retrieved from the DHT\n   * @param {Object} best - the best record that was found\n   * @returns {Promise}\n   *\n   * @private\n   */\n\n\n  const sendCorrectionRecord = async (key, vals, best) => {\n    const fixupRec = await utils.createPutRecord(key, best);\n    return Promise.all(vals.map(async v => {\n      // no need to do anything\n      if (v.val.equals(best)) {\n        return;\n      } // correct ourself\n\n\n      if (dht._isSelf(v.from)) {\n        try {\n          await dht._putLocal(key, fixupRec);\n        } catch (err) {\n          dht._log.error('Failed error correcting self', err);\n        }\n\n        return;\n      } // send correction\n\n\n      try {\n        await dht._putValueToPeer(key, fixupRec, v.from);\n      } catch (err) {\n        dht._log.error('Failed error correcting entry', err);\n      }\n    }));\n  };\n\n  return {\n    /**\n     * Store the given key/value pair locally, in the datastore.\n     * @param {Buffer} key\n     * @param {Buffer} rec - encoded record\n     * @returns {Promise<void>}\n     * @private\n     */\n    async _putLocal(key, rec) {\n      // eslint-disable-line require-await\n      return putLocal(key, rec);\n    },\n\n    /**\n     * Store the given key/value  pair in the DHT.\n     *\n     * @param {Buffer} key\n     * @param {Buffer} value\n     * @param {Object} [options] - put options\n     * @param {number} [options.minPeers] - minimum number of peers required to successfully put (default: closestPeers.length)\n     * @returns {Promise<void>}\n     */\n    async put(key, value, options = {}) {\n      dht._log('PutValue %b', key); // create record in the dht format\n\n\n      const record = await utils.createPutRecord(key, value); // store the record locally\n\n      await putLocal(key, record); // put record to the closest peers\n\n      let counterAll = 0;\n      let counterSuccess = 0;\n\n      for await (const peer of dht.getClosestPeers(key, {\n        shallow: true\n      })) {\n        try {\n          counterAll += 1;\n          await dht._putValueToPeer(key, record, peer);\n          counterSuccess += 1;\n        } catch (err) {\n          dht._log.error('Failed to put to peer (%b): %s', peer.id, err);\n        }\n      } // verify if we were able to put to enough peers\n\n\n      const minPeers = options.minPeers || counterAll; // Ensure we have a default `minPeers`\n\n      if (minPeers > counterSuccess) {\n        const error = errcode(new Error(`Failed to put value to enough peers: ${counterSuccess}/${minPeers}`), 'ERR_NOT_ENOUGH_PUT_PEERS');\n\n        dht._log.error(error);\n\n        throw error;\n      }\n    },\n\n    /**\n     * Get the value to the given key.\n     * Times out after 1 minute by default.\n     *\n     * @param {Buffer} key\n     * @param {Object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout (default: 60000)\n     * @returns {Promise<Buffer>}\n     */\n    async get(key, options = {}) {\n      options.timeout = options.timeout || c.minute;\n\n      dht._log('_get %b', key);\n\n      const vals = await dht.getMany(key, c.GET_MANY_RECORD_COUNT, options);\n      const recs = vals.map(v => v.val);\n      let i = 0;\n\n      try {\n        i = libp2pRecord.selection.bestRecord(dht.selectors, key, recs);\n      } catch (err) {\n        // Assume the first record if no selector available\n        if (err.code !== 'ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY') {\n          throw err;\n        }\n      }\n\n      const best = recs[i];\n\n      dht._log('GetValue %b %s', key, best);\n\n      if (!best) {\n        throw errcode(new Error('best value was not found'), 'ERR_NOT_FOUND');\n      }\n\n      await sendCorrectionRecord(key, vals, best);\n      return best;\n    },\n\n    /**\n     * Get the `n` values to the given key without sorting.\n     *\n     * @param {Buffer} key\n     * @param {number} nvals\n     * @param {Object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout (default: 60000)\n     * @returns {Promise<Array<{from: PeerId, val: Buffer}>>}\n     */\n    async getMany(key, nvals, options = {}) {\n      options.timeout = options.timeout || c.minute;\n\n      dht._log('getMany %b (%s)', key, nvals);\n\n      let vals = [];\n      let localRec;\n\n      try {\n        localRec = await getLocal(key);\n      } catch (err) {\n        if (nvals === 0) {\n          throw err;\n        }\n      }\n\n      if (localRec) {\n        vals.push({\n          val: localRec.value,\n          from: dht.peerInfo.id\n        });\n      }\n\n      if (vals.length >= nvals) {\n        return vals;\n      }\n\n      const paths = [];\n      const id = await utils.convertBuffer(key);\n      const rtp = dht.routingTable.closestPeers(id, this.kBucketSize);\n\n      dht._log('peers in rt: %d', rtp.length);\n\n      if (rtp.length === 0) {\n        const errMsg = 'Failed to lookup key! No peers from routing table!';\n\n        dht._log.error(errMsg);\n\n        if (vals.length === 0) {\n          throw errcode(new Error(errMsg), 'ERR_NO_PEERS_IN_ROUTING_TABLE');\n        }\n\n        return vals;\n      } // we have peers, lets do the actual query to them\n\n\n      const query = new Query(dht, key, (pathIndex, numPaths) => {\n        // This function body runs once per disjoint path\n        const pathSize = utils.pathSize(nvals - vals.length, numPaths);\n        const pathVals = [];\n        paths.push(pathVals); // Here we return the query function to use on this particular disjoint path\n\n        return async peer => {\n          let rec, peers, lookupErr;\n\n          try {\n            const results = await dht._getValueOrPeers(peer, key);\n            rec = results.record;\n            peers = results.peers;\n          } catch (err) {\n            // If we have an invalid record we just want to continue and fetch a new one.\n            if (err.code !== 'ERR_INVALID_RECORD') {\n              throw err;\n            }\n\n            lookupErr = err;\n          }\n\n          const res = {\n            closerPeers: peers\n          };\n\n          if (rec && rec.value || lookupErr) {\n            pathVals.push({\n              val: rec && rec.value,\n              from: peer\n            });\n          } // enough is enough\n\n\n          if (pathVals.length >= pathSize) {\n            res.pathComplete = true;\n          }\n\n          return res;\n        };\n      });\n      let error;\n\n      try {\n        await pTimeout(query.run(rtp), options.timeout);\n      } catch (err) {\n        error = err;\n      }\n\n      query.stop(); // combine vals from each path\n\n      vals = [].concat.apply(vals, paths).slice(0, nvals);\n\n      if (error && vals.length === 0) {\n        throw error;\n      }\n\n      return vals;\n    }\n\n  };\n};","map":null,"metadata":{},"sourceType":"script"}