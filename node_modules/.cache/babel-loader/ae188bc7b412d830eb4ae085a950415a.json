{"ast":null,"code":"\"use strict\"; // Copyright (C) 2019 Kyle Den Hartog\n// MIT License. See LICENSE file for details.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar xchacha20_1 = require(\"@stablelib/xchacha20\");\n\nvar chacha20poly1305_1 = require(\"@stablelib/chacha20poly1305\");\n\nvar wipe_1 = require(\"@stablelib/wipe\");\n\nexports.KEY_LENGTH = 32;\nexports.NONCE_LENGTH = 24;\nexports.TAG_LENGTH = 16;\n/**\n * XChaCha20-Poly1305 Authenticated Encryption with Associated Data.\n *\n * Defined in draft-irtf-cfrg-xchacha-01.\n * See https://tools.ietf.org/html/draft-irtf-cfrg-xchacha-01\n */\n\nvar XChaCha20Poly1305 =\n/** @class */\nfunction () {\n  /**\n   * Creates a new instance with the given 32-byte key.\n   */\n  function XChaCha20Poly1305(key) {\n    this.nonceLength = exports.NONCE_LENGTH;\n    this.tagLength = exports.TAG_LENGTH;\n\n    if (key.length !== exports.KEY_LENGTH) {\n      throw new Error(\"ChaCha20Poly1305 needs 32-byte key\");\n    } // Copy key.\n\n\n    this._key = new Uint8Array(key);\n  }\n  /**\n   * Encrypts and authenticates plaintext, authenticates associated data,\n   * and returns sealed ciphertext, which includes authentication tag.\n   *\n   * draft-irtf-cfrg-xchacha-01 defines a 24 byte nonce (192 bits) which\n   * uses the first 16 bytes of the nonce and the secret key with\n   * HChaCha to generate an initial subkey. The last 8 bytes of the nonce\n   * are then prefixed with 4 zero bytes and then provided with the subkey\n   * to the ChaCha20Poly1305 implementation.\n   *\n   * If dst is given (it must be the size of plaintext + the size of tag\n   * length) the result will be put into it. Dst and plaintext must not\n   * overlap.\n   */\n\n\n  XChaCha20Poly1305.prototype.seal = function (nonce, plaintext, associatedData, dst) {\n    if (nonce.length !== 24) {\n      throw new Error(\"XChaCha20Poly1305: incorrect nonce length\");\n    } // Use HSalsa one-way function to transform first 16 bytes of\n    // 24-byte extended nonce and key into a new key for Salsa\n    // stream -- \"subkey\".\n\n\n    var subKey = xchacha20_1.hchacha(this._key, nonce.subarray(0, 16), new Uint8Array(32)); // Use last 8 bytes of 24-byte extended nonce as an actual nonce prefixed by 4 zero bytes,\n    // and a subkey derived in the previous step as key to encrypt.\n\n    var modifiedNonce = new Uint8Array(12);\n    modifiedNonce.set(nonce.subarray(16), 4);\n    var chaChaPoly = new chacha20poly1305_1.ChaCha20Poly1305(subKey);\n    var result = chaChaPoly.seal(modifiedNonce, plaintext, associatedData, dst);\n    wipe_1.wipe(subKey);\n    wipe_1.wipe(modifiedNonce);\n    chaChaPoly.clean();\n    return result;\n  };\n  /**\n   * Authenticates sealed ciphertext (which includes authentication tag) and\n   * associated data, decrypts ciphertext and returns decrypted plaintext.\n   *\n   * draft-irtf-cfrg-xchacha-01 defines a 24 byte nonce (192 bits) which\n   * then uses the first 16 bytes of the nonce and the secret key with\n   * Hchacha to generate an initial subkey. The last 8 bytes of the nonce\n   * are then prefixed with 4 zero bytes and then provided with the subkey\n   * to the chacha20poly1305 implementation.\n   *\n   * If authentication fails, it returns null.\n   *\n   * If dst is given (it must be the size of plaintext + the size of tag\n   * length) the result will be put into it. Dst and plaintext must not\n   * overlap.\n   */\n\n\n  XChaCha20Poly1305.prototype.open = function (nonce, sealed, associatedData, dst) {\n    if (nonce.length !== 24) {\n      throw new Error(\"XChaCha20Poly1305: incorrect nonce length\");\n    } // Sealed ciphertext should at least contain tag.\n\n\n    if (sealed.length < this.tagLength) {\n      // TODO(dchest): should we throw here instead?\n      return null;\n    }\n    /**\n    * Generate subKey by using HChaCha20 function as defined\n    * in section 2 step 1 of draft-irtf-cfrg-xchacha-01\n    */\n\n\n    var subKey = xchacha20_1.hchacha(this._key, nonce.subarray(0, 16), new Uint8Array(32));\n    /**\n    * Generate Nonce as defined - remaining 8 bytes of the nonce prefixed with\n    * 4 zero bytes\n    */\n\n    var modifiedNonce = new Uint8Array(12);\n    modifiedNonce.set(nonce.subarray(16), 4);\n    /**\n     * Authenticate and decrypt by calling into chacha20poly1305.\n     */\n\n    var chaChaPoly = new chacha20poly1305_1.ChaCha20Poly1305(subKey);\n    var result = chaChaPoly.open(modifiedNonce, sealed, associatedData, dst);\n    wipe_1.wipe(subKey);\n    wipe_1.wipe(modifiedNonce);\n    chaChaPoly.clean();\n    return result;\n  };\n\n  XChaCha20Poly1305.prototype.clean = function () {\n    wipe_1.wipe(this._key);\n    return this;\n  };\n\n  return XChaCha20Poly1305;\n}();\n\nexports.XChaCha20Poly1305 = XChaCha20Poly1305;","map":null,"metadata":{},"sourceType":"script"}