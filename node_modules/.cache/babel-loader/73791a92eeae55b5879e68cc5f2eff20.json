{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar TaskMerger = {\n  /**\n   * Indicates whether the given task has newer information than the active\n   * tasks with the same topic\n   * @param {Task} task\n   * @param {Task[]} tasksWithTopic\n   * @returns {boolean}\n   */\n  hasNewInfo: function hasNewInfo(task, tasksWithTopic) {\n    var haveBlock = false;\n    var isWantBlock = false;\n\n    var _iterator = _createForOfIteratorHelper(tasksWithTopic),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var existing = _step.value;\n\n        if (existing.data.haveBlock) {\n          haveBlock = true;\n        }\n\n        if (existing.data.isWantBlock) {\n          isWantBlock = true;\n        }\n      } // If there is no active want-block and the new task is a want-block,\n      // the new task is better\n\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    if (!isWantBlock && task.data.isWantBlock) {\n      return true;\n    } // If we didn't have the block, and the new task indicates that we now\n    // do have the block, then we must also have size information for the\n    // block, so the new task has new information.\n\n\n    if (!haveBlock && task.data.haveBlock) {\n      return true;\n    }\n\n    return false;\n  },\n\n  /**\n   * Merge the information from the task into the existing pending task\n   * @param {Task} newTask\n   * @param {Task} existingTask\n   */\n  merge: function merge(newTask, existingTask) {\n    // Tasks look like this:\n    // {\n    //   topic: \"some topic\",\n    //   priority: 5,\n    //\n    //   # The size of the response on the wire. This is used to calculate\n    //   # how many tasks to pop off the request queue and add to a message.\n    //   # If the response is\n    //   # - a HAVE or DONT_HAVE\n    //   #   it is the size of the CID + type (HAVE/DONT_HAVE)\n    //   # - a block\n    //   #   it is the size of the block\n    //   size: 32,\n    //\n    //   data: {\n    //\n    //     # The size of the block, if known (if we don't have the block this is zero)\n    //     blockSize: 128 * 1024,\n    //\n    //     # Indicates if the request is for a block or for a HAVE\n    //     isWantBlock: false,\n    //\n    //     # Do we have the block?\n    //     # Note: a block can have size zero.\n    //     haveBlock: true,\n    //\n    //     # Indicates whether to send a DONT_HAVE response if we don't have\n    //     # the block.\n    //     # If this is false and we don't have the block, we just ignore the\n    //     # want-block request (useful for discovery where we query lots of\n    //     # peers but don't want a response unless the peer has the block).\n    //     sendDontHave: false\n    //   }\n    // }\n    //\n    // The merge function ignores the topic and priority as these don't change.\n    //\n    // We may receive new information about a want before the want has been\n    // popped from the queue in the following scenarios:\n    //\n    // - Replace want type:\n    //   1. Client sends want-have CID1\n    //   2. Client sends want-block CID1\n    //   In this case we should replace want-have with want-block, including\n    //   updating the task size to be the block size.\n    //\n    // - Replace DONT_HAVE with want:\n    //   1. Client sends want-have CID1 or want-block CID1\n    //   2. Local node doesn't have block for CID1\n    //   3. Local node receives block for CID1 from peer\n    //   In this case we should replace DONT_HAVE with the want, including\n    //   updating the task size and block size.\n    //\n    var taskData = newTask.data;\n    var existingData = existingTask.data; // If we didn't have block size information (because we didn't have the\n    // block) and we receive the block from a peer, update the task with the\n    // new block size\n\n    if (!existingData.haveBlock && taskData.haveBlock) {\n      existingData.haveBlock = taskData.haveBlock;\n      existingData.blockSize = taskData.blockSize;\n    } // If replacing a want-have with a want-block\n\n\n    if (!existingData.isWantBlock && taskData.isWantBlock) {\n      // Change the type from want-have to want-block\n      existingData.isWantBlock = true; // If the want-have was a DONT_HAVE, or the want-block has a size\n\n      if (!existingData.haveBlock || taskData.haveBlock) {\n        // Update the entry size\n        existingData.haveBlock = taskData.haveBlock;\n        existingTask.size = newTask.size;\n      }\n    } // If the task is a want-block, make sure the entry size is equal\n    // to the block size (because we will send the whole block)\n\n\n    if (existingData.isWantBlock && existingData.haveBlock) {\n      existingTask.size = existingData.blockSize;\n    }\n  }\n};\nmodule.exports = TaskMerger;","map":null,"metadata":{},"sourceType":"script"}