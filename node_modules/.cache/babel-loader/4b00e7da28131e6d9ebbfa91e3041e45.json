{"ast":null,"code":"'use strict';\n\nconst ipns = require('ipns');\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst {\n  fromB58String,\n  toB58String\n} = require('multihashes');\n\nconst PubsubDatastore = require('datastore-pubsub');\n\nconst withIs = require('class-is');\n\nconst errcode = require('err-code');\n\nconst debug = require('debug');\n\nconst log = debug('ipfs:ipns:pubsub');\nlog.error = debug('ipfs:ipns:pubsub:error'); // Pubsub datastore aims to manage the pubsub subscriptions for IPNS\n\nclass IpnsPubsubDatastore {\n  constructor(pubsub, localDatastore, peerId) {\n    this._pubsub = pubsub;\n    this._subscriptions = {}; // Bind _handleSubscriptionKey function, which is called by PubsubDatastore.\n\n    this._handleSubscriptionKey = this._handleSubscriptionKey.bind(this);\n    this._pubsubDs = new PubsubDatastore(pubsub, localDatastore, peerId, ipns.validator, this._handleSubscriptionKey);\n  }\n  /**\n   * Put a value to the pubsub datastore indexed by the received key properly encoded.\n   * @param {Buffer} key identifier of the value.\n   * @param {Buffer} value value to be stored.\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n\n\n  async put(key, value) {\n    // eslint-disable-line require-await\n    return this._pubsubDs.put(key, value);\n  }\n  /**\n   * Get a value from the pubsub datastore indexed by the received key properly encoded.\n   * Also, the identifier topic is subscribed to and the pubsub datastore records will be\n   * updated once new publishes occur.\n   * @param {Buffer} key identifier of the value to be obtained.\n   * @param {function(Error, Buffer)} callback\n   * @returns {void}\n   */\n\n\n  async get(key) {\n    let res;\n    let err;\n\n    try {\n      res = await this._pubsubDs.get(key);\n    } catch (e) {\n      err = e;\n    } // Add topic subscribed\n\n\n    const ns = key.slice(0, ipns.namespaceLength);\n\n    if (ns.toString() === ipns.namespace) {\n      const stringifiedTopic = toB58String(key);\n      const id = toB58String(key.slice(ipns.namespaceLength));\n      this._subscriptions[stringifiedTopic] = id;\n      log(`subscribed to pubsub topic ${stringifiedTopic}, id ${id}`);\n    } // If no data was obtained, after storing the subscription, return the error.\n\n\n    if (err) {\n      throw err;\n    }\n\n    return res;\n  } // Modify subscription key to have a proper encoding\n\n\n  _handleSubscriptionKey(key) {\n    if (Buffer.isBuffer(key)) {\n      key = toB58String(key);\n    }\n\n    const subscriber = this._subscriptions[key];\n\n    if (!subscriber) {\n      throw errcode(new Error(`key ${key} does not correspond to a subscription`), 'ERR_INVALID_KEY');\n    }\n\n    let keys;\n\n    try {\n      keys = ipns.getIdKeys(fromB58String(subscriber));\n    } catch (err) {\n      log.error(err);\n      throw err;\n    }\n\n    return keys.routingKey.toBuffer();\n  }\n  /**\n   * Get pubsub subscriptions related to ipns.\n   * @param {function(Error, Object)} callback\n   * @returns {Array<Object>}\n   */\n\n\n  getSubscriptions() {\n    const subscriptions = Object.values(this._subscriptions).filter(Boolean);\n    return subscriptions.map(sub => `${ipns.namespace}${sub}`);\n  }\n  /**\n   * Cancel pubsub subscriptions related to ipns.\n   * @param {String} name ipns path to cancel the pubsub subscription.\n   * @param {function(Error, Object)} callback\n   * @returns {void}\n   */\n\n\n  async cancel(name) {\n    // eslint-disable-line require-await\n    if (typeof name !== 'string') {\n      throw errcode(new Error('invalid subscription name'), 'ERR_INVALID_SUBSCRIPTION_NAME');\n    } // Trim /ipns/ prefix from the name\n\n\n    if (name.startsWith(ipns.namespace)) {\n      name = name.substring(ipns.namespaceLength);\n    }\n\n    const stringifiedTopic = Object.keys(this._subscriptions).find(key => this._subscriptions[key] === name); // Not found topic\n\n    if (!stringifiedTopic) {\n      return {\n        canceled: false\n      };\n    } // Unsubscribe topic\n\n\n    const bufTopic = Buffer.from(stringifiedTopic);\n\n    this._pubsubDs.unsubscribe(bufTopic);\n\n    this._subscriptions[stringifiedTopic] = undefined;\n    log(`unsubscribed pubsub ${stringifiedTopic}: ${name}`);\n    return {\n      canceled: true\n    };\n  }\n\n}\n\nexports = module.exports = withIs(IpnsPubsubDatastore, {\n  className: 'IpnsPubsubDatastore',\n  symbolName: '@js-ipfs/ipns/IpnsPubsubDatastore'\n});","map":null,"metadata":{},"sourceType":"script"}