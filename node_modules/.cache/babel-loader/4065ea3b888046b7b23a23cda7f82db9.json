{"ast":null,"code":"/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict';\n\nconst {\n  DAGNode,\n  DAGLink\n} = require('ipld-dag-pb');\n\nconst CID = require('cids');\n\nconst {\n  default: Queue\n} = require('p-queue');\n\nconst {\n  Key\n} = require('interface-datastore');\n\nconst errCode = require('err-code');\n\nconst multicodec = require('multicodec');\n\nconst dagCborLinks = require('dag-cbor-links');\n\nconst debug = require('debug');\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst {\n  cidToString\n} = require('../../../utils/cid');\n\nconst createPinSet = require('./pin-set');\n\nconst {\n  Errors\n} = require('interface-datastore');\n\nconst ERR_NOT_FOUND = Errors.notFoundError().code; // arbitrary limit to the number of concurrent dag operations\n\nconst WALK_DAG_CONCURRENCY_LIMIT = 300;\nconst IS_PINNED_WITH_TYPE_CONCURRENCY_LIMIT = 300;\nconst PIN_DS_KEY = new Key('/local/pins');\n\nfunction invalidPinTypeErr(type) {\n  const errMsg = `Invalid type '${type}', must be one of {direct, indirect, recursive, all}`;\n  return errCode(new Error(errMsg), 'ERR_INVALID_PIN_TYPE');\n}\n\nconst PinTypes = {\n  direct: 'direct',\n  recursive: 'recursive',\n  indirect: 'indirect',\n  all: 'all'\n};\n\nclass PinManager {\n  constructor(repo, dag) {\n    this.repo = repo;\n    this.dag = dag;\n    this.log = debug('ipfs:pin');\n    this.pinset = createPinSet(dag);\n    this.directPins = new Set();\n    this.recursivePins = new Set();\n  }\n\n  async _walkDag({\n    cid,\n    preload = false,\n    onCid = () => {}\n  }) {\n    if (!CID.isCID(cid)) {\n      cid = new CID(cid);\n    }\n\n    const walk = cid => {\n      return async () => {\n        const {\n          value: node\n        } = await this.dag.get(cid, {\n          preload\n        });\n        onCid(cid);\n\n        if (cid.codec === 'dag-pb') {\n          queue.addAll(node.Links.map(link => walk(link.Hash)));\n        } else if (cid.codec === 'dag-cbor') {\n          for (const [_, childCid] of dagCborLinks(node)) {\n            // eslint-disable-line no-unused-vars\n            queue.add(walk(childCid));\n          }\n        }\n      };\n    };\n\n    const queue = new Queue({\n      concurrency: WALK_DAG_CONCURRENCY_LIMIT\n    });\n    queue.add(walk(cid));\n    await queue.onIdle();\n  }\n\n  directKeys() {\n    return Array.from(this.directPins, key => new CID(key).buffer);\n  }\n\n  recursiveKeys() {\n    return Array.from(this.recursivePins, key => new CID(key).buffer);\n  }\n\n  async getIndirectKeys({\n    preload\n  }) {\n    const indirectKeys = new Set();\n\n    for (const multihash of this.recursiveKeys()) {\n      await this._walkDag({\n        cid: new CID(multihash),\n        preload: preload || false,\n        onCid: cid => {\n          cid = cid.toString(); // recursive pins pre-empt indirect pins\n\n          if (!this.recursivePins.has(cid)) {\n            indirectKeys.add(cid);\n          }\n        }\n      });\n    }\n\n    return Array.from(indirectKeys);\n  } // Encode and write pin key sets to the datastore:\n  // a DAGLink for each of the recursive and direct pinsets\n  // a DAGNode holding those as DAGLinks, a kind of root pin\n\n\n  async flushPins() {\n    const [dLink, rLink] = await Promise.all([// create a DAGLink to the node with direct pins\n    this.pinset.storeSet(this.directKeys()).then(result => {\n      return new DAGLink(PinTypes.direct, result.node.size, result.cid);\n    }), // create a DAGLink to the node with recursive pins\n    this.pinset.storeSet(this.recursiveKeys()).then(result => {\n      return new DAGLink(PinTypes.recursive, result.node.size, result.cid);\n    }), // the pin-set nodes link to a special 'empty' node, so make sure it exists\n    this.dag.put(new DAGNode(Buffer.alloc(0)), {\n      version: 0,\n      format: multicodec.DAG_PB,\n      hashAlg: multicodec.SHA2_256,\n      preload: false\n    })]); // create a root node with DAGLinks to the direct and recursive DAGs\n\n    const rootNode = new DAGNode(Buffer.alloc(0), [dLink, rLink]);\n    const rootCid = await this.dag.put(rootNode, {\n      version: 0,\n      format: multicodec.DAG_PB,\n      hashAlg: multicodec.SHA2_256,\n      preload: false\n    }); // save root to datastore under a consistent key\n\n    await this.repo.datastore.put(PIN_DS_KEY, rootCid.buffer);\n    this.log(`Flushed pins with root: ${rootCid}`);\n  }\n\n  async load() {\n    const has = await this.repo.datastore.has(PIN_DS_KEY);\n\n    if (!has) {\n      return;\n    }\n\n    const mh = await this.repo.datastore.get(PIN_DS_KEY);\n    const pinRoot = await this.dag.get(new CID(mh), '', {\n      preload: false\n    });\n    const [rKeys, dKeys] = await Promise.all([this.pinset.loadSet(pinRoot.value, PinTypes.recursive), this.pinset.loadSet(pinRoot.value, PinTypes.direct)]);\n    this.directPins = new Set(dKeys.map(k => cidToString(k)));\n    this.recursivePins = new Set(rKeys.map(k => cidToString(k)));\n    this.log('Loaded pins from the datastore');\n  }\n\n  async isPinnedWithType(multihash, type) {\n    const key = cidToString(multihash);\n    const {\n      recursive,\n      direct,\n      all\n    } = PinTypes; // recursive\n\n    if ((type === recursive || type === all) && this.recursivePins.has(key)) {\n      return {\n        key,\n        pinned: true,\n        reason: recursive\n      };\n    }\n\n    if (type === recursive) {\n      return {\n        key,\n        pinned: false\n      };\n    } // direct\n\n\n    if ((type === direct || type === all) && this.directPins.has(key)) {\n      return {\n        key,\n        pinned: true,\n        reason: direct\n      };\n    }\n\n    if (type === direct) {\n      return {\n        key,\n        pinned: false\n      };\n    } // indirect (default)\n    // check each recursive key to see if multihash is under it\n    // arbitrary limit, enables handling 1000s of pins.\n\n\n    const queue = new Queue({\n      concurrency: IS_PINNED_WITH_TYPE_CONCURRENCY_LIMIT\n    });\n    let cid;\n    queue.addAll(this.recursiveKeys().map(childKey => {\n      childKey = new CID(childKey);\n      return async () => {\n        const has = await this.pinset.hasDescendant(childKey, key);\n\n        if (has) {\n          cid = childKey;\n          queue.clear();\n        }\n      };\n    }));\n    await queue.onIdle();\n    return {\n      key,\n      pinned: Boolean(cid),\n      reason: cid\n    };\n  } // Gets CIDs of blocks used internally by the pinner\n\n\n  async getInternalBlocks() {\n    let mh;\n\n    try {\n      mh = await this.repo.datastore.get(PIN_DS_KEY);\n    } catch (err) {\n      if (err.code === ERR_NOT_FOUND) {\n        this.log('No pinned blocks');\n        return [];\n      }\n\n      throw new Error(`Could not get pin sets root from datastore: ${err.message}`);\n    }\n\n    const cid = new CID(mh);\n    const obj = await this.dag.get(cid, '', {\n      preload: false\n    }); // The pinner stores an object that has two links to pin sets:\n    // 1. The directly pinned CIDs\n    // 2. The recursively pinned CIDs\n    // If large enough, these pin sets may have links to buckets to hold\n    // the pins\n\n    const cids = await this.pinset.getInternalCids(obj.value);\n    return cids.concat(cid);\n  }\n\n  async fetchCompleteDag(cid, options) {\n    await this._walkDag({\n      cid,\n      preload: options.preload\n    });\n  } // Returns an error if the pin type is invalid\n\n\n  static checkPinType(type) {\n    if (typeof type !== 'string' || !Object.keys(PinTypes).includes(type)) {\n      return invalidPinTypeErr(type);\n    }\n  }\n\n}\n\nPinManager.PinTypes = PinTypes;\nmodule.exports = PinManager;","map":null,"metadata":{},"sourceType":"script"}