{"ast":null,"code":"const pageResults = require('graph-results-pager');\n\nconst ws = require('isomorphic-ws');\n\nconst {\n  SubscriptionClient\n} = require('subscriptions-transport-ws');\n\nconst {\n  request,\n  gql\n} = require('graphql-request');\n\nconst {\n  graphAPIEndpoints,\n  graphWSEndpoints,\n  makerAddress\n} = require('./../constants');\n\nconst {\n  timestampToBlock\n} = require('./../utils');\n\nmodule.exports = {\n  async info({\n    block = undefined,\n    timestamp = undefined\n  } = {}) {\n    block = block ? block : timestamp ? await timestampToBlock(timestamp) : undefined;\n    block = block ? `block: { number: ${block} }` : \"\";\n    const result = await request(graphAPIEndpoints.maker, gql`{\n                    makers(first: 1, ${block}) {\n                        ${info.properties.toString()}\n                    }\n                }`);\n    return info.callback(result.makers[0]);\n  },\n\n  servings({\n    minTimestamp = undefined,\n    maxTimestamp = undefined,\n    minBlock = undefined,\n    maxBlock = undefined,\n    max = undefined\n  } = {}) {\n    return pageResults({\n      api: graphAPIEndpoints.maker,\n      query: {\n        entity: 'servings',\n        selection: {\n          where: {\n            block_gte: minBlock || undefined,\n            block_lte: maxBlock || undefined,\n            timestamp_gte: minTimestamp || undefined,\n            timestamp_lte: maxTimestamp || undefined\n          }\n        },\n        properties: servings.properties\n      },\n      max\n    }).then(results => servings.callback(results)).catch(err => console.log(err));\n  },\n\n  async servers({\n    block = undefined,\n    timestamp = undefined,\n    max = undefined\n  } = {}) {\n    return pageResults({\n      api: graphAPIEndpoints.maker,\n      query: {\n        entity: 'servers',\n        block: block ? {\n          number: block\n        } : timestamp ? {\n          number: await timestampToBlock(timestamp)\n        } : undefined,\n        properties: servers.properties\n      },\n      max\n    }).then(results => servers.callback(results)).catch(err => console.log(err));\n  },\n\n  async pendingServings({\n    block = undefined,\n    timestamp = undefined,\n    max = undefined\n  } = {}) {\n    return pageResults({\n      api: graphAPIEndpoints.exchange,\n      query: {\n        entity: 'users',\n        selection: {\n          where: {\n            id: `\\\\\"${makerAddress}\\\\\"`\n          }\n        },\n        block: block ? {\n          number: block\n        } : timestamp ? {\n          number: await timestampToBlock(timestamp)\n        } : undefined,\n        properties: pendingServings.properties\n      },\n      max\n    }).then(results => pendingServings.callback(results)).catch(err => console.log(err));\n  },\n\n  observePendingServings() {\n    const query = gql`\n            subscription {\n                users(first: 1000, where: {id: \"${makerAddress}\"}) {\n                    ${pendingServings.properties.toString()}\n                }\n        }`;\n    const client = new SubscriptionClient(graphWSEndpoints.exchange, {\n      reconnect: true\n    }, ws);\n    const observable = client.request({\n      query\n    });\n    return {\n      subscribe({\n        next,\n        error,\n        complete\n      }) {\n        return observable.subscribe({\n          next(results) {\n            next(pendingServings.callback(results.data.users));\n          },\n\n          error,\n          complete\n        });\n      }\n\n    };\n  }\n\n};\nconst info = {\n  properties: ['id', 'sushiServed'],\n\n  callback(results) {\n    return {\n      address: results.id,\n      sushiServed: Number(results.sushiServed)\n    };\n  }\n\n};\nconst servings = {\n  properties: ['server { id }', 'tx', 'pair', 'token0', 'token1', 'sushiServed', 'block', 'timestamp'],\n\n  callback(results) {\n    return results.map(({\n      server,\n      tx,\n      pair,\n      token0,\n      token1,\n      sushiServed,\n      block,\n      timestamp\n    }) => ({\n      serverAddress: server.id,\n      tx: tx,\n      pair: pair,\n      token0: token0,\n      token1: token1,\n      sushiServed: Number(sushiServed),\n      block: Number(block),\n      timestamp: Number(timestamp * 1000),\n      date: new Date(timestamp * 1000)\n    }));\n  }\n\n};\nconst servers = {\n  properties: ['id', 'sushiServed', 'servings(first: 1000, orderBy: block, orderDirection: desc) { tx, block, pair, sushiServed }'],\n\n  callback(results) {\n    return results.map(({\n      id,\n      sushiServed,\n      servings\n    }) => ({\n      serverAddress: id,\n      sushiServed: Number(sushiServed),\n      servings: servings.map(({\n        tx,\n        block,\n        pair,\n        sushiServed\n      }) => ({\n        tx,\n        block: Number(block),\n        pair,\n        sushiServed: Number(sushiServed)\n      }))\n    }));\n  }\n\n};\nconst pendingServings = {\n  properties: ['liquidityPositions(first: 1000) { id, liquidityTokenBalance, pair { id, totalSupply, reserveUSD, token0 { id, name, symbol }, token1 { id, symbol, name } } }'],\n\n  callback(results) {\n    return results[0].liquidityPositions.map(({\n      liquidityTokenBalance,\n      pair\n    }) => ({\n      address: pair.id,\n      token0: pair.token0,\n      token1: pair.token1,\n      valueUSD: liquidityTokenBalance / pair.totalSupply * pair.reserveUSD\n    })).sort((a, b) => b.valueUSD - a.valueUSD);\n  }\n\n};","map":null,"metadata":{},"sourceType":"script"}