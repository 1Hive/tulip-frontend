{"ast":null,"code":"import { Buffer } from \"buffer\";\nimport AEAD from 'bcrypto/lib/js/aead';\nimport x25519 from 'bcrypto/lib/js/x25519';\nimport SHA256 from 'bcrypto/lib/js/sha256';\nimport { getHkdf } from \"../utils\";\nimport { logger } from \"../logger\";\nexport const MIN_NONCE = 0;\nexport class AbstractHandshake {\n  encryptWithAd(cs, ad, plaintext) {\n    const e = this.encrypt(cs.k, cs.n, ad, plaintext);\n    this.setNonce(cs, this.incrementNonce(cs.n));\n    return e;\n  }\n\n  decryptWithAd(cs, ad, ciphertext) {\n    const {\n      plaintext,\n      valid\n    } = this.decrypt(cs.k, cs.n, ad, ciphertext);\n    this.setNonce(cs, this.incrementNonce(cs.n));\n    return {\n      plaintext,\n      valid\n    };\n  } // Cipher state related\n\n\n  hasKey(cs) {\n    return !this.isEmptyKey(cs.k);\n  }\n\n  setNonce(cs, nonce) {\n    cs.n = nonce;\n  }\n\n  createEmptyKey() {\n    return Buffer.alloc(32);\n  }\n\n  isEmptyKey(k) {\n    const emptyKey = this.createEmptyKey();\n    return emptyKey.equals(k);\n  }\n\n  incrementNonce(n) {\n    return n + 1;\n  }\n\n  nonceToBytes(n) {\n    const nonce = Buffer.alloc(12);\n    nonce.writeUInt32LE(n, 4);\n    return nonce;\n  }\n\n  encrypt(k, n, ad, plaintext) {\n    const nonce = this.nonceToBytes(n);\n    const ctx = new AEAD();\n    plaintext = Buffer.from(plaintext);\n    ctx.init(k, nonce);\n    ctx.aad(ad);\n    ctx.encrypt(plaintext); // Encryption is done on the sent reference\n\n    return Buffer.concat([plaintext, ctx.final()]);\n  }\n\n  encryptAndHash(ss, plaintext) {\n    let ciphertext;\n\n    if (this.hasKey(ss.cs)) {\n      ciphertext = this.encryptWithAd(ss.cs, ss.h, plaintext);\n    } else {\n      ciphertext = plaintext;\n    }\n\n    this.mixHash(ss, ciphertext);\n    return ciphertext;\n  }\n\n  decrypt(k, n, ad, ciphertext) {\n    const nonce = this.nonceToBytes(n);\n    const ctx = new AEAD();\n    ciphertext = Buffer.from(ciphertext);\n    const tag = ciphertext.slice(ciphertext.length - 16);\n    ciphertext = ciphertext.slice(0, ciphertext.length - 16);\n    ctx.init(k, nonce);\n    ctx.aad(ad);\n    ctx.decrypt(ciphertext); // Decryption is done on the sent reference\n\n    return {\n      plaintext: ciphertext,\n      valid: ctx.verify(tag)\n    };\n  }\n\n  decryptAndHash(ss, ciphertext) {\n    let plaintext,\n        valid = true;\n\n    if (this.hasKey(ss.cs)) {\n      ({\n        plaintext,\n        valid\n      } = this.decryptWithAd(ss.cs, ss.h, ciphertext));\n    } else {\n      plaintext = ciphertext;\n    }\n\n    this.mixHash(ss, ciphertext);\n    return {\n      plaintext,\n      valid\n    };\n  }\n\n  dh(privateKey, publicKey) {\n    try {\n      const derived = x25519.derive(publicKey, privateKey);\n      const result = Buffer.alloc(32);\n      derived.copy(result);\n      return result;\n    } catch (e) {\n      logger(e.message);\n      return Buffer.alloc(32);\n    }\n  }\n\n  mixHash(ss, data) {\n    ss.h = this.getHash(ss.h, data);\n  }\n\n  getHash(a, b) {\n    return SHA256.digest(Buffer.from([...a, ...b]));\n  }\n\n  mixKey(ss, ikm) {\n    const [ck, tempK] = getHkdf(ss.ck, ikm);\n    ss.cs = this.initializeKey(tempK);\n    ss.ck = ck;\n  }\n\n  initializeKey(k) {\n    const n = MIN_NONCE;\n    return {\n      k,\n      n\n    };\n  } // Symmetric state related\n\n\n  initializeSymmetric(protocolName) {\n    const protocolNameBytes = Buffer.from(protocolName, 'utf-8');\n    const h = this.hashProtocolName(protocolNameBytes);\n    const ck = h;\n    const key = this.createEmptyKey();\n    const cs = this.initializeKey(key);\n    return {\n      cs,\n      ck,\n      h\n    };\n  }\n\n  hashProtocolName(protocolName) {\n    if (protocolName.length <= 32) {\n      const h = Buffer.alloc(32);\n      protocolName.copy(h);\n      return h;\n    } else {\n      return this.getHash(protocolName, Buffer.alloc(0));\n    }\n  }\n\n  split(ss) {\n    const [tempk1, tempk2] = getHkdf(ss.ck, Buffer.alloc(0));\n    const cs1 = this.initializeKey(tempk1);\n    const cs2 = this.initializeKey(tempk2);\n    return {\n      cs1,\n      cs2\n    };\n  }\n\n  writeMessageRegular(cs, payload) {\n    const ciphertext = this.encryptWithAd(cs, Buffer.alloc(0), payload);\n    const ne = this.createEmptyKey();\n    const ns = Buffer.alloc(0);\n    return {\n      ne,\n      ns,\n      ciphertext\n    };\n  }\n\n  readMessageRegular(cs, message) {\n    return this.decryptWithAd(cs, Buffer.alloc(0), message.ciphertext);\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}