{"ast":null,"code":"/*!\n * ecdh.js - ECDH for bcrypto\n * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Resources:\n *   https://cr.yp.to/ecdh.html\n *   https://cr.yp.to/ecdh/curve25519-20060209.pdf\n *   https://tools.ietf.org/html/rfc7748\n */\n'use strict';\n\nconst assert = require('../internal/assert');\n\nconst elliptic = require('./elliptic');\n\nconst rng = require('../random');\n\nconst {\n  padRight\n} = require('../encoding/util');\n/**\n * ECDH\n */\n\n\nclass ECDH {\n  constructor(id, eid, pre) {\n    assert(typeof id === 'string');\n    assert(!eid || typeof eid === 'string');\n    this.id = id;\n    this.type = 'ecdh';\n    this.eid = eid || null;\n    this._pre = pre || null;\n    this._curve = null;\n    this._edwards = null;\n    this.native = 0;\n  }\n\n  get curve() {\n    if (!this._curve) this._curve = elliptic.curve(this.id);\n    return this._curve;\n  }\n\n  get edwards() {\n    if (this.eid && !this._edwards) {\n      this._edwards = elliptic.curve(this.eid, this._pre);\n\n      this._edwards.precompute(rng);\n\n      this._pre = null;\n    }\n\n    return this._edwards;\n  }\n\n  get size() {\n    return this.curve.fieldSize;\n  }\n\n  get bits() {\n    return this.curve.fieldBits;\n  }\n\n  privateKeyGenerate() {\n    const key = rng.randomBytes(this.curve.scalarSize);\n    return this.curve.clamp(key);\n  }\n\n  privateKeyVerify(key) {\n    assert(Buffer.isBuffer(key));\n    return key.length === this.curve.scalarSize;\n  }\n\n  privateKeyExport(key, sign) {\n    const pub = this.publicKeyCreate(key);\n    const {\n      x,\n      y\n    } = this.publicKeyExport(pub, sign);\n    return {\n      d: Buffer.from(key),\n      x,\n      y\n    };\n  }\n\n  privateKeyImport(json) {\n    assert(json && typeof json === 'object');\n    return padRight(json.d, this.curve.scalarSize);\n  }\n\n  publicKeyCreate(key) {\n    const a = this.curve.decodeScalar(key);\n    const k = this.curve.reduce(a);\n\n    if (this.edwards && this.edwards.g.pre) {\n      const A = this.edwards.g.mulBlind(k);\n      const P = this.curve.pointFromEdwards(A);\n      return P.encode();\n    }\n\n    const G = this.curve.g.toX();\n    const A = G.mulBlind(k, rng);\n    return A.encode();\n  }\n\n  publicKeyConvert(key, sign) {\n    assert(sign == null || typeof sign === 'boolean');\n    if (!this.edwards) throw new Error('No equivalent edwards curve.');\n    const A = this.curve.decodePoint(key);\n    const P = this.edwards.pointFromMont(A);\n\n    if (sign != null) {\n      if (P.isOdd() !== sign) return P.neg().encode();\n    }\n\n    return P.encode();\n  }\n\n  publicKeyFromUniform(bytes) {\n    const u = this.curve.decodeUniform(bytes);\n    const A = this.curve.pointFromUniform(u);\n    return A.encode();\n  }\n\n  publicKeyToUniform(key, hint = rng.randomInt()) {\n    const A = this.curve.decodePoint(key);\n    const u = this.curve.pointToUniform(A, hint);\n    return this.curve.encodeUniform(u, hint >>> 8);\n  }\n\n  publicKeyFromHash(bytes, pake = false) {\n    const A = this.curve.pointFromHash(bytes, pake);\n    return A.encode();\n  }\n\n  publicKeyToHash(key, subgroup = rng.randomInt()) {\n    const A = this.curve.decodePoint(key);\n    return this.curve.pointToHash(A, subgroup, rng);\n  }\n\n  publicKeyVerify(key) {\n    assert(Buffer.isBuffer(key));\n    let A;\n\n    try {\n      A = this.curve.decodeX(key);\n    } catch (e) {\n      return false;\n    }\n\n    return A.validate();\n  }\n\n  publicKeyIsSmall(key) {\n    assert(Buffer.isBuffer(key));\n    let A;\n\n    try {\n      A = this.curve.decodeX(key);\n    } catch (e) {\n      return false;\n    }\n\n    if (!A.validate()) return false;\n    return A.isSmall();\n  }\n\n  publicKeyHasTorsion(key) {\n    assert(Buffer.isBuffer(key));\n    let A;\n\n    try {\n      A = this.curve.decodeX(key);\n    } catch (e) {\n      return false;\n    }\n\n    if (!A.validate()) return false;\n    return A.hasTorsion();\n  }\n\n  publicKeyExport(key, sign) {\n    const {\n      x,\n      y\n    } = this.curve.decodePoint(key, sign);\n    return {\n      x: this.curve.encodeField(x.fromRed()),\n      y: this.curve.encodeField(y.fromRed())\n    };\n  }\n\n  publicKeyImport(json) {\n    assert(json && typeof json === 'object');\n    const x = padRight(json.x, this.curve.fieldSize);\n    const A = this.curve.decodeX(x);\n    if (!A.validate()) throw new Error('Invalid point.');\n    return A.encode();\n  }\n\n  derive(pub, priv) {\n    const A = this.curve.decodeX(pub);\n    const a = this.curve.decodeScalar(priv);\n    const k = this.curve.reduce(a);\n    const P = A.mulConst(k, rng);\n    return P.encode();\n  }\n\n}\n/*\n * Expose\n */\n\n\nmodule.exports = ECDH;","map":null,"metadata":{},"sourceType":"script"}