{"ast":null,"code":"import { nanoid } from 'nanoid';\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nvar _ERROR_MESSAGE;\n\nvar ERROR_CODE;\n\n(function (ERROR_CODE) {\n  ERROR_CODE[ERROR_CODE[\"PARSE_ERROR\"] = -32700] = \"PARSE_ERROR\";\n  ERROR_CODE[ERROR_CODE[\"INVALID_REQUEST\"] = -32600] = \"INVALID_REQUEST\";\n  ERROR_CODE[ERROR_CODE[\"METHOD_NOT_FOUND\"] = -32601] = \"METHOD_NOT_FOUND\";\n  ERROR_CODE[ERROR_CODE[\"INVALID_PARAMS\"] = -32602] = \"INVALID_PARAMS\";\n  ERROR_CODE[ERROR_CODE[\"INTERNAL_ERROR\"] = -32603] = \"INTERNAL_ERROR\";\n})(ERROR_CODE || (ERROR_CODE = {}));\n\nvar ERROR_MESSAGE = (_ERROR_MESSAGE = {}, _ERROR_MESSAGE[ERROR_CODE.PARSE_ERROR] = 'Parse error', _ERROR_MESSAGE[ERROR_CODE.INVALID_REQUEST] = 'Invalid request', _ERROR_MESSAGE[ERROR_CODE.METHOD_NOT_FOUND] = 'Method not found', _ERROR_MESSAGE[ERROR_CODE.INVALID_PARAMS] = 'Invalid params', _ERROR_MESSAGE[ERROR_CODE.INTERNAL_ERROR] = 'Internal error', _ERROR_MESSAGE);\n\nfunction isServerError(code) {\n  return -32000 >= code && code >= -32099;\n}\n\nfunction getErrorMessage(code) {\n  var _ERROR_MESSAGE$code$t;\n\n  return (_ERROR_MESSAGE$code$t = ERROR_MESSAGE[code.toString()]) !== null && _ERROR_MESSAGE$code$t !== void 0 ? _ERROR_MESSAGE$code$t : isServerError(code) ? 'Server error' : 'Application error';\n}\n\nvar RPCError = /*#__PURE__*/function (_Error) {\n  _inheritsLoose(RPCError, _Error);\n\n  function RPCError(code, message, data) {\n    var _this;\n\n    _this = _Error.call(this) || this;\n    Object.setPrototypeOf(_assertThisInitialized(_this), RPCError.prototype);\n    _this.code = code;\n    _this.data = data;\n    _this.message = message !== null && message !== void 0 ? message : getErrorMessage(code);\n    return _this;\n  }\n\n  RPCError.fromObject = function fromObject(err) {\n    return new RPCError(err.code, err.message, err.data);\n  };\n\n  var _proto = RPCError.prototype;\n\n  _proto.toObject = function toObject() {\n    return {\n      code: this.code,\n      data: this.data,\n      message: this.message\n    };\n  };\n\n  return RPCError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nfunction createErrorFactory(code) {\n  var message = ERROR_MESSAGE[code];\n  return function createError(data) {\n    return new RPCError(code, message, data);\n  };\n}\n\nvar createParseError = /*#__PURE__*/createErrorFactory(ERROR_CODE.PARSE_ERROR);\nvar createInvalidRequest = /*#__PURE__*/createErrorFactory(ERROR_CODE.INVALID_REQUEST);\nvar createMethodNotFound = /*#__PURE__*/createErrorFactory(ERROR_CODE.METHOD_NOT_FOUND);\nvar createInvalidParams = /*#__PURE__*/createErrorFactory(ERROR_CODE.INVALID_PARAMS);\nvar createInternalError = /*#__PURE__*/createErrorFactory(ERROR_CODE.INTERNAL_ERROR);\n\nvar RPCClient = /*#__PURE__*/function () {\n  function RPCClient(connection) {\n    this.connection = connection;\n  }\n\n  var _proto = RPCClient.prototype;\n\n  _proto.createID = function createID() {\n    return nanoid();\n  };\n\n  _proto.request = function request(method, params) {\n    try {\n      var _this2 = this;\n\n      return Promise.resolve(_this2.connection.send({\n        jsonrpc: '2.0',\n        id: _this2.createID(),\n        method: method,\n        params: params\n      })).then(function (res) {\n        if (res == null) {\n          throw new Error('Missing response');\n        }\n\n        if (res.error != null) {\n          throw RPCError.fromObject(res.error);\n        }\n\n        return res.result;\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  return RPCClient;\n}(); // A type of promise-like that resolves synchronously and supports only one observer\n\n\nvar _iteratorSymbol = /*#__PURE__*/typeof Symbol !== \"undefined\" ? Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\")) : \"@@iterator\";\n\nvar _asyncIteratorSymbol = /*#__PURE__*/typeof Symbol !== \"undefined\" ? Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\")) : \"@@asyncIterator\"; // Asynchronously call a function and send errors to recovery continuation\n\n\nfunction _catch(body, recover) {\n  try {\n    var result = body();\n  } catch (e) {\n    return recover(e);\n  }\n\n  if (result && result.then) {\n    return result.then(void 0, recover);\n  }\n\n  return result;\n}\n\nfunction parseJSON(input) {\n  try {\n    return JSON.parse(input);\n  } catch (err) {\n    throw createParseError();\n  }\n}\n\nfunction createErrorResponse(id, code) {\n  return {\n    jsonrpc: '2.0',\n    id: id,\n    error: {\n      code: code,\n      message: getErrorMessage(code)\n    }\n  };\n}\n\nfunction fallbackOnHandlerError(_ctx, msg, error) {\n  // eslint-disable-next-line no-console\n  console.warn('Unhandled handler error', msg, error);\n}\n\nfunction fallbackOnInvalidMessage(_ctx, msg) {\n  // eslint-disable-next-line no-console\n  console.warn('Unhandled invalid message', msg);\n}\n\nfunction fallbackOnNotification(_ctx, msg) {\n  // eslint-disable-next-line no-console\n  console.warn('Unhandled notification', msg);\n}\n\nfunction createHandler(methods, options) {\n  var _options$onHandlerErr, _options$onInvalidMes, _options$onNotificati;\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  var onHandlerError = (_options$onHandlerErr = options.onHandlerError) !== null && _options$onHandlerErr !== void 0 ? _options$onHandlerErr : fallbackOnHandlerError;\n  var onInvalidMessage = (_options$onInvalidMes = options.onInvalidMessage) !== null && _options$onInvalidMes !== void 0 ? _options$onInvalidMes : fallbackOnInvalidMessage;\n  var onNotification = (_options$onNotificati = options.onNotification) !== null && _options$onNotificati !== void 0 ? _options$onNotificati : fallbackOnNotification;\n  return function handleRequest(ctx, msg) {\n    try {\n      var id = msg.id;\n\n      if (msg.jsonrpc !== '2.0' || msg.method == null) {\n        if (id == null) {\n          onInvalidMessage(ctx, msg);\n          return Promise.resolve(null);\n        }\n\n        return Promise.resolve(createErrorResponse(id, ERROR_CODE.INVALID_REQUEST));\n      }\n\n      if (id == null) {\n        onNotification(ctx, msg);\n        return Promise.resolve(null);\n      }\n\n      var handler = methods[msg.method];\n\n      if (handler == null) {\n        return Promise.resolve(createErrorResponse(id, ERROR_CODE.METHOD_NOT_FOUND));\n      }\n\n      return Promise.resolve(_catch(function () {\n        var _msg$params;\n\n        function _temp2(result) {\n          return {\n            jsonrpc: '2.0',\n            id: id,\n            result: result\n          };\n        }\n\n        var handled = handler(ctx, (_msg$params = msg.params) !== null && _msg$params !== void 0 ? _msg$params : {});\n\n        var _temp = typeof handled.then === 'function';\n\n        return _temp ? Promise.resolve(handled).then(_temp2) : _temp2(handled);\n      }, function (err) {\n        var error;\n\n        if (err instanceof RPCError) {\n          error = err.toObject();\n        } else {\n          var _err$code;\n\n          onHandlerError(ctx, msg, err);\n          var code = (_err$code = err.code) !== null && _err$code !== void 0 ? _err$code : -32000; // Server error\n\n          error = {\n            code: code,\n            message: err.message || getErrorMessage(code)\n          };\n        }\n\n        return {\n          jsonrpc: '2.0',\n          id: id,\n          error: error\n        };\n      }));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n}\n\nexport { ERROR_CODE, ERROR_MESSAGE, RPCClient, RPCError, createErrorResponse, createHandler, createInternalError, createInvalidParams, createInvalidRequest, createMethodNotFound, createParseError, getErrorMessage, isServerError, parseJSON };","map":null,"metadata":{},"sourceType":"module"}