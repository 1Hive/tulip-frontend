{"ast":null,"code":"'use strict';\n\nconst errCode = require('err-code');\n\nconst {\n  messages,\n  codes\n} = require('./errors');\n\nconst all = require('it-all');\n\nconst pAny = require('p-any');\n\nmodule.exports = node => {\n  const routers = node._modules.contentRouting || [];\n  const dht = node._dht; // If we have the dht, make it first\n\n  if (dht) {\n    routers.unshift(dht);\n  }\n\n  return {\n    /**\n     * Iterates over all content routers in series to find providers of the given key.\n     * Once a content router succeeds, iteration will stop.\n     *\n     * @param {CID} key The CID key of the content to find\n     * @param {object} [options]\n     * @param {number} [options.timeout] How long the query should run\n     * @param {number} [options.maxNumProviders] - maximum number of providers to find\n     * @returns {AsyncIterable<PeerInfo>}\n     */\n    async *findProviders(key, options) {\n      if (!routers.length) {\n        throw errCode(new Error('No content routers available'), 'NO_ROUTERS_AVAILABLE');\n      }\n\n      const result = await pAny(routers.map(async router => {\n        const provs = await all(router.findProviders(key, options));\n\n        if (!provs || !provs.length) {\n          throw errCode(new Error('not found'), 'NOT_FOUND');\n        }\n\n        return provs;\n      }));\n\n      for (const pInfo of result) {\n        yield pInfo;\n      }\n    },\n\n    /**\n     * Iterates over all content routers in parallel to notify it is\n     * a provider of the given key.\n     *\n     * @param {CID} key The CID key of the content to find\n     * @returns {Promise<void>}\n     */\n    async provide(key) {\n      // eslint-disable-line require-await\n      if (!routers.length) {\n        throw errCode(new Error('No content routers available'), 'NO_ROUTERS_AVAILABLE');\n      }\n\n      return Promise.all(routers.map(router => router.provide(key)));\n    },\n\n    /**\n     * Store the given key/value pair in the DHT.\n     * @param {Buffer} key\n     * @param {Buffer} value\n     * @param {Object} [options] - put options\n     * @param {number} [options.minPeers] - minimum number of peers required to successfully put\n     * @returns {Promise<void>}\n     */\n    async put(key, value, options) {\n      // eslint-disable-line require-await\n      if (!node.isStarted() || !dht.isStarted) {\n        throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);\n      }\n\n      return dht.put(key, value, options);\n    },\n\n    /**\n     * Get the value to the given key.\n     * Times out after 1 minute by default.\n     * @param {Buffer} key\n     * @param {Object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout (default: 60000)\n     * @returns {Promise<{from: PeerId, val: Buffer}>}\n     */\n    async get(key, options) {\n      // eslint-disable-line require-await\n      if (!node.isStarted() || !dht.isStarted) {\n        throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);\n      }\n\n      return dht.get(key, options);\n    },\n\n    /**\n     * Get the `n` values to the given key without sorting.\n     * @param {Buffer} key\n     * @param {number} nVals\n     * @param {Object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout (default: 60000)\n     * @returns {Promise<Array<{from: PeerId, val: Buffer}>>}\n     */\n    async getMany(key, nVals, options) {\n      // eslint-disable-line require-await\n      if (!node.isStarted() || !dht.isStarted) {\n        throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);\n      }\n\n      return dht.getMany(key, nVals, options);\n    }\n\n  };\n};","map":null,"metadata":{},"sourceType":"script"}