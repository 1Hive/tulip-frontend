{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _asyncIterator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar EventEmitter = require('events');\n\nvar pipe = require('it-pipe');\n\nvar PROTOCOL = require('./protocol');\n\nvar encoding = require('./encoding');\n\nmodule.exports = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Connection, _EventEmitter);\n\n  var _super = _createSuper(Connection);\n\n  function Connection(remoteId, libp2p, room) {\n    var _this;\n\n    _classCallCheck(this, Connection);\n\n    _this = _super.call(this);\n    _this._remoteId = remoteId;\n    _this._libp2p = libp2p;\n    _this._room = room;\n    _this._connection = null;\n    _this._connecting = false;\n    return _this;\n  }\n\n  _createClass(Connection, [{\n    key: \"push\",\n    value: function push(message) {\n      var _this2 = this;\n\n      if (this._connection) {\n        this._connection.push(encoding(message));\n\n        return;\n      }\n\n      this.once('connect', function () {\n        _this2.push(message);\n      });\n\n      if (!this._connecting) {\n        this._connect();\n      }\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this._connection) {\n        this._connection.end();\n      }\n    }\n  }, {\n    key: \"_connect\",\n    value: function () {\n      var _connect2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var _this3 = this;\n\n        var peerInfo, _yield$this$_libp2p$d, stream;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                this._connecting = true;\n\n                if (this._isConnectedToRemote()) {\n                  _context2.next = 5;\n                  break;\n                }\n\n                this.emit('disconnect');\n                this._connecting = false;\n                return _context2.abrupt(\"return\");\n\n              case 5:\n                peerInfo = this._libp2p.peerStore.get(this._remoteId);\n                _context2.next = 8;\n                return this._libp2p.dialProtocol(peerInfo, PROTOCOL);\n\n              case 8:\n                _yield$this$_libp2p$d = _context2.sent;\n                stream = _yield$this$_libp2p$d.stream;\n                this._connection = new FiFoMessageQueue();\n                pipe(this._connection, stream, /*#__PURE__*/function () {\n                  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(source) {\n                    var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, message;\n\n                    return _regeneratorRuntime.wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            _this3._connecting = false;\n\n                            _this3.emit('connect', _this3._connection);\n\n                            _iteratorNormalCompletion = true;\n                            _didIteratorError = false;\n                            _context.prev = 4;\n                            _iterator = _asyncIterator(source);\n\n                          case 6:\n                            _context.next = 8;\n                            return _iterator.next();\n\n                          case 8:\n                            _step = _context.sent;\n                            _iteratorNormalCompletion = _step.done;\n                            _context.next = 12;\n                            return _step.value;\n\n                          case 12:\n                            _value = _context.sent;\n\n                            if (_iteratorNormalCompletion) {\n                              _context.next = 19;\n                              break;\n                            }\n\n                            message = _value;\n\n                            _this3.emit('message', message);\n\n                          case 16:\n                            _iteratorNormalCompletion = true;\n                            _context.next = 6;\n                            break;\n\n                          case 19:\n                            _context.next = 25;\n                            break;\n\n                          case 21:\n                            _context.prev = 21;\n                            _context.t0 = _context[\"catch\"](4);\n                            _didIteratorError = true;\n                            _iteratorError = _context.t0;\n\n                          case 25:\n                            _context.prev = 25;\n                            _context.prev = 26;\n\n                            if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                              _context.next = 30;\n                              break;\n                            }\n\n                            _context.next = 30;\n                            return _iterator.return();\n\n                          case 30:\n                            _context.prev = 30;\n\n                            if (!_didIteratorError) {\n                              _context.next = 33;\n                              break;\n                            }\n\n                            throw _iteratorError;\n\n                          case 33:\n                            return _context.finish(30);\n\n                          case 34:\n                            return _context.finish(25);\n\n                          case 35:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee, null, [[4, 21, 25, 35], [26,, 30, 34]]);\n                  }));\n\n                  return function (_x) {\n                    return _ref.apply(this, arguments);\n                  };\n                }()).then(function () {\n                  _this3.emit('disconnect');\n                }, function (err) {\n                  _this3.emit('error', err);\n                });\n\n              case 12:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _connect() {\n        return _connect2.apply(this, arguments);\n      }\n\n      return _connect;\n    }()\n  }, {\n    key: \"_isConnectedToRemote\",\n    value: function _isConnectedToRemote() {\n      var _iterator2 = _createForOfIteratorHelper(this._libp2p.connections.keys()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var peerId = _step2.value;\n\n          if (peerId === this._remoteId) {\n            return true;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }]);\n\n  return Connection;\n}(EventEmitter);\n\nvar FiFoMessageQueue = /*#__PURE__*/function () {\n  function FiFoMessageQueue() {\n    _classCallCheck(this, FiFoMessageQueue);\n\n    this._queue = [];\n  }\n\n  _createClass(FiFoMessageQueue, [{\n    key: Symbol.asyncIterator,\n    value: function value() {\n      return this;\n    }\n  }, {\n    key: \"push\",\n    value: function push(message) {\n      if (this._ended) {\n        throw new Error('Message queue ended');\n      }\n\n      if (this._resolve) {\n        return this._resolve({\n          done: false,\n          value: message\n        });\n      }\n\n      this._queue.push(message);\n    }\n  }, {\n    key: \"end\",\n    value: function end() {\n      this._ended = true;\n\n      if (this._resolve) {\n        this._resolve({\n          done: true\n        });\n      }\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      var _this4 = this;\n\n      if (this._ended) {\n        return {\n          done: true\n        };\n      }\n\n      if (this._queue.length) {\n        return {\n          done: false,\n          value: this._queue.shift()\n        };\n      }\n\n      return new Promise(function (resolve) {\n        _this4._resolve = resolve;\n      });\n    }\n  }]);\n\n  return FiFoMessageQueue;\n}();","map":null,"metadata":{},"sourceType":"script"}