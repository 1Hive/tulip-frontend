{"ast":null,"code":"'use strict';\n\nconst errcode = require('err-code');\n\nconst pipe = require('it-pipe');\n\nconst lp = require('it-length-prefixed');\n\nconst pTimeout = require('p-timeout');\n\nconst MulticodecTopology = require('libp2p-interfaces/src/topology/multicodec-topology');\n\nconst rpc = require('./rpc');\n\nconst c = require('./constants');\n\nconst Message = require('./message');\n\nconst utils = require('./utils');\n/**\n * Handle network operations for the dht\n */\n\n\nclass Network {\n  /**\n   * Create a new network.\n   *\n   * @param {KadDHT} self\n   */\n  constructor(self) {\n    this.dht = self;\n    this.readMessageTimeout = c.READ_MESSAGE_TIMEOUT;\n    this._log = utils.logger(this.dht.peerInfo.id, 'net');\n    this._rpc = rpc(this.dht);\n    this._onPeerConnected = this._onPeerConnected.bind(this);\n    this._running = false;\n  }\n  /**\n   * Start the network.\n   * @returns {Promise<void>}\n   */\n\n\n  async start() {\n    if (this._running) {\n      return;\n    }\n\n    if (!this.dht.isStarted) {\n      throw errcode(new Error('Can not start network'), 'ERR_CANNOT_START_NETWORK');\n    }\n\n    this._running = true; // Incoming streams\n\n    this.dht.registrar.handle(c.PROTOCOL_DHT, this._rpc); // register protocol with topology\n\n    const topology = new MulticodecTopology({\n      multicodecs: [c.PROTOCOL_DHT],\n      handlers: {\n        onConnect: this._onPeerConnected,\n        onDisconnect: () => {}\n      }\n    });\n    this._registrarId = await this.dht.registrar.register(topology);\n  }\n  /**\n   * Stop all network activity.\n   * @returns {Promise<void>}\n   */\n\n\n  async stop() {\n    if (!this.dht.isStarted && !this.isStarted) {\n      return;\n    }\n\n    this._running = false; // unregister protocol and handlers\n\n    await this.dht.registrar.unregister(this._registrarId);\n  }\n  /**\n   * Is the network online?\n   *\n   * @type {bool}\n   */\n\n\n  get isStarted() {\n    return this._running;\n  }\n  /**\n   * Are all network components there?\n   *\n   * @type {bool}\n   */\n\n\n  get isConnected() {\n    // TODO add a way to check if switch has started or not\n    return this.dht.isStarted && this.isStarted;\n  }\n  /**\n   * Registrar notifies a connection successfully with dht protocol.\n   * @private\n   * @param {PeerInfo} peerInfo remote peer info\n   * @returns {Promise<void>}\n   */\n\n\n  async _onPeerConnected(peerInfo) {\n    await this.dht._add(peerInfo);\n\n    this._log('added to the routing table: %s', peerInfo.id.toB58String());\n  }\n  /**\n   * Send a request and record RTT for latency measurements.\n   * @async\n   * @param {PeerId} to - The peer that should receive a message\n   * @param {Message} msg - The message to send.\n   * @returns {Promise<Message>}\n   */\n\n\n  async sendRequest(to, msg) {\n    // TODO: record latency\n    if (!this.isConnected) {\n      throw errcode(new Error('Network is offline'), 'ERR_NETWORK_OFFLINE');\n    }\n\n    const id = to.toB58String();\n\n    this._log('sending to: %s', id);\n\n    const conn = await this.dht.dialer.connectToPeer(to);\n    const {\n      stream\n    } = await conn.newStream(c.PROTOCOL_DHT);\n    return this._writeReadMessage(stream, msg.serialize());\n  }\n  /**\n   * Sends a message without expecting an answer.\n   *\n   * @param {PeerId} to\n   * @param {Message} msg\n   * @returns {Promise<void>}\n   */\n\n\n  async sendMessage(to, msg) {\n    if (!this.isConnected) {\n      throw errcode(new Error('Network is offline'), 'ERR_NETWORK_OFFLINE');\n    }\n\n    const id = to.toB58String();\n\n    this._log('sending to: %s', id);\n\n    const conn = await this.dht.dialer.connectToPeer(to);\n    const {\n      stream\n    } = await conn.newStream(c.PROTOCOL_DHT);\n    return this._writeMessage(stream, msg.serialize());\n  }\n  /**\n   * Write a message and read its response.\n   * If no response is received after the specified timeout\n   * this will error out.\n   *\n   * @param {DuplexIterable} stream - the stream to use\n   * @param {Buffer} msg - the message to send\n   * @returns {Promise<Message>}\n   * @private\n   */\n\n\n  async _writeReadMessage(stream, msg) {\n    // eslint-disable-line require-await\n    return pTimeout(writeReadMessage(stream, msg), this.readMessageTimeout);\n  }\n  /**\n   * Write a message to the given stream.\n   *\n   * @param {DuplexIterable} stream - the stream to use\n   * @param {Buffer} msg - the message to send\n   * @returns {Promise<void>}\n   * @private\n   */\n\n\n  _writeMessage(stream, msg) {\n    return pipe([msg], lp.encode(), stream);\n  }\n\n}\n\nasync function writeReadMessage(stream, msg) {\n  const res = await pipe([msg], lp.encode(), stream, lp.decode(), async source => {\n    for await (const chunk of source) {\n      return chunk.slice();\n    }\n  });\n\n  if (res.length === 0) {\n    throw errcode(new Error('No message received'), 'ERR_NO_MESSAGE_RECEIVED');\n  }\n\n  return Message.deserialize(res);\n}\n\nmodule.exports = Network;","map":null,"metadata":{},"sourceType":"script"}