{"ast":null,"code":"/*!\n * poly1305.js - poly1305 for bcrypto\n * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Parts of this software are based on floodyberry/poly1305-donna:\n *   Placed into the public domain by Andrew Moon.\n *   https://github.com/floodyberry/poly1305-donna\n *\n * Resources:\n *   https://en.wikipedia.org/wiki/Poly1305\n *   https://cr.yp.to/mac.html\n *   https://tools.ietf.org/html/rfc7539#section-2.5\n *   https://github.com/floodyberry/poly1305-donna/blob/master/poly1305-donna-16.h\n */\n'use strict';\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar assert = require('../internal/assert');\n/**\n * Poly1305\n */\n\n\nvar Poly1305 = /*#__PURE__*/function () {\n  /**\n   * Create a Poly1305 context.\n   * @constructor\n   */\n  function Poly1305() {\n    _classCallCheck(this, Poly1305);\n\n    this.r = new Uint16Array(10);\n    this.h = new Uint16Array(10);\n    this.pad = new Uint16Array(8);\n    this.buffer = Buffer.alloc(16);\n    this.fin = -1;\n    this.leftover = 0;\n  }\n  /**\n   * Initialize poly1305 with a key.\n   * @param {Buffer} key\n   */\n\n\n  _createClass(Poly1305, [{\n    key: \"init\",\n    value: function init(key) {\n      assert(Buffer.isBuffer(key) && key.length >= 32); // r &= 0xffffffc0ffffffc0ffffffc0fffffff\n\n      var t0 = readU16(key, 0);\n      var t1 = readU16(key, 2);\n      var t2 = readU16(key, 4);\n      var t3 = readU16(key, 6);\n      var t4 = readU16(key, 8);\n      var t5 = readU16(key, 10);\n      var t6 = readU16(key, 12);\n      var t7 = readU16(key, 14);\n      this.r[0] = t0 & 0x1fff;\n      this.r[1] = (t0 >>> 13 | t1 << 3) & 0x1fff;\n      this.r[2] = (t1 >>> 10 | t2 << 6) & 0x1f03;\n      this.r[3] = (t2 >>> 7 | t3 << 9) & 0x1fff;\n      this.r[4] = (t3 >>> 4 | t4 << 12) & 0x00ff;\n      this.r[5] = t4 >>> 1 & 0x1ffe;\n      this.r[6] = (t4 >>> 14 | t5 << 2) & 0x1fff;\n      this.r[7] = (t5 >>> 11 | t6 << 5) & 0x1f81;\n      this.r[8] = (t6 >>> 8 | t7 << 8) & 0x1fff;\n      this.r[9] = t7 >>> 5 & 0x007f; // h = 0\n\n      for (var i = 0; i < 10; i++) {\n        this.h[i] = 0;\n      } // Save pad for later.\n\n\n      for (var _i = 0; _i < 8; _i++) {\n        this.pad[_i] = readU16(key, 16 + 2 * _i);\n      }\n\n      this.fin = 0;\n      this.leftover = 0;\n      return this;\n    }\n    /**\n     * Process 16 byte blocks.\n     * @private\n     * @param {Buffer} data - Blocks.\n     * @param {Number} bytes - Size.\n     * @param {Number} m - Offset pointer.\n     */\n\n  }, {\n    key: \"_blocks\",\n    value: function _blocks(data, bytes, m) {\n      var hibit = this.fin ? 0 : 1 << 11; // 1 << 128\n\n      var d = new Uint32Array(10);\n\n      while (bytes >= 16) {\n        // h += m[i]\n        var t0 = readU16(data, m + 0);\n        var t1 = readU16(data, m + 2);\n        var t2 = readU16(data, m + 4);\n        var t3 = readU16(data, m + 6);\n        var t4 = readU16(data, m + 8);\n        var t5 = readU16(data, m + 10);\n        var t6 = readU16(data, m + 12);\n        var t7 = readU16(data, m + 14);\n        this.h[0] += t0 & 0x1fff;\n        this.h[1] += (t0 >>> 13 | t1 << 3) & 0x1fff;\n        this.h[2] += (t1 >>> 10 | t2 << 6) & 0x1fff;\n        this.h[3] += (t2 >>> 7 | t3 << 9) & 0x1fff;\n        this.h[4] += (t3 >>> 4 | t4 << 12) & 0x1fff;\n        this.h[5] += t4 >>> 1 & 0x1fff;\n        this.h[6] += (t4 >>> 14 | t5 << 2) & 0x1fff;\n        this.h[7] += (t5 >>> 11 | t6 << 5) & 0x1fff;\n        this.h[8] += (t6 >>> 8 | t7 << 8) & 0x1fff;\n        this.h[9] += t7 >>> 5 | hibit; // h *= r, (partial) h %= p\n\n        var c = 0;\n\n        for (var i = 0; i < 10; i++) {\n          d[i] = c;\n\n          for (var j = 0; j < 10; j++) {\n            var a = this.h[j];\n            if (j <= i) a *= this.r[i - j];else a *= 5 * this.r[i + 10 - j];\n            d[i] += a; // Sum(h[i] * r[i] * 5) will overflow\n            // slightly above 6 products with an\n            // unclamped r, so carry at 5.\n\n            if (j === 4) {\n              c = d[i] >>> 13;\n              d[i] &= 0x1fff;\n            }\n          }\n\n          c += d[i] >>> 13;\n          d[i] &= 0x1fff;\n        }\n\n        c = (c << 2) + c; // c *= 5\n\n        c += d[0];\n        d[0] = c & 0x1fff;\n        c = c >>> 13;\n        d[1] += c;\n\n        for (var _i2 = 0; _i2 < 10; _i2++) {\n          this.h[_i2] = d[_i2];\n        }\n\n        m += 16;\n        bytes -= 16;\n      }\n    }\n    /**\n     * Update the MAC with data (will be\n     * processed as 16 byte blocks).\n     * @param {Buffer} data\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(data) {\n      assert(Buffer.isBuffer(data));\n      if (this.fin === -1) throw new Error('Context is not initialized.');\n      var bytes = data.length;\n      var m = 0; // Handle leftover.\n\n      if (this.leftover) {\n        var want = 16 - this.leftover;\n        if (want > bytes) want = bytes;\n\n        for (var i = 0; i < want; i++) {\n          this.buffer[this.leftover + i] = data[m + i];\n        }\n\n        bytes -= want;\n        m += want;\n        this.leftover += want;\n        if (this.leftover < 16) return this;\n\n        this._blocks(this.buffer, 16, 0);\n\n        this.leftover = 0;\n      } // Process full blocks.\n\n\n      if (bytes >= 16) {\n        var _want = bytes & ~(16 - 1);\n\n        this._blocks(data, _want, m);\n\n        m += _want;\n        bytes -= _want;\n      } // Store leftover.\n\n\n      if (bytes) {\n        for (var _i3 = 0; _i3 < bytes; _i3++) {\n          this.buffer[this.leftover + _i3] = data[m + _i3];\n        }\n\n        this.leftover += bytes;\n      }\n\n      return this;\n    }\n    /**\n     * Finalize and return a 16-byte MAC.\n     * @returns {Buffer}\n     */\n\n  }, {\n    key: \"final\",\n    value: function final() {\n      if (this.fin === -1) throw new Error('Context is not initialized.');\n      var mac = Buffer.alloc(16);\n      var g = new Uint16Array(10); // Process the remaining block.\n\n      if (this.leftover) {\n        var i = this.leftover;\n        this.buffer[i++] = 1;\n\n        for (; i < 16; i++) {\n          this.buffer[i] = 0;\n        }\n\n        this.fin = 1;\n\n        this._blocks(this.buffer, 16, 0);\n      } // Fully carry h.\n\n\n      var c = this.h[1] >>> 13;\n      this.h[1] &= 0x1fff;\n\n      for (var _i4 = 2; _i4 < 10; _i4++) {\n        this.h[_i4] += c;\n        c = this.h[_i4] >>> 13;\n        this.h[_i4] &= 0x1fff;\n      }\n\n      this.h[0] += c * 5;\n      c = this.h[0] >>> 13;\n      this.h[0] &= 0x1fff;\n      this.h[1] += c;\n      c = this.h[1] >>> 13;\n      this.h[1] &= 0x1fff;\n      this.h[2] += c; // Compute h + -p.\n\n      g[0] = this.h[0] + 5;\n      c = g[0] >>> 13;\n      g[0] &= 0x1fff;\n\n      for (var _i5 = 1; _i5 < 10; _i5++) {\n        g[_i5] = this.h[_i5] + c;\n        c = g[_i5] >>> 13;\n        g[_i5] &= 0x1fff;\n      } // Select h if h < p, or h + -p if h >= p.\n\n\n      var mask = (c ^ 1) - 1;\n\n      for (var _i6 = 0; _i6 < 10; _i6++) {\n        g[_i6] &= mask;\n      }\n\n      mask = ~mask;\n\n      for (var _i7 = 0; _i7 < 10; _i7++) {\n        this.h[_i7] = this.h[_i7] & mask | g[_i7];\n      } // h = h % (2^128)\n\n\n      this.h[0] = (this.h[0] | this.h[1] << 13) & 0xffff;\n      this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 0xffff;\n      this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 0xffff;\n      this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 0xffff;\n      this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 0xffff;\n      this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 0xffff;\n      this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 0xffff;\n      this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 0xffff; // mac = (h + pad) % (2^128)\n\n      var f = this.h[0] + this.pad[0];\n      this.h[0] = f;\n\n      for (var _i8 = 1; _i8 < 8; _i8++) {\n        f = this.h[_i8] + this.pad[_i8] + (f >>> 16);\n        this.h[_i8] = f;\n      }\n\n      for (var _i9 = 0; _i9 < 8; _i9++) {\n        writeU16(mac, this.h[_i9], _i9 * 2);\n      } // Zero out the state.\n\n\n      this.destroy();\n      return mac;\n    }\n    /**\n     * Destroy the context.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      for (var i = 0; i < 10; i++) {\n        this.r[i] = 0;\n        this.h[i] = 0;\n      }\n\n      for (var _i10 = 0; _i10 < 8; _i10++) {\n        this.pad[_i10] = 0;\n      }\n\n      for (var _i11 = 0; _i11 < 16; _i11++) {\n        this.buffer[_i11] = 0;\n      }\n\n      this.fin = -1;\n      this.leftover = 0;\n    }\n    /**\n     * Finalize and verify MAC against tag.\n     * @param {Buffer} tag\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: \"verify\",\n    value: function verify(tag) {\n      assert(Buffer.isBuffer(tag));\n      assert(tag.length === 16);\n      var mac = this.final();\n      var z = 0;\n\n      for (var i = 0; i < 16; i++) {\n        z |= mac[i] ^ tag[i];\n      }\n\n      return z - 1 >>> 31 !== 0;\n    }\n  }]);\n\n  return Poly1305;\n}();\n/*\n * Static\n */\n\n\nPoly1305.native = 0;\n/*\n * Helpers\n */\n\nfunction readU16(data, off) {\n  return data[off++] + data[off] * 0x100;\n}\n\nfunction writeU16(dst, num, off) {\n  dst[off++] = num;\n  dst[off++] = num >>> 8;\n  return off;\n}\n/*\n * Expose\n */\n\n\nmodule.exports = Poly1305;","map":null,"metadata":{},"sourceType":"script"}