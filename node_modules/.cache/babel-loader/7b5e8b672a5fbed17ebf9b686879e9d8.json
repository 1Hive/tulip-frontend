{"ast":null,"code":"'use strict';\n\nconst PeerId = require('peer-id');\n\nconst PeerInfo = require('peer-info');\n\nconst multiaddr = require('multiaddr');\n\nconst errCode = require('err-code');\n/**\n * Converts the given `peer` to a `PeerInfo` instance.\n * The `PeerStore` will be checked for the resulting peer, and\n * the peer will be updated in the `PeerStore`.\n *\n * @param {PeerInfo|PeerId|Multiaddr|string} peer\n * @param {PeerStore} peerStore\n * @returns {PeerInfo}\n */\n\n\nfunction getPeerInfo(peer, peerStore) {\n  if (typeof peer === 'string') {\n    peer = multiaddr(peer);\n  }\n\n  let addr;\n\n  if (multiaddr.isMultiaddr(peer)) {\n    addr = peer;\n\n    try {\n      peer = PeerId.createFromB58String(peer.getPeerId());\n    } catch (err) {\n      throw errCode(new Error(`${peer} is not a valid peer type`), 'ERR_INVALID_MULTIADDR');\n    }\n  }\n\n  if (PeerId.isPeerId(peer)) {\n    peer = new PeerInfo(peer);\n  }\n\n  addr && peer.multiaddrs.add(addr);\n  return peerStore ? peerStore.put(peer) : peer;\n}\n/**\n * If `getPeerInfo` does not return a peer with multiaddrs,\n * the `libp2p` PeerRouter will be used to attempt to find the peer.\n *\n * @async\n * @param {PeerInfo|PeerId|Multiaddr|string} peer\n * @param {Libp2p} libp2p\n * @returns {Promise<PeerInfo>}\n */\n\n\nfunction getPeerInfoRemote(peer, libp2p) {\n  let peerInfo;\n\n  try {\n    peerInfo = getPeerInfo(peer, libp2p.peerStore);\n  } catch (err) {\n    throw errCode(err, 'ERR_INVALID_PEER_TYPE');\n  } // If we don't have an address for the peer, attempt to find it\n\n\n  if (peerInfo.multiaddrs.size < 1) {\n    return libp2p.peerRouting.findPeer(peerInfo.id);\n  }\n\n  return peerInfo;\n}\n\nmodule.exports = {\n  getPeerInfoRemote,\n  getPeerInfo\n};","map":null,"metadata":{},"sourceType":"script"}