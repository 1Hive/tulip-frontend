{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _objectSpread = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar PeerId = require('peer-id');\n\nvar multiaddr = require('multiaddr');\n\nvar withIs = require('class-is');\n\nvar errCode = require('err-code');\n\nvar Status = require('./status');\n\nfunction validateArgs(localAddr, localPeer, remotePeer, newStream, close, getStreams, stat) {\n  if (localAddr && !multiaddr.isMultiaddr(localAddr)) {\n    throw errCode(new Error('localAddr must be an instance of multiaddr'), 'ERR_INVALID_PARAMETERS');\n  }\n\n  if (!PeerId.isPeerId(localPeer)) {\n    throw errCode(new Error('localPeer must be an instance of peer-id'), 'ERR_INVALID_PARAMETERS');\n  }\n\n  if (!PeerId.isPeerId(remotePeer)) {\n    throw errCode(new Error('remotePeer must be an instance of peer-id'), 'ERR_INVALID_PARAMETERS');\n  }\n\n  if (typeof newStream !== 'function') {\n    throw errCode(new Error('new stream must be a function'), 'ERR_INVALID_PARAMETERS');\n  }\n\n  if (typeof close !== 'function') {\n    throw errCode(new Error('close must be a function'), 'ERR_INVALID_PARAMETERS');\n  }\n\n  if (typeof getStreams !== 'function') {\n    throw errCode(new Error('getStreams must be a function'), 'ERR_INVALID_PARAMETERS');\n  }\n\n  if (!stat) {\n    throw errCode(new Error('connection metadata object must be provided'), 'ERR_INVALID_PARAMETERS');\n  }\n\n  if (stat.direction !== 'inbound' && stat.direction !== 'outbound') {\n    throw errCode(new Error('direction must be \"inbound\" or \"outbound\"'), 'ERR_INVALID_PARAMETERS');\n  }\n\n  if (!stat.timeline) {\n    throw errCode(new Error('connection timeline object must be provided in the stat object'), 'ERR_INVALID_PARAMETERS');\n  }\n\n  if (!stat.timeline.open) {\n    throw errCode(new Error('connection open timestamp must be provided'), 'ERR_INVALID_PARAMETERS');\n  }\n\n  if (!stat.timeline.upgraded) {\n    throw errCode(new Error('connection upgraded timestamp must be provided'), 'ERR_INVALID_PARAMETERS');\n  }\n}\n/**\n * An implementation of the js-libp2p connection.\n * Any libp2p transport should use an upgrader to return this connection.\n */\n\n\nvar Connection = /*#__PURE__*/function () {\n  /**\n   * Creates an instance of Connection.\n   * @param {object} properties properties of the connection.\n   * @param {multiaddr} [properties.localAddr] local multiaddr of the connection if known.\n   * @param {multiaddr} [properties.remoteAddr] remote multiaddr of the connection.\n   * @param {PeerId} properties.localPeer local peer-id.\n   * @param {PeerId} properties.remotePeer remote peer-id.\n   * @param {function} properties.newStream new stream muxer function.\n   * @param {function} properties.close close raw connection function.\n   * @param {function} properties.getStreams get streams from muxer function.\n   * @param {object} properties.stat metadata of the connection.\n   * @param {string} properties.stat.direction connection establishment direction (\"inbound\" or \"outbound\").\n   * @param {object} properties.stat.timeline connection relevant events timestamp.\n   * @param {string} properties.stat.timeline.open connection opening timestamp.\n   * @param {string} properties.stat.timeline.upgraded connection upgraded timestamp.\n   * @param {string} [properties.stat.multiplexer] connection multiplexing identifier.\n   * @param {string} [properties.stat.encryption] connection encryption method identifier.\n   */\n  function Connection(_ref) {\n    var localAddr = _ref.localAddr,\n        remoteAddr = _ref.remoteAddr,\n        localPeer = _ref.localPeer,\n        remotePeer = _ref.remotePeer,\n        newStream = _ref.newStream,\n        close = _ref.close,\n        getStreams = _ref.getStreams,\n        stat = _ref.stat;\n\n    _classCallCheck(this, Connection);\n\n    validateArgs(localAddr, localPeer, remotePeer, newStream, close, getStreams, stat);\n    /**\n     * Connection identifier.\n     */\n\n    this.id = parseInt(Math.random() * 1e9).toString(36) + Date.now();\n    /**\n     * Observed multiaddr of the local peer\n     */\n\n    this.localAddr = localAddr;\n    /**\n     * Observed multiaddr of the remote peer\n     */\n\n    this.remoteAddr = remoteAddr;\n    /**\n     * Local peer id.\n     */\n\n    this.localPeer = localPeer;\n    /**\n     * Remote peer id.\n     */\n\n    this.remotePeer = remotePeer;\n    /**\n     * Connection metadata.\n     */\n\n    this._stat = _objectSpread(_objectSpread({}, stat), {}, {\n      status: Status.OPEN\n    });\n    /**\n     * Reference to the new stream function of the multiplexer\n     */\n\n    this._newStream = newStream;\n    /**\n     * Reference to the close function of the raw connection\n     */\n\n    this._close = close;\n    /**\n     * Reference to the getStreams function of the muxer\n     */\n\n    this._getStreams = getStreams;\n    /**\n     * Connection streams registry\n     */\n\n    this.registry = new Map();\n    /**\n     * User provided tags\n     */\n\n    this.tags = [];\n  }\n  /**\n   * Get connection metadata\n   * @return {Object}\n   */\n\n\n  _createClass(Connection, [{\n    key: \"stat\",\n    get: function get() {\n      return this._stat;\n    }\n    /**\n     * Get all the streams of the muxer.\n     * @return {Array<*>}\n     */\n\n  }, {\n    key: \"streams\",\n    get: function get() {\n      return this._getStreams();\n    }\n    /**\n     * Create a new stream from this connection\n     * @param {string[]} protocols intended protocol for the stream\n     * @return {Promise<object>} with muxed+multistream-selected stream and selected protocol\n     */\n\n  }, {\n    key: \"newStream\",\n    value: function () {\n      var _newStream = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(protocols) {\n        var _yield$this$_newStrea, stream, protocol;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(this.stat.status === Status.CLOSING)) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw errCode(new Error('the connection is being closed'), 'ERR_CONNECTION_BEING_CLOSED');\n\n              case 2:\n                if (!(this.stat.status === Status.CLOSED)) {\n                  _context.next = 4;\n                  break;\n                }\n\n                throw errCode(new Error('the connection is closed'), 'ERR_CONNECTION_CLOSED');\n\n              case 4:\n                if (!Array.isArray(protocols)) protocols = [protocols];\n                _context.next = 7;\n                return this._newStream(protocols);\n\n              case 7:\n                _yield$this$_newStrea = _context.sent;\n                stream = _yield$this$_newStrea.stream;\n                protocol = _yield$this$_newStrea.protocol;\n                this.addStream(stream, {\n                  protocol: protocol\n                });\n                return _context.abrupt(\"return\", {\n                  stream: stream,\n                  protocol: protocol\n                });\n\n              case 12:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function newStream(_x) {\n        return _newStream.apply(this, arguments);\n      }\n\n      return newStream;\n    }()\n    /**\n     * Add a stream when it is opened to the registry.\n     * @param {*} muxedStream a muxed stream\n     * @param {object} properties the stream properties to be registered\n     * @param {string} properties.protocol the protocol used by the stream\n     * @param {object} properties.metadata metadata of the stream\n     * @return {void}\n     */\n\n  }, {\n    key: \"addStream\",\n    value: function addStream(muxedStream, _ref2) {\n      var protocol = _ref2.protocol,\n          _ref2$metadata = _ref2.metadata,\n          metadata = _ref2$metadata === void 0 ? {} : _ref2$metadata;\n      // Add metadata for the stream\n      this.registry.set(muxedStream.id, _objectSpread({\n        protocol: protocol\n      }, metadata));\n    }\n    /**\n     * Remove stream registry after it is closed.\n     * @param {string} id identifier of the stream\n     */\n\n  }, {\n    key: \"removeStream\",\n    value: function removeStream(id) {\n      this.registry.delete(id);\n    }\n    /**\n     * Close the connection.\n     * @return {Promise}\n     */\n\n  }, {\n    key: \"close\",\n    value: function () {\n      var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(this.stat.status === Status.CLOSED)) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 2:\n                if (!this._closing) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", this._closing);\n\n              case 4:\n                this.stat.status = Status.CLOSING; // Close raw connection\n\n                _context2.next = 7;\n                return this._close();\n\n              case 7:\n                this._closing = _context2.sent;\n                this._stat.timeline.close = Date.now();\n                this.stat.status = Status.CLOSED;\n\n              case 10:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function close() {\n        return _close.apply(this, arguments);\n      }\n\n      return close;\n    }()\n  }]);\n\n  return Connection;\n}();\n\nmodule.exports = withIs(Connection, {\n  className: 'Connection',\n  symbolName: '@libp2p/interface-connection/connection'\n});","map":null,"metadata":{},"sourceType":"script"}