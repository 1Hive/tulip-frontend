{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _slicedToArray = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _get = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _require = require('libp2p-pubsub'),\n    utils = _require.utils;\n\nvar PeerInfo = require('peer-info');\n\nvar BasicPubsub = require('./pubsub');\n\nvar _require2 = require('./messageCache'),\n    MessageCache = _require2.MessageCache;\n\nvar _require3 = require('./message'),\n    rpc = _require3.rpc;\n\nvar constants = require('./constants');\n\nvar Heartbeat = require('./heartbeat');\n\nvar GossipSub = /*#__PURE__*/function (_BasicPubsub) {\n  _inherits(GossipSub, _BasicPubsub);\n\n  var _super = _createSuper(GossipSub);\n\n  /**\n   * @param {PeerInfo} peerInfo instance of the peer's PeerInfo\n   * @param {Object} registrar\n   * @param {function} registrar.handle\n   * @param {function} registrar.register\n   * @param {function} registrar.unregister\n   * @param {Object} [options]\n   * @param {bool} [options.emitSelf] if publish should emit to self, if subscribed, defaults to false\n   * @param {bool} [options.gossipIncoming] if incoming messages on a subscribed topic should be automatically gossiped, defaults to true\n   * @param {bool} [options.fallbackToFloodsub] if dial should fallback to floodsub, defaults to true\n   * @param {function} [options.msgIdFn] override the default message id function\n   * @param {Object} [options.messageCache] override the default MessageCache\n   * @constructor\n   */\n  function GossipSub(peerInfo, registrar) {\n    var _this;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, GossipSub);\n\n    if (!PeerInfo.isPeerInfo(peerInfo)) {\n      throw new Error('peer info must be an instance of `peer-info`');\n    }\n\n    _this = _super.call(this, {\n      debugName: 'libp2p:gossipsub',\n      multicodec: constants.GossipSubID,\n      peerInfo: peerInfo,\n      registrar: registrar,\n      options: options\n    });\n    /**\n     * Map of topic meshes\n     *\n     * @type {Map<string, Set<Peer>>}\n     */\n\n    _this.mesh = new Map();\n    /**\n     * Map of topics to set of peers. These mesh peers are the ones to which we are publishing without a topic membership\n     *\n     * @type {Map<string, Set<Peer>>}\n     */\n\n    _this.fanout = new Map();\n    /**\n     * Map of last publish time for fanout topics\n     *\n     * @type {Map<string, Number>}\n     */\n\n    _this.lastpub = new Map();\n    /**\n     * Map of pending messages to gossip\n     *\n     * @type {Map<Peer, Array<rpc.RPC.ControlIHave object>> }\n     */\n\n    _this.gossip = new Map();\n    /**\n     * Map of control messages\n     *\n     * @type {Map<Peer, rpc.RPC.ControlMessage object>}\n     */\n\n    _this.control = new Map();\n    /**\n     * Use the overriden mesgIdFn or the default one.\n     */\n\n    _this._msgIdFn = options.msgIdFn || _this.defaultMsgIdFn;\n    /**\n     * A message cache that contains the messages for last few hearbeat ticks\n     *\n     */\n\n    _this.messageCache = options.messageCache || new MessageCache(constants.GossipSubHistoryGossip, constants.GossipSubHistoryLength, _this._msgIdFn);\n    /**\n     * A heartbeat timer that maintains the mesh\n     */\n\n    _this.heartbeat = new Heartbeat(_assertThisInitialized(_this));\n    return _this;\n  }\n  /**\n   * Removes a peer from the router\n   * @override\n   * @param {Peer} peer\n   * @returns {PeerInfo}\n   */\n\n\n  _createClass(GossipSub, [{\n    key: \"_removePeer\",\n    value: function _removePeer(peer) {\n      _get(_getPrototypeOf(GossipSub.prototype), \"_removePeer\", this).call(this, peer); // Remove this peer from the mesh\n      // eslint-disable-next-line no-unused-vars\n\n\n      var _iterator = _createForOfIteratorHelper(this.mesh.entries()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n              _ = _step$value[0],\n              peers = _step$value[1];\n\n          peers.delete(peer);\n        } // Remove this peer from the fanout\n        // eslint-disable-next-line no-unused-vars\n\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var _iterator2 = _createForOfIteratorHelper(this.fanout.entries()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _step2$value = _slicedToArray(_step2.value, 2),\n              _2 = _step2$value[0],\n              _peers = _step2$value[1];\n\n          _peers.delete(peer);\n        } // Remove from gossip mapping\n\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      this.gossip.delete(peer); // Remove from control mapping\n\n      this.control.delete(peer);\n      return peer;\n    }\n    /**\n     * Handles an rpc control message from a peer\n     * @param {Peer} peer\n     * @param {rpc.RPC} rpc\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_handleRpcControl\",\n    value: function _handleRpcControl(peer, rpc) {\n      var controlMsg = rpc.control;\n\n      if (!controlMsg) {\n        return;\n      }\n\n      var iWant = this._handleIHave(peer, controlMsg.ihave);\n\n      var iHave = this._handleIWant(peer, controlMsg.iwant);\n\n      var prune = this._handleGraft(peer, controlMsg.graft);\n\n      this._handlePrune(peer, controlMsg.prune);\n\n      if (!iWant || !iHave || !prune) {\n        return;\n      }\n\n      var outRpc = this._rpcWithControl(iHave, null, iWant, null, prune);\n\n      this._sendRpc(rpc.from, outRpc);\n    }\n    /**\n     * Process incoming message,\n     * emitting locally and forwarding on to relevant floodsub and gossipsub peers\n     * @param {rpc.RPC.Message} msg\n     */\n\n  }, {\n    key: \"_processRpcMessage\",\n    value: function _processRpcMessage(msg) {\n      var _this2 = this;\n\n      _get(_getPrototypeOf(GossipSub.prototype), \"_processRpcMessage\", this).call(this, msg);\n\n      var topics = msg.topicIDs; // If options.gossipIncoming is false, do NOT emit incoming messages to peers\n\n      if (!this._options.gossipIncoming) {\n        return;\n      } // Emit to floodsub peers\n\n\n      this.peers.forEach(function (peer) {\n        if (peer.info.protocols.has(constants.FloodSubID) && peer.info.id.toB58String() !== msg.from && utils.anyMatch(peer.topics, topics) && peer.isWritable) {\n          peer.sendMessages(utils.normalizeOutRpcMessages([msg]));\n\n          _this2.log('publish msg on topics - floodsub', topics, peer.info.id.toB58String());\n        }\n      }); // Emit to peers in the mesh\n\n      topics.forEach(function (topic) {\n        if (!_this2.mesh.has(topic)) {\n          return;\n        }\n\n        _this2.mesh.get(topic).forEach(function (peer) {\n          if (!peer.isWritable || peer.info.id.toB58String() === msg.from) {\n            return;\n          }\n\n          peer.sendMessages(utils.normalizeOutRpcMessages([msg]));\n\n          _this2.log('publish msg on topic - meshsub', topic, peer.info.id.toB58String());\n        });\n      });\n    }\n    /**\n     * Handles IHAVE messages\n     * @param {Peer} peer\n     * @param {Array<rpc.RPC.ControlIHave>} ihave\n     * @returns {rpc.RPC.ControlIWant}\n     */\n\n  }, {\n    key: \"_handleIHave\",\n    value: function _handleIHave(peer, ihave) {\n      var _this3 = this;\n\n      var iwant = new Set();\n      ihave.forEach(function (_ref) {\n        var topicID = _ref.topicID,\n            messageIDs = _ref.messageIDs;\n\n        if (!_this3.mesh.has(topicID)) {\n          return;\n        }\n\n        messageIDs.forEach(function (msgID) {\n          if (_this3.seenCache.has(msgID)) {\n            return;\n          }\n\n          iwant.add(msgID);\n        });\n      });\n\n      if (!iwant.size) {\n        return;\n      }\n\n      this.log('IHAVE: Asking for %d messages from %s', iwant.size, peer.info.id.toB58String());\n      return {\n        messageIDs: Array.from(iwant)\n      };\n    }\n    /**\n     * Handles IWANT messages\n     * Returns messages to send back to peer\n     * @param {Peer} peer\n     * @param {Array<rpc.RPC.ControlIWant>} iwant\n     * @returns {Array<rpc.RPC.Message>}\n     */\n\n  }, {\n    key: \"_handleIWant\",\n    value: function _handleIWant(peer, iwant) {\n      var _this4 = this;\n\n      // @type {Map<string, rpc.RPC.Message>}\n      var ihave = new Map();\n      iwant.forEach(function (_ref2) {\n        var messageIDs = _ref2.messageIDs;\n        messageIDs.forEach(function (msgID) {\n          var msg = _this4.messageCache.get(msgID);\n\n          if (msg) {\n            ihave.set(msgID, msg);\n          }\n        });\n      });\n\n      if (!ihave.size) {\n        return;\n      }\n\n      this.log('IWANT: Sending %d messages to %s', ihave.size, peer.info.id.toB58String());\n      return Array.from(ihave.values());\n    }\n    /**\n     * Handles Graft messages\n     * @param {Peer} peer\n     * @param {Array<rpc.RPC.ControlGraft>} graft\n     * @return {Array<rpc.RPC.ControlPrune>}\n     */\n\n  }, {\n    key: \"_handleGraft\",\n    value: function _handleGraft(peer, graft) {\n      var _this5 = this;\n\n      var prune = [];\n      graft.forEach(function (_ref3) {\n        var topicID = _ref3.topicID;\n\n        var peers = _this5.mesh.get(topicID);\n\n        if (!peers) {\n          prune.push(topicID);\n        } else {\n          _this5.log('GRAFT: Add mesh link from %s in %s', peer.info.id.toB58String(), topicID);\n\n          peers.add(peer);\n          peer.topics.add(topicID);\n\n          _this5.mesh.set(topicID, peers);\n        }\n      });\n\n      if (!prune.length) {\n        return;\n      }\n\n      var buildCtrlPruneMsg = function buildCtrlPruneMsg(topic) {\n        return {\n          topicID: topic\n        };\n      };\n\n      return prune.map(buildCtrlPruneMsg);\n    }\n    /**\n     * Handles Prune messages\n     * @param {Peer} peer\n     * @param {Array<rpc.RPC.ControlPrune>} prune\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_handlePrune\",\n    value: function _handlePrune(peer, prune) {\n      var _this6 = this;\n\n      prune.forEach(function (_ref4) {\n        var topicID = _ref4.topicID;\n\n        var peers = _this6.mesh.get(topicID);\n\n        if (peers) {\n          _this6.log('PRUNE: Remove mesh link to %s in %s', peer.info.id.toB58String(), topicID);\n\n          peers.delete(peer);\n          peer.topics.delete(topicID);\n        }\n      });\n    }\n    /**\n     * Mounts the gossipsub protocol onto the libp2p node and sends our\n     * our subscriptions to every peer connected\n     * @override\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"start\",\n    value: function () {\n      var _start = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return _get(_getPrototypeOf(GossipSub.prototype), \"start\", this).call(this);\n\n              case 2:\n                this.heartbeat.start();\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function start() {\n        return _start.apply(this, arguments);\n      }\n\n      return start;\n    }()\n    /**\n     * Unmounts the gossipsub protocol and shuts down every connection\n     * @override\n     * @returns {Promise}\n     */\n\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return _get(_getPrototypeOf(GossipSub.prototype), \"stop\", this).call(this);\n\n              case 2:\n                this.heartbeat.stop();\n                this.mesh = new Map();\n                this.fanout = new Map();\n                this.lastpub = new Map();\n                this.gossip = new Map();\n                this.control = new Map();\n\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function stop() {\n        return _stop.apply(this, arguments);\n      }\n\n      return stop;\n    }()\n    /**\n     * Join topics\n     * @param {Array<string>|string} topics\n     * @returns {void}\n     */\n\n  }, {\n    key: \"join\",\n    value: function join(topics) {\n      var _this7 = this;\n\n      if (!this.started) {\n        throw new Error('GossipSub has not started');\n      }\n\n      topics = utils.ensureArray(topics);\n      this.log('JOIN %s', topics);\n      topics.forEach(function (topic) {\n        // Send GRAFT to mesh peers\n        var fanoutPeers = _this7.fanout.get(topic);\n\n        if (fanoutPeers) {\n          _this7.mesh.set(topic, fanoutPeers);\n\n          _this7.fanout.delete(topic);\n\n          _this7.lastpub.delete(topic);\n        } else {\n          var peers = _this7._getPeers(topic, constants.GossipSubD);\n\n          _this7.mesh.set(topic, peers);\n        }\n\n        _this7.mesh.get(topic).forEach(function (peer) {\n          _this7.log('JOIN: Add mesh link to %s in %s', peer.info.id.toB58String(), topic);\n\n          _this7._sendGraft(peer, topic);\n        });\n      });\n    }\n    /**\n     * Leave topics\n     * @param {Array<string>|string} topics\n     * @returns {void}\n     */\n\n  }, {\n    key: \"leave\",\n    value: function leave(topics) {\n      var _this8 = this;\n\n      topics = utils.ensureArray(topics);\n      this.log('LEAVE %s', topics);\n      topics.forEach(function (topic) {\n        // Send PRUNE to mesh peers\n        var meshPeers = _this8.mesh.get(topic);\n\n        if (meshPeers) {\n          meshPeers.forEach(function (peer) {\n            _this8.log('LEAVE: Remove mesh link to %s in %s', peer.info.id.toB58String(), topic);\n\n            _this8._sendPrune(peer, topic);\n          });\n\n          _this8.mesh.delete(topic);\n        }\n      });\n    }\n    /**\n     * Override the default implementation in BasicPubSub.\n     * If we don't provide msgIdFn in constructor option, it's the same.\n     * @override\n     * @param {rpc.RPC.Message} msg the message object\n     * @returns {string} message id as string\n     */\n\n  }, {\n    key: \"getMsgId\",\n    value: function getMsgId(msg) {\n      return this._msgIdFn(msg);\n    }\n  }, {\n    key: \"_publish\",\n    value: function _publish(messages) {\n      var _this9 = this;\n\n      messages.forEach(function (msgObj) {\n        _this9.messageCache.put(msgObj); // @type Set<string>\n\n\n        var tosend = new Set();\n        msgObj.topicIDs.forEach(function (topic) {\n          var peersInTopic = _this9.topics.get(topic);\n\n          if (!peersInTopic) {\n            return;\n          } // floodsub peers\n\n\n          peersInTopic.forEach(function (peer) {\n            if (peer.info.protocols.has(constants.FloodSubID)) {\n              tosend.add(peer);\n            }\n          }); // Gossipsub peers handling\n\n          var meshPeers = _this9.mesh.get(topic);\n\n          if (!meshPeers) {\n            // We are not in the mesh for topic, use fanout peers\n            meshPeers = _this9.fanout.get(topic);\n\n            if (!meshPeers) {\n              // If we are not in the fanout, then pick any peers in topic\n              var peers = _this9._getPeers(topic, constants.GossipSubD);\n\n              if (peers.size > 0) {\n                meshPeers = peers;\n\n                _this9.fanout.set(topic, peers);\n              } else {\n                meshPeers = [];\n              }\n            } // Store the latest publishing time\n\n\n            _this9.lastpub.set(topic, _this9._now());\n          }\n\n          meshPeers.forEach(function (peer) {\n            tosend.add(peer);\n          });\n        }); // Publish messages to peers\n\n        tosend.forEach(function (peer) {\n          if (peer.info.id.toB58String() === msgObj.from) {\n            return;\n          }\n\n          _this9._sendRpc(peer, {\n            msgs: [msgObj]\n          });\n        });\n      });\n    }\n    /**\n     * Sends a GRAFT message to a peer\n     * @param {Peer} peer\n     * @param {String} topic\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_sendGraft\",\n    value: function _sendGraft(peer, topic) {\n      var graft = [{\n        topicID: topic\n      }];\n\n      var out = this._rpcWithControl(null, null, null, graft, null);\n\n      this._sendRpc(peer, out);\n    }\n    /**\n     * Sends a PRUNE message to a peer\n     * @param {Peer} peer\n     * @param {String} topic\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_sendPrune\",\n    value: function _sendPrune(peer, topic) {\n      var prune = [{\n        topicID: topic\n      }];\n\n      var out = this._rpcWithControl(null, null, null, null, prune);\n\n      this._sendRpc(peer, out);\n    }\n  }, {\n    key: \"_sendRpc\",\n    value: function _sendRpc(peer, outRpc) {\n      if (!peer || !peer.isWritable) {\n        return;\n      } // piggyback control message retries\n\n\n      var ctrl = this.control.get(peer);\n\n      if (ctrl) {\n        this._piggybackControl(peer, outRpc, ctrl);\n\n        this.control.delete(peer);\n      } // piggyback gossip\n\n\n      var ihave = this.gossip.get(peer);\n\n      if (ihave) {\n        this._piggybackGossip(peer, outRpc, ihave);\n\n        this.gossip.delete(peer);\n      }\n\n      peer.write(rpc.RPC.encode(outRpc));\n    }\n  }, {\n    key: \"_piggybackControl\",\n    value: function _piggybackControl(peer, outRpc, ctrl) {\n      var _this10 = this;\n\n      var tograft = (ctrl.graft || []).filter(function (_ref5) {\n        var topicID = _ref5.topicID;\n        return (_this10.mesh.get(topicID) || new Set()).has(peer);\n      });\n      var toprune = (ctrl.prune || []).filter(function (_ref6) {\n        var topicID = _ref6.topicID;\n        return !(_this10.mesh.get(topicID) || new Set()).has(peer);\n      });\n\n      if (!tograft.length && !toprune.length) {\n        return;\n      }\n\n      outRpc.control = outRpc.control || {};\n      outRpc.control.graft = (outRpc.control.graft || []).concat(tograft);\n      outRpc.control.prune = (outRpc.control.prune || []).concat(toprune);\n    }\n  }, {\n    key: \"_piggybackGossip\",\n    value: function _piggybackGossip(peer, outRpc, ihave) {\n      outRpc.control = outRpc.control || {};\n      outRpc.control.ihave = ihave;\n    }\n    /**\n     * Send graft and prune messages\n     * @param {Map<Peer, Array<String>>} tograft\n     * @param {Map<Peer, Array<String>>} toprune\n     */\n\n  }, {\n    key: \"_sendGraftPrune\",\n    value: function _sendGraftPrune(tograft, toprune) {\n      var _iterator3 = _createForOfIteratorHelper(tograft),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _step3$value = _slicedToArray(_step3.value, 2),\n              p = _step3$value[0],\n              topics = _step3$value[1];\n\n          var graft = topics.map(function (topicID) {\n            return {\n              topicID: topicID\n            };\n          });\n          var prune = null; // If a peer also has prunes, process them now\n\n          var pruneMsg = toprune.get(p);\n\n          if (pruneMsg) {\n            prune = pruneMsg.map(function (topicID) {\n              return {\n                topicID: topicID\n              };\n            });\n            toprune.delete(p);\n          }\n\n          var outRpc = this._rpcWithControl(null, null, null, graft, prune);\n\n          this._sendRpc(p, outRpc);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      var _iterator4 = _createForOfIteratorHelper(toprune),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var _step4$value = _slicedToArray(_step4.value, 2),\n              _p = _step4$value[0],\n              _topics = _step4$value[1];\n\n          var _prune = _topics.map(function (topicID) {\n            return {\n              topicID: topicID\n            };\n          });\n\n          var _outRpc = this._rpcWithControl(null, null, null, null, _prune);\n\n          this._sendRpc(_p, _outRpc);\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n    /**\n     * Emits gossip to peers in a particular topic\n     * @param {String} topic\n     * @param {Set<Peer>} peers - peers to exclude\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_emitGossip\",\n    value: function _emitGossip(topic, peers) {\n      var _this11 = this;\n\n      var messageIDs = this.messageCache.getGossipIDs(topic);\n\n      if (!messageIDs.length) {\n        return;\n      }\n\n      var gossipSubPeers = this._getPeers(topic, constants.GossipSubD);\n\n      gossipSubPeers.forEach(function (peer) {\n        // skip mesh peers\n        if (!peers.has(peer)) {\n          _this11._pushGossip(peer, {\n            topicID: topic,\n            messageIDs: messageIDs\n          });\n        }\n      });\n    }\n    /**\n     * Flush gossip and control messages\n     */\n\n  }, {\n    key: \"_flush\",\n    value: function _flush() {\n      // send gossip first, which will also piggyback control\n      var _iterator5 = _createForOfIteratorHelper(this.gossip.entries()),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _step5$value = _slicedToArray(_step5.value, 2),\n              peer = _step5$value[0],\n              ihave = _step5$value[1];\n\n          this.gossip.delete(peer);\n\n          var out = this._rpcWithControl(null, ihave, null, null, null);\n\n          this._sendRpc(peer, out);\n        } // send the remaining control messages\n\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      var _iterator6 = _createForOfIteratorHelper(this.control.entries()),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var _step6$value = _slicedToArray(_step6.value, 2),\n              _peer = _step6$value[0],\n              control = _step6$value[1];\n\n          this.control.delete(_peer);\n\n          var _out = this._rpcWithControl(null, null, null, control.graft, control.prune);\n\n          this._sendRpc(_peer, _out);\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n    }\n    /**\n     * Adds new IHAVE messages to pending gossip\n     * @param {Peer} peer\n     * @param {Array<rpc.RPC.ControlIHave>} controlIHaveMsgs\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_pushGossip\",\n    value: function _pushGossip(peer, controlIHaveMsgs) {\n      this.log('Add gossip to %s', peer.info.id.toB58String());\n      var gossip = this.gossip.get(peer) || [];\n      this.gossip.set(peer, gossip.concat(controlIHaveMsgs));\n    }\n    /**\n     * Returns the current time in milliseconds\n     * @returns {number}\n     */\n\n  }, {\n    key: \"_now\",\n    value: function _now() {\n      return Date.now();\n    }\n  }]);\n\n  return GossipSub;\n}(BasicPubsub);\n\nmodule.exports = GossipSub;\nmodule.exports.multicodec = constants.GossipSubID;","map":null,"metadata":{},"sourceType":"script"}