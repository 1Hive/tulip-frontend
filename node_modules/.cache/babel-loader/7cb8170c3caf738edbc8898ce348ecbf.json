{"ast":null,"code":"'use strict';\n\nconst lp = require('it-length-prefixed');\n\nconst pipe = require('it-pipe');\n\nconst Message = require('./types/message');\n\nconst CONSTANTS = require('./constants');\n\nconst logger = require('./utils').logger;\n\nconst BITSWAP100 = '/ipfs/bitswap/1.0.0';\nconst BITSWAP110 = '/ipfs/bitswap/1.1.0';\nconst BITSWAP120 = '/ipfs/bitswap/1.2.0';\n\nclass Network {\n  constructor(libp2p, bitswap, options, stats) {\n    this._log = logger(libp2p.peerInfo.id, 'network');\n    options = options || {};\n    this.libp2p = libp2p;\n    this.bitswap = bitswap;\n    this.protocols = [BITSWAP100];\n\n    if (!options.b100Only) {\n      // Latest bitswap first\n      this.protocols.unshift(BITSWAP110);\n      this.protocols.unshift(BITSWAP120);\n    }\n\n    this._stats = stats;\n    this._running = false; // bind event listeners\n\n    this._onPeerConnect = this._onPeerConnect.bind(this);\n    this._onPeerDisconnect = this._onPeerDisconnect.bind(this);\n    this._onConnection = this._onConnection.bind(this);\n  }\n\n  start() {\n    this._running = true;\n    this.libp2p.handle(this.protocols, this._onConnection);\n    this.libp2p.on('peer:connect', this._onPeerConnect);\n    this.libp2p.on('peer:disconnect', this._onPeerDisconnect); // All existing connections are like new ones for us\n\n    for (const peer of this.libp2p.peerStore.peers.values()) {\n      if (this.libp2p.registrar.getConnection(peer)) {\n        this._onPeerConnect(peer);\n      }\n    }\n  }\n\n  stop() {\n    this._running = false; // Unhandle both, libp2p doesn't care if it's not already handled\n\n    this.libp2p.unhandle(this.protocols);\n    this.libp2p.removeListener('peer:connect', this._onPeerConnect);\n    this.libp2p.removeListener('peer:disconnect', this._onPeerDisconnect);\n  }\n  /**\n   * Handles both types of incoming bitswap messages\n   * @private\n   * @param {object} param0\n   * @param {string} param0.protocol The protocol the stream is running\n   * @param {Stream} param0.stream A duplex iterable stream\n   * @param {Connection} param0.connection A libp2p Connection\n   * @returns {void}\n   */\n\n\n  async _onConnection({\n    protocol,\n    stream,\n    connection\n  }) {\n    if (!this._running) {\n      return;\n    }\n\n    this._log('incoming new bitswap %s connection from %s', protocol, connection.remotePeer.toB58String());\n\n    try {\n      await pipe(stream, lp.decode(), async source => {\n        for await (const data of source) {\n          try {\n            const message = await Message.deserialize(data.slice());\n            await this.bitswap._receiveMessage(connection.remotePeer, message);\n          } catch (err) {\n            this.bitswap._receiveError(err);\n\n            break;\n          }\n        }\n      });\n    } catch (err) {\n      this._log(err);\n    }\n  }\n\n  _onPeerConnect(peerInfo) {\n    this.bitswap._onPeerConnected(peerInfo.id);\n  }\n\n  _onPeerDisconnect(peerInfo) {\n    this.bitswap._onPeerDisconnected(peerInfo.id);\n  }\n  /**\n   * Find providers given a `cid`.\n   *\n   * @param {CID} cid\n   * @param {number} maxProviders\n   * @param {Object} options\n   * @param {AbortSignal} options.abortSignal\n   * @returns {AsyncIterable<PeerInfo>}\n   */\n\n\n  findProviders(cid, maxProviders, options = {}) {\n    return this.libp2p.contentRouting.findProviders(cid, {\n      maxTimeout: CONSTANTS.providerRequestTimeout,\n      maxNumProviders: maxProviders,\n      signal: options.signal\n    });\n  }\n  /**\n   * Find the providers of a given `cid` and connect to them.\n   *\n   * @param {CID} cid\n   * @param {Object} options\n   * @param {AbortSignal} options.abortSignal\n   * @returns {void}\n   */\n\n\n  async findAndConnect(cid, options) {\n    const connectAttempts = [];\n\n    for await (const provider of this.findProviders(cid, CONSTANTS.maxProvidersPerRequest, options)) {\n      this._log('connecting to providers', provider.id.toB58String());\n\n      connectAttempts.push(this.connectTo(provider, options));\n    }\n\n    await Promise.all(connectAttempts);\n  }\n  /**\n   * Tell the network we can provide content for the passed CID\n   *\n   * @param {CID} cid\n   * @param {Object} options\n   * @param {AbortSignal} options.abortSignal\n   * @returns {Promise<void>}\n   */\n\n\n  async provide(cid, options) {\n    await this.libp2p.contentRouting.provide(cid, options);\n  } // Connect to the given peer\n  // Send the given msg (instance of Message) to the given peer\n\n\n  async sendMessage(peer, msg) {\n    if (!this._running) throw new Error('network isn\\'t running');\n    const stringId = peer.toB58String();\n\n    this._log('sendMessage to %s', stringId, msg);\n\n    const {\n      stream,\n      protocol\n    } = await this._dialPeer(peer);\n    let serialized;\n\n    switch (protocol) {\n      case BITSWAP100:\n        serialized = msg.serializeToBitswap100();\n        break;\n\n      case BITSWAP110:\n      case BITSWAP120:\n        serialized = msg.serializeToBitswap110();\n        break;\n\n      default:\n        throw new Error('Unknown protocol: ' + protocol);\n    } // Note: Don't wait for writeMessage() to complete\n\n\n    writeMessage(stream, serialized, this._log);\n\n    this._updateSentStats(peer, msg.blocks);\n  }\n  /**\n   * Connects to another peer\n   *\n   * @param {PeerInfo|PeerId|Multiaddr} peer\n   * @param {Object} options\n   * @param {AbortSignal} options.abortSignal\n   * @returns {Promise<Connection>}\n   */\n\n\n  async connectTo(peer, options) {\n    // eslint-disable-line require-await\n    if (!this._running) {\n      throw new Error('network isn\\'t running');\n    }\n\n    return this.libp2p.dial(peer, options);\n  } // Dial to the peer and try to use the most recent Bitswap\n\n\n  _dialPeer(peer) {\n    return this.libp2p.dialProtocol(peer, [BITSWAP120, BITSWAP110, BITSWAP100]);\n  }\n\n  _updateSentStats(peer, blocks) {\n    const peerId = peer.toB58String();\n\n    if (this._stats) {\n      blocks.forEach(block => this._stats.push(peerId, 'dataSent', block.data.length));\n\n      this._stats.push(peerId, 'blocksSent', blocks.size);\n    }\n  }\n\n}\n\nasync function writeMessage(stream, msg, log) {\n  try {\n    await pipe([msg], lp.encode(), stream);\n  } catch (err) {\n    log(err);\n  }\n}\n\nmodule.exports = Network;","map":null,"metadata":{},"sourceType":"script"}