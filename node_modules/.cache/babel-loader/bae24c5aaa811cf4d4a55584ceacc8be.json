{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar Message = require('../types/message');\n\nvar Wantlist = require('../types/wantlist');\n\nvar CONSTANTS = require('../constants');\n\nvar MsgQueue = require('./msg-queue');\n\nvar logger = require('../utils').logger;\n\nmodule.exports = /*#__PURE__*/function () {\n  function WantManager(peerId, network, stats) {\n    _classCallCheck(this, WantManager);\n\n    this.peers = new Map();\n    this.wantlist = new Wantlist(stats);\n    this.network = network;\n    this._stats = stats;\n    this._peerId = peerId;\n    this._log = logger(peerId, 'want');\n  }\n\n  _createClass(WantManager, [{\n    key: \"_addEntries\",\n    value: function _addEntries(cids, cancel, force) {\n      var _this = this;\n\n      var entries = cids.map(function (cid, i) {\n        return new Message.Entry(cid, CONSTANTS.kMaxPriority - i, Message.WantType.Block, cancel);\n      });\n      entries.forEach(function (e) {\n        // add changes to our wantlist\n        if (e.cancel) {\n          if (force) {\n            _this.wantlist.removeForce(e.cid);\n          } else {\n            _this.wantlist.remove(e.cid);\n          }\n        } else {\n          _this._log('adding to wl');\n\n          _this.wantlist.add(e.cid, e.priority);\n        }\n      }); // broadcast changes\n\n      var _iterator = _createForOfIteratorHelper(this.peers.values()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var p = _step.value;\n          p.addEntries(entries);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"_startPeerHandler\",\n    value: function _startPeerHandler(peerId) {\n      var mq = this.peers.get(peerId.toB58String());\n\n      if (mq) {\n        mq.refcnt++;\n        return;\n      }\n\n      mq = new MsgQueue(this._peerId, peerId, this.network); // new peer, give them the full wantlist\n\n      var fullwantlist = new Message(true);\n\n      var _iterator2 = _createForOfIteratorHelper(this.wantlist.entries()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var entry = _step2.value;\n          fullwantlist.addEntry(entry[1].cid, entry[1].priority);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      mq.addMessage(fullwantlist);\n      this.peers.set(peerId.toB58String(), mq);\n      return mq;\n    }\n  }, {\n    key: \"_stopPeerHandler\",\n    value: function _stopPeerHandler(peerId) {\n      var mq = this.peers.get(peerId.toB58String());\n\n      if (!mq) {\n        return;\n      }\n\n      mq.refcnt--;\n\n      if (mq.refcnt > 0) {\n        return;\n      }\n\n      this.peers.delete(peerId.toB58String());\n    } // add all the cids to the wantlist\n\n  }, {\n    key: \"wantBlocks\",\n    value: function wantBlocks(cids) {\n      var _this2 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      this._addEntries(cids, false);\n\n      if (options && options.signal) {\n        options.signal.addEventListener('abort', function () {\n          _this2.cancelWants(cids);\n        });\n      }\n    } // remove blocks of all the given keys without respecting refcounts\n\n  }, {\n    key: \"unwantBlocks\",\n    value: function unwantBlocks(cids) {\n      this._log('unwant blocks: %s', cids.length);\n\n      this._addEntries(cids, true, true);\n    } // cancel wanting all of the given keys\n\n  }, {\n    key: \"cancelWants\",\n    value: function cancelWants(cids) {\n      this._log('cancel wants: %s', cids.length);\n\n      this._addEntries(cids, true);\n    } // Returns a list of all currently connected peers\n\n  }, {\n    key: \"connectedPeers\",\n    value: function connectedPeers() {\n      return Array.from(this.peers.keys());\n    }\n  }, {\n    key: \"connected\",\n    value: function connected(peerId) {\n      this._startPeerHandler(peerId);\n    }\n  }, {\n    key: \"disconnected\",\n    value: function disconnected(peerId) {\n      this._stopPeerHandler(peerId);\n    }\n  }, {\n    key: \"start\",\n    value: function start() {}\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      var _this3 = this;\n\n      this.peers.forEach(function (mq) {\n        return _this3.disconnected(mq.peerId);\n      });\n      clearInterval(this.timer);\n    }\n  }]);\n\n  return WantManager;\n}();","map":null,"metadata":{},"sourceType":"script"}