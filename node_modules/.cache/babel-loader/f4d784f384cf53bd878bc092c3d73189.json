{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar errCode = require('err-code');\n\nvar log = require('debug')('ipfs:mfs:mkdir');\n\nvar exporter = require('ipfs-unixfs-exporter');\n\nvar createNode = require('./utils/create-node');\n\nvar toPathComponents = require('./utils/to-path-components');\n\nvar updateMfsRoot = require('./utils/update-mfs-root');\n\nvar updateTree = require('./utils/update-tree');\n\nvar addLink = require('./utils/add-link');\n\nvar withMfsRoot = require('./utils/with-mfs-root');\n\nvar applyDefaultOptions = require('./utils/apply-default-options');\n\nvar _require = require('../../utils'),\n    withTimeoutOption = _require.withTimeoutOption;\n\nvar defaultOptions = {\n  parents: false,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  shardSplitThreshold: 1000,\n  flush: true,\n  mode: null,\n  mtime: null\n};\n\nmodule.exports = function (context) {\n  return withTimeoutOption( /*#__PURE__*/function () {\n    var _mfsMkdir = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(path, options) {\n      var pathComponents, root, parent, trail, emptyDir, i, subPathComponents, subPath, newRootCid;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              options = applyDefaultOptions(options, defaultOptions);\n\n              if (path) {\n                _context.next = 3;\n                break;\n              }\n\n              throw new Error('no path given to Mkdir');\n\n            case 3:\n              path = path.trim();\n\n              if (!(path === '/')) {\n                _context.next = 8;\n                break;\n              }\n\n              if (!options.parents) {\n                _context.next = 7;\n                break;\n              }\n\n              return _context.abrupt(\"return\");\n\n            case 7:\n              throw errCode(new Error('cannot create directory \\'/\\': Already exists'), 'ERR_INVALID_PATH');\n\n            case 8:\n              if (!(path.substring(0, 1) !== '/')) {\n                _context.next = 10;\n                break;\n              }\n\n              throw errCode(new Error('paths must start with a leading slash'), 'ERR_INVALID_PATH');\n\n            case 10:\n              log(\"Creating \".concat(path));\n              pathComponents = toPathComponents(path);\n\n              if (!(pathComponents[0] === 'ipfs')) {\n                _context.next = 14;\n                break;\n              }\n\n              throw errCode(new Error(\"path cannot have the prefix 'ipfs'\"), 'ERR_INVALID_PATH');\n\n            case 14:\n              _context.next = 16;\n              return withMfsRoot(context);\n\n            case 16:\n              root = _context.sent;\n              trail = [];\n              _context.next = 20;\n              return createNode(context, 'directory', options);\n\n            case 20:\n              emptyDir = _context.sent;\n              i = 0;\n\n            case 22:\n              if (!(i <= pathComponents.length)) {\n                _context.next = 51;\n                break;\n              }\n\n              subPathComponents = pathComponents.slice(0, i);\n              subPath = \"/ipfs/\".concat(root, \"/\").concat(subPathComponents.join('/'));\n              _context.prev = 25;\n              _context.next = 28;\n              return exporter(subPath, context.ipld);\n\n            case 28:\n              parent = _context.sent;\n              log(\"\".concat(subPath, \" existed\"));\n              log(\"\".concat(subPath, \" had children \").concat(parent.node.Links.map(function (link) {\n                return link.Name;\n              })));\n\n              if (!(i === pathComponents.length)) {\n                _context.next = 35;\n                break;\n              }\n\n              if (!options.parents) {\n                _context.next = 34;\n                break;\n              }\n\n              return _context.abrupt(\"return\");\n\n            case 34:\n              throw errCode(new Error('file already exists'), 'ERR_ALREADY_EXISTS');\n\n            case 35:\n              trail.push({\n                name: parent.name,\n                cid: parent.cid\n              });\n              _context.next = 48;\n              break;\n\n            case 38:\n              _context.prev = 38;\n              _context.t0 = _context[\"catch\"](25);\n\n              if (!(_context.t0.code === 'ERR_NOT_FOUND')) {\n                _context.next = 47;\n                break;\n              }\n\n              if (!(i < pathComponents.length && !options.parents)) {\n                _context.next = 43;\n                break;\n              }\n\n              throw errCode(new Error(\"Intermediate directory path \".concat(subPath, \" does not exist, use the -p flag to create it\")), 'ERR_NOT_FOUND');\n\n            case 43:\n              _context.next = 45;\n              return addEmptyDir(context, subPathComponents[subPathComponents.length - 1], emptyDir, trail[trail.length - 1], trail, options);\n\n            case 45:\n              _context.next = 48;\n              break;\n\n            case 47:\n              throw _context.t0;\n\n            case 48:\n              i++;\n              _context.next = 22;\n              break;\n\n            case 51:\n              _context.next = 53;\n              return updateTree(context, trail, options);\n\n            case 53:\n              newRootCid = _context.sent;\n              _context.next = 56;\n              return updateMfsRoot(context, newRootCid);\n\n            case 56:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[25, 38]]);\n    }));\n\n    function mfsMkdir(_x, _x2) {\n      return _mfsMkdir.apply(this, arguments);\n    }\n\n    return mfsMkdir;\n  }());\n};\n\nvar addEmptyDir = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(context, childName, emptyDir, parent, trail, options) {\n    var result;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            log(\"Adding empty dir called \".concat(childName, \" to \").concat(parent.cid));\n            _context2.next = 3;\n            return addLink(context, {\n              parent: parent.node,\n              parentCid: parent.cid,\n              size: emptyDir.node.size,\n              cid: emptyDir.cid,\n              name: childName,\n              hashAlg: options.hashAlg,\n              cidVersion: options.cidVersion,\n              flush: options.flush\n            });\n\n          case 3:\n            result = _context2.sent;\n            trail[trail.length - 1].cid = result.cid;\n            trail.push({\n              name: childName,\n              cid: emptyDir.cid\n            });\n\n          case 6:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function addEmptyDir(_x3, _x4, _x5, _x6, _x7, _x8) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":null,"metadata":{},"sourceType":"script"}