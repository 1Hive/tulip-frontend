{"ast":null,"code":"'use strict';\n\nconst errCode = require('err-code');\n\nconst log = require('debug')('ipfs:mfs:mkdir');\n\nconst exporter = require('ipfs-unixfs-exporter');\n\nconst createNode = require('./utils/create-node');\n\nconst toPathComponents = require('./utils/to-path-components');\n\nconst updateMfsRoot = require('./utils/update-mfs-root');\n\nconst updateTree = require('./utils/update-tree');\n\nconst addLink = require('./utils/add-link');\n\nconst withMfsRoot = require('./utils/with-mfs-root');\n\nconst applyDefaultOptions = require('./utils/apply-default-options');\n\nconst {\n  withTimeoutOption\n} = require('../../utils');\n\nconst defaultOptions = {\n  parents: false,\n  hashAlg: 'sha2-256',\n  cidVersion: 0,\n  shardSplitThreshold: 1000,\n  flush: true,\n  mode: null,\n  mtime: null\n};\n\nmodule.exports = context => {\n  return withTimeoutOption(async function mfsMkdir(path, options) {\n    options = applyDefaultOptions(options, defaultOptions);\n\n    if (!path) {\n      throw new Error('no path given to Mkdir');\n    }\n\n    path = path.trim();\n\n    if (path === '/') {\n      if (options.parents) {\n        return;\n      }\n\n      throw errCode(new Error('cannot create directory \\'/\\': Already exists'), 'ERR_INVALID_PATH');\n    }\n\n    if (path.substring(0, 1) !== '/') {\n      throw errCode(new Error('paths must start with a leading slash'), 'ERR_INVALID_PATH');\n    }\n\n    log(`Creating ${path}`);\n    const pathComponents = toPathComponents(path);\n\n    if (pathComponents[0] === 'ipfs') {\n      throw errCode(new Error(\"path cannot have the prefix 'ipfs'\"), 'ERR_INVALID_PATH');\n    }\n\n    const root = await withMfsRoot(context);\n    let parent;\n    const trail = [];\n    const emptyDir = await createNode(context, 'directory', options); // make sure the containing folder exists, creating it if necessary\n\n    for (let i = 0; i <= pathComponents.length; i++) {\n      const subPathComponents = pathComponents.slice(0, i);\n      const subPath = `/ipfs/${root}/${subPathComponents.join('/')}`;\n\n      try {\n        parent = await exporter(subPath, context.ipld);\n        log(`${subPath} existed`);\n        log(`${subPath} had children ${parent.node.Links.map(link => link.Name)}`);\n\n        if (i === pathComponents.length) {\n          if (options.parents) {\n            return;\n          }\n\n          throw errCode(new Error('file already exists'), 'ERR_ALREADY_EXISTS');\n        }\n\n        trail.push({\n          name: parent.name,\n          cid: parent.cid\n        });\n      } catch (err) {\n        if (err.code === 'ERR_NOT_FOUND') {\n          if (i < pathComponents.length && !options.parents) {\n            throw errCode(new Error(`Intermediate directory path ${subPath} does not exist, use the -p flag to create it`), 'ERR_NOT_FOUND');\n          } // add the intermediate directory\n\n\n          await addEmptyDir(context, subPathComponents[subPathComponents.length - 1], emptyDir, trail[trail.length - 1], trail, options);\n        } else {\n          throw err;\n        }\n      }\n    } // add an empty dir to the last path component\n    // await addEmptyDir(context, pathComponents[pathComponents.length - 1], emptyDir, parent, trail)\n    // update the tree from the leaf to the root\n\n\n    const newRootCid = await updateTree(context, trail, options); // Update the MFS record with the new CID for the root of the tree\n\n    await updateMfsRoot(context, newRootCid);\n  });\n};\n\nconst addEmptyDir = async (context, childName, emptyDir, parent, trail, options) => {\n  log(`Adding empty dir called ${childName} to ${parent.cid}`);\n  const result = await addLink(context, {\n    parent: parent.node,\n    parentCid: parent.cid,\n    size: emptyDir.node.size,\n    cid: emptyDir.cid,\n    name: childName,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion,\n    flush: options.flush\n  });\n  trail[trail.length - 1].cid = result.cid;\n  trail.push({\n    name: childName,\n    cid: emptyDir.cid\n  });\n};","map":null,"metadata":{},"sourceType":"script"}