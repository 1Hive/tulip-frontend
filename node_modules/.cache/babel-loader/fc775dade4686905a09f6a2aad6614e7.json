{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar EventEmitter = require(\"eventemitter3\");\n\nvar p_timeout_1 = require(\"p-timeout\");\n\nvar priority_queue_1 = require(\"./priority-queue\"); // eslint-disable-next-line @typescript-eslint/no-empty-function\n\n\nvar empty = function empty() {};\n\nvar timeoutError = new p_timeout_1.TimeoutError();\n/**\nPromise queue with concurrency control.\n*/\n\nvar PQueue = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(PQueue, _EventEmitter);\n\n  var _super = _createSuper(PQueue);\n\n  function PQueue(options) {\n    var _this;\n\n    _classCallCheck(this, PQueue);\n\n    var _a, _b, _c, _d;\n\n    _this = _super.call(this);\n    _this._intervalCount = 0;\n    _this._intervalEnd = 0;\n    _this._pendingCount = 0;\n    _this._resolveEmpty = empty;\n    _this._resolveIdle = empty; // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n\n    options = Object.assign({\n      carryoverConcurrencyCount: false,\n      intervalCap: Infinity,\n      interval: 0,\n      concurrency: Infinity,\n      autoStart: true,\n      queueClass: priority_queue_1.default\n    }, options);\n\n    if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {\n      throw new TypeError(\"Expected `intervalCap` to be a number from 1 and up, got `\".concat((_b = (_a = options.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : '', \"` (\").concat(typeof options.intervalCap, \")\"));\n    }\n\n    if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {\n      throw new TypeError(\"Expected `interval` to be a finite number >= 0, got `\".concat((_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : '', \"` (\").concat(typeof options.interval, \")\"));\n    }\n\n    _this._carryoverConcurrencyCount = options.carryoverConcurrencyCount;\n    _this._isIntervalIgnored = options.intervalCap === Infinity || options.interval === 0;\n    _this._intervalCap = options.intervalCap;\n    _this._interval = options.interval;\n    _this._queue = new options.queueClass();\n    _this._queueClass = options.queueClass;\n    _this.concurrency = options.concurrency;\n    _this._timeout = options.timeout;\n    _this._throwOnTimeout = options.throwOnTimeout === true;\n    _this._isPaused = options.autoStart === false;\n    return _this;\n  }\n\n  _createClass(PQueue, [{\n    key: \"_doesIntervalAllowAnother\",\n    get: function get() {\n      return this._isIntervalIgnored || this._intervalCount < this._intervalCap;\n    }\n  }, {\n    key: \"_doesConcurrentAllowAnother\",\n    get: function get() {\n      return this._pendingCount < this._concurrency;\n    }\n  }, {\n    key: \"_next\",\n    value: function _next() {\n      this._pendingCount--;\n\n      this._tryToStartAnother();\n\n      this.emit('next');\n    }\n  }, {\n    key: \"_resolvePromises\",\n    value: function _resolvePromises() {\n      this._resolveEmpty();\n\n      this._resolveEmpty = empty;\n\n      if (this._pendingCount === 0) {\n        this._resolveIdle();\n\n        this._resolveIdle = empty;\n        this.emit('idle');\n      }\n    }\n  }, {\n    key: \"_onResumeInterval\",\n    value: function _onResumeInterval() {\n      this._onInterval();\n\n      this._initializeIntervalIfNeeded();\n\n      this._timeoutId = undefined;\n    }\n  }, {\n    key: \"_isIntervalPaused\",\n    value: function _isIntervalPaused() {\n      var _this2 = this;\n\n      var now = Date.now();\n\n      if (this._intervalId === undefined) {\n        var delay = this._intervalEnd - now;\n\n        if (delay < 0) {\n          // Act as the interval was done\n          // We don't need to resume it here because it will be resumed on line 160\n          this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;\n        } else {\n          // Act as the interval is pending\n          if (this._timeoutId === undefined) {\n            this._timeoutId = setTimeout(function () {\n              _this2._onResumeInterval();\n            }, delay);\n          }\n\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_tryToStartAnother\",\n    value: function _tryToStartAnother() {\n      if (this._queue.size === 0) {\n        // We can clear the interval (\"pause\")\n        // Because we can redo it later (\"resume\")\n        if (this._intervalId) {\n          clearInterval(this._intervalId);\n        }\n\n        this._intervalId = undefined;\n\n        this._resolvePromises();\n\n        return false;\n      }\n\n      if (!this._isPaused) {\n        var canInitializeInterval = !this._isIntervalPaused();\n\n        if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {\n          var job = this._queue.dequeue();\n\n          if (!job) {\n            return false;\n          }\n\n          this.emit('active');\n          job();\n\n          if (canInitializeInterval) {\n            this._initializeIntervalIfNeeded();\n          }\n\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_initializeIntervalIfNeeded\",\n    value: function _initializeIntervalIfNeeded() {\n      var _this3 = this;\n\n      if (this._isIntervalIgnored || this._intervalId !== undefined) {\n        return;\n      }\n\n      this._intervalId = setInterval(function () {\n        _this3._onInterval();\n      }, this._interval);\n      this._intervalEnd = Date.now() + this._interval;\n    }\n  }, {\n    key: \"_onInterval\",\n    value: function _onInterval() {\n      if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) {\n        clearInterval(this._intervalId);\n        this._intervalId = undefined;\n      }\n\n      this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;\n\n      this._processQueue();\n    }\n    /**\n    Executes all queued functions until it reaches the limit.\n    */\n\n  }, {\n    key: \"_processQueue\",\n    value: function _processQueue() {\n      // eslint-disable-next-line no-empty\n      while (this._tryToStartAnother()) {}\n    }\n  }, {\n    key: \"concurrency\",\n    get: function get() {\n      return this._concurrency;\n    },\n    set: function set(newConcurrency) {\n      if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {\n        throw new TypeError(\"Expected `concurrency` to be a number from 1 and up, got `\".concat(newConcurrency, \"` (\").concat(typeof newConcurrency, \")\"));\n      }\n\n      this._concurrency = newConcurrency;\n\n      this._processQueue();\n    }\n    /**\n    Adds a sync or async task to the queue. Always returns a promise.\n    */\n\n  }, {\n    key: \"add\",\n    value: function () {\n      var _add = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(fn) {\n        var _this4 = this;\n\n        var options,\n            _args2 = arguments;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};\n                return _context2.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  var run = /*#__PURE__*/function () {\n                    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n                      var operation;\n                      return _regeneratorRuntime.wrap(function _callee$(_context) {\n                        while (1) {\n                          switch (_context.prev = _context.next) {\n                            case 0:\n                              _this4._pendingCount++;\n                              _this4._intervalCount++;\n                              _context.prev = 2;\n                              operation = _this4._timeout === undefined && options.timeout === undefined ? fn() : p_timeout_1.default(Promise.resolve(fn()), options.timeout === undefined ? _this4._timeout : options.timeout, function () {\n                                if (options.throwOnTimeout === undefined ? _this4._throwOnTimeout : options.throwOnTimeout) {\n                                  reject(timeoutError);\n                                }\n\n                                return undefined;\n                              });\n                              _context.t0 = resolve;\n                              _context.next = 7;\n                              return operation;\n\n                            case 7:\n                              _context.t1 = _context.sent;\n                              (0, _context.t0)(_context.t1);\n                              _context.next = 14;\n                              break;\n\n                            case 11:\n                              _context.prev = 11;\n                              _context.t2 = _context[\"catch\"](2);\n                              reject(_context.t2);\n\n                            case 14:\n                              _this4._next();\n\n                            case 15:\n                            case \"end\":\n                              return _context.stop();\n                          }\n                        }\n                      }, _callee, null, [[2, 11]]);\n                    }));\n\n                    return function run() {\n                      return _ref.apply(this, arguments);\n                    };\n                  }();\n\n                  _this4._queue.enqueue(run, options);\n\n                  _this4._tryToStartAnother();\n\n                  _this4.emit('add');\n                }));\n\n              case 2:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function add(_x) {\n        return _add.apply(this, arguments);\n      }\n\n      return add;\n    }()\n    /**\n    Same as `.add()`, but accepts an array of sync or async functions.\n     @returns A promise that resolves when all functions are resolved.\n    */\n\n  }, {\n    key: \"addAll\",\n    value: function () {\n      var _addAll = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(functions, options) {\n        var _this5 = this;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                return _context4.abrupt(\"return\", Promise.all(functions.map( /*#__PURE__*/function () {\n                  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(function_) {\n                    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                      while (1) {\n                        switch (_context3.prev = _context3.next) {\n                          case 0:\n                            return _context3.abrupt(\"return\", _this5.add(function_, options));\n\n                          case 1:\n                          case \"end\":\n                            return _context3.stop();\n                        }\n                      }\n                    }, _callee3);\n                  }));\n\n                  return function (_x4) {\n                    return _ref2.apply(this, arguments);\n                  };\n                }())));\n\n              case 1:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      function addAll(_x2, _x3) {\n        return _addAll.apply(this, arguments);\n      }\n\n      return addAll;\n    }()\n    /**\n    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)\n    */\n\n  }, {\n    key: \"start\",\n    value: function start() {\n      if (!this._isPaused) {\n        return this;\n      }\n\n      this._isPaused = false;\n\n      this._processQueue();\n\n      return this;\n    }\n    /**\n    Put queue execution on hold.\n    */\n\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      this._isPaused = true;\n    }\n    /**\n    Clear the queue.\n    */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._queue = new this._queueClass();\n    }\n    /**\n    Can be called multiple times. Useful if you for example add additional items at a later time.\n     @returns A promise that settles when the queue becomes empty.\n    */\n\n  }, {\n    key: \"onEmpty\",\n    value: function () {\n      var _onEmpty = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        var _this6 = this;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (!(this._queue.size === 0)) {\n                  _context5.next = 2;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\");\n\n              case 2:\n                return _context5.abrupt(\"return\", new Promise(function (resolve) {\n                  var existingResolve = _this6._resolveEmpty;\n\n                  _this6._resolveEmpty = function () {\n                    existingResolve();\n                    resolve();\n                  };\n                }));\n\n              case 3:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function onEmpty() {\n        return _onEmpty.apply(this, arguments);\n      }\n\n      return onEmpty;\n    }()\n    /**\n    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.\n     @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.\n    */\n\n  }, {\n    key: \"onIdle\",\n    value: function () {\n      var _onIdle = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        var _this7 = this;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (!(this._pendingCount === 0 && this._queue.size === 0)) {\n                  _context6.next = 2;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\");\n\n              case 2:\n                return _context6.abrupt(\"return\", new Promise(function (resolve) {\n                  var existingResolve = _this7._resolveIdle;\n\n                  _this7._resolveIdle = function () {\n                    existingResolve();\n                    resolve();\n                  };\n                }));\n\n              case 3:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function onIdle() {\n        return _onIdle.apply(this, arguments);\n      }\n\n      return onIdle;\n    }()\n    /**\n    Size of the queue.\n    */\n\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this._queue.size;\n    }\n    /**\n    Size of the queue, filtered by the given options.\n     For example, this can be used to find the number of items remaining in the queue with a specific priority level.\n    */\n\n  }, {\n    key: \"sizeBy\",\n    value: function sizeBy(options) {\n      // eslint-disable-next-line unicorn/no-fn-reference-in-iterator\n      return this._queue.filter(options).length;\n    }\n    /**\n    Number of pending promises.\n    */\n\n  }, {\n    key: \"pending\",\n    get: function get() {\n      return this._pendingCount;\n    }\n    /**\n    Whether the queue is currently paused.\n    */\n\n  }, {\n    key: \"isPaused\",\n    get: function get() {\n      return this._isPaused;\n    }\n  }, {\n    key: \"timeout\",\n    get: function get() {\n      return this._timeout;\n    }\n    /**\n    Set the timeout for future operations.\n    */\n    ,\n    set: function set(milliseconds) {\n      this._timeout = milliseconds;\n    }\n  }]);\n\n  return PQueue;\n}(EventEmitter);\n\nexports.default = PQueue;","map":null,"metadata":{},"sourceType":"script"}