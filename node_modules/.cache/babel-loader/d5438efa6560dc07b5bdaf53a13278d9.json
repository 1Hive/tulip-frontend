{"ast":null,"code":"const ensureAddress = require('orbit-db-access-controllers/src/utils/ensure-ac-address');\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst entryIPFS = require('ipfs-log/src/entry');\n\nconst isIPFS = require('is-ipfs');\n\nconst orbitAddress = require('orbit-db/src/orbit-db-address');\n\nconst type = 'thread-access';\nconst MODERATOR = 'MODERATOR';\nconst MEMBER = 'MEMBER';\n\nconst isValid3ID = did => {\n  const parts = did.split(':');\n  if (!parts[0] === 'did' || !parts[1] === '3') return false;\n  return isIPFS.cid(parts[2]);\n};\n\nclass ThreadAccessController extends EventEmitter {\n  constructor(orbitdb, ipfs, identity, firstModerator, options) {\n    super();\n    this._orbitdb = orbitdb;\n    this._db = null;\n    this._options = options || {};\n    this._ipfs = ipfs;\n    this._members = Boolean(options.members);\n    this._firstModerator = firstModerator;\n    this._threadName = options.threadName;\n    this._identity = identity;\n    this._encKeyId = options.encKeyId;\n  }\n\n  static get type() {\n    return type;\n  } // return address of AC (in this case orbitdb address of AC)\n\n\n  get address() {\n    return this._db.address;\n  }\n\n  async canAppend(entry, identityProvider) {\n    const trueIfValidSig = async () => await identityProvider.verifyIdentity(entry.identity);\n\n    const op = entry.payload.op;\n    const mods = this.capabilities['moderators'];\n    const members = this.capabilities['members'];\n    const isMod = mods.includes(entry.identity.id);\n    const isMember = members.includes(entry.identity.id);\n\n    if (op === 'ADD') {\n      // Anyone can add entry if open thread\n      if (!this._members) return await trueIfValidSig(); // Not open thread, any member or mod can add to thread\n\n      if (isMember || isMod) return await trueIfValidSig();\n    }\n\n    if (op === 'DEL') {\n      const hash = entry.payload.value;\n      const delEntry = await entryIPFS.fromMultihash(this._ipfs, hash); // An id can delete their own entries\n\n      if (delEntry.identity.id === entry.identity.id) return await trueIfValidSig(); // Mods can delete any entry\n\n      if (isMod) return await trueIfValidSig();\n    }\n\n    return false;\n  }\n\n  get capabilities() {\n    if (!this._capabilities) this._updateCapabilites();\n    return this._capabilities;\n  }\n\n  getEncryptedKey(did) {\n    if (!this._encKeyId) throw new Error(`getEncryptedKey: only available for confidential threads`);\n    const didEntries = Object.entries(this._db.index).map(entry => {\n      return {\n        id: entry[1].payload.value.id,\n        encryptedReadKey: entry[1].payload.value.encryptedReadKey\n      };\n    }).filter(entry => {\n      return entry.id === did;\n    });\n    if (didEntries.length === 0) throw new Error(`getEncryptedKey: no access for ${did}`);\n    return didEntries[0].encryptedReadKey;\n  }\n\n  _updateCapabilites() {\n    let moderators = [],\n        members = [];\n\n    if (this._db) {\n      moderators.push(this._db.access._firstModerator);\n      Object.entries(this._db.index).forEach(entry => {\n        const capability = entry[1].payload.value.capability;\n        const id = entry[1].payload.value.id;\n\n        if (capability === MODERATOR) {\n          if (!moderators.includes(id)) moderators.push(id);\n        }\n\n        if (capability === MEMBER) members.push(id);\n      });\n    }\n\n    this._capabilities = {\n      moderators,\n      members\n    };\n    return this._capabilities;\n  }\n\n  get(capability) {\n    return this.capabilities[capability] || [];\n  }\n\n  async close() {\n    await this._db.close();\n  }\n\n  async load(address) {\n    const isAddress = orbitAddress.isValid(address);\n\n    if (this._db) {\n      await this._db.close();\n    } // TODO - skip manifest for mod-access\n\n\n    this._db = await this._orbitdb.feed(ensureAddress(address), this._createOrbitOpts(isAddress));\n\n    this._db.events.on('ready', this._onUpdate.bind(this));\n\n    this._db.events.on('write', this._onUpdate.bind(this));\n\n    this._db.events.on('replicated', this._onUpdate.bind(this));\n\n    await this._db.load();\n  }\n\n  _createOrbitOpts(loadByAddress = false) {\n    const accessController = {\n      type: 'moderator-access',\n      firstModerator: this._firstModerator,\n      members: this._members,\n      encKeyId: this._encKeyId\n    };\n    const opts = {\n      identity: this._identity,\n      sync: true\n    };\n    return Object.assign(opts, loadByAddress ? {} : {\n      accessController\n    });\n  }\n\n  async save() {\n    const address = await this._orbitdb.determineAddress(`${this._threadName}/_access`, 'feed', this._createOrbitOpts());\n    const manifest = {\n      address: address.toString(),\n      firstModerator: this._firstModerator,\n      members: this._members\n    };\n    if (this._encKeyId) manifest.encKeyId = this._encKeyId;\n    return manifest;\n  }\n\n  async grant(capability, id, encryptedReadKey) {\n    if (!this._db.access.isValidCapability(capability)) {\n      throw new Error('grant: Invalid capability to grant');\n    }\n\n    if (capability === MEMBER && this.capabilities['members'].includes(id)) {\n      throw new Error(`grant: capability ${capability} has already been granted to ${id}`);\n    } // length 1 allows first mod to add entry with encryptedReadKey\n\n\n    if (capability === MODERATOR && this.capabilities['moderators'].includes(id) && this.capabilities['moderators'].length !== 1) {\n      throw new Error(`grant: capability ${capability} has already been granted to ${id}`);\n    }\n\n    if (this._encKeyId && !encryptedReadKey) {\n      throw new Error('grant: confidential threads require access to be granted with encrypted key');\n    }\n\n    try {\n      const entry = {\n        capability,\n        id\n      };\n      if (encryptedReadKey) entry.encryptedReadKey = encryptedReadKey;\n      await this._db.add(entry);\n    } catch (e) {\n      if (e.toString().includes('not append entry')) throw new Error(`grant: Capability ${capability} can not be granted to ${id}`);\n      throw e;\n    }\n  }\n\n  _onUpdate() {\n    this._updateCapabilites();\n\n    this.emit('updated');\n  }\n  /* Factory */\n\n\n  static async create(orbitdb, options = {}) {\n    if (!options.firstModerator) throw new Error('Thread AC: firstModerator required');\n    if (options.address) options.threadName = options.address.split('/')[3];\n    return new ThreadAccessController(orbitdb, orbitdb._ipfs, options.identity, options.firstModerator, options);\n  }\n\n}\n\nmodule.exports = ThreadAccessController;","map":null,"metadata":{},"sourceType":"script"}