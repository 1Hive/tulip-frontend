{"ast":null,"code":"function n(a, b) {\n  if (Array.isArray(a)) {\n    for (var c = 0; c < a.length; c++) {\n      n(a[c], b);\n    }\n  } else if (\"object\" == typeof a && null !== a) {\n    for (c in a) {\n      \"__typename\" === c && \"string\" == typeof a[c] ? b[a[c]] = 0 : n(a[c], b);\n    }\n  }\n\n  return b;\n}\n\nfunction p(a) {\n  return a.kind === Kind.FIELD && \"__typename\" === a.name.value && !a.alias;\n}\n\nfunction r(a) {\n  if (a.selectionSet && !a.selectionSet.selections.some(p)) {\n    return _extends({}, a, {\n      selectionSet: _extends({}, a.selectionSet, {\n        selections: a.selectionSet.selections.concat([{\n          kind: Kind.FIELD,\n          name: {\n            kind: Kind.NAME,\n            value: \"__typename\"\n          }\n        }])\n      })\n    });\n  }\n}\n\nfunction u(a) {\n  a = keyDocument(a);\n  var b = t.get(a.__key);\n  b || ((b = visit(a, {\n    Field: r,\n    InlineFragment: r\n  })).__key = a.__key, t.set(a.__key, b));\n  return b;\n}\n\nfunction v(a) {\n  return a && \"object\" == typeof a ? Object.keys(a).reduce(function (b, c) {\n    var d = a[c];\n    \"__typename\" === c ? Object.defineProperty(b, \"__typename\", {\n      enumerable: !1,\n      value: d\n    }) : Array.isArray(d) ? b[c] = d.map(v) : b[c] = d && \"object\" == typeof d && \"__typename\" in d ? v(d) : d;\n    return b;\n  }, {}) : a;\n}\n\nfunction w(a) {\n  a.toPromise = function () {\n    return toPromise(take(1)(a));\n  };\n\n  return a;\n}\n\nfunction z(a, b, c) {\n  c || (c = b.context);\n  return {\n    key: b.key,\n    query: b.query,\n    variables: b.variables,\n    kind: a,\n    context: c,\n\n    get operationName() {\n      if (\"production\" !== process.env.NODE_ENV) {\n        var a = y_operationName,\n            c = a.key;\n        a = a.message;\n        x[c] || (console.warn(\"[WARNING: Deprecated] \" + a), x[c] = !0);\n      }\n\n      return this.kind;\n    }\n\n  };\n}\n\nfunction A(a, b) {\n  return z(a.kind, a, _extends({}, a.context, {\n    meta: _extends({}, a.context.meta, b)\n  }));\n}\n\nfunction B() {}\n\nfunction C(a, b, c) {\n  var d, e, f;\n\n  for (d = 0; d < c.length; d++) {\n    if (c[d].kind === Kind.FRAGMENT_DEFINITION) {\n      e = c[d].name.value, f = stringifyDocument(c[d]);\n      a.has(e) ? \"production\" !== process.env.NODE_ENV && a.get(e) !== f && console.warn(\"[WARNING: Duplicate Fragment] A fragment with name `\" + e + \"` already exists in this document.\\nWhile fragment names may not be unique across your source, each name must be unique per document.\") : (a.set(e, f), b.push(c[d]));\n    } else {\n      b.push(c[d]);\n    }\n  }\n}\n\nfunction D(a) {\n  return \"subscription\" !== (a = a.kind) && \"query\" !== a;\n}\n\nfunction E(a) {\n  return a.path || a.extensions ? {\n    message: a.message,\n    path: a.path,\n    extensions: a.extensions\n  } : a.message;\n}\n\nfunction F(a) {\n  return \"mutation\" !== (a = a.kind) && \"query\" !== a;\n}\n\nfunction G(a) {\n  var b = z(a.kind, a);\n  b.query = u(a.query);\n  return b;\n}\n\nfunction H(a) {\n  return \"query\" !== a.kind || \"cache-only\" !== a.context.requestPolicy;\n}\n\nfunction I(a) {\n  return A(a, {\n    cacheOutcome: \"miss\"\n  });\n}\n\nfunction J(a) {\n  return F(a);\n}\n\nfunction K(a) {\n  function b(a) {\n    var b = a.context.requestPolicy;\n    return \"query\" === a.kind && \"network-only\" !== b && (\"cache-only\" === b || k.has(a.key));\n  }\n\n  function c(a) {\n    var c = k.get(a.key);\n    \"production\" !== process.env.NODE_ENV && q(_extends({}, {\n      operation: a\n    }, c ? {\n      type: \"cacheHit\",\n      message: \"The result was successfully retried from the cache\"\n    } : {\n      type: \"cacheMiss\",\n      message: \"The result could not be retrieved from the cache\"\n    }));\n    c = _extends({}, c, {\n      operation: A(a, {\n        cacheOutcome: c ? \"hit\" : \"miss\"\n      })\n    });\n    \"cache-and-network\" === a.context.requestPolicy && (c.stale = !0, L(m, a));\n    return c;\n  }\n\n  function d(a) {\n    return !F(a) && b(a);\n  }\n\n  function e(a) {\n    function c(a) {\n      l.add(a);\n    }\n\n    var e,\n        l,\n        g,\n        d = a.operation;\n\n    if (d) {\n      e = Object.keys(n(a.data, {})).concat(d.context.additionalTypenames || []);\n\n      if (\"mutation\" === a.operation.kind) {\n        l = new Set();\n        \"production\" !== process.env.NODE_ENV && q({\n          type: \"cacheInvalidation\",\n          message: \"The following typenames have been invalidated: \" + e,\n          operation: d,\n          data: {\n            typenames: e,\n            response: a\n          },\n          source: \"cacheExchange\"\n        });\n\n        for (a = 0; a < e.length; a++) {\n          (g = h[g = e[a]] || (h[g] = new Set())).forEach(c);\n          g.clear();\n        }\n\n        l.forEach(function b(a) {\n          k.has(a) && (d = k.get(a).operation, k.delete(a), L(m, d));\n        });\n      } else if (\"query\" === d.kind && a.data) {\n        for (k.set(d.key, a), a = 0; a < e.length; a++) {\n          (h[g = e[a]] || (h[g] = new Set())).add(d.key);\n        }\n      }\n    }\n  }\n\n  function f(a) {\n    return !F(a) && !b(a);\n  }\n\n  var g = a.forward,\n      m = a.client,\n      q = a.dispatchDebug,\n      k = new Map(),\n      h = Object.create(null);\n  return function (a) {\n    var b = share(a);\n    a = map(c)(filter(d)(b));\n    b = tap(e)(g(filter(H)(map(I)(merge([map(G)(filter(f)(b)), filter(J)(b)])))));\n    return merge([a, b]);\n  };\n}\n\nfunction L(a, b) {\n  return a.reexecuteOperation(z(b.kind, b, _extends({}, b.context, {\n    requestPolicy: \"network-only\"\n  })));\n}\n\nfunction M(a) {\n  return console.log(\"[Exchange debug]: Completed operation: \", a);\n}\n\nfunction N(a) {\n  return console.log(\"[Exchange debug]: Incoming operation: \", a);\n}\n\nfunction O(a) {\n  function b(a) {\n    f.delete(a.operation.key);\n  }\n\n  function c(a) {\n    var c = a.key,\n        b = a.kind;\n\n    if (\"teardown\" === b) {\n      return f.delete(c), !0;\n    }\n\n    if (\"query\" !== b && \"subscription\" !== b) {\n      return !0;\n    }\n\n    b = f.has(c);\n    f.add(c);\n    b && \"production\" !== process.env.NODE_ENV && e({\n      type: \"dedup\",\n      message: \"An operation has been deduped.\",\n      operation: a,\n      source: \"dedupExchange\"\n    });\n    return !b;\n  }\n\n  var d = a.forward,\n      e = a.dispatchDebug,\n      f = new Set();\n  return function (a) {\n    a = filter(c)(a);\n    return tap(b)(d(a));\n  };\n}\n\nfunction P(a) {\n  return \"query\" === a.kind || \"mutation\" === a.kind;\n}\n\nfunction Q(a) {\n  return \"query\" !== a.kind && \"mutation\" !== a.kind;\n}\n\nfunction R(a) {\n  var b = a.forward,\n      c = a.dispatchDebug;\n  return function (a) {\n    var f,\n        d = share(a);\n    a = mergeMap(function (a) {\n      var b = a.key,\n          e = filter(function (a) {\n        return \"teardown\" === a.kind && a.key === b;\n      })(d),\n          f = makeFetchBody(a),\n          h = makeFetchURL(a, f),\n          l = makeFetchOptions(a, f);\n      \"production\" !== process.env.NODE_ENV && c({\n        type: \"fetchRequest\",\n        message: \"A fetch request is being executed.\",\n        operation: a,\n        data: {\n          url: h,\n          fetchOptions: l\n        },\n        source: \"fetchExchange\"\n      });\n      return onPush(function (b) {\n        var d = b.data ? void 0 : b.error;\n        \"production\" !== process.env.NODE_ENV && c({\n          type: d ? \"fetchError\" : \"fetchSuccess\",\n          message: \"A \" + (d ? \"failed\" : \"successful\") + \" fetch response has been returned.\",\n          operation: a,\n          data: {\n            url: h,\n            fetchOptions: l,\n            value: d || b\n          },\n          source: \"fetchExchange\"\n        });\n      })(takeUntil(e)(makeFetchSource(a, h, l)));\n    })(filter(P)(d));\n    f = b(filter(Q)(d));\n    return merge([a, f]);\n  };\n}\n\nfunction S() {\n  return !1;\n}\n\nfunction T(a) {\n  function b(a) {\n    if (\"teardown\" !== a.kind && \"production\" !== process.env.NODE_ENV) {\n      var b = 'No exchange has handled operations of kind \"' + a.kind + \"\\\". Check whether you've added an exchange responsible for these operations.\";\n      \"production\" !== process.env.NODE_ENV && c({\n        type: \"fallbackCatch\",\n        message: b,\n        operation: a,\n        source: \"fallbackExchange\"\n      });\n      console.warn(b);\n    }\n  }\n\n  var c = a.dispatchDebug;\n  return function (a) {\n    return filter(S)(tap(b)(a));\n  };\n}\n\nfunction V(a) {\n  return function (b) {\n    var c = b.client,\n        d = b.dispatchDebug;\n    return a.reduceRight(function (a, b) {\n      return b({\n        client: c,\n        forward: a,\n        dispatchDebug: function dispatchDebug(a) {\n          \"production\" !== process.env.NODE_ENV && d(_extends({}, {\n            timestamp: Date.now(),\n            source: b.name\n          }, a));\n        }\n      });\n    }, b.forward);\n  };\n}\n\nfunction X(a) {\n  var d,\n      e,\n      f,\n      g,\n      m,\n      c = this;\n  this.activeOperations = Object.create(null);\n  this.queue = [];\n\n  this.createOperationContext = function (a) {\n    a || (a = {});\n    return _extends({}, {\n      url: c.url,\n      fetchOptions: c.fetchOptions,\n      fetch: c.fetch,\n      preferGetMethod: c.preferGetMethod\n    }, a, {\n      suspense: a.suspense || !1 !== a.suspense && c.suspense,\n      requestPolicy: a.requestPolicy || c.requestPolicy\n    });\n  };\n\n  this.createRequestOperation = function (a, b, d) {\n    return z(a, b, c.createOperationContext(d));\n  };\n\n  this.executeQuery = function (a, b) {\n    a = c.createRequestOperation(\"query\", a, b);\n    return c.executeRequestOperation(a);\n  };\n\n  this.executeSubscription = function (a, b) {\n    a = c.createRequestOperation(\"subscription\", a, b);\n    return c.executeRequestOperation(a);\n  };\n\n  this.executeMutation = function (a, b) {\n    a = c.createRequestOperation(\"mutation\", a, b);\n    return c.executeRequestOperation(a);\n  };\n\n  if (\"production\" !== process.env.NODE_ENV && !a.url) {\n    throw Error(\"You are creating an urql-client without a url.\");\n  }\n\n  d = B;\n\n  if (\"production\" !== process.env.NODE_ENV) {\n    e = (d = makeSubject()).next, f = d.source;\n\n    this.subscribeToDebugTarget = function b(a) {\n      return subscribe(a)(f);\n    };\n\n    d = e;\n  }\n\n  this.url = a.url;\n  this.fetchOptions = a.fetchOptions;\n  this.fetch = a.fetch;\n  this.suspense = !!a.suspense;\n  this.requestPolicy = a.requestPolicy || \"cache-first\";\n  this.preferGetMethod = !!a.preferGetMethod;\n  this.maskTypename = !!a.maskTypename;\n  e = makeSubject();\n  g = e.next;\n  this.operations$ = e.source;\n  m = !1;\n\n  this.dispatchOperation = function (a) {\n    m = !0;\n\n    for (a && g(a); a = c.queue.shift();) {\n      g(a);\n    }\n\n    m = !1;\n  };\n\n  this.reexecuteOperation = function (a) {\n    if (\"mutation\" === a.kind || 0 < (c.activeOperations[a.key] || 0)) {\n      c.queue.push(a), m || Promise.resolve().then(c.dispatchOperation);\n    }\n  };\n\n  a = V(void 0 !== a.exchanges ? a.exchanges : W);\n  this.results$ = share(a({\n    client: this,\n    dispatchDebug: d,\n    forward: T({\n      dispatchDebug: d\n    })\n  })(this.operations$));\n  publish(this.results$);\n}\n\nfunction Y(a) {\n  a.data = v(a.data);\n  return a;\n}\n\nfunction createClient(a) {\n  return new X(a);\n}\n\nfunction debugExchange(a) {\n  var d = a.forward;\n  return \"production\" === process.env.NODE_ENV ? function b(a) {\n    return d(a);\n  } : function c(a) {\n    return tap(M)(d(tap(N)(a)));\n  };\n}\n\nfunction errorExchange(a) {\n  function b(a) {\n    var b = a.error;\n    a = a.operation;\n    b && c(b, a);\n  }\n\n  var c = a.onError;\n  return function (a) {\n    var c = a.forward;\n    return function (a) {\n      return tap(b)(c(a));\n    };\n  };\n}\n\nfunction gql() {\n  var a, b, c, d, e, f, g;\n\n  for (a = arguments, b = new Map(), c = [], d = [], e = Array.isArray(arguments[0]) ? arguments[0][0] : arguments[0] || \"\", f = 1; f < arguments.length; f++) {\n    (g = a[f]) && g.definitions ? d.push.apply(d, g.definitions) : e += g;\n    e += a[0][f];\n  }\n\n  C(b, c, keyDocument(e).definitions);\n  C(b, c, d);\n  return keyDocument({\n    kind: Kind.DOCUMENT,\n    definitions: c\n  });\n}\n\nfunction ssrExchange(a) {\n  function b(b) {\n    var c = b.client,\n        e = b.forward;\n    return function (b) {\n      var l = a && \"boolean\" == typeof a.isClient ? !!a.isClient : !c.suspense,\n          h = share(b);\n      b = e(filter(f)(h));\n      h = map(g)(filter(m)(h));\n      l ? h = tap(d)(h) : b = tap(q)(b);\n      return merge([b, h]);\n    };\n  }\n\n  function c(a) {\n    return !D(a) && void 0 !== k[a.key];\n  }\n\n  function d(a) {\n    h.push(a.operation.key);\n    1 === h.length && Promise.resolve().then(e);\n  }\n\n  function e() {\n    for (var a; a = h.shift();) {\n      delete k[a];\n    }\n  }\n\n  function f(a) {\n    return !c(a);\n  }\n\n  function g(a) {\n    var b = k[a.key],\n        c = b.error;\n    return {\n      operation: a,\n      data: (b = b.data) ? JSON.parse(b) : void 0,\n      extensions: void 0,\n      error: c ? new CombinedError({\n        networkError: c.networkError ? Error(c.networkError) : void 0,\n        graphQLErrors: c.graphQLErrors && c.graphQLErrors.length ? c.graphQLErrors : void 0\n      }) : void 0\n    };\n  }\n\n  function m(a) {\n    return c(a);\n  }\n\n  function q(a) {\n    var c,\n        d,\n        b = a.operation;\n\n    if (!D(b)) {\n      c = a.data;\n      a = a.error;\n      d = {};\n      void 0 !== c && (d.data = JSON.stringify(c));\n      a && (d.error = {\n        graphQLErrors: a.graphQLErrors.map(E)\n      }, a.networkError && (d.error.networkError = \"\" + a.networkError));\n      k[b.key] = d;\n    }\n  }\n\n  var k = {},\n      h = [];\n\n  b.restoreData = function (a) {\n    return _extends(k, a);\n  };\n\n  b.extractData = function () {\n    return _extends({}, k);\n  };\n\n  a && a.initialState && b.restoreData(a.initialState);\n  return b;\n}\n\nfunction subscriptionExchange(a) {\n  function b(a) {\n    return \"subscription\" === (a = a.kind) || !!d && (\"query\" === a || \"mutation\" === a);\n  }\n\n  var c = a.forwardSubscription,\n      d = a.enableAllOperations;\n  return function (a) {\n    function d(a) {\n      var b = c({\n        key: a.key.toString(36),\n        query: print(a.query),\n        variables: a.variables,\n        context: _extends({}, a.context)\n      });\n      return make(function (c) {\n        function d(b) {\n          return h(makeResult(a, b));\n        }\n\n        function e(b) {\n          return h(makeErrorResult(a, b));\n        }\n\n        function f() {\n          k || (k = !0, \"subscription\" === a.kind && m.reexecuteOperation(z(\"teardown\", a, a.context)), g());\n        }\n\n        var l,\n            h = c.next,\n            g = c.complete,\n            k = !1;\n        Promise.resolve().then(function () {\n          k || (l = b.subscribe({\n            next: d,\n            error: e,\n            complete: f\n          }));\n        });\n        return function () {\n          k = !0;\n          l && l.unsubscribe();\n        };\n      });\n    }\n\n    function e(a) {\n      return !k(a);\n    }\n\n    var m = a.client,\n        q = a.forward,\n        k = b;\n    return function (a) {\n      var c,\n          b = share(a);\n      a = mergeMap(function (a) {\n        var c = a.key,\n            e = filter(function (a) {\n          return \"teardown\" === a.kind && a.key === c;\n        })(b);\n        return takeUntil(e)(d(a));\n      })(filter(k)(b));\n      c = q(filter(e)(b));\n      return merge([a, c]);\n    };\n  };\n}\n\nvar t, x, y_operationName, U, W;\nimport { toPromise, take, share, filter, map, tap, merge, mergeMap, takeUntil, make, onPush, makeSubject, publish, onStart, onEnd, switchMap, fromValue, interval, subscribe } from \"wonka\";\nimport { k as keyDocument, _ as _extends, s as stringifyDocument, C as CombinedError, m as makeResult, a as makeErrorResult, b as makeFetchBody, c as makeFetchURL, d as makeFetchOptions, e as makeFetchSource, f as createRequest } from \"./2c01d8b2.mjs\";\nimport { visit } from \"graphql/language/visitor.mjs\";\nimport { Kind } from \"graphql/language/kinds.mjs\";\nimport { print } from \"graphql/language/printer.mjs\";\nexport { C as CombinedError, f as createRequest, h as getOperationName, a as makeErrorResult, m as makeResult, g as stringifyVariables } from \"./2c01d8b2.mjs\";\nt = new Map();\nx = {}, y_operationName = {\n  key: \"Operation.operationName\",\n  message: 'The \"Operation.operationName\" property has been deprecated and will be removed in a future release of urql. Use \"Operation.kind\" instead.'\n};\nU = T({\n  dispatchDebug: B\n});\nW = [O, K, R];\n\nX.prototype.onOperationStart = function (a) {\n  var b = a.key;\n  this.activeOperations[b] = (this.activeOperations[b] || 0) + 1;\n  this.dispatchOperation(a);\n};\n\nX.prototype.onOperationEnd = function (a) {\n  var b = a.key,\n      c = this.activeOperations[b] || 0;\n\n  if (0 >= (this.activeOperations[b] = 0 >= c ? 0 : c - 1)) {\n    for (b = this.queue.length - 1; 0 <= b; b--) {\n      this.queue[b].key === a.key && this.queue.splice(b, 1);\n    }\n\n    this.dispatchOperation(z(\"teardown\", a, a.context));\n  }\n};\n\nX.prototype.executeRequestOperation = function (a) {\n  var f,\n      g,\n      d = this,\n      e = filter(function (b) {\n    return b.operation.key === a.key;\n  })(this.results$);\n  this.maskTypename && (e = map(Y)(e));\n\n  if (\"mutation\" === a.kind) {\n    return take(1)(onStart(function b() {\n      return d.dispatchOperation(a);\n    })(e));\n  }\n\n  f = filter(function (b) {\n    return \"teardown\" === b.kind && b.key === a.key;\n  })(this.operations$), g = onEnd(function () {\n    d.onOperationEnd(a);\n  })(onStart(function () {\n    d.onOperationStart(a);\n  })(takeUntil(f)(e)));\n  return \"query\" === a.kind && a.context.pollInterval ? switchMap(function c() {\n    return g;\n  })(merge([fromValue(0), interval(a.context.pollInterval)])) : g;\n};\n\nX.prototype.query = function (a, b, c) {\n  c && \"boolean\" == typeof c.suspense || (c = _extends({}, c, {\n    suspense: !1\n  }));\n  return w(this.executeQuery(createRequest(a, b), c));\n};\n\nX.prototype.readQuery = function (a, b, c) {\n  var d = null;\n  subscribe(function (a) {\n    d = a;\n  })(this.executeQuery(createRequest(a, b), c)).unsubscribe();\n  return d;\n};\n\nX.prototype.subscription = function (a, b, c) {\n  return this.executeSubscription(createRequest(a, b), c);\n};\n\nX.prototype.mutation = function (a, b, c) {\n  return w(this.executeMutation(createRequest(a, b), c));\n};\n\nexport { X as Client, K as cacheExchange, V as composeExchanges, createClient, debugExchange, O as dedupExchange, W as defaultExchanges, errorExchange, U as fallbackExchangeIO, R as fetchExchange, u as formatDocument, gql, z as makeOperation, v as maskTypename, ssrExchange, subscriptionExchange };","map":null,"metadata":{},"sourceType":"module"}