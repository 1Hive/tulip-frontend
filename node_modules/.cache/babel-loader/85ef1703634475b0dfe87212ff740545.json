{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = queue;\n\nvar _baseIndexOf = require('lodash/_baseIndexOf');\n\nvar _baseIndexOf2 = _interopRequireDefault(_baseIndexOf);\n\nvar _isArray = require('lodash/isArray');\n\nvar _isArray2 = _interopRequireDefault(_isArray);\n\nvar _noop = require('lodash/noop');\n\nvar _noop2 = _interopRequireDefault(_noop);\n\nvar _onlyOnce = require('./onlyOnce');\n\nvar _onlyOnce2 = _interopRequireDefault(_onlyOnce);\n\nvar _setImmediate = require('./setImmediate');\n\nvar _setImmediate2 = _interopRequireDefault(_setImmediate);\n\nvar _DoublyLinkedList = require('./DoublyLinkedList');\n\nvar _DoublyLinkedList2 = _interopRequireDefault(_DoublyLinkedList);\n\nvar _wrapAsync = require('./wrapAsync');\n\nvar _wrapAsync2 = _interopRequireDefault(_wrapAsync);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction queue(worker, concurrency, payload) {\n  if (concurrency == null) {\n    concurrency = 1;\n  } else if (concurrency === 0) {\n    throw new Error('Concurrency must not be zero');\n  }\n\n  var _worker = (0, _wrapAsync2.default)(worker);\n\n  var numRunning = 0;\n  var workersList = [];\n  var processingScheduled = false;\n\n  function _insert(data, insertAtFront, callback) {\n    if (callback != null && typeof callback !== 'function') {\n      throw new Error('task callback must be a function');\n    }\n\n    q.started = true;\n\n    if (!(0, _isArray2.default)(data)) {\n      data = [data];\n    }\n\n    if (data.length === 0 && q.idle()) {\n      // call drain immediately if there are no tasks\n      return (0, _setImmediate2.default)(function () {\n        q.drain();\n      });\n    }\n\n    for (var i = 0, l = data.length; i < l; i++) {\n      var item = {\n        data: data[i],\n        callback: callback || _noop2.default\n      };\n\n      if (insertAtFront) {\n        q._tasks.unshift(item);\n      } else {\n        q._tasks.push(item);\n      }\n    }\n\n    if (!processingScheduled) {\n      processingScheduled = true;\n      (0, _setImmediate2.default)(function () {\n        processingScheduled = false;\n        q.process();\n      });\n    }\n  }\n\n  function _next(tasks) {\n    return function (err) {\n      numRunning -= 1;\n\n      for (var i = 0, l = tasks.length; i < l; i++) {\n        var task = tasks[i];\n        var index = (0, _baseIndexOf2.default)(workersList, task, 0);\n\n        if (index === 0) {\n          workersList.shift();\n        } else if (index > 0) {\n          workersList.splice(index, 1);\n        }\n\n        task.callback.apply(task, arguments);\n\n        if (err != null) {\n          q.error(err, task.data);\n        }\n      }\n\n      if (numRunning <= q.concurrency - q.buffer) {\n        q.unsaturated();\n      }\n\n      if (q.idle()) {\n        q.drain();\n      }\n\n      q.process();\n    };\n  }\n\n  var isProcessing = false;\n  var q = {\n    _tasks: new _DoublyLinkedList2.default(),\n    concurrency: concurrency,\n    payload: payload,\n    saturated: _noop2.default,\n    unsaturated: _noop2.default,\n    buffer: concurrency / 4,\n    empty: _noop2.default,\n    drain: _noop2.default,\n    error: _noop2.default,\n    started: false,\n    paused: false,\n    push: function (data, callback) {\n      _insert(data, false, callback);\n    },\n    kill: function () {\n      q.drain = _noop2.default;\n\n      q._tasks.empty();\n    },\n    unshift: function (data, callback) {\n      _insert(data, true, callback);\n    },\n    remove: function (testFn) {\n      q._tasks.remove(testFn);\n    },\n    process: function () {\n      // Avoid trying to start too many processing operations. This can occur\n      // when callbacks resolve synchronously (#1267).\n      if (isProcessing) {\n        return;\n      }\n\n      isProcessing = true;\n\n      while (!q.paused && numRunning < q.concurrency && q._tasks.length) {\n        var tasks = [],\n            data = [];\n        var l = q._tasks.length;\n        if (q.payload) l = Math.min(l, q.payload);\n\n        for (var i = 0; i < l; i++) {\n          var node = q._tasks.shift();\n\n          tasks.push(node);\n          workersList.push(node);\n          data.push(node.data);\n        }\n\n        numRunning += 1;\n\n        if (q._tasks.length === 0) {\n          q.empty();\n        }\n\n        if (numRunning === q.concurrency) {\n          q.saturated();\n        }\n\n        var cb = (0, _onlyOnce2.default)(_next(tasks));\n\n        _worker(data, cb);\n      }\n\n      isProcessing = false;\n    },\n    length: function () {\n      return q._tasks.length;\n    },\n    running: function () {\n      return numRunning;\n    },\n    workersList: function () {\n      return workersList;\n    },\n    idle: function () {\n      return q._tasks.length + numRunning === 0;\n    },\n    pause: function () {\n      q.paused = true;\n    },\n    resume: function () {\n      if (q.paused === false) {\n        return;\n      }\n\n      q.paused = false;\n      (0, _setImmediate2.default)(q.process);\n    }\n  };\n  return q;\n}\n\nmodule.exports = exports['default'];","map":null,"metadata":{},"sourceType":"script"}