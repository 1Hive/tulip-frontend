{"ast":null,"code":"function _extends() {\n  return (_extends = Object.assign || function (target) {\n    var i, source, key;\n\n    for (i = 1; i < arguments.length; i++) {\n      source = arguments[i];\n\n      for (key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  }).apply(this, arguments);\n}\n\nfunction useMutation(query) {\n  function _ref(result) {\n    if (isMounted.current) {\n      setState({\n        fetching: !1,\n        stale: !!result.stale,\n        data: result.data,\n        error: result.error,\n        extensions: result.extensions,\n        operation: result.operation\n      });\n    }\n\n    return result;\n  }\n\n  function _ref2() {\n    isMounted.current = !1;\n  }\n\n  var isMounted = useRef(!0),\n      client = useClient(),\n      ref = useState(initialState),\n      state = ref[0],\n      setState = ref[1],\n      executeMutation = useCallback(function (variables, context) {\n    setState(_extends({}, initialState, {\n      fetching: !0\n    }));\n    return toPromise(client.executeMutation(createRequest(query, variables), context || {})).then(_ref);\n  }, [client, query, setState]);\n  useEffect(function () {\n    return _ref2;\n  }, []);\n  return [state, executeMutation];\n}\n\nfunction _ref3() {\n  return currentInit;\n}\n\nfunction useSource(input, transform) {\n  function _ref() {\n    return input;\n  }\n\n  function _ref5(value) {\n    if (!currentInit) {\n      setState(function _ref4(prevValue) {\n        return isShallowDifferent(prevValue, value) ? value : prevValue;\n      });\n    }\n  }\n\n  var ref = useMemo(function () {\n    var subject = makeSubject(),\n        source = concat([map(_ref)(fromValue(input)), subject.source]),\n        updateInput = function (nextInput) {\n      var prevInput = input;\n\n      try {\n        if (nextInput !== prevInput) {\n          subject.next(input = nextInput);\n        }\n      } catch (error) {\n        input = prevInput;\n        throw error;\n      }\n    };\n\n    return [source, updateInput];\n  }, []),\n      input$ = ref[0],\n      updateInput = ref[1],\n      ref$1 = useState(function () {\n    currentInit = !0;\n    var state;\n\n    try {\n      subscribe(function _ref2(value) {\n        state = value;\n      })(takeWhile(_ref3)(transform(input$))).unsubscribe();\n    } finally {\n      currentInit = !1;\n    }\n\n    return state;\n  }),\n      state = ref$1[0],\n      setState = ref$1[1];\n  useEffect(function () {\n    return subscribe(_ref5)(transform(input$, state)).unsubscribe;\n  }, [input$]);\n  return [state, updateInput];\n}\n\nfunction useRequest(query, variables) {\n  var prev = useRef(void 0);\n  return useMemo(function () {\n    var request = createRequest(query, variables);\n\n    if (void 0 !== prev.current && prev.current.key === request.key) {\n      return prev.current;\n    } else {\n      prev.current = request;\n      return request;\n    }\n  }, [query, variables]);\n}\n\nfunction _ref3$1(x) {\n  return void 0 !== x;\n}\n\nfunction _ref4(result, partial) {\n  return _extends({}, result, partial);\n}\n\nfunction _ref5(ref) {\n  var stale = ref.stale,\n      data = ref.data,\n      error = ref.error,\n      extensions = ref.extensions,\n      operation = ref.operation;\n  return {\n    fetching: !1,\n    stale: !!stale,\n    data: data,\n    error: error,\n    operation: operation,\n    extensions: extensions\n  };\n}\n\nfunction _ref6(query$) {\n  if (!query$) {\n    return fromValue({\n      fetching: !1,\n      stale: !1\n    });\n  }\n\n  return concat([fromValue({\n    fetching: !0,\n    stale: !1\n  }), map(_ref5)(query$), fromValue({\n    fetching: !1,\n    stale: !1\n  })]);\n}\n\nfunction _ref7(query$$, prevState) {\n  return scan(_ref4, prevState || initialState)(switchMap(_ref6)(query$$));\n}\n\nfunction useQuery(args) {\n  var client = useClient(),\n      request = useRequest(args.query, args.variables),\n      makeQuery$ = useCallback(function (opts) {\n    var suspense = isSuspense(client, args.context),\n        source = suspense ? sources.get(request.key) : void 0;\n\n    if (!source) {\n      source = client.executeQuery(request, _extends({}, {\n        requestPolicy: args.requestPolicy,\n        pollInterval: args.pollInterval\n      }, args.context, opts));\n\n      if (suspense) {\n        source = function toSuspenseSource(source) {\n          function _ref(result) {\n            if (resolve && void 0 === cache) {\n              resolve(result);\n            }\n\n            cache = result;\n          }\n\n          function _ref2(_resolve) {\n            resolve = _resolve;\n          }\n\n          var cache,\n              resolve,\n              shared = share(source),\n              suspend$ = function (sink) {\n            onPush(_ref)(shared)(sink);\n\n            if (void 0 === cache) {\n              throw new Promise(_ref2);\n            }\n          };\n\n          return concat([filter(_ref3$1)(map(function () {\n            return cache;\n          })(fromValue(cache))), suspend$]);\n        }(source);\n\n        if (\"undefined\" != typeof window) {\n          sources.set(request.key, source);\n        }\n      }\n    }\n\n    return source;\n  }, [client, request, args.requestPolicy, args.pollInterval, args.context]),\n      query$ = useMemo(function () {\n    return args.pause ? null : makeQuery$();\n  }, [args.pause, makeQuery$]),\n      ref = useSource(query$, useCallback(_ref7, [])),\n      state = ref[0],\n      update = ref[1],\n      executeQuery = useCallback(function (opts) {\n    update(makeQuery$(_extends({}, {\n      suspense: !1\n    }, opts)));\n  }, [update, makeQuery$]);\n  useEffect(function () {\n    sources.delete(request.key);\n\n    if (!isSuspense(client, args.context)) {\n      update(query$);\n    }\n  }, [update, client, query$, request, args.context]);\n\n  if (isSuspense(client, args.context)) {\n    update(query$);\n  }\n\n  return [state, executeQuery];\n}\n\nfunction _ref2(ref) {\n  var stale = ref.stale,\n      data = ref.data,\n      error = ref.error,\n      extensions = ref.extensions,\n      operation = ref.operation;\n  return {\n    fetching: !0,\n    stale: !!stale,\n    data: data,\n    error: error,\n    extensions: extensions,\n    operation: operation\n  };\n}\n\nfunction _ref3$2(subscription$) {\n  if (!subscription$) {\n    return fromValue({\n      fetching: !1\n    });\n  }\n\n  return concat([fromValue({\n    fetching: !0,\n    stale: !1\n  }), map(_ref2)(subscription$), fromValue({\n    fetching: !1,\n    stale: !1\n  })]);\n}\n\nfunction useSubscription(args, handler) {\n  function _ref(result, partial) {\n    var handler = handlerRef.current,\n        data = void 0 !== partial.data ? \"function\" == typeof handler ? handler(result.data, partial.data) : partial.data : result.data;\n    return _extends({}, result, partial, {\n      data: data\n    });\n  }\n\n  var request,\n      makeSubscription$,\n      subscription$,\n      ref,\n      state,\n      update,\n      executeSubscription,\n      client = useClient(),\n      handlerRef = useRef(handler);\n  handlerRef.current = handler;\n  request = useRequest(args.query, args.variables);\n  makeSubscription$ = useCallback(function (opts) {\n    return client.executeSubscription(request, _extends({}, args.context, opts));\n  }, [client, request, args.context]);\n  state = (ref = useSource(subscription$ = useMemo(function () {\n    return args.pause ? null : makeSubscription$();\n  }, [args.pause, makeSubscription$]), useCallback(function (subscription$$, prevState) {\n    return scan(_ref, prevState || initialState)(switchMap(_ref3$2)(subscription$$));\n  }, [])))[0];\n  executeSubscription = useCallback(function (opts) {\n    return update(makeSubscription$(opts));\n  }, [update = ref[1], makeSubscription$]);\n  useEffect(function () {\n    update(subscription$);\n  }, [update, subscription$]);\n  return [state, executeSubscription];\n}\n\nfunction Mutation(props) {\n  var mutation = useMutation(props.query);\n  return props.children(_extends({}, mutation[0], {\n    executeMutation: mutation[1]\n  }));\n}\n\nfunction Query(props) {\n  var query = useQuery(props);\n  return props.children(_extends({}, query[0], {\n    executeQuery: query[1]\n  }));\n}\n\nfunction Subscription(props) {\n  var subscription = useSubscription(props, props.handler);\n  return props.children(_extends({}, subscription[0], {\n    executeSubscription: subscription[1]\n  }));\n}\n\nvar defaultClient, Context, Provider, Consumer, hasWarnedAboutDefault, useClient, initialState, currentInit, isShallowDifferent, isSuspense, sources;\nimport { createClient, createRequest } from \"@urql/core\";\nexport * from \"@urql/core\";\nimport { createContext, useContext, useRef, useState, useCallback, useEffect, useMemo } from \"react\";\nimport { toPromise, makeSubject, concat, map, fromValue, subscribe, takeWhile, filter, share, onPush, scan, switchMap } from \"wonka\";\ndefaultClient = createClient({\n  url: \"/graphql\"\n});\nProvider = (Context = createContext(defaultClient)).Provider;\nConsumer = Context.Consumer;\nhasWarnedAboutDefault = !1;\n\nuseClient = function () {\n  var client = useContext(Context);\n\n  if (\"production\" !== process.env.NODE_ENV && client === defaultClient && !hasWarnedAboutDefault) {\n    hasWarnedAboutDefault = !0;\n    console.warn(\"Default Client: No client has been specified using urql's Provider.This means that urql will be falling back to defaults including making requests to `/graphql`.\\nIf that's not what you want, please create a client and add a Provider.\");\n  }\n\n  return client;\n};\n\ninitialState = {\n  fetching: !1,\n  stale: !1,\n  error: void 0,\n  data: void 0,\n  extensions: void 0,\n  operation: void 0\n};\ncurrentInit = !1;\n\nisShallowDifferent = function (a, b) {\n  var x, x$1;\n\n  if (\"object\" != typeof a || \"object\" != typeof b) {\n    return a !== b;\n  }\n\n  for (x in a) {\n    if (!(x in b)) {\n      return !0;\n    }\n  }\n\n  for (x$1 in b) {\n    if (a[x$1] !== b[x$1]) {\n      return !0;\n    }\n  }\n\n  return !1;\n};\n\nisSuspense = function (client, context) {\n  return client.suspense && (!context || !1 !== context.suspense);\n};\n\nsources = new Map();\nexport { Consumer, Context, Mutation, Provider, Query, Subscription, useClient, useMutation, useQuery, useSubscription };","map":null,"metadata":{},"sourceType":"module"}