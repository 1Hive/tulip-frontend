{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _slicedToArray = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar SortedMap = require('../utils/sorted-map');\n/**\n * @typedef {Object} Task\n * @property {string} topic - a name for the Task (like an id but not necessarily unique)\n * @property {number} priority - tasks are ordered by priority per peer\n * @property {number} size - the size of the task, eg the number of bytes in a block\n */\n\n/**\n * @typedef {Object} TaskMerger\n * @property {function(task, tasksWithTopic)} hasNewInfo - given the existing\n *   tasks with the same topic, does the task add some new information?\n *   Used to decide whether to merge the task or ignore it.\n * @property {function(task, existingTask)} merge - merge the information from\n *   the given task into the existing task (with the same topic)\n */\n\n/**\n * The task merger that is used by default.\n * Assumes that new tasks do not add any information over existing tasks,\n * and doesn't try to merge.\n */\n\n\nvar DefaultTaskMerger = {\n  hasNewInfo: function hasNewInfo() {\n    return false;\n  },\n  merge: function merge() {}\n};\n/**\n * Queue of requests to be processed by the engine.\n * The requests from each peer are added to the peer's queue, sorted by\n * priority.\n * Tasks are popped in priority order from the best peer - see popTasks()\n * for more details.\n */\n\nvar RequestQueue = /*#__PURE__*/function () {\n  /**\n   * @param {TaskMerger} taskMerger\n   */\n  function RequestQueue(taskMerger) {\n    _classCallCheck(this, RequestQueue);\n\n    this._taskMerger = taskMerger || DefaultTaskMerger;\n    this._byPeer = new SortedMap([], PeerTasks.compare, true);\n  }\n  /**\n   * Push tasks onto the queue for the given peer\n   * @param {PeerId} peerId\n   * @param {Task} tasks\n   */\n\n\n  _createClass(RequestQueue, [{\n    key: \"pushTasks\",\n    value: function pushTasks(peerId, tasks) {\n      var peerTasks = this._byPeer.get(peerId.toB58String());\n\n      if (!peerTasks) {\n        peerTasks = new PeerTasks(peerId, this._taskMerger);\n      }\n\n      peerTasks.pushTasks(tasks);\n\n      this._byPeer.set(peerId.toB58String(), peerTasks);\n    }\n    /**\n     * Choose the peer with the least active work (or if all have the same active\n     * work, the most pending tasks) and pop off the highest priority tasks until\n     * the total size is at least targetMinBytes.\n     * This puts the popped tasks into the \"active\" state, meaning they are\n     * actively being processed (and cannot be modified).\n     * @param {number} targetMinBytes - the minimum total size of tasks to pop\n     * @returns {Object}\n     */\n\n  }, {\n    key: \"popTasks\",\n    value: function popTasks(targetMinBytes) {\n      if (this._byPeer.size === 0) {\n        return {\n          tasks: [],\n          pendingSize: 0\n        };\n      } // Get the queue of tasks for the best peer and pop off tasks up to\n      // targetMinBytes\n\n\n      var peerTasks = this._head();\n\n      var _peerTasks$popTasks = peerTasks.popTasks(targetMinBytes),\n          tasks = _peerTasks$popTasks.tasks,\n          pendingSize = _peerTasks$popTasks.pendingSize;\n\n      if (tasks.length === 0) {\n        return {\n          tasks: tasks,\n          pendingSize: pendingSize\n        };\n      }\n\n      var peerId = peerTasks.peerId;\n\n      if (peerTasks.isIdle()) {\n        // If there are no more tasks for the peer, free up its memory\n        this._byPeer.delete(peerId.toB58String());\n      } else {\n        // If there are still tasks remaining, update the sort order of peerTasks\n        // (because it depends on the number of pending tasks)\n        this._byPeer.update(0);\n      }\n\n      return {\n        peerId: peerId,\n        tasks: tasks,\n        pendingSize: pendingSize\n      };\n    }\n  }, {\n    key: \"_head\",\n    value: function _head() {\n      var _iterator = _createForOfIteratorHelper(this._byPeer),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n              v = _step$value[1];\n\n          return v;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return undefined;\n    }\n    /**\n     * Remove the task with the given topic for the given peer.\n     * @param {string} topic\n     * @param {PeerId} peerId\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(topic, peerId) {\n      var peerTasks = this._byPeer.get(peerId.toB58String());\n\n      peerTasks && peerTasks.remove(topic);\n    }\n    /**\n     * Called when the tasks for the given peer complete.\n     * @param {PeerId} peerId\n     * @param {Task[]} tasks\n     */\n\n  }, {\n    key: \"tasksDone\",\n    value: function tasksDone(peerId, tasks) {\n      var peerTasks = this._byPeer.get(peerId.toB58String());\n\n      if (!peerTasks) {\n        return;\n      }\n\n      var i = this._byPeer.indexOf(peerId.toB58String());\n\n      var _iterator2 = _createForOfIteratorHelper(tasks),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var task = _step2.value;\n          peerTasks.taskDone(task);\n        } // Marking the tasks as done takes them out of the \"active\" state, and the\n        // sort order depends on the size of the active tasks, so we need to update\n        // the order.\n\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      this._byPeer.update(i);\n    }\n  }]);\n\n  return RequestQueue;\n}();\n/**\n * Queue of tasks for a particular peer, sorted by priority.\n */\n\n\nvar PeerTasks = /*#__PURE__*/function () {\n  /**\n   * @param {PeerId} peerId\n   * @param {TaskMerger} taskMerger\n   */\n  function PeerTasks(peerId, taskMerger) {\n    _classCallCheck(this, PeerTasks);\n\n    this.peerId = peerId;\n    this._taskMerger = taskMerger;\n    this._activeTotalSize = 0;\n    this._pending = new PendingTasks();\n    this._active = new Set();\n  }\n  /**\n   * Push tasks onto the queue.\n   * @param {Task[]} tasks\n   */\n\n\n  _createClass(PeerTasks, [{\n    key: \"pushTasks\",\n    value: function pushTasks(tasks) {\n      var _iterator3 = _createForOfIteratorHelper(tasks),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var t = _step3.value;\n\n          this._pushTask(t);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  }, {\n    key: \"_pushTask\",\n    value: function _pushTask(task) {\n      // If the new task doesn't add any more information over what we\n      // already have in the active queue, then we can skip the new task\n      if (!this._taskHasMoreInfoThanActiveTasks(task)) {\n        return;\n      } // If there is already a non-active (pending) task with this topic\n\n\n      var existingTask = this._pending.get(task.topic);\n\n      if (existingTask) {\n        // If the new task has a higher priority than the old task,\n        if (task.priority > existingTask.priority) {\n          // Update the priority and the task's position in the queue\n          this._pending.updatePriority(task.topic, task.priority);\n        } // Merge the information from the new task into the existing task\n\n\n        this._taskMerger.merge(task, existingTask); // A task with the topic exists, so we don't need to add\n        // the new task to the queue\n\n\n        return;\n      } // Push the new task onto the queue\n\n\n      this._pending.add(task);\n    } // Indicates whether the new task adds any more information over tasks that are\n    // already in the active task queue\n\n  }, {\n    key: \"_taskHasMoreInfoThanActiveTasks\",\n    value: function _taskHasMoreInfoThanActiveTasks(task) {\n      var tasksWithTopic = [];\n\n      var _iterator4 = _createForOfIteratorHelper(this._active),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var activeTask = _step4.value;\n\n          if (activeTask.topic === task.topic) {\n            tasksWithTopic.push(activeTask);\n          }\n        } // No tasks with that topic, so the new task adds information\n\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      if (tasksWithTopic.length === 0) {\n        return true;\n      }\n\n      return this._taskMerger.hasNewInfo(task, tasksWithTopic);\n    }\n    /**\n     * Pop tasks off the queue such that the total size is at least targetMinBytes\n     * @param {number} targetMinBytes\n     * @returns {Object}\n     */\n\n  }, {\n    key: \"popTasks\",\n    value: function popTasks(targetMinBytes) {\n      var size = 0;\n      var tasks = []; // Keep popping tasks until we get up to targetMinBytes (or one item over\n      // targetMinBytes)\n\n      var pendingTasks = this._pending.tasks();\n\n      for (var i = 0; i < pendingTasks.length && size < targetMinBytes; i++) {\n        var task = pendingTasks[i];\n        tasks.push(task);\n        size += task.size; // Move tasks from pending to active\n\n        this._pending.delete(task.topic);\n\n        this._activeTotalSize += task.size;\n\n        this._active.add(task);\n      }\n\n      return {\n        tasks: tasks,\n        pendingSize: this._pending.totalSize\n      };\n    }\n    /**\n     * Called when a task completes.\n     * Note: must be the same reference as returned from popTasks.\n     * @param {Task} task\n     */\n\n  }, {\n    key: \"taskDone\",\n    value: function taskDone(task) {\n      if (this._active.has(task)) {\n        this._activeTotalSize -= task.size;\n\n        this._active.delete(task);\n      }\n    }\n    /**\n     * Remove pending tasks with the given topic\n     * @param {string} topic\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(topic) {\n      this._pending.delete(topic);\n    }\n    /**\n     * No work to be done, this PeerTasks object can be freed.\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isIdle\",\n    value: function isIdle() {\n      return this._pending.length === 0 && this._active.length === 0;\n    } // Compare PeerTasks\n\n  }], [{\n    key: \"compare\",\n    value: function compare(a, b) {\n      // Move peers with no pending tasks to the back of the queue\n      if (a[1]._pending.length === 0) {\n        return 1;\n      }\n\n      if (b[1]._pending.length === 0) {\n        return -1;\n      } // If the amount of active work is the same\n\n\n      if (a[1]._activeTotalSize === b[1]._activeTotalSize) {\n        // Choose the peer with the most pending work\n        return b[1]._pending.length - a[1]._pending.length;\n      } // Choose the peer with the least amount of active work (\"keep peers busy\")\n\n\n      return a[1]._activeTotalSize - b[1]._activeTotalSize;\n    }\n  }]);\n\n  return PeerTasks;\n}();\n/**\n * Queue of pending tasks for a particular peer, sorted by priority.\n */\n\n\nvar PendingTasks = /*#__PURE__*/function () {\n  function PendingTasks() {\n    _classCallCheck(this, PendingTasks);\n\n    this._tasks = new SortedMap([], this._compare);\n  }\n\n  _createClass(PendingTasks, [{\n    key: \"length\",\n    get: function get() {\n      return this._tasks.size;\n    } // Sum of the size of all pending tasks\n\n  }, {\n    key: \"totalSize\",\n    get: function get() {\n      return _toConsumableArray(this._tasks.values()).reduce(function (a, t) {\n        return a + t.task.size;\n      }, 0);\n    }\n  }, {\n    key: \"get\",\n    value: function get(topic) {\n      return (this._tasks.get(topic) || {}).task;\n    }\n  }, {\n    key: \"add\",\n    value: function add(task) {\n      this._tasks.set(task.topic, {\n        created: Date.now(),\n        task: task\n      });\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(topic) {\n      this._tasks.delete(topic);\n    } // All pending tasks, in priority order\n\n  }, {\n    key: \"tasks\",\n    value: function tasks() {\n      return _toConsumableArray(this._tasks.values()).map(function (i) {\n        return i.task;\n      });\n    } // Update the priority of the task with the given topic, and update the order\n\n  }, {\n    key: \"updatePriority\",\n    value: function updatePriority(topic, priority) {\n      var obj = this._tasks.get(topic);\n\n      if (!obj) {\n        return;\n      }\n\n      var i = this._tasks.indexOf(topic);\n\n      obj.task.priority = priority;\n\n      this._tasks.update(i);\n    } // Sort by priority desc then FIFO\n\n  }, {\n    key: \"_compare\",\n    value: function _compare(a, b) {\n      if (a[1].task.priority === b[1].task.priority) {\n        // FIFO\n        return a[1].created - b[1].created;\n      } // Priority high -> low\n\n\n      return b[1].task.priority - a[1].task.priority;\n    }\n  }]);\n\n  return PendingTasks;\n}();\n\nmodule.exports = RequestQueue;","map":null,"metadata":{},"sourceType":"script"}