{"ast":null,"code":"/* eslint max-nested-callbacks: [\"error\", 5] */\n'use strict';\n\nconst sanitize = require('sanitize-filename');\n\nconst mergeOptions = require('merge-options');\n\nconst crypto = require('libp2p-crypto');\n\nconst DS = require('interface-datastore');\n\nconst CMS = require('./cms');\n\nconst errcode = require('err-code');\n\nconst keyPrefix = '/pkcs8/';\nconst infoPrefix = '/info/'; // NIST SP 800-132\n\nconst NIST = {\n  minKeyLength: 112 / 8,\n  minSaltLength: 128 / 8,\n  minIterationCount: 1000\n};\nconst defaultOptions = {\n  // See https://cryptosense.com/parametesr-choice-for-pbkdf2/\n  dek: {\n    keyLength: 512 / 8,\n    iterationCount: 10000,\n    salt: 'you should override this value with a crypto secure random number',\n    hash: 'sha2-512'\n  }\n};\n\nfunction validateKeyName(name) {\n  if (!name) return false;\n  if (typeof name !== 'string') return false;\n  return name === sanitize(name.trim());\n}\n/**\n * Throws an error after a delay\n *\n * This assumes than an error indicates that the keychain is under attack. Delay returning an\n * error to make brute force attacks harder.\n *\n * @param {string | Error} err - The error\n * @private\n */\n\n\nasync function throwDelayed(err) {\n  const min = 200;\n  const max = 1000;\n  const delay = Math.random() * (max - min) + min;\n  await new Promise(resolve => setTimeout(resolve, delay));\n  throw err;\n}\n/**\n * Converts a key name into a datastore name.\n *\n * @param {string} name\n * @returns {DS.Key}\n * @private\n */\n\n\nfunction DsName(name) {\n  return new DS.Key(keyPrefix + name);\n}\n/**\n * Converts a key name into a datastore info name.\n *\n * @param {string} name\n * @returns {DS.Key}\n * @private\n */\n\n\nfunction DsInfoName(name) {\n  return new DS.Key(infoPrefix + name);\n}\n/**\n * Information about a key.\n *\n * @typedef {Object} KeyInfo\n *\n * @property {string} id - The universally unique key id.\n * @property {string} name - The local key name.\n */\n\n/**\n * Manages the lifecycle of a key. Keys are encrypted at rest using PKCS #8.\n *\n * A key in the store has two entries\n * - '/info/*key-name*', contains the KeyInfo for the key\n * - '/pkcs8/*key-name*', contains the PKCS #8 for the key\n *\n */\n\n\nclass Keychain {\n  /**\n   * Creates a new instance of a key chain.\n   *\n   * @param {DS} store - where the key are.\n   * @param {object} options - ???\n   */\n  constructor(store, options) {\n    if (!store) {\n      throw new Error('store is required');\n    }\n\n    this.store = store;\n    const opts = mergeOptions(defaultOptions, options); // Enforce NIST SP 800-132\n\n    if (!opts.passPhrase || opts.passPhrase.length < 20) {\n      throw new Error('passPhrase must be least 20 characters');\n    }\n\n    if (opts.dek.keyLength < NIST.minKeyLength) {\n      throw new Error(`dek.keyLength must be least ${NIST.minKeyLength} bytes`);\n    }\n\n    if (opts.dek.salt.length < NIST.minSaltLength) {\n      throw new Error(`dek.saltLength must be least ${NIST.minSaltLength} bytes`);\n    }\n\n    if (opts.dek.iterationCount < NIST.minIterationCount) {\n      throw new Error(`dek.iterationCount must be least ${NIST.minIterationCount}`);\n    } // Create the derived encrypting key\n\n\n    const dek = crypto.pbkdf2(opts.passPhrase, opts.dek.salt, opts.dek.iterationCount, opts.dek.keyLength, opts.dek.hash);\n    Object.defineProperty(this, '_', {\n      value: () => dek\n    });\n  }\n  /**\n   * Gets an object that can encrypt/decrypt protected data\n   * using the Cryptographic Message Syntax (CMS).\n   *\n   * CMS describes an encapsulation syntax for data protection. It\n   * is used to digitally sign, digest, authenticate, or encrypt\n   * arbitrary message content.\n   *\n   * @returns {CMS}\n   */\n\n\n  get cms() {\n    return new CMS(this);\n  }\n  /**\n   * Generates the options for a keychain.  A random salt is produced.\n   *\n   * @returns {object}\n   */\n\n\n  static generateOptions() {\n    const options = Object.assign({}, defaultOptions);\n    const saltLength = Math.ceil(NIST.minSaltLength / 3) * 3; // no base64 padding\n\n    options.dek.salt = crypto.randomBytes(saltLength).toString('base64');\n    return options;\n  }\n  /**\n   * Gets an object that can encrypt/decrypt protected data.\n   * The default options for a keychain.\n   *\n   * @returns {object}\n   */\n\n\n  static get options() {\n    return defaultOptions;\n  }\n  /**\n   * Create a new key.\n   *\n   * @param {string} name - The local key name; cannot already exist.\n   * @param {string} type - One of the key types; 'rsa'.\n   * @param {int} size - The key size in bits.\n    * @returns {KeyInfo}\n   */\n\n\n  async createKey(name, type, size) {\n    const self = this;\n\n    if (!validateKeyName(name) || name === 'self') {\n      return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'));\n    }\n\n    if (typeof type !== 'string') {\n      return throwDelayed(errcode(new Error(`Invalid key type '${type}'`), 'ERR_INVALID_KEY_TYPE'));\n    }\n\n    if (!Number.isSafeInteger(size)) {\n      return throwDelayed(errcode(new Error(`Invalid key size '${size}'`), 'ERR_INVALID_KEY_SIZE'));\n    }\n\n    const dsname = DsName(name);\n    const exists = await self.store.has(dsname);\n    if (exists) return throwDelayed(errcode(new Error(`Key '${name}' already exists`), 'ERR_KEY_ALREADY_EXISTS'));\n\n    switch (type.toLowerCase()) {\n      case 'rsa':\n        if (size < 2048) {\n          return throwDelayed(errcode(new Error(`Invalid RSA key size ${size}`), 'ERR_INVALID_KEY_SIZE'));\n        }\n\n        break;\n\n      default:\n        break;\n    }\n\n    let keyInfo;\n\n    try {\n      const keypair = await crypto.keys.generateKeyPair(type, size);\n      const kid = await keypair.id();\n      const pem = await keypair.export(this._());\n      keyInfo = {\n        name: name,\n        id: kid\n      };\n      const batch = self.store.batch();\n      batch.put(dsname, pem);\n      batch.put(DsInfoName(name), JSON.stringify(keyInfo));\n      await batch.commit();\n    } catch (err) {\n      return throwDelayed(err);\n    }\n\n    return keyInfo;\n  }\n  /**\n   * List all the keys.\n   *\n    * @returns {KeyInfo[]}\n   */\n\n\n  async listKeys() {\n    const self = this;\n    const query = {\n      prefix: infoPrefix\n    };\n    const info = [];\n\n    for await (const value of self.store.query(query)) {\n      info.push(JSON.parse(value.value));\n    }\n\n    return info;\n  }\n  /**\n   * Find a key by it's id.\n   *\n   * @param {string} id - The universally unique key identifier.\n    * @returns {KeyInfo}\n   */\n\n\n  async findKeyById(id) {\n    try {\n      const keys = await this.listKeys();\n      return keys.find(k => k.id === id);\n    } catch (err) {\n      return throwDelayed(err);\n    }\n  }\n  /**\n   * Find a key by it's name.\n   *\n   * @param {string} name - The local key name.\n    * @returns {KeyInfo}\n   */\n\n\n  async findKeyByName(name) {\n    if (!validateKeyName(name)) {\n      return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'));\n    }\n\n    const dsname = DsInfoName(name);\n\n    try {\n      const res = await this.store.get(dsname);\n      return JSON.parse(res.toString());\n    } catch (err) {\n      return throwDelayed(errcode(new Error(`Key '${name}' does not exist. ${err.message}`), 'ERR_KEY_NOT_FOUND'));\n    }\n  }\n  /**\n   * Remove an existing key.\n   *\n   * @param {string} name - The local key name; must already exist.\n    * @returns {KeyInfo}\n   */\n\n\n  async removeKey(name) {\n    const self = this;\n\n    if (!validateKeyName(name) || name === 'self') {\n      return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'));\n    }\n\n    const dsname = DsName(name);\n    const keyInfo = await self.findKeyByName(name);\n    const batch = self.store.batch();\n    batch.delete(dsname);\n    batch.delete(DsInfoName(name));\n    await batch.commit();\n    return keyInfo;\n  }\n  /**\n   * Rename a key\n   *\n   * @param {string} oldName - The old local key name; must already exist.\n   * @param {string} newName - The new local key name; must not already exist.\n    * @returns {KeyInfo}\n   */\n\n\n  async renameKey(oldName, newName) {\n    const self = this;\n\n    if (!validateKeyName(oldName) || oldName === 'self') {\n      return throwDelayed(errcode(new Error(`Invalid old key name '${oldName}'`), 'ERR_OLD_KEY_NAME_INVALID'));\n    }\n\n    if (!validateKeyName(newName) || newName === 'self') {\n      return throwDelayed(errcode(new Error(`Invalid new key name '${newName}'`), 'ERR_NEW_KEY_NAME_INVALID'));\n    }\n\n    const oldDsname = DsName(oldName);\n    const newDsname = DsName(newName);\n    const oldInfoName = DsInfoName(oldName);\n    const newInfoName = DsInfoName(newName);\n    const exists = await self.store.has(newDsname);\n    if (exists) return throwDelayed(errcode(new Error(`Key '${newName}' already exists`), 'ERR_KEY_ALREADY_EXISTS'));\n\n    try {\n      let res = await this.store.get(oldDsname);\n      const pem = res.toString();\n      res = await self.store.get(oldInfoName);\n      const keyInfo = JSON.parse(res.toString());\n      keyInfo.name = newName;\n      const batch = self.store.batch();\n      batch.put(newDsname, pem);\n      batch.put(newInfoName, JSON.stringify(keyInfo));\n      batch.delete(oldDsname);\n      batch.delete(oldInfoName);\n      await batch.commit();\n      return keyInfo;\n    } catch (err) {\n      return throwDelayed(err);\n    }\n  }\n  /**\n   * Export an existing key as a PEM encrypted PKCS #8 string\n   *\n   * @param {string} name - The local key name; must already exist.\n   * @param {string} password - The password\n    * @returns {string}\n   */\n\n\n  async exportKey(name, password) {\n    if (!validateKeyName(name)) {\n      return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'));\n    }\n\n    if (!password) {\n      return throwDelayed(errcode(new Error('Password is required'), 'ERR_PASSWORD_REQUIRED'));\n    }\n\n    const dsname = DsName(name);\n\n    try {\n      const res = await this.store.get(dsname);\n      const pem = res.toString();\n      const privateKey = await crypto.keys.import(pem, this._());\n      return privateKey.export(password);\n    } catch (err) {\n      return throwDelayed(err);\n    }\n  }\n  /**\n   * Import a new key from a PEM encoded PKCS #8 string\n   *\n   * @param {string} name - The local key name; must not already exist.\n   * @param {string} pem - The PEM encoded PKCS #8 string\n   * @param {string} password - The password.\n    * @returns {KeyInfo}\n   */\n\n\n  async importKey(name, pem, password) {\n    const self = this;\n\n    if (!validateKeyName(name) || name === 'self') {\n      return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'));\n    }\n\n    if (!pem) {\n      return throwDelayed(errcode(new Error('PEM encoded key is required'), 'ERR_PEM_REQUIRED'));\n    }\n\n    const dsname = DsName(name);\n    const exists = await self.store.has(dsname);\n    if (exists) return throwDelayed(errcode(new Error(`Key '${name}' already exists`), 'ERR_KEY_ALREADY_EXISTS'));\n    let privateKey;\n\n    try {\n      privateKey = await crypto.keys.import(pem, password);\n    } catch (err) {\n      return throwDelayed(errcode(new Error('Cannot read the key, most likely the password is wrong'), 'ERR_CANNOT_READ_KEY'));\n    }\n\n    let kid;\n\n    try {\n      kid = await privateKey.id();\n      pem = await privateKey.export(this._());\n    } catch (err) {\n      return throwDelayed(err);\n    }\n\n    const keyInfo = {\n      name: name,\n      id: kid\n    };\n    const batch = self.store.batch();\n    batch.put(dsname, pem);\n    batch.put(DsInfoName(name), JSON.stringify(keyInfo));\n    await batch.commit();\n    return keyInfo;\n  }\n\n  async importPeer(name, peer) {\n    const self = this;\n\n    if (!validateKeyName(name)) {\n      return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'));\n    }\n\n    if (!peer || !peer.privKey) {\n      return throwDelayed(errcode(new Error('Peer.privKey is required'), 'ERR_MISSING_PRIVATE_KEY'));\n    }\n\n    const privateKey = peer.privKey;\n    const dsname = DsName(name);\n    const exists = await self.store.has(dsname);\n    if (exists) return throwDelayed(errcode(new Error(`Key '${name}' already exists`), 'ERR_KEY_ALREADY_EXISTS'));\n\n    try {\n      const kid = await privateKey.id();\n      const pem = await privateKey.export(this._());\n      const keyInfo = {\n        name: name,\n        id: kid\n      };\n      const batch = self.store.batch();\n      batch.put(dsname, pem);\n      batch.put(DsInfoName(name), JSON.stringify(keyInfo));\n      await batch.commit();\n      return keyInfo;\n    } catch (err) {\n      return throwDelayed(err);\n    }\n  }\n  /**\n   * Gets the private key as PEM encoded PKCS #8 string.\n   *\n   * @param {string} name\n    * @returns {string}\n   * @private\n   */\n\n\n  async _getPrivateKey(name) {\n    if (!validateKeyName(name)) {\n      return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), 'ERR_INVALID_KEY_NAME'));\n    }\n\n    try {\n      const dsname = DsName(name);\n      const res = await this.store.get(dsname);\n      return res.toString();\n    } catch (err) {\n      return throwDelayed(errcode(new Error(`Key '${name}' does not exist. ${err.message}`), 'ERR_KEY_NOT_FOUND'));\n    }\n  }\n\n}\n\nmodule.exports = Keychain;","map":null,"metadata":{},"sourceType":"script"}