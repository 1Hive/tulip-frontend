{"ast":null,"code":"/*!\n * bn.js - big numbers for bcrypto\n * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Parts of this software are based on indutny/bn.js:\n *   Copyright (c) 2015, Fedor Indutny (MIT License).\n *   https://github.com/indutny/bn.js\n *\n * Parts of this software are based on golang/go:\n *   Copyright (c) 2009, The Go Authors. All rights reserved.\n *   https://github.com/golang/go\n *\n * Parts of this software are based on openssl/openssl:\n *   Copyright (c) 1998-2018, The OpenSSL Project (Apache License v2.0).\n *   Copyright (c) 1995-1998, Eric A. Young, Tim J. Hudson. All rights reserved.\n *   https://github.com/openssl/openssl\n *\n * Parts of this software are based on libgmp:\n *   Copyright (c) 1991-1997, 1999-2014, Free Software Foundation, Inc.\n *   https://gmplib.org/\n *\n * Parts of this software are based on v8/v8:\n *   Copyright (c) 2017, The V8 Project Authors (BSD-Style License).\n *   https://github.com/v8/v8\n *\n * Resources:\n *   https://github.com/indutny/bn.js/blob/master/lib/bn.js\n *   https://github.com/indutny/miller-rabin/blob/master/lib/mr.js\n *   https://github.com/golang/go/blob/master/src/math/big/int.go\n *   https://github.com/golang/go/blob/master/src/math/big/nat.go\n *   https://github.com/golang/go/blob/master/src/math/big/prime.go\n *   https://github.com/openssl/openssl/tree/master/crypto/bn\n *   https://github.com/openssl/openssl/blob/master/crypto/bn/bn_kron.c\n *   https://github.com/gnutls/nettle/blob/master/mini-gmp.c\n *   https://github.com/v8/v8/blob/master/src/objects/bigint.cc\n */\n\n/* eslint valid-typeof: \"off\" */\n'use strict';\n\nvar _get = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _createForOfIteratorHelper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _slicedToArray = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _require = require('../internal/custom'),\n    custom = _require.custom;\n/*\n * Constants\n */\n\n\nvar zeros = ['', '0', '00', '000', '0000', '00000', '000000', '0000000', '00000000', '000000000', '0000000000', '00000000000', '000000000000', '0000000000000', '00000000000000', '000000000000000', '0000000000000000', '00000000000000000', '000000000000000000', '0000000000000000000', '00000000000000000000', '000000000000000000000', '0000000000000000000000', '00000000000000000000000', '000000000000000000000000', '0000000000000000000000000'];\nvar groupSizes = [0x00, 0x19, 0x10, 0x0c, 0x0b, 0x0a, 0x09, 0x08, 0x08, 0x07, 0x07, 0x07, 0x07, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05, 0x05];\nvar groupBases = [0x00000000, 0x02000000, 0x0290d741, 0x01000000, 0x02e90edd, 0x039aa400, 0x0267bf47, 0x01000000, 0x0290d741, 0x00989680, 0x012959c3, 0x0222c000, 0x03bd7765, 0x0072e440, 0x00adcea1, 0x01000000, 0x01704f61, 0x0206fc40, 0x02cddcf9, 0x03d09000, 0x003e5185, 0x004ea360, 0x006235f7, 0x00798000, 0x009502f9, 0x00b54ba0, 0x00daf26b, 0x01069c00, 0x0138f9ad, 0x0172c9e0, 0x01b4d89f, 0x02000000, 0x025528a1, 0x02b54a20, 0x03216b93, 0x039aa400];\nvar primes = {\n  p192: null,\n  p224: null,\n  p521: null,\n  k256: null,\n  p25519: null,\n  p448: null\n};\nvar modes = {\n  NONE: 0,\n  QUO: 1,\n  REM: 2,\n  BOTH: 3,\n  EUCLID: 4,\n  ALL: 7\n};\nvar WND_WIDTH = 4;\nvar WND_SIZE = 1 << WND_WIDTH - 1;\nvar HAS_BIGINT = typeof BigInt === 'function';\n/**\n * BN\n */\n\nvar BN = /*#__PURE__*/function () {\n  function BN(num, base, endian) {\n    _classCallCheck(this, BN);\n\n    this.words = [0];\n    this.length = 1;\n    this.negative = 0;\n    this.red = null;\n    this.from(num, base, endian);\n  }\n  /*\n   * Addition Engine\n   */\n\n\n  _createClass(BN, [{\n    key: \"_iadd\",\n    value: function _iadd(a, b) {\n      var carry = 0;\n      var i = 0; // a.length > b.length\n\n      if (a.length < b.length) {\n        var _ref = [b, a];\n        a = _ref[0];\n        b = _ref[1];\n      }\n\n      if (a !== this) this._alloc(a.length);\n\n      for (; i < b.length; i++) {\n        var r = (a.words[i] | 0) + (b.words[i] | 0) + carry;\n        this.words[i] = r & 0x3ffffff;\n        carry = r >>> 26;\n      }\n\n      for (; carry !== 0 && i < a.length; i++) {\n        var _r = (a.words[i] | 0) + carry;\n\n        this.words[i] = _r & 0x3ffffff;\n        carry = _r >>> 26;\n      }\n\n      this.length = a.length;\n\n      if (carry !== 0) {\n        this._alloc(this.length + 1);\n\n        this.words[this.length++] = carry;\n      } else if (a !== this) {\n        // Copy the rest of the words.\n        for (; i < a.length; i++) {\n          this.words[i] = a.words[i];\n        }\n      } // Note: we shouldn't need to strip here.\n\n\n      return this;\n    }\n  }, {\n    key: \"_iaddn\",\n    value: function _iaddn(num) {\n      this.words[0] += num;\n      if (this.words[0] < 0x4000000) return this; // Carry.\n\n      var i = 0;\n\n      this._alloc(this.length + 1);\n\n      this.words[this.length] = 0;\n\n      for (; i < this.length && this.words[i] >= 0x4000000; i++) {\n        this.words[i] -= 0x4000000;\n        this.words[i + 1] += 1;\n      }\n\n      this.length = Math.max(this.length, i + 1); // Note: we shouldn't need to strip here.\n\n      return this;\n    }\n    /*\n     * Addition\n     */\n\n  }, {\n    key: \"iadd\",\n    value: function iadd(num) {\n      enforce(BN.isBN(num), 'num', 'bignum');\n\n      if (this.negative === num.negative) {\n        // x + y == x + y\n        // (-x) + (-y) == -(x + y)\n        this._iadd(this, num);\n      } else {\n        // x + (-y) == x - y == -(y - x)\n        // (-x) + y == y - x == -(x - y)\n        var cmp = this.ucmp(num); // x + (-x) == (-x) + x == 0\n\n        if (cmp === 0) {\n          this.words[0] = 0;\n          this.length = 1;\n          this.negative = 0;\n          return this;\n        }\n\n        if (cmp < 0) {\n          this._isub(num, this);\n\n          this.negative ^= 1;\n        } else {\n          this._isub(this, num);\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"iaddn\",\n    value: function iaddn(num) {\n      enforce(isSMI(num), 'num', 'smi');\n      var negative = num < 0 | 0;\n      if (negative) num = -num;\n\n      if (this.negative === negative) {\n        // x + y == x + y\n        // (-x) + (-y) == -(x + y)\n        this._iaddn(num);\n      } else {\n        // x + (-y) == x - y == -(y - x)\n        // (-x) + y == y - x == -(x - y)\n        if (this.length === 1 && this.words[0] < num) {\n          this.words[0] = num - this.words[0];\n          this.negative ^= 1;\n        } else {\n          this._isubn(num);\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"add\",\n    value: function add(num) {\n      enforce(BN.isBN(num), 'num', 'bignum');\n      if (num.length > this.length) return num.clone().iadd(this);\n      return this.clone().iadd(num);\n    }\n  }, {\n    key: \"addn\",\n    value: function addn(num) {\n      return this.clone().iaddn(num);\n    }\n    /*\n     * Subtraction Engine\n     */\n\n  }, {\n    key: \"_isub\",\n    value: function _isub(a, b) {\n      var carry = 0;\n      var i = 0; // a > b\n\n      assert(a.length >= b.length);\n      if (a !== this) this._alloc(a.length);\n\n      for (; i < b.length; i++) {\n        var r = (a.words[i] | 0) - (b.words[i] | 0) + carry;\n        carry = r >> 26;\n        this.words[i] = r & 0x3ffffff;\n      }\n\n      for (; carry !== 0 && i < a.length; i++) {\n        var _r2 = (a.words[i] | 0) + carry;\n\n        carry = _r2 >> 26;\n        this.words[i] = _r2 & 0x3ffffff;\n      }\n\n      assert(carry === 0); // Copy rest of the words.\n\n      if (a !== this) {\n        for (; i < a.length; i++) {\n          this.words[i] = a.words[i];\n        }\n      }\n\n      this.length = Math.max(this.length, i);\n      return this._strip();\n    }\n  }, {\n    key: \"_isubn\",\n    value: function _isubn(num) {\n      this.words[0] -= num;\n      if (this.words[0] >= 0) return this._normalize();\n      assert(this.length !== 1); // Carry.\n\n      this._alloc(this.length + 1);\n\n      for (var i = 0; i < this.length && this.words[i] < 0; i++) {\n        this.words[i] += 0x4000000;\n        this.words[i + 1] -= 1;\n      }\n\n      this.words[this.length] = 0;\n      return this._strip();\n    }\n    /*\n     * Subtraction\n     */\n\n  }, {\n    key: \"isub\",\n    value: function isub(num) {\n      enforce(BN.isBN(num), 'num', 'bignum');\n\n      if (this.negative !== num.negative) {\n        // x - (-y) == x + y\n        // (-x) - y == -(x + y)\n        this._iadd(this, num);\n      } else {\n        // x - y == x - y == -(y - x)\n        // (-x) - (-y) == y - x == -(x - y)\n        var cmp = this.ucmp(num); // x - x == 0\n\n        if (cmp === 0) {\n          this.words[0] = 0;\n          this.length = 1;\n          this.negative = 0;\n          return this;\n        }\n\n        if (cmp < 0) {\n          this._isub(num, this);\n\n          this.negative ^= 1;\n        } else {\n          this._isub(this, num);\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"isubn\",\n    value: function isubn(num) {\n      enforce(isSMI(num), 'num', 'smi');\n      var negative = num < 0 | 0;\n      if (negative) num = -num;\n\n      if (this.negative !== negative) {\n        // x - (-y) == x + y\n        // (-x) - y == -(x + y)\n        this._iaddn(num);\n      } else {\n        // x - y == x - y == -(y - x)\n        // (-x) - (-y) == y - x == -(x - y)\n        if (this.length === 1 && this.words[0] < num) {\n          this.words[0] = num - this.words[0];\n          this.negative ^= 1;\n        } else {\n          this._isubn(num);\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"sub\",\n    value: function sub(num) {\n      return this.clone().isub(num);\n    }\n  }, {\n    key: \"subn\",\n    value: function subn(num) {\n      return this.clone().isubn(num);\n    }\n    /*\n     * Multiplication Engine\n     */\n\n  }, {\n    key: \"_mul\",\n    value: function _mul(num, out) {\n      enforce(BN.isBN(num), 'num', 'bignum');\n      enforce(BN.isBN(out), 'out', 'bignum');\n      if (this.length === 10 && num.length === 10) return comb10MulTo(this, num, out);\n      var len = this.length + num.length;\n      if (len < 63) return smallMulTo(this, num, out);\n      if (len < 1024) return bigMulTo(this, num, out);\n      return jumboMulTo(this, num, out);\n    }\n    /*\n     * Multiplication\n     */\n\n  }, {\n    key: \"imul\",\n    value: function imul(num) {\n      return this.mul(num)._move(this);\n    }\n  }, {\n    key: \"imuln\",\n    value: function imuln(num) {\n      enforce(isSMI(num), 'num', 'smi');\n      var neg = num < 0 | 0;\n      if (neg) num = -num; // Carry.\n\n      var carry = 0;\n\n      for (var i = 0; i < this.length; i++) {\n        var w = this.words[i] * num;\n        var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);\n        carry >>= 26;\n        carry += w / 0x4000000 | 0;\n        carry += lo >>> 26;\n        this.words[i] = lo & 0x3ffffff;\n      }\n\n      this.negative ^= neg;\n\n      if (carry !== 0) {\n        this._alloc(this.length + 1);\n\n        this.words[this.length++] = carry;\n      } else {\n        this._strip();\n      }\n\n      return this;\n    }\n  }, {\n    key: \"mul\",\n    value: function mul(num) {\n      enforce(BN.isBN(num), 'num', 'bignum');\n      var len = this.length + num.length;\n      var out = new BN();\n      out.words = new Array(len);\n\n      for (var i = 0; i < len; i++) {\n        out.words[i] = 0;\n      }\n\n      return this._mul(num, out);\n    }\n  }, {\n    key: \"muln\",\n    value: function muln(num) {\n      return this.clone().imuln(num);\n    }\n    /*\n     * Multiplication + Shift\n     */\n\n  }, {\n    key: \"mulShift\",\n    value: function mulShift(num, bits) {\n      enforce(BN.isBN(num), 'num', 'bignum');\n      enforce(bits >>> 0 === bits, 'bits', 'uint32');\n      var r = this.mul(num);\n      var b = r.utestn(bits - 1);\n      r.iushrn(bits);\n      if (this.negative ^ num.negative) return r.isubn(b);\n      return r.iaddn(b);\n    }\n    /*\n     * Division Engine\n     */\n\n  }, {\n    key: \"_div\",\n    value: function _div(num, flags) {\n      enforce(BN.isBN(num), 'num', 'bignum');\n      assert((flags & modes.ALL) === flags);\n      assert(flags !== modes.NONE);\n      var a = this;\n      var b = num;\n      nonzero(!b.isZero());\n      if (a.isZero()) return [new BN(0), new BN(0)];\n      var as = a.negative;\n      var bs = b.negative;\n      a.negative = 0;\n      b.negative = 0;\n      var q = null;\n      var r = null;\n\n      if (a.ucmp(b) < 0) {\n        if (flags & modes.QUO) q = new BN(0);\n        if (flags & modes.REM) r = a.clone();\n      } else if (b.length === 1) {\n        if (flags & modes.QUO) q = a.quon(b.words[0]);\n        if (flags & modes.REM) r = a.remn(b.words[0]);\n      } else {\n        var _a$_wordDiv = a._wordDiv(b, flags);\n\n        var _a$_wordDiv2 = _slicedToArray(_a$_wordDiv, 2);\n\n        q = _a$_wordDiv2[0];\n        r = _a$_wordDiv2[1];\n      }\n\n      a.negative = as;\n      b.negative = bs;\n\n      if (flags & modes.QUO) {\n        q.negative = a.negative ^ b.negative;\n\n        q._normalize();\n      }\n\n      if (flags & modes.REM) {\n        r.negative = a.negative;\n\n        r._normalize();\n      }\n\n      if (flags & modes.EUCLID) {\n        if (flags & modes.QUO) {\n          assert((flags & modes.REM) !== 0);\n\n          if (r.negative !== 0) {\n            if (b.negative !== 0) q.iaddn(1);else q.isubn(1);\n          }\n        }\n\n        if (flags & modes.REM) {\n          if (r.negative !== 0) {\n            if (b.negative !== 0) r.isub(b);else r.iadd(b);\n          }\n        }\n      }\n\n      return [q, r];\n    }\n  }, {\n    key: \"_wordDiv\",\n    value: function _wordDiv(num, flags) {\n      var a = this.clone();\n      var b = num;\n      var q = null;\n      var hi; // Normalize.\n\n      var word = b.words[b.length - 1] | 0;\n      var shift = 26 - countBits(word);\n\n      if (shift !== 0) {\n        b = b.clone();\n        a.iushln(shift);\n        b.iushln(shift);\n        hi = b.words[b.length - 1] | 0;\n      } else {\n        hi = word;\n      } // Initialize quotient.\n\n\n      var m = a.length - b.length;\n      assert(m >= 0);\n\n      if (flags & modes.QUO) {\n        q = new BN(0);\n        q.length = m + 1;\n        q.words = new Array(q.length);\n\n        for (var i = 0; i < q.length; i++) {\n          q.words[i] = 0;\n        }\n      } // Diff.\n\n\n      var d = a.clone();\n\n      d._ishlnsubmul(b, 1, m);\n\n      if (d.negative === 0) {\n        if (q) q.words[m] = 1;\n        a = d;\n      } // Divide.\n\n\n      for (var j = m - 1; j >= 0; j--) {\n        var ahi = a.words[b.length + j];\n        var alo = a.words[b.length + j - 1];\n        var quo = (ahi * 0x4000000 + alo) / hi | 0;\n        var qj = Math.min(quo, 0x3ffffff);\n\n        a._ishlnsubmul(b, qj, j);\n\n        while (a.negative !== 0) {\n          qj -= 1;\n          a.negative = 0;\n\n          a._ishlnsubmul(b, 1, j);\n\n          a.ineg();\n        }\n\n        if (q) q.words[j] = qj;\n      } // Strip.\n\n\n      if (q) q._strip(); // Denormalize.\n      // Note: we shouldn't need to strip `a` here.\n\n      if (flags & modes.REM && shift !== 0) a.iushrn(shift);\n      return [q, a];\n    }\n  }, {\n    key: \"_ishlnsubmul\",\n    value: function _ishlnsubmul(num, mul, shift) {\n      var carry = 0;\n      var i = 0;\n\n      this._expand(num.length + shift);\n\n      for (; i < num.length; i++) {\n        var k = (this.words[i + shift] | 0) + carry;\n        var r = num.words[i] * mul;\n        var w = k - (r & 0x3ffffff);\n        carry = (w >> 26) - (r / 0x4000000 | 0);\n        this.words[i + shift] = w & 0x3ffffff;\n      }\n\n      for (; i < this.length - shift; i++) {\n        var _w = (this.words[i + shift] | 0) + carry;\n\n        carry = _w >> 26;\n        this.words[i + shift] = _w & 0x3ffffff;\n      }\n\n      if (carry === 0) return this._strip(); // Subtraction overflow.\n\n      assert(carry === -1);\n      carry = 0;\n\n      for (var _i = 0; _i < this.length; _i++) {\n        var _w2 = -(this.words[_i] | 0) + carry;\n\n        carry = _w2 >> 26;\n        this.words[_i] = _w2 & 0x3ffffff;\n      }\n\n      this.negative = 1;\n      return this._strip();\n    }\n    /*\n     * Truncation Division + Modulo\n     */\n\n  }, {\n    key: \"quorem\",\n    value: function quorem(num) {\n      return this._div(num, modes.BOTH);\n    }\n    /*\n     * Truncation Division\n     */\n\n  }, {\n    key: \"iquo\",\n    value: function iquo(num) {\n      return this.quo(num)._move(this);\n    }\n  }, {\n    key: \"iquon\",\n    value: function iquon(num) {\n      enforce(isSMI(num), 'num', 'smi');\n      nonzero(num !== 0);\n      var neg = num < 0 | 0;\n      if (neg) num = -num;\n      var carry = 0;\n\n      for (var i = this.length - 1; i >= 0; i--) {\n        var w = (this.words[i] | 0) + carry * 0x4000000;\n        this.words[i] = w / num | 0;\n        carry = w % num;\n      }\n\n      this.negative ^= neg;\n      return this._strip();\n    }\n  }, {\n    key: \"quo\",\n    value: function quo(num) {\n      return this._div(num, modes.QUO)[0];\n    }\n  }, {\n    key: \"quon\",\n    value: function quon(num) {\n      return this.clone().iquon(num);\n    }\n    /*\n     * Truncation Modulo\n     */\n\n  }, {\n    key: \"irem\",\n    value: function irem(num) {\n      return this.rem(num)._move(this);\n    }\n  }, {\n    key: \"iremn\",\n    value: function iremn(num) {\n      var m = this.remrn(num);\n      if (m < 0) m = -m;\n      this.words[0] = m;\n      this.length = 1;\n      return this._normalize();\n    }\n  }, {\n    key: \"rem\",\n    value: function rem(num) {\n      return this._div(num, modes.REM)[1];\n    }\n  }, {\n    key: \"remn\",\n    value: function remn(num) {\n      return this.clone().iremn(num);\n    }\n  }, {\n    key: \"remrn\",\n    value: function remrn(num) {\n      enforce(isSMI(num), 'num', 'smi');\n      nonzero(num !== 0);\n      if (num < 0) num = -num;\n      var p = (1 << 26) % num;\n      var acc = 0;\n\n      for (var i = this.length - 1; i >= 0; i--) {\n        acc = (p * acc + (this.words[i] | 0)) % num;\n      }\n\n      return this.negative !== 0 ? -acc | 0 : acc;\n    }\n    /*\n     * Euclidean Division + Modulo\n     */\n\n  }, {\n    key: \"divmod\",\n    value: function divmod(num) {\n      return this._div(num, modes.BOTH | modes.EUCLID);\n    }\n    /*\n     * Euclidean Division\n     */\n\n  }, {\n    key: \"idiv\",\n    value: function idiv(num) {\n      return this.div(num)._move(this);\n    }\n  }, {\n    key: \"idivn\",\n    value: function idivn(num) {\n      if (this.negative === 0) return this.iquon(num);\n      var r = this.remrn(num);\n      this.iquon(num);\n\n      if (r < 0) {\n        if (num < 0) this.iaddn(1);else this.isubn(1);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"div\",\n    value: function div(num) {\n      return this._div(num, modes.BOTH | modes.EUCLID)[0];\n    }\n  }, {\n    key: \"divn\",\n    value: function divn(num) {\n      return this.clone().idivn(num);\n    }\n    /*\n     * Euclidean Modulo\n     */\n\n  }, {\n    key: \"imod\",\n    value: function imod(num) {\n      if (this.ucmp(num) < 0) {\n        if (this.negative !== 0) {\n          this._isub(num, this);\n\n          this.negative = 0;\n        }\n\n        return this;\n      }\n\n      return this.mod(num)._move(this);\n    }\n  }, {\n    key: \"imodn\",\n    value: function imodn(num) {\n      this.words[0] = this.modrn(num);\n      this.length = 1;\n      this.negative = 0;\n      return this;\n    }\n  }, {\n    key: \"mod\",\n    value: function mod(num) {\n      return this._div(num, modes.REM | modes.EUCLID)[1];\n    }\n  }, {\n    key: \"modn\",\n    value: function modn(num) {\n      return this.clone().imodn(num);\n    }\n  }, {\n    key: \"modrn\",\n    value: function modrn(num) {\n      enforce(isSMI(num), 'num', 'smi');\n      var r = this.remrn(num);\n\n      if (r < 0) {\n        if (num < 0) r -= num;else r += num;\n      }\n\n      return r;\n    }\n    /*\n     * Round Division\n     */\n\n  }, {\n    key: \"divRound\",\n    value: function divRound(num) {\n      var _this$quorem = this.quorem(num),\n          _this$quorem2 = _slicedToArray(_this$quorem, 2),\n          q = _this$quorem2[0],\n          r = _this$quorem2[1]; // Fast case - exact division.\n\n\n      if (r.isZero()) return q;\n      var bit = num.words[0] & 1;\n      num.iushrn(1);\n      var cmp = r.ucmp(num);\n      num.iushln(1);\n      num.words[0] |= bit; // Round down.\n\n      if (cmp < 0 || num.isOdd() && cmp === 0) return q; // Round up.\n\n      if (this.negative ^ num.negative) return q.isubn(1);\n      return q.iaddn(1);\n    }\n    /*\n     * Exponentiation\n     */\n\n  }, {\n    key: \"ipow\",\n    value: function ipow(num) {\n      return this.pow(num)._move(this);\n    }\n  }, {\n    key: \"ipown\",\n    value: function ipown(num) {\n      return this.pown(num)._move(this);\n    }\n  }, {\n    key: \"pow\",\n    value: function pow(num) {\n      enforce(BN.isBN(num), 'num', 'bignum');\n      var b = countBits(num.words[num.length - 1]);\n      var r = new BN(1);\n\n      for (var i = num.length - 1; i >= 0; i--) {\n        var word = num.words[i];\n\n        for (var j = b - 1; j >= 0; j--) {\n          r = r.sqr();\n          if (word >> j & 1) r = r.mul(this);\n        }\n\n        b = 26;\n      }\n\n      return r;\n    }\n  }, {\n    key: \"pown\",\n    value: function pown(num) {\n      enforce(isSMI(num), 'num', 'smi');\n      if (num < 0) num = -num;\n      if (num === 0) return new BN(1);\n      if (num === 1) return this.clone();\n      var bits = countBits(num);\n      var r = this;\n\n      for (var i = bits - 2; i >= 0; i--) {\n        r = r.sqr();\n        if (num >> i & 1) r = r.mul(this);\n      }\n\n      return r;\n    }\n  }, {\n    key: \"isqr\",\n    value: function isqr() {\n      return this.imul(this);\n    }\n  }, {\n    key: \"sqr\",\n    value: function sqr() {\n      return this.mul(this);\n    }\n    /*\n     * Roots Engine\n     */\n\n  }, {\n    key: \"_rootrem\",\n    value: function _rootrem(pow, rem) {\n      enforce(pow >>> 0 === pow, 'num', 'uint32');\n      if (pow === 0) throw new RangeError('Zeroth root.');\n      if (~pow & this.negative) throw new RangeError('Negative with even root.');\n      if (this.ucmpn(1) <= 0) return [this.clone(), new BN(0)];\n      var u = new BN(0);\n      var t = BN.shift(1, this.bitLength() / pow + 1 | 0);\n      var v, r;\n      if (this.negative !== 0) t.ineg();\n\n      if (pow === 2) {\n        do {\n          u = t;\n          t = this.quo(u);\n          t.iadd(u);\n          t.iushrn(1);\n        } while (t.ucmp(u) < 0);\n      } else {\n        do {\n          u = t;\n          t = u.pown(pow - 1);\n          t = this.quo(t);\n          v = u.muln(pow - 1);\n          t.iadd(v);\n          t = t.quon(pow);\n        } while (t.ucmp(u) < 0);\n      }\n\n      if (rem) {\n        t = u.pown(pow);\n        r = this.sub(t);\n      }\n\n      return [u, r];\n    }\n    /*\n     * Roots\n     */\n\n  }, {\n    key: \"rootrem\",\n    value: function rootrem(pow) {\n      return this._rootrem(pow, 1);\n    }\n  }, {\n    key: \"iroot\",\n    value: function iroot(pow) {\n      return this.root(pow)._move(this);\n    }\n  }, {\n    key: \"root\",\n    value: function root(pow) {\n      return this._rootrem(pow, 0)[0];\n    }\n  }, {\n    key: \"isPower\",\n    value: function isPower(pow) {\n      enforce(pow >>> 0 === pow, 'num', 'uint32');\n      if (pow === 0 || ~pow & this.negative) return false;\n\n      var _this$rootrem = this.rootrem(pow),\n          _this$rootrem2 = _slicedToArray(_this$rootrem, 2),\n          r = _this$rootrem2[1];\n\n      return r.sign() === 0;\n    }\n  }, {\n    key: \"sqrtrem\",\n    value: function sqrtrem() {\n      return this.rootrem(2);\n    }\n  }, {\n    key: \"isqrt\",\n    value: function isqrt() {\n      return this.sqrt()._move(this);\n    }\n  }, {\n    key: \"sqrt\",\n    value: function sqrt() {\n      return this.root(2);\n    }\n  }, {\n    key: \"isSquare\",\n    value: function isSquare() {\n      return this.isPower(2);\n    }\n    /*\n     * AND\n     */\n\n  }, {\n    key: \"iand\",\n    value: function iand(num) {\n      enforce(BN.isBN(num), 'num', 'bignum');\n      var x = this;\n      var y = num;\n      if (x === y) return x;\n      if ((x.negative | y.negative) === 0) return x.iuand(y);\n\n      if ((x.negative & y.negative) === 1) {\n        // (-x) & (-y) == ~(x-1) & ~(y-1)\n        //             == ~((x-1) | (y-1))\n        //             == -(((x-1) | (y-1)) + 1)\n        x.iaddn(1);\n        y.iaddn(1);\n        x.iuor(y);\n        x.isubn(1);\n        y.isubn(1);\n        return x;\n      } // Assume x is the positive number.\n\n\n      if (x.negative !== 0) {\n        var _ref2 = [y.clone(), x];\n        x = _ref2[0];\n        y = _ref2[1];\n      } // x & (-y) == x & ~(y-1)\n      //          == x & ~(y-1)\n\n\n      var width = x.bitLength();\n      y.iaddn(1);\n      y.inotn(width);\n      x.iuand(y);\n      y.inotn(width);\n      y.isubn(1);\n      return x._move(this);\n    }\n  }, {\n    key: \"iandn\",\n    value: function iandn(num) {\n      enforce(isSMI(num), 'num', 'smi');\n      if ((this.negative | num < 0) !== 0) return this.iand(new BN(num));\n      this.words[0] &= num;\n      this.length = 1;\n      return this;\n    }\n  }, {\n    key: \"and\",\n    value: function and(num) {\n      return this.clone().iand(num);\n    }\n  }, {\n    key: \"andn\",\n    value: function andn(num) {\n      return this.clone().iandn(num);\n    }\n  }, {\n    key: \"andrn\",\n    value: function andrn(num) {\n      enforce(isSMI(num), 'num', 'smi');\n\n      if ((this.negative | num < 0) !== 0) {\n        var n = this.iand(new BN(num));\n        if (n.length > 1) throw new RangeError('Number exceeds 26 bits.');\n        return n.negative !== 0 ? -n.words[0] : n.words[0];\n      }\n\n      return this.words[0] & num;\n    }\n    /*\n     * Unsigned AND\n     */\n\n  }, {\n    key: \"iuand\",\n    value: function iuand(num) {\n      enforce(BN.isBN(num), 'num', 'bignum');\n      this.length = Math.min(this.length, num.length);\n\n      for (var i = 0; i < this.length; i++) {\n        this.words[i] &= num.words[i];\n      }\n\n      return this._strip();\n    }\n  }, {\n    key: \"iuandn\",\n    value: function iuandn(num) {\n      enforce(isSMI(num), 'num', 'smi');\n      this.words[0] &= Math.abs(num);\n      this.length = 1;\n      return this._normalize();\n    }\n  }, {\n    key: \"uand\",\n    value: function uand(num) {\n      return this.clone().iuand(num);\n    }\n  }, {\n    key: \"uandn\",\n    value: function uandn(num) {\n      return this.clone().iuandn(num);\n    }\n  }, {\n    key: \"uandrn\",\n    value: function uandrn(num) {\n      enforce(isSMI(num), 'num', 'smi');\n      var n = this.words[0] & Math.abs(num);\n      return this.negative !== 0 ? -n | 0 : n;\n    }\n    /*\n     * OR\n     */\n\n  }, {\n    key: \"ior\",\n    value: function ior(num) {\n      enforce(BN.isBN(num), 'num', 'bignum');\n      var x = this;\n      var y = num;\n      if (x === y) return x;\n      if ((x.negative | y.negative) === 0) return x.iuor(y);\n\n      if ((x.negative & y.negative) === 1) {\n        // (-x) | (-y) == ~(x-1) | ~(y-1)\n        //             == ~((x-1) & (y-1))\n        //             == -(((x-1) & (y-1)) + 1)\n        x.iaddn(1);\n        y.iaddn(1);\n        x.iuand(y);\n        x.isubn(1);\n        y.isubn(1);\n        return x;\n      } // Assume x is the positive number.\n\n\n      y = y.clone();\n\n      if (x.negative !== 0) {\n        var _ref3 = [y, x];\n        x = _ref3[0];\n        y = _ref3[1];\n      } // x | (-y) == x | ~(y-1)\n      //          == ~((y-1) & ~x)\n      //          == -(((y-1) & ~x) + 1)\n\n\n      y.iaddn(1);\n      x.inotn(y.bitLength());\n      y.iuand(x);\n      y.isubn(1);\n      return y._move(this);\n    }\n  }, {\n    key: \"iorn\",\n    value: function iorn(num) {\n      enforce(isSMI(num), 'num', 'smi');\n      if ((this.negative | num < 0) !== 0) return this.ior(new BN(num));\n      this.words[0] |= num;\n      return this;\n    }\n  }, {\n    key: \"or\",\n    value: function or(num) {\n      return this.clone().ior(num);\n    }\n  }, {\n    key: \"orn\",\n    value: function orn(num) {\n      return this.clone().iorn(num);\n    }\n    /*\n     * Unsigned OR\n     */\n\n  }, {\n    key: \"iuor\",\n    value: function iuor(num) {\n      enforce(BN.isBN(num), 'num', 'bignum');\n\n      this._expand(num.length);\n\n      for (var i = 0; i < num.length; i++) {\n        this.words[i] |= num.words[i];\n      } // Note: we shouldn't need to strip here.\n\n\n      return this;\n    }\n  }, {\n    key: \"iuorn\",\n    value: function iuorn(num) {\n      enforce(isSMI(num), 'num', 'smi');\n      this.words[0] |= Math.abs(num);\n      return this;\n    }\n  }, {\n    key: \"uor\",\n    value: function uor(num) {\n      return this.clone().iuor(num);\n    }\n  }, {\n    key: \"uorn\",\n    value: function uorn(num) {\n      return this.clone().iuorn(num);\n    }\n    /*\n     * XOR\n     */\n\n  }, {\n    key: \"ixor\",\n    value: function ixor(num) {\n      enforce(BN.isBN(num), 'num', 'bignum');\n      var x = this;\n      var y = num;\n\n      if (x === y) {\n        x.words[0] = 0;\n        x.length = 1;\n        x.negative = 0;\n        return x;\n      }\n\n      if ((x.negative | y.negative) === 0) return x.iuxor(y);\n\n      if ((x.negative & y.negative) === 1) {\n        // (-x) ^ (-y) == ~(x-1) ^ ~(y-1)\n        //             == (x-1) ^ (y-1)\n        x.iaddn(1);\n        y.iaddn(1);\n        x.iuxor(y);\n        x.ineg();\n        y.isubn(1);\n        return x;\n      } // Assume x is the positive number.\n\n\n      if (x.negative !== 0) {\n        var _ref4 = [y.clone(), x];\n        x = _ref4[0];\n        y = _ref4[1];\n      } // x ^ (-y) == x ^ ~(y-1)\n      //          == ~(x ^ (y-1))\n      //          == -((x ^ (y-1)) + 1)\n\n\n      y.iaddn(1);\n      x.iuxor(y);\n      x.iaddn(1);\n      x.ineg();\n      y.isubn(1);\n      return x._move(this);\n    }\n  }, {\n    key: \"ixorn\",\n    value: function ixorn(num) {\n      enforce(isSMI(num), 'num', 'smi');\n      if ((this.negative | num < 0) !== 0) return this.ixor(new BN(num));\n      this.words[0] ^= num;\n      return this;\n    }\n  }, {\n    key: \"xor\",\n    value: function xor(num) {\n      return this.clone().ixor(num);\n    }\n  }, {\n    key: \"xorn\",\n    value: function xorn(num) {\n      return this.clone().ixorn(num);\n    }\n    /*\n     * Unsigned XOR\n     */\n\n  }, {\n    key: \"iuxor\",\n    value: function iuxor(num) {\n      enforce(BN.isBN(num), 'num', 'bignum');\n      var a = this;\n      var b = num;\n\n      if (a.length < b.length) {\n        var _ref5 = [b, a];\n        a = _ref5[0];\n        b = _ref5[1];\n      }\n\n      var i = 0;\n\n      for (; i < b.length; i++) {\n        this.words[i] = a.words[i] ^ b.words[i];\n      }\n\n      if (a !== this) {\n        this._alloc(a.length);\n\n        for (; i < a.length; i++) {\n          this.words[i] = a.words[i];\n        }\n      }\n\n      this.length = a.length;\n      return this._strip();\n    }\n  }, {\n    key: \"iuxorn\",\n    value: function iuxorn(num) {\n      enforce(isSMI(num), 'num', 'smi');\n      this.words[0] ^= Math.abs(num);\n      return this._normalize();\n    }\n  }, {\n    key: \"uxor\",\n    value: function uxor(num) {\n      return this.clone().iuxor(num);\n    }\n  }, {\n    key: \"uxorn\",\n    value: function uxorn(num) {\n      return this.clone().iuxorn(num);\n    }\n    /*\n     * NOT\n     */\n\n  }, {\n    key: \"inot\",\n    value: function inot() {\n      if (this.negative !== 0) {\n        // ~(-x) == ~(~(x-1)) == x-1\n        this.ineg().isubn(1);\n      } else {\n        // ~x == -x-1 == -(x+1)\n        this.iaddn(1).ineg();\n      }\n\n      return this;\n    }\n  }, {\n    key: \"not\",\n    value: function not() {\n      return this.clone().inot();\n    }\n  }, {\n    key: \"inotn\",\n    value: function inotn(width) {\n      enforce(width >>> 0 === width, 'width', 'uint32');\n      var r = width % 26;\n      var s = Math.ceil(width / 26);\n      var i = 0; // Extend the buffer with leading zeroes.\n\n      this._expand(s);\n\n      if (r > 0) s -= 1; // Handle complete words.\n\n      for (; i < s; i++) {\n        this.words[i] ^= 0x3ffffff;\n      } // Handle the residue.\n\n\n      if (r > 0) this.words[i] ^= (1 << r) - 1; // And remove leading zeroes.\n\n      return this._strip();\n    }\n  }, {\n    key: \"notn\",\n    value: function notn(width) {\n      return this.clone().inotn(width);\n    }\n    /*\n     * Left Shift\n     */\n\n  }, {\n    key: \"ishl\",\n    value: function ishl(num) {\n      enforce(BN.isBN(num), 'bits', 'bignum');\n      enforce(num.bitLength() <= 32, 'bits', 'uint32');\n      return this.ishln(num.toNumber());\n    }\n  }, {\n    key: \"ishln\",\n    value: function ishln(bits) {\n      return this.iushln(bits);\n    }\n  }, {\n    key: \"shl\",\n    value: function shl(num) {\n      return this.clone().ishl(num);\n    }\n  }, {\n    key: \"shln\",\n    value: function shln(bits) {\n      return this.clone().ishln(bits);\n    }\n    /*\n     * Unsigned Left Shift\n     */\n\n  }, {\n    key: \"iushl\",\n    value: function iushl(num) {\n      enforce(BN.isBN(num), 'bits', 'bignum');\n      enforce(num.bitLength() <= 32, 'bits', 'uint32');\n      return this.iushln(num.toNumber());\n    }\n  }, {\n    key: \"iushln\",\n    value: function iushln(bits) {\n      enforce(bits >>> 0 === bits, 'bits', 'uint32');\n      var r = bits % 26;\n      var s = (bits - r) / 26;\n      var mask = (1 << r) - 1 << 26 - r;\n\n      if (r !== 0) {\n        var carry = 0;\n\n        for (var i = 0; i < this.length; i++) {\n          var ncarry = this.words[i] & mask;\n          var c = (this.words[i] | 0) - ncarry << r;\n          this.words[i] = c | carry;\n          carry = ncarry >>> 26 - r;\n        }\n\n        if (carry !== 0) {\n          this._alloc(this.length + 1);\n\n          this.words[this.length++] = carry;\n        }\n      }\n\n      if (s !== 0) {\n        this._alloc(this.length + s);\n\n        for (var _i2 = this.length - 1; _i2 >= 0; _i2--) {\n          this.words[_i2 + s] = this.words[_i2];\n        }\n\n        for (var _i3 = 0; _i3 < s; _i3++) {\n          this.words[_i3] = 0;\n        }\n\n        this.length += s;\n      }\n\n      return this._strip();\n    }\n  }, {\n    key: \"ushl\",\n    value: function ushl(num) {\n      return this.clone().iushl(num);\n    }\n  }, {\n    key: \"ushln\",\n    value: function ushln(bits) {\n      return this.clone().iushln(bits);\n    }\n    /*\n     * Right Shift Engine\n     */\n\n  }, {\n    key: \"_split\",\n    value: function _split(bits, output) {\n      var r = bits % 26;\n      var s = Math.min((bits - r) / 26, this.length);\n      var mask = (1 << r) - 1; // Extended mode, copy masked part.\n\n      if (output) {\n        output._alloc(s);\n\n        for (var i = 0; i < s; i++) {\n          output.words[i] = this.words[i];\n        }\n\n        output.length = s;\n      }\n\n      if (s === 0) {// No-op, we should not move anything at all.\n      } else if (this.length > s) {\n        this.length -= s;\n\n        for (var _i4 = 0; _i4 < this.length; _i4++) {\n          this.words[_i4] = this.words[_i4 + s];\n        }\n      } else {\n        this.words[0] = 0;\n        this.length = 1;\n      }\n\n      var carry = 0;\n\n      if (r !== 0) {\n        for (var _i5 = this.length - 1; _i5 >= 0; _i5--) {\n          var word = this.words[_i5] | 0;\n          this.words[_i5] = carry << 26 - r | word >>> r;\n          carry = word & mask;\n        }\n      } // Push carried bits as a mask.\n\n\n      if (output) {\n        if (carry !== 0) {\n          output._alloc(output.length + 1);\n\n          output.words[output.length++] = carry;\n        } else {\n          if (output.length === 0) output.words[output.length++] = 0;\n\n          output._strip();\n        }\n      }\n\n      return this._strip();\n    }\n    /*\n     * Right Shift\n     */\n\n  }, {\n    key: \"ishr\",\n    value: function ishr(num) {\n      enforce(BN.isBN(num), 'bits', 'bignum');\n      enforce(num.bitLength() <= 32, 'bits', 'uint32');\n      return this.ishrn(num.toNumber());\n    }\n  }, {\n    key: \"ishrn\",\n    value: function ishrn(bits) {\n      enforce(bits >>> 0 === bits, 'bits', 'uint32');\n\n      if (this.negative !== 0) {\n        // (-x) >> y == ~(x-1) >> y\n        //           == ~((x-1) >> y)\n        //           == -(((x-1) >> y) + 1)\n        this.iaddn(1);\n        this.iushrn(bits);\n        this.isubn(1);\n        return this;\n      }\n\n      return this.iushrn(bits);\n    }\n  }, {\n    key: \"shr\",\n    value: function shr(num) {\n      return this.clone().ishr(num);\n    }\n  }, {\n    key: \"shrn\",\n    value: function shrn(bits) {\n      return this.clone().ishrn(bits);\n    }\n    /*\n     * Unsigned Right Shift\n     */\n\n  }, {\n    key: \"iushr\",\n    value: function iushr(num) {\n      enforce(BN.isBN(num), 'bits', 'bignum');\n      enforce(num.bitLength() <= 32, 'bits', 'uint32');\n      return this.iushrn(num.toNumber());\n    }\n  }, {\n    key: \"iushrn\",\n    value: function iushrn(bits) {\n      enforce(bits >>> 0 === bits, 'bits', 'uint32');\n      return this._split(bits, null);\n    }\n  }, {\n    key: \"ushr\",\n    value: function ushr(num) {\n      return this.clone().iushr(num);\n    }\n  }, {\n    key: \"ushrn\",\n    value: function ushrn(bits) {\n      return this.clone().iushrn(bits);\n    }\n    /*\n     * Bit Manipulation\n     */\n\n  }, {\n    key: \"setn\",\n    value: function setn(bit, val) {\n      enforce(bit >>> 0 === bit, 'bit', 'uint32');\n\n      if (this.negative !== 0) {\n        this.iaddn(1);\n        this.usetn(bit, !val);\n        this.isubn(1);\n        return this;\n      }\n\n      return this.usetn(bit, val);\n    }\n  }, {\n    key: \"usetn\",\n    value: function usetn(bit, val) {\n      enforce(bit >>> 0 === bit, 'bit', 'uint32');\n      var r = bit % 26;\n      var s = (bit - r) / 26;\n\n      this._expand(s + 1);\n\n      if (val) this.words[s] |= 1 << r;else this.words[s] &= ~(1 << r);\n      return this._strip();\n    }\n  }, {\n    key: \"testn\",\n    value: function testn(bit) {\n      enforce(bit >>> 0 === bit, 'bit', 'uint32');\n      var r = bit % 26;\n      var s = (bit - r) / 26; // Fast case: bit is much higher than all existing words.\n\n      if (this.length <= s) return this.negative; // Check bit and return.\n\n      var w = this.words[s];\n      var val = w >> r & 1;\n\n      if (this.negative !== 0) {\n        if (r > 0 && w & (1 << r) - 1) return val ^ 1;\n        var j = s;\n\n        while (j--) {\n          if (this.words[j] > 0) return val ^ 1;\n        }\n      }\n\n      return val;\n    }\n  }, {\n    key: \"utestn\",\n    value: function utestn(bit) {\n      enforce(bit >>> 0 === bit, 'bit', 'uint32');\n      var r = bit % 26;\n      var s = (bit - r) / 26; // Fast case: bit is much higher than all existing words.\n\n      if (this.length <= s) return 0; // Check bit and return.\n\n      return this.words[s] >> r & 1;\n    }\n  }, {\n    key: \"imaskn\",\n    value: function imaskn(bits) {\n      enforce(bits >>> 0 === bits, 'bits', 'uint32');\n\n      if (this.negative !== 0) {\n        this.iaddn(1);\n        this.inotn(bits + 1);\n        this.ineg();\n      }\n\n      return this.iumaskn(bits);\n    }\n  }, {\n    key: \"maskn\",\n    value: function maskn(bits) {\n      return this.clone().imaskn(bits);\n    }\n  }, {\n    key: \"iumaskn\",\n    value: function iumaskn(bits) {\n      enforce(bits >>> 0 === bits, 'bits', 'uint32');\n      var r = bits % 26;\n      var s = (bits - r) / 26;\n      if (this.length <= s) return this;\n      if (r !== 0) s += 1;\n      this.length = Math.min(s, this.length);\n      if (r !== 0) this.words[this.length - 1] &= (1 << r) - 1;\n      if (this.length === 0) this.words[this.length++] = 0;\n      return this._strip();\n    }\n  }, {\n    key: \"umaskn\",\n    value: function umaskn(bits) {\n      return this.clone().iumaskn(bits);\n    }\n  }, {\n    key: \"andln\",\n    value: function andln(num) {\n      return this.words[0] & num;\n    }\n  }, {\n    key: \"bit\",\n    value: function bit(pos) {\n      return this.utestn(pos);\n    }\n  }, {\n    key: \"bits\",\n    value: function bits(pos, width) {\n      enforce(pos >>> 0 === pos, 'pos', 'uint32');\n      enforce(width >>> 0 === width, 'width', 'uint32');\n      enforce(width <= 26, 'width', 'width');\n      var shift = pos % 26;\n      var index = (pos - shift) / 26;\n      if (index >= this.length) return 0;\n      var bits = this.words[index] >> shift & (1 << width) - 1;\n\n      if (shift + width > 26 && index + 1 < this.length) {\n        var more = shift + width - 26;\n        var next = this.words[index + 1] & (1 << more) - 1;\n        bits |= next << 26 - shift;\n      }\n\n      return bits;\n    }\n    /*\n     * Negation\n     */\n\n  }, {\n    key: \"ineg\",\n    value: function ineg() {\n      if (!this.isZero()) this.negative ^= 1;\n      return this;\n    }\n  }, {\n    key: \"neg\",\n    value: function neg() {\n      return this.clone().ineg();\n    }\n  }, {\n    key: \"iabs\",\n    value: function iabs() {\n      this.negative = 0;\n      return this;\n    }\n  }, {\n    key: \"abs\",\n    value: function abs() {\n      return this.clone().iabs();\n    }\n    /*\n     * Comparison\n     */\n\n  }, {\n    key: \"cmp\",\n    value: function cmp(num) {\n      enforce(BN.isBN(num), 'num', 'bignum');\n      if (this.negative !== num.negative) return num.negative - this.negative;\n      var res = this.ucmp(num);\n      if (this.negative !== 0) return -res | 0;\n      return res;\n    }\n  }, {\n    key: \"cmpn\",\n    value: function cmpn(num) {\n      enforce(isSMI(num), 'num', 'smi');\n      var negative = num < 0 | 0;\n      if (this.negative !== negative) return negative - this.negative;\n      var res = this.ucmpn(num);\n      if (this.negative !== 0) return -res | 0;\n      return res;\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(num) {\n      return this.cmp(num) === 0;\n    }\n  }, {\n    key: \"eqn\",\n    value: function eqn(num) {\n      return this.cmpn(num) === 0;\n    }\n  }, {\n    key: \"gt\",\n    value: function gt(num) {\n      return this.cmp(num) > 0;\n    }\n  }, {\n    key: \"gtn\",\n    value: function gtn(num) {\n      return this.cmpn(num) > 0;\n    }\n  }, {\n    key: \"gte\",\n    value: function gte(num) {\n      return this.cmp(num) >= 0;\n    }\n  }, {\n    key: \"gten\",\n    value: function gten(num) {\n      return this.cmpn(num) >= 0;\n    }\n  }, {\n    key: \"lt\",\n    value: function lt(num) {\n      return this.cmp(num) < 0;\n    }\n  }, {\n    key: \"ltn\",\n    value: function ltn(num) {\n      return this.cmpn(num) < 0;\n    }\n  }, {\n    key: \"lte\",\n    value: function lte(num) {\n      return this.cmp(num) <= 0;\n    }\n  }, {\n    key: \"lten\",\n    value: function lten(num) {\n      return this.cmpn(num) <= 0;\n    }\n  }, {\n    key: \"sign\",\n    value: function sign() {\n      if (this.negative !== 0) return -1;\n      if (this.length === 1 && this.words[0] === 0) return 0;\n      return 1;\n    }\n  }, {\n    key: \"isZero\",\n    value: function isZero() {\n      return this.length === 1 && this.words[0] === 0;\n    }\n  }, {\n    key: \"isNeg\",\n    value: function isNeg() {\n      return this.negative !== 0;\n    }\n  }, {\n    key: \"isPos\",\n    value: function isPos() {\n      return this.negative === 0;\n    }\n  }, {\n    key: \"isOdd\",\n    value: function isOdd() {\n      return (this.words[0] & 1) === 1;\n    }\n  }, {\n    key: \"isEven\",\n    value: function isEven() {\n      return (this.words[0] & 1) === 0;\n    }\n    /*\n     * Unsigned Comparison\n     */\n\n  }, {\n    key: \"ucmp\",\n    value: function ucmp(num) {\n      enforce(BN.isBN(num), 'num', 'bignum');\n      if (this.length < num.length) return -1;\n      if (this.length > num.length) return 1;\n\n      for (var i = this.length - 1; i >= 0; i--) {\n        var a = this.words[i] | 0;\n        var b = num.words[i] | 0;\n        if (a === b) continue;\n        return (a > b) - (a < b);\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"ucmpn\",\n    value: function ucmpn(num) {\n      enforce(isSMI(num), 'num', 'smi');\n      if (this.length > 1) return 1;\n      var w = this.words[0] | 0;\n      if (num < 0) num = -num;\n      return (w > num) - (w < num);\n    }\n    /*\n     * Number Theoretic Functions\n     */\n\n  }, {\n    key: \"legendre\",\n    value: function legendre(num) {\n      var red = HAS_BIGINT ? BN.red(num) : BN.mont(num);\n      return this.toRed(red).redLegendre();\n    }\n  }, {\n    key: \"jacobi\",\n    value: function jacobi(num) {\n      enforce(BN.isBN(num), 'num', 'bignum');\n      if (num.isZero() || num.isEven()) throw new Error('jacobi: `num` must be odd.');\n\n      var a = this._cloneNormal();\n\n      var b = num.clone();\n      var j = 1;\n\n      if (b.isNeg()) {\n        if (a.isNeg()) j = -1;\n        b.ineg();\n      }\n\n      for (;;) {\n        if (b.cmpn(1) === 0) return j;\n        if (a.isZero()) return 0;\n        a.imod(b);\n        if (a.isZero()) return 0;\n        var s = a.zeroBits();\n\n        if (s & 1) {\n          var bmod8 = b.andln(7);\n          if (bmod8 === 3 || bmod8 === 5) j = -j;\n        }\n\n        var c = a.iushrn(s);\n        if (b.andln(3) === 3 && c.andln(3) === 3) j = -j;\n        a = b;\n        b = c;\n      }\n    }\n  }, {\n    key: \"kronecker\",\n    value: function kronecker(num) {\n      enforce(BN.isBN(num), 'num', 'bignum');\n      var table = [0, 1, 0, -1, 0, -1, 0, 1];\n\n      var a = this._cloneNormal();\n\n      var b = num.clone();\n      var s = 1;\n      if (b.isZero()) return a.ucmpn(1) === 0 ? s : 0;\n      if (!a.isOdd() && !b.isOdd()) return 0;\n      var z = b.zeroBits();\n      b.iushrn(z);\n      if (z & 1) s = table[a.andln(7)];\n\n      if (b.isNeg()) {\n        if (a.isNeg()) s = -s;\n        b.ineg();\n      }\n\n      for (;;) {\n        if (a.isZero()) return b.cmpn(1) === 0 ? s : 0;\n\n        var _z = a.zeroBits();\n\n        a.iushrn(_z);\n        if (_z & 1) s *= table[b.andln(7)];\n        var w = a.words[0] ^ a.negative * 0x3ffffff;\n        if (w & b.words[0] & 2) s = -s;\n        b.imod(a);\n        var _ref6 = [b, a];\n        a = _ref6[0];\n        b = _ref6[1];\n        b.negative = 0;\n      }\n    }\n  }, {\n    key: \"igcd\",\n    value: function igcd(num) {\n      return this.gcd(num)._move(this);\n    }\n  }, {\n    key: \"gcd\",\n    value: function gcd(num) {\n      enforce(BN.isBN(num), 'num', 'bignum');\n      if (this.isZero()) return num.abs();\n      if (num.isZero()) return this.abs();\n      var a = this.clone();\n      var b = num.clone();\n      a.negative = 0;\n      b.negative = 0; // Remove common factor of two.\n\n      var shift = a._factor2(b);\n\n      if (shift !== 0) {\n        a.iushrn(shift);\n        b.iushrn(shift);\n      }\n\n      for (;;) {\n        var az = a.zeroBits();\n        var bz = b.zeroBits();\n        if (az !== 0) a.iushrn(az);\n        if (bz !== 0) b.iushrn(bz);\n        var cmp = a.ucmp(b);\n\n        if (cmp < 0) {\n          // a > b\n          var _ref7 = [b, a];\n          a = _ref7[0];\n          b = _ref7[1];\n        } else if (cmp === 0 || b.ucmpn(1) === 0) {\n          // Break if a == b.\n          // Break if b == 1 to avoid repeated subtraction.\n          break;\n        }\n\n        a._isub(a, b);\n      }\n\n      return b.iushln(shift);\n    }\n  }, {\n    key: \"ilcm\",\n    value: function ilcm(num) {\n      return this.lcm(num)._move(this);\n    }\n  }, {\n    key: \"lcm\",\n    value: function lcm(num) {\n      enforce(BN.isBN(num), 'num', 'bignum');\n      if (this.isZero() || num.isZero()) return new BN(0);\n      return this.quo(this.gcd(num)).mul(num).iabs();\n    }\n  }, {\n    key: \"egcd\",\n    value: function egcd(num) {\n      enforce(BN.isBN(num), 'num', 'bignum');\n\n      if (this.isZero()) {\n        return [new BN(0), new BN(num.sign()), num.abs()];\n      }\n\n      if (num.isZero()) {\n        return [new BN(this.sign()), new BN(0), this.abs()];\n      }\n\n      var x = this.clone();\n      var y = num.clone();\n      x.negative = 0;\n      y.negative = 0; // A * x + B * y = x\n\n      var A = new BN(1);\n      var B = new BN(0); // C * x + D * y = y\n\n      var C = new BN(0);\n      var D = new BN(1); // Remove common factor of two.\n\n      var g = x._factor2(y);\n\n      if (g !== 0) {\n        x.iushrn(g);\n        y.iushrn(g);\n      }\n\n      var yp = y.clone();\n      var xp = x.clone();\n\n      while (!x.isZero()) {\n        var i = 0;\n\n        for (var im = 1; (x.words[0] & im) === 0 && i < 26; im <<= 1) {\n          i += 1;\n        }\n\n        if (i > 0) {\n          x.iushrn(i);\n\n          while (i > 0) {\n            if (A.isOdd() || B.isOdd()) {\n              A.iadd(yp);\n              B.isub(xp);\n            }\n\n            A.iushrn(1);\n            B.iushrn(1);\n            i -= 1;\n          }\n        }\n\n        var j = 0;\n\n        for (var jm = 1; (y.words[0] & jm) === 0 && j < 26; jm <<= 1) {\n          j += 1;\n        }\n\n        if (j > 0) {\n          y.iushrn(j);\n\n          while (j > 0) {\n            if (C.isOdd() || D.isOdd()) {\n              C.iadd(yp);\n              D.isub(xp);\n            }\n\n            C.iushrn(1);\n            D.iushrn(1);\n            j -= 1;\n          }\n        }\n\n        if (x.cmp(y) >= 0) {\n          x.isub(y);\n          A.isub(C);\n          B.isub(D);\n        } else {\n          y.isub(x);\n          C.isub(A);\n          D.isub(B);\n        }\n      }\n\n      if (this.negative !== 0) C.ineg();\n      if (num.negative !== 0) D.ineg();\n      return [C, D, y.iushln(g)];\n    }\n  }, {\n    key: \"iinvert\",\n    value: function iinvert(num) {\n      return this.invert(num)._move(this);\n    }\n  }, {\n    key: \"invert\",\n    value: function invert(num) {\n      enforce(BN.isBN(num), 'num', 'bignum');\n      range(num.sign() > 0, 'invert');\n      if (num.cmpn(1) === 0) throw new RangeError('Not invertible.');\n\n      var _this$egcd = this.egcd(num),\n          _this$egcd2 = _slicedToArray(_this$egcd, 3),\n          s = _this$egcd2[0],\n          g = _this$egcd2[2];\n\n      if (g.cmpn(1) !== 0) throw new RangeError('Not invertible.');\n      return s.imod(num);\n    }\n  }, {\n    key: \"ifermat\",\n    value: function ifermat(num) {\n      return this.fermat(num)._move(this);\n    }\n  }, {\n    key: \"fermat\",\n    value: function fermat(num) {\n      var red = HAS_BIGINT ? BN.red(num) : BN.mont(num);\n      return this.toRed(red).redFermat().fromRed();\n    }\n  }, {\n    key: \"ipowm\",\n    value: function ipowm(y, m, mont) {\n      return this.powm(y, m, mont)._move(this);\n    }\n  }, {\n    key: \"powm\",\n    value: function powm(y, m, mont) {\n      var red = !HAS_BIGINT && mont ? BN.mont(m) : BN.red(m);\n      return this.toRed(red).redPow(y).fromRed();\n    }\n  }, {\n    key: \"ipowmn\",\n    value: function ipowmn(y, m, mont) {\n      return this.powmn(y, m, mont)._move(this);\n    }\n  }, {\n    key: \"powmn\",\n    value: function powmn(y, m, mont) {\n      var red = mont ? BN.mont(m) : BN.red(m);\n      return this.toRed(red).redPown(y).fromRed();\n    }\n  }, {\n    key: \"isqrtm\",\n    value: function isqrtm(p) {\n      return this.sqrtm(p)._move(this);\n    }\n  }, {\n    key: \"sqrtm\",\n    value: function sqrtm(p) {\n      enforce(BN.isBN(p), 'p', 'bignum');\n      var red;\n\n      if (p.andln(3) === 3 || p.andln(7) === 5) {\n        // Probably not worth the setup.\n        red = BN.red(p);\n      } else {\n        red = BN.mont(p);\n      }\n\n      return this.toRed(red).redSqrt().fromRed();\n    }\n  }, {\n    key: \"isqrtpq\",\n    value: function isqrtpq(p, q) {\n      return this.sqrtpq(p, q)._move(this);\n    }\n  }, {\n    key: \"sqrtpq\",\n    value: function sqrtpq(p, q) {\n      var sp = this.sqrtm(p);\n      var sq = this.sqrtm(q);\n\n      var _p$egcd = p.egcd(q),\n          _p$egcd2 = _slicedToArray(_p$egcd, 2),\n          mp = _p$egcd2[0],\n          mq = _p$egcd2[1];\n\n      var lhs = sq.mul(mp).mul(p);\n      var rhs = sp.mul(mq).mul(q);\n      var n = p.mul(q);\n      return lhs.iadd(rhs).imod(n);\n    }\n    /*\n     * Primality Testing\n     */\n\n  }, {\n    key: \"isPrime\",\n    value: function isPrime(rng, reps, limit) {\n      enforce(reps >>> 0 === reps, 'reps', 'uint32');\n      if (!this.isPrimeMR(rng, reps + 1, true)) return false;\n      if (!this.isPrimeLucas(limit)) return false;\n      return true;\n    }\n  }, {\n    key: \"isPrimeMR\",\n    value: function isPrimeMR(rng, reps) {\n      var force2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      enforce(reps >>> 0 === reps, 'reps', 'uint32');\n      enforce(reps > 0, 'reps', 'integer');\n      enforce(typeof force2 === 'boolean', 'force2', 'boolean');\n      var n = this;\n\n      if (n.cmpn(7) < 0) {\n        return n.cmpn(2) === 0 || n.cmpn(3) === 0 || n.cmpn(5) === 0;\n      }\n\n      if (n.isEven()) return false;\n      var nm1 = n.subn(1);\n      var nm3 = nm1.subn(2);\n      var k = nm1.zeroBits();\n      var q = nm1.ushrn(k);\n      var red = BN.red(n);\n      var rnm1 = nm1.toRed(red);\n      var rone = new BN(1).toRed(red);\n\n      next: for (var i = 0; i < reps; i++) {\n        var x = void 0;\n\n        if (i === reps - 1 && force2) {\n          x = new BN(2);\n        } else {\n          x = BN.random(rng, 0, nm3);\n          x.iaddn(2);\n        }\n\n        var y = x.toRed(red).redPow(q);\n        if (y.cmp(rone) === 0 || y.cmp(rnm1) === 0) continue;\n\n        for (var j = 1; j < k; j++) {\n          y = y.redSqr();\n          if (y.cmp(rnm1) === 0) continue next;\n          if (y.cmp(rone) === 0) return false;\n        }\n\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"isPrimeLucas\",\n    value: function isPrimeLucas() {\n      var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      enforce(limit >>> 0 === limit, 'limit', 'uint32');\n      var n = this; // Ignore 0 and 1.\n\n      if (n.cmpn(1) <= 0) return false; // Two is the only even prime.\n\n      if (n.isEven()) return n.cmpn(2) === 0;\n      var p = 3;\n\n      for (;;) {\n        if (p > 10000) {\n          // Thought to be impossible.\n          throw new Error(\"Cannot find (D/n) = -1 for \".concat(n.toString(10), \".\"));\n        }\n\n        if (limit !== 0 && p > limit) {\n          // Optional DoS limit.\n          return false;\n        }\n\n        var d = new BN(p * p - 4);\n        var j = d.jacobi(n);\n        if (j === -1) break;\n        if (j === 0) return n.cmpn(p + 2) === 0;\n\n        if (p === 40) {\n          if (n.isSquare()) return false;\n        }\n\n        p += 1;\n      }\n\n      var s = n.addn(1);\n      var r = s.zeroBits();\n      var nm2 = n.subn(2);\n      var x = new BN(2);\n      var y = new BN(p);\n      s.iushrn(r);\n\n      for (var i = s.bitLength(); i >= 0; i--) {\n        if (s.utestn(i)) {\n          x = x.mul(y).iadd(n).isubn(p).imod(n);\n          y = y.sqr().iadd(nm2).imod(n);\n        } else {\n          y = y.mul(x).iadd(n).isubn(p).imod(n);\n          x = x.sqr().iadd(nm2).imod(n);\n        }\n      }\n\n      if (x.cmpn(2) === 0 || x.cmp(nm2) === 0) {\n        var a = x.muln(p);\n        var b = y.ushln(1);\n\n        if (a.cmp(b) < 0) {\n          var _ref8 = [b, a];\n          a = _ref8[0];\n          b = _ref8[1];\n        }\n\n        if (a.isub(b).imod(n).isZero()) return true;\n      }\n\n      for (var t = 0; t < r - 1; t++) {\n        if (x.isZero()) return true;\n        if (x.cmpn(2) === 0) return false;\n        x = x.sqr().isubn(2).imod(n);\n      }\n\n      return false;\n    }\n    /*\n     * Twos Complement\n     */\n\n  }, {\n    key: \"toTwos\",\n    value: function toTwos(width) {\n      if (this.negative !== 0) return this.abs().inotn(width).iaddn(1);\n      return this.clone();\n    }\n  }, {\n    key: \"fromTwos\",\n    value: function fromTwos(width) {\n      enforce(width >>> 0 === width, 'width', 'uint32');\n      range(width > 0, 'width');\n      if (this.testn(width - 1)) return this.notn(width).iaddn(1).ineg();\n      return this.clone();\n    }\n    /*\n     * Reduction Context\n     */\n\n  }, {\n    key: \"toRed\",\n    value: function toRed(ctx) {\n      enforce(ctx instanceof Red, 'ctx', 'reduction context');\n      if (this.red) throw new Error('Already in reduction context.');\n      return ctx.convertTo(this);\n    }\n  }, {\n    key: \"fromRed\",\n    value: function fromRed() {\n      red(this.red, 'fromRed');\n      return this.red.convertFrom(this);\n    }\n  }, {\n    key: \"forceRed\",\n    value: function forceRed(ctx) {\n      enforce(ctx instanceof Red, 'ctx', 'reduction context');\n\n      if (this.red) {\n        if (!ctx.m.eq(this.red.m) || ctx.mont !== this.red.mont) throw new Error('Already in reduction context.');\n      } else {\n        range(this.negative === 0, 'red');\n        range(this.ucmp(ctx.m) < 0, 'red');\n      }\n\n      return this.clone()._forceRed(ctx);\n    }\n  }, {\n    key: \"redIAdd\",\n    value: function redIAdd(num) {\n      enforce(BN.isBN(num), 'num', 'bignum');\n      red(this.red, 'redIAdd');\n      return this.red.iadd(this, num);\n    }\n  }, {\n    key: \"redAdd\",\n    value: function redAdd(num) {\n      enforce(BN.isBN(num), 'num', 'bignum');\n      red(this.red, 'redAdd');\n      return this.red.add(this, num);\n    }\n  }, {\n    key: \"redIAddn\",\n    value: function redIAddn(num) {\n      enforce(isSMI(num), 'num', 'smi');\n      red(this.red, 'redIAddn');\n      return this.red.iaddn(this, num);\n    }\n  }, {\n    key: \"redAddn\",\n    value: function redAddn(num) {\n      enforce(isSMI(num), 'num', 'smi');\n      red(this.red, 'redAddn');\n      return this.red.addn(this, num);\n    }\n  }, {\n    key: \"redISub\",\n    value: function redISub(num) {\n      enforce(BN.isBN(num), 'num', 'bignum');\n      red(this.red, 'redISub');\n      return this.red.isub(this, num);\n    }\n  }, {\n    key: \"redSub\",\n    value: function redSub(num) {\n      enforce(BN.isBN(num), 'num', 'bignum');\n      red(this.red, 'redSub');\n      return this.red.sub(this, num);\n    }\n  }, {\n    key: \"redISubn\",\n    value: function redISubn(num) {\n      enforce(isSMI(num), 'num', 'smi');\n      red(this.red, 'redISubn');\n      return this.red.isubn(this, num);\n    }\n  }, {\n    key: \"redSubn\",\n    value: function redSubn(num) {\n      enforce(isSMI(num), 'num', 'smi');\n      red(this.red, 'redSubn');\n      return this.red.subn(this, num);\n    }\n  }, {\n    key: \"redIMul\",\n    value: function redIMul(num) {\n      enforce(BN.isBN(num), 'num', 'bignum');\n      red(this.red, 'redIMul');\n      return this.red.imul(this, num);\n    }\n  }, {\n    key: \"redMul\",\n    value: function redMul(num) {\n      enforce(BN.isBN(num), 'num', 'bignum');\n      red(this.red, 'redMul');\n      return this.red.mul(this, num);\n    }\n  }, {\n    key: \"redIMuln\",\n    value: function redIMuln(num) {\n      enforce(isSMI(num), 'num', 'smi');\n      red(this.red, 'redIMuln');\n      return this.red.imuln(this, num);\n    }\n  }, {\n    key: \"redMuln\",\n    value: function redMuln(num) {\n      enforce(isSMI(num), 'num', 'smi');\n      red(this.red, 'redMuln');\n      return this.red.muln(this, num);\n    }\n  }, {\n    key: \"redIDiv\",\n    value: function redIDiv(num) {\n      enforce(BN.isBN(num), 'num', 'bignum');\n      red(this.red, 'redIDiv');\n      return this.red.idiv(this, num);\n    }\n  }, {\n    key: \"redDiv\",\n    value: function redDiv(num) {\n      enforce(BN.isBN(num), 'num', 'bignum');\n      red(this.red, 'redDiv');\n      return this.red.div(this, num);\n    }\n  }, {\n    key: \"redIDivn\",\n    value: function redIDivn(num) {\n      enforce(isSMI(num), 'num', 'smi');\n      red(this.red, 'redIDivn');\n      return this.red.idivn(this, num);\n    }\n  }, {\n    key: \"redDivn\",\n    value: function redDivn(num) {\n      enforce(isSMI(num), 'num', 'smi');\n      red(this.red, 'redDivn');\n      return this.red.divn(this, num);\n    }\n  }, {\n    key: \"redIPow\",\n    value: function redIPow(num) {\n      enforce(BN.isBN(num), 'num', 'bignum');\n      red(this.red, 'redIPow');\n      nonred(!num.red, 'redIPow');\n      return this.red.ipow(this, num);\n    }\n  }, {\n    key: \"redPow\",\n    value: function redPow(num) {\n      enforce(BN.isBN(num), 'num', 'bignum');\n      red(this.red, 'redPow');\n      nonred(!num.red, 'redPow');\n      return this.red.pow(this, num);\n    }\n  }, {\n    key: \"redIPown\",\n    value: function redIPown(num) {\n      enforce(isSMI(num), 'num', 'smi');\n      red(this.red, 'redIPown');\n      return this.red.ipown(this, num);\n    }\n  }, {\n    key: \"redPown\",\n    value: function redPown(num) {\n      enforce(isSMI(num), 'num', 'smi');\n      red(this.red, 'redPown');\n      return this.red.pown(this, num);\n    }\n  }, {\n    key: \"redISqr\",\n    value: function redISqr() {\n      red(this.red, 'redISqr');\n      return this.red.isqr(this);\n    }\n  }, {\n    key: \"redSqr\",\n    value: function redSqr() {\n      red(this.red, 'redSqr');\n      return this.red.sqr(this);\n    }\n  }, {\n    key: \"redISqrt\",\n    value: function redISqrt() {\n      red(this.red, 'redISqrt');\n      return this.red.isqrt(this);\n    }\n  }, {\n    key: \"redSqrt\",\n    value: function redSqrt() {\n      red(this.red, 'redSqrt');\n      return this.red.sqrt(this);\n    }\n  }, {\n    key: \"redIDivSqrt\",\n    value: function redIDivSqrt(v) {\n      red(this.red, 'redIDivSqrt');\n      return this.red.idivsqrt(this, v);\n    }\n  }, {\n    key: \"redDivSqrt\",\n    value: function redDivSqrt(v) {\n      red(this.red, 'redDivSqrt');\n      return this.red.divsqrt(this, v);\n    }\n  }, {\n    key: \"redIsSquare\",\n    value: function redIsSquare() {\n      red(this.red, 'redIsSquare');\n      return this.red.isSquare(this);\n    }\n  }, {\n    key: \"redIShl\",\n    value: function redIShl(num) {\n      enforce(BN.isBN(num), 'num', 'bignum');\n      red(this.red, 'redIShl');\n      nonred(!num.red, 'redIShl');\n      return this.red.ishl(this, num);\n    }\n  }, {\n    key: \"redShl\",\n    value: function redShl(num) {\n      enforce(BN.isBN(num), 'num', 'bignum');\n      red(this.red, 'redShl');\n      nonred(!num.red, 'redShl');\n      return this.red.shl(this, num);\n    }\n  }, {\n    key: \"redIShln\",\n    value: function redIShln(num) {\n      enforce(num >>> 0 === num, 'num', 'uint32');\n      red(this.red, 'redIShln');\n      return this.red.ishln(this, num);\n    }\n  }, {\n    key: \"redShln\",\n    value: function redShln(num) {\n      enforce(num >>> 0 === num, 'num', 'uint32');\n      red(this.red, 'redShln');\n      return this.red.shln(this, num);\n    }\n  }, {\n    key: \"redINeg\",\n    value: function redINeg() {\n      red(this.red, 'redINeg');\n      return this.red.ineg(this);\n    }\n  }, {\n    key: \"redNeg\",\n    value: function redNeg() {\n      red(this.red, 'redNeg');\n      return this.red.neg(this);\n    }\n  }, {\n    key: \"redEq\",\n    value: function redEq(num) {\n      enforce(BN.isBN(num), 'num', 'bignum');\n      red(this.red, 'redEq');\n      return this.red.eq(this, num);\n    }\n  }, {\n    key: \"redEqn\",\n    value: function redEqn(num) {\n      enforce(isSMI(num), 'num', 'smi');\n      red(this.red, 'redEqn');\n      return this.red.eqn(this, num);\n    }\n  }, {\n    key: \"redIsHigh\",\n    value: function redIsHigh() {\n      red(this.red, 'redIsHigh');\n      return this.red.isHigh(this);\n    }\n  }, {\n    key: \"redIsLow\",\n    value: function redIsLow() {\n      red(this.red, 'redIsLow');\n      return this.red.isLow(this);\n    }\n  }, {\n    key: \"redIsOdd\",\n    value: function redIsOdd() {\n      red(this.red, 'redIsOdd');\n      return this.red.isOdd(this);\n    }\n  }, {\n    key: \"redIsEven\",\n    value: function redIsEven() {\n      red(this.red, 'redIsEven');\n      return this.red.isEven(this);\n    }\n  }, {\n    key: \"redLegendre\",\n    value: function redLegendre() {\n      red(this.red, 'redLegendre');\n      return this.red.legendre(this);\n    }\n  }, {\n    key: \"redJacobi\",\n    value: function redJacobi() {\n      red(this.red, 'redJacobi');\n      return this.red.jacobi(this);\n    }\n  }, {\n    key: \"redKronecker\",\n    value: function redKronecker() {\n      red(this.red, 'redKronecker');\n      return this.red.kronecker(this);\n    }\n  }, {\n    key: \"redIInvert\",\n    value: function redIInvert() {\n      red(this.red, 'redIInvert');\n      return this.red.iinvert(this);\n    }\n  }, {\n    key: \"redInvert\",\n    value: function redInvert() {\n      red(this.red, 'redInvert');\n      return this.red.invert(this);\n    }\n  }, {\n    key: \"redIFermat\",\n    value: function redIFermat() {\n      red(this.red, 'redIFermat');\n      return this.red.ifermat(this);\n    }\n  }, {\n    key: \"redFermat\",\n    value: function redFermat() {\n      red(this.red, 'redFermat');\n      return this.red.fermat(this);\n    }\n    /*\n     * Internal\n     */\n\n  }, {\n    key: \"_move\",\n    value: function _move(dest) {\n      dest.words = this.words;\n      dest.length = this.length;\n      dest.negative = this.negative;\n      dest.red = this.red;\n      return dest;\n    }\n  }, {\n    key: \"_alloc\",\n    value: function _alloc(size) {\n      while (this.words.length < size) {\n        this.words.push(0);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"_expand\",\n    value: function _expand(size) {\n      this._alloc(size);\n\n      while (this.length < size) {\n        this.words[this.length++] = 0;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"_strip\",\n    value: function _strip() {\n      while (this.length > 1 && this.words[this.length - 1] === 0) {\n        this.length -= 1;\n      }\n\n      return this._normalize();\n    }\n  }, {\n    key: \"_normalize\",\n    value: function _normalize() {\n      assert(this.length > 0); // -0 = 0\n\n      if (this.length === 1 && this.words[0] === 0) this.negative = 0;\n      return this;\n    }\n  }, {\n    key: \"_check\",\n    value: function _check() {\n      // We never have a zero length number.\n      assert(this.length > 0); // Cannot exceed array bounds.\n\n      assert(this.length <= this.words.length);\n\n      if (this.length === 1) {\n        // Must be normalized.\n        if (this.words[0] === 0) assert(this.negative === 0);\n        return this;\n      } // Must be stripped.\n\n\n      assert(this.words[this.length - 1] !== 0);\n      return this;\n    }\n  }, {\n    key: \"_invertp\",\n    value: function _invertp(p) {\n      enforce(BN.isBN(p), 'p', 'bignum');\n      assert(this.negative === 0);\n      assert(p.sign() > 0);\n      if (this.isZero() || p.cmpn(1) === 0) throw new RangeError('Not invertible.');\n      var a = this.clone();\n      var b = p.clone();\n      var x1 = new BN(1);\n      var x2 = new BN(0);\n      var delta = b.clone();\n\n      while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {\n        var i = 0;\n\n        for (var im = 1; (a.words[0] & im) === 0 && i < 26; im <<= 1) {\n          i += 1;\n        }\n\n        if (i > 0) {\n          a.iushrn(i);\n\n          while (i > 0) {\n            if (x1.isOdd()) x1.iadd(delta);\n            x1.iushrn(1);\n            i -= 1;\n          }\n        }\n\n        var j = 0;\n\n        for (var jm = 1; (b.words[0] & jm) === 0 && j < 26; jm <<= 1) {\n          j += 1;\n        }\n\n        if (j > 0) {\n          b.iushrn(j);\n\n          while (j > 0) {\n            if (x2.isOdd()) x2.iadd(delta);\n            x2.iushrn(1);\n            j -= 1;\n          }\n        }\n\n        if (a.cmp(b) >= 0) {\n          a.isub(b);\n          x1.isub(x2);\n        } else {\n          b.isub(a);\n          x2.isub(x1);\n        }\n      } // Quick reduction (typically +/- 2P).\n\n\n      var res = a.cmpn(1) === 0 ? x1 : x2;\n\n      if (res.ucmp(p) >= 0) {\n        res._isub(res, p);\n\n        if (res.ucmp(p) >= 0) res._isub(res, p);\n      }\n\n      if (res.isNeg()) res.iadd(p);\n      return res;\n    }\n  }, {\n    key: \"_factor2\",\n    value: function _factor2(num) {\n      // Find common factor of two.\n      // Expects inputs to be non-zero.\n      if ((this.words[0] | num.words[0]) & 1) return 0;\n      var len = Math.min(this.length, num.length);\n      var r = 0;\n\n      for (var i = 0; i < len; i++) {\n        var b = _zeroBits(this.words[i] | num.words[i]);\n\n        r += b;\n        if (b !== 26) break;\n      }\n\n      return r;\n    }\n  }, {\n    key: \"_cloneNormal\",\n    value: function _cloneNormal() {\n      return this.red ? this.fromRed() : this.clone();\n    }\n  }, {\n    key: \"_forceRed\",\n    value: function _forceRed(ctx) {\n      this.red = ctx;\n      return this;\n    }\n    /*\n     * Helpers\n     */\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var copy = new BN();\n      copy.words = new Array(this.length);\n\n      for (var i = 0; i < this.length; i++) {\n        copy.words[i] = this.words[i];\n      }\n\n      copy.length = this.length;\n      copy.negative = this.negative;\n      copy.red = this.red;\n      return copy;\n    }\n  }, {\n    key: \"inject\",\n    value: function inject(num) {\n      enforce(BN.isBN(num), 'num', 'bignum');\n\n      this._alloc(num.length);\n\n      for (var i = 0; i < num.length; i++) {\n        this.words[i] = num.words[i];\n      }\n\n      this.length = num.length;\n      this.negative = num.negative;\n      this.red = num.red;\n      return this;\n    }\n  }, {\n    key: \"set\",\n    value: function set(num, endian) {\n      return this.fromNumber(num, endian);\n    }\n  }, {\n    key: \"swap\",\n    value: function swap(num) {\n      enforce(BN.isBN(num), 'num', 'bignum');\n      var x = this;\n      var y = num;\n      var _ref9 = [y.words, x.words];\n      x.words = _ref9[0];\n      y.words = _ref9[1];\n      var _ref10 = [y.length, x.length];\n      x.length = _ref10[0];\n      y.length = _ref10[1];\n      var _ref11 = [y.negative, x.negative];\n      x.negative = _ref11[0];\n      y.negative = _ref11[1];\n      var _ref12 = [y.red, x.red];\n      x.red = _ref12[0];\n      y.red = _ref12[1];\n      return x;\n    }\n  }, {\n    key: \"reverse\",\n    value: function reverse() {\n      var neg = this.negative;\n      this.fromBuffer(this.toBuffer('be'), 'le');\n      this.negative = neg;\n      return this;\n    }\n  }, {\n    key: \"byteLength\",\n    value: function byteLength() {\n      return Math.ceil(this.bitLength() / 8);\n    }\n  }, {\n    key: \"bitLength\",\n    value: function bitLength() {\n      var w = this.words[this.length - 1];\n      var hi = countBits(w);\n      return (this.length - 1) * 26 + hi;\n    }\n  }, {\n    key: \"zeroBits\",\n    value: function zeroBits() {\n      if (this.isZero()) return 0;\n      if (this.isOdd()) return 0;\n      var r = 0;\n\n      for (var i = 0; i < this.length; i++) {\n        var b = _zeroBits(this.words[i]);\n\n        r += b;\n        if (b !== 26) break;\n      }\n\n      return r;\n    }\n  }, {\n    key: \"isSafe\",\n    value: function isSafe() {\n      if (this.length <= 2) return true;\n      if (this.length === 3 && this.words[2] === 0x01) return true;\n      return false;\n    }\n  }, {\n    key: \"word\",\n    value: function word(pos) {\n      enforce(pos >>> 0 === pos, 'pos', 'uint32');\n      if (pos >= this.length) return 0;\n      return this.words[pos];\n    }\n  }, {\n    key: custom,\n    value: function value() {\n      var prefix = 'BN';\n      if (this.red) prefix = 'BN-R';\n      return \"<\".concat(prefix, \": \").concat(this.toString(10), \">\");\n    }\n    /*\n     * Constant Time\n     */\n\n  }, {\n    key: \"csign\",\n    value: function csign() {\n      return this.negative * -2 + 1 - this.czero();\n    }\n  }, {\n    key: \"czero\",\n    value: function czero() {\n      var zword = this.words[0] - 1 >>> 31;\n      return this.length - 2 >>> 31 & zword;\n    }\n  }, {\n    key: \"cneg\",\n    value: function cneg() {\n      return this.negative;\n    }\n  }, {\n    key: \"cpos\",\n    value: function cpos() {\n      return this.negative ^ 1;\n    }\n  }, {\n    key: \"ceq\",\n    value: function ceq(num) {\n      enforce(BN.isBN(num), 'num', 'bignum'); // Assumes `num` is the \"constant size\"\n      // parameter. Note that constant size\n      // doesn't necessarily mean secret.\n\n      var z = 0;\n\n      for (var i = 0; i < num.length; i++) {\n        z |= this.words[i % this.length] ^ num.words[i];\n      }\n\n      z |= this.length ^ num.length;\n      z |= this.negative ^ num.negative;\n      return z - 1 >>> 31;\n    }\n  }, {\n    key: \"ceqn\",\n    value: function ceqn(num) {\n      var neg = num >> 31 & 1;\n      var word = (num | 0) * (-neg | 1) & 0x3ffffff;\n      var z = 0;\n      z |= this.words[0] ^ word;\n      z |= this.length ^ 1;\n      z |= this.negative ^ neg;\n      return z - 1 >>> 31;\n    }\n  }, {\n    key: \"cswap\",\n    value: function cswap(num, flag) {\n      enforce(BN.isBN(num), 'num', 'bignum');\n      var x = this;\n      var y = num;\n      var cond = (flag >> 31 | -flag >> 31) & 1;\n      var mask = -cond & 0x3ffffff;\n\n      x._alloc(y.words.length);\n\n      y._alloc(x.words.length);\n\n      for (var i = 0; i < x.words.length; i++) {\n        var word = (x.words[i] ^ y.words[i]) & mask;\n        x.words[i] ^= word;\n        y.words[i] ^= word;\n      }\n\n      var length = (x.length ^ y.length) & mask;\n      var negative = (x.negative ^ y.negative) & mask;\n      x.length ^= length;\n      y.length ^= length;\n      x.negative ^= negative;\n      y.negative ^= negative;\n      return this;\n    }\n  }, {\n    key: \"cinject\",\n    value: function cinject(num, flag) {\n      enforce(BN.isBN(num), 'num', 'bignum');\n      var x = this;\n      var y = num;\n      var cond = (flag >> 31 | -flag >> 31) & 1;\n      var mask0 = cond - 1 & 0x3ffffff;\n      var mask1 = ~(cond - 1) & 0x3ffffff;\n\n      x._alloc(y.length);\n\n      for (var i = 0; i < y.length; i++) {\n        x.words[i] = x.words[i] & mask0 | y.words[i] & mask1;\n      }\n\n      x.length = x.length & mask0 | y.length & mask1;\n      x.negative = x.negative & mask0 | y.negative & mask1;\n      return this;\n    }\n  }, {\n    key: \"cset\",\n    value: function cset(num, flag) {\n      var cond = (flag >> 31 | -flag >> 31) & 1;\n      var mask0 = cond - 1 & 0x3ffffff;\n      var mask1 = ~(cond - 1) & 0x3ffffff;\n      var neg = num >> 31 & 1;\n      var word = (num | 0) * (-neg | 1) & 0x3ffffff;\n      this.words[0] = this.words[0] & mask0 | word & mask1;\n      this.length = this.length & mask0 | 1 & mask1;\n      this.negative = this.negative & mask0 | neg & mask1;\n      return this;\n    }\n    /*\n     * Conversion\n     */\n\n  }, {\n    key: \"toNumber\",\n    value: function toNumber() {\n      var num = this.words[0];\n\n      if (this.length === 2) {\n        num += this.words[1] * 0x4000000;\n      } else if (this.length === 3 && this.words[2] === 0x01) {\n        // Note: at this stage it is known that the top bit is set.\n        num += 0x10000000000000 + this.words[1] * 0x4000000;\n      } else if (this.length > 2) {\n        throw new RangeError('Number can only safely store up to 53 bits.');\n      }\n\n      return this.negative !== 0 ? -num : num;\n    }\n  }, {\n    key: \"toDouble\",\n    value: function toDouble() {\n      var num = 0;\n\n      for (var i = this.length - 1; i >= 0; i--) {\n        num = num * 0x4000000 + this.words[i];\n      }\n\n      return this.negative !== 0 ? -num : num;\n    }\n  }, {\n    key: \"valueOf\",\n    value: function valueOf() {\n      return this.toDouble();\n    }\n  }, {\n    key: \"toBigInt\",\n    value: function toBigInt() {\n      if (!HAS_BIGINT) throw new Error('BigInt is not supported!');\n      var s52 = BigInt(52);\n      var s26 = BigInt(26);\n      var i = this.length - 1;\n      var num = BigInt(0);\n\n      for (; i >= 1; i -= 2) {\n        var hi = this.words[i] * 0x4000000;\n        var lo = this.words[i - 1];\n        num = num << s52 | BigInt(hi + lo);\n      }\n\n      if (i >= 0) num = num << s26 | BigInt(this.words[0]);\n      return this.negative !== 0 ? -num : num;\n    }\n  }, {\n    key: \"toBool\",\n    value: function toBool() {\n      return !this.isZero();\n    }\n  }, {\n    key: \"toString\",\n    value: function toString(base, padding) {\n      base = getBase(base);\n      if (padding == null) padding = 0;\n      if (padding === 0) padding = 1;\n      enforce(base >>> 0 === base, 'base', 'uint32');\n      enforce(padding >>> 0 === padding, 'padding', 'uint32');\n      if (base < 2 || base > 36) throw new RangeError('Base ranges between 2 and 36.');\n\n      this._check();\n\n      if (base === 16) {\n        var _out = '';\n        var off = 0;\n        var carry = 0;\n\n        for (var i = 0; i < this.length; i++) {\n          var w = this.words[i];\n          var word = ((w << off | carry) & 0xffffff).toString(16);\n          carry = w >>> 24 - off & 0xffffff;\n          if (carry !== 0 || i !== this.length - 1) _out = zeros[6 - word.length] + word + _out;else _out = word + _out;\n          off += 2;\n\n          if (off >= 26) {\n            off -= 26;\n            i -= 1;\n          }\n        }\n\n        if (carry !== 0) _out = carry.toString(16) + _out;\n\n        while (_out.length % padding !== 0) {\n          _out = '0' + _out;\n        }\n\n        if (this.negative !== 0) _out = '-' + _out;\n        return _out;\n      }\n\n      var groupSize = groupSizes[base - 1];\n      var groupBase = groupBases[base - 1];\n      var c = this.clone();\n      var out = '';\n      c.negative = 0;\n\n      while (!c.isZero()) {\n        var r = c.remrn(groupBase).toString(base);\n        c.iquon(groupBase);\n        if (!c.isZero()) out = zeros[groupSize - r.length] + r + out;else out = r + out;\n      }\n\n      if (this.isZero()) out = '0';\n\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n\n      if (this.negative !== 0) out = '-' + out;\n      return out;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.toString(16, 2);\n    }\n  }, {\n    key: \"toArray\",\n    value: function toArray(endian, length) {\n      return this.toArrayLike(Array, endian, length);\n    }\n  }, {\n    key: \"toBuffer\",\n    value: function toBuffer(endian, length) {\n      return this.toArrayLike(Buffer, endian, length);\n    }\n  }, {\n    key: \"toArrayLike\",\n    value: function toArrayLike(ArrayType, endian, length) {\n      if (endian == null) endian = 'be';\n      if (length == null) length = 0;\n      enforce(typeof ArrayType === 'function', 'ArrayType', 'function');\n      enforce(endian === 'be' || endian === 'le', 'endian', 'endianness');\n      enforce(length >>> 0 === length, 'length', 'uint32');\n\n      this._check();\n\n      var bytes = this.byteLength();\n      var size = length || Math.max(1, bytes);\n      if (bytes > size) throw new RangeError('Byte array longer than desired length.');\n      var res = allocate(ArrayType, size); // See: https://github.com/indutny/bn.js/pull/222\n\n      if (endian === 'be') {\n        var pos = res.length - 1;\n        var carry = 0;\n\n        for (var i = 0; i < this.length; i++) {\n          var shift = (i & 3) << 1;\n          var word = this.words[i] << shift | carry;\n          res[pos--] = word & 0xff;\n          if (pos >= 0) res[pos--] = word >>> 8 & 0xff;\n          if (pos >= 0) res[pos--] = word >>> 16 & 0xff;\n\n          if (shift === 6) {\n            if (pos >= 0) res[pos--] = word >>> 24 & 0xff;\n            carry = 0;\n          } else {\n            carry = word >>> 24;\n          }\n        }\n\n        if (pos >= 0) {\n          res[pos--] = carry;\n\n          while (pos >= 0) {\n            res[pos--] = 0;\n          }\n\n          carry = 0;\n        }\n\n        assert(carry === 0);\n      } else {\n        var _pos = 0;\n        var _carry = 0;\n\n        for (var _i6 = 0; _i6 < this.length; _i6++) {\n          var _shift = (_i6 & 3) << 1;\n\n          var _word = this.words[_i6] << _shift | _carry;\n\n          res[_pos++] = _word & 0xff;\n          if (_pos < res.length) res[_pos++] = _word >>> 8 & 0xff;\n          if (_pos < res.length) res[_pos++] = _word >>> 16 & 0xff;\n\n          if (_shift === 6) {\n            if (_pos < res.length) res[_pos++] = _word >>> 24 & 0xff;\n            _carry = 0;\n          } else {\n            _carry = _word >>> 24;\n          }\n        }\n\n        if (_pos < res.length) {\n          res[_pos++] = _carry;\n\n          while (_pos < res.length) {\n            res[_pos++] = 0;\n          }\n\n          _carry = 0;\n        }\n\n        assert(_carry === 0);\n      }\n\n      return res;\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(endian, length) {\n      return this.toBuffer(endian, length);\n    }\n    /*\n     * Instantiation\n     */\n\n  }, {\n    key: \"of\",\n    value: function of(num, endian) {\n      return this.fromNumber(num, endian);\n    }\n  }, {\n    key: \"fromNumber\",\n    value: function fromNumber(num, endian) {\n      if (endian == null) endian = 'be';\n      enforce(isInteger(num), 'num', 'integer');\n      enforce(endian === 'be' || endian === 'le', 'endian', 'endianness');\n      var neg = num < 0 | 0;\n      if (neg) num = -num;\n\n      if (num < 0x4000000) {\n        this.words[0] = num & 0x3ffffff;\n        this.length = 1;\n      } else if (num < 0x10000000000000) {\n        this.words = [num & 0x3ffffff, num / 0x4000000 & 0x3ffffff];\n        this.length = 2;\n      } else {\n        this.words = [num & 0x3ffffff, num / 0x4000000 & 0x3ffffff, 1];\n        this.length = 3;\n      }\n\n      this.negative = neg;\n      if (endian === 'le') this.reverse();\n      return this;\n    }\n  }, {\n    key: \"fromDouble\",\n    value: function fromDouble(num, endian) {\n      if (endian == null) endian = 'be';\n      enforce(typeof num === 'number', 'num', 'double');\n      enforce(endian === 'be' || endian === 'le', 'endian', 'endianness');\n      if (!isFinite(num)) num = 0;\n      var neg = num <= -1 | 0;\n      if (num < 0) num = -num;\n      num = Math.floor(num);\n      this.words = [];\n\n      while (num > 0) {\n        var lo = num % 0x4000000;\n        var hi = (num - lo) / 0x4000000;\n        this.words.push(lo);\n        num = hi;\n      }\n\n      if (this.words.length === 0) this.words.push(0);\n      this.length = this.words.length;\n      this.negative = neg;\n      if (endian === 'le') this.reverse();\n      return this;\n    }\n  }, {\n    key: \"fromBigInt\",\n    value: function fromBigInt(num, endian) {\n      if (endian == null) endian = 'be';\n      enforce(typeof num === 'bigint', 'num', 'bigint');\n      enforce(endian === 'be' || endian === 'le', 'endian', 'endianness');\n      if (!HAS_BIGINT) throw new Error('BigInt is not supported!'); // You know the implementation has a\n      // problem when strings are twice\n      // as fast as bigints.\n\n      var start = num < BigInt(0) | 0;\n\n      this._fromHex(num.toString(16), start);\n\n      this.negative = start;\n      if (endian === 'le') this.reverse();\n      return this;\n    }\n  }, {\n    key: \"fromBool\",\n    value: function fromBool(value) {\n      enforce(typeof value === 'boolean', 'value', 'boolean');\n      this.words[0] = value | 0;\n      this.length = 1;\n      this.negative = 0;\n      return this;\n    }\n  }, {\n    key: \"fromString\",\n    value: function fromString(str, base, endian) {\n      if (base === 'le' || base === 'be') {\n        var _ref13 = [endian, base];\n        base = _ref13[0];\n        endian = _ref13[1];\n      }\n\n      base = getBase(base);\n      if (endian == null) endian = 'be';\n      enforce(typeof str === 'string', 'string', 'string');\n      enforce(base >>> 0 === base, 'base', 'uint32');\n      enforce(endian === 'be' || endian === 'le', 'endian', 'endianness');\n      if (base < 2 || base > 36) throw new Error('Base ranges between 2 and 36.');\n      str = str.replace(/\\s+/g, '');\n      var start = 0;\n      if (str.length > 0 && str.charCodeAt(0) === 0x2d) start = 1;\n      if (base === 16) this._fromHex(str, start);else this._fromBase(str, base, start);\n      this.negative = start;\n\n      this._normalize();\n\n      if (endian === 'le') this.reverse();\n      return this;\n    }\n  }, {\n    key: \"_fromHex\",\n    value: function _fromHex(str, start) {\n      this.length = Math.max(2, Math.ceil((str.length - start) / 6));\n      this.words = new Array(this.length);\n\n      for (var _i7 = 0; _i7 < this.length; _i7++) {\n        this.words[_i7] = 0;\n      } // Scan 24-bit chunks and add them to the number.\n\n\n      var off = 0;\n      var i = str.length - 6;\n      var j = 0;\n\n      for (; i >= start; i -= 6) {\n        var w = parseHex(str, i, i + 6);\n        this.words[j] |= w << off & 0x3ffffff; // `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb.\n\n        this.words[j + 1] |= w >>> 26 - off & 0x3fffff;\n        off += 24;\n\n        if (off >= 26) {\n          off -= 26;\n          j += 1;\n        }\n      }\n\n      if (i + 6 !== start) {\n        var _w3 = parseHex(str, start, i + 6);\n\n        this.words[j] |= _w3 << off & 0x3ffffff;\n        this.words[j + 1] |= _w3 >>> 26 - off & 0x3fffff;\n      }\n\n      return this._strip();\n    }\n  }, {\n    key: \"_fromBase\",\n    value: function _fromBase(str, base, start) {\n      // Initialize as zero.\n      this.words[0] = 0;\n      this.length = 1;\n      this.negative = 0; // Find length of limb in base.\n\n      var limbLen = 0;\n      var limbPow = 1;\n\n      for (; limbPow <= 0x3ffffff; limbPow *= base) {\n        limbLen += 1;\n      }\n\n      limbLen -= 1;\n      limbPow = limbPow / base | 0;\n      var total = str.length - start;\n      var mod = total % limbLen;\n      var end = Math.min(total, total - mod) + start;\n      var i = start;\n\n      for (; i < end; i += limbLen) {\n        var word = parseBase(str, i, i + limbLen, base);\n        this.imuln(limbPow);\n\n        this._iaddn(word);\n      }\n\n      if (mod !== 0) {\n        var pow = Math.pow(base, mod);\n\n        var _word2 = parseBase(str, i, str.length, base);\n\n        this.imuln(pow);\n\n        this._iaddn(_word2);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      if (BN.isBN(json)) {\n        if (json.red) return json.fromRed();\n        return json.clone();\n      }\n\n      if (Array.isArray(json)) {\n        var _iterator = _createForOfIteratorHelper(json),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var chunk = _step.value;\n            enforce(typeof chunk === 'string', 'chunk', 'string');\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        json = json.join('');\n      }\n\n      return this.fromString(json, 16);\n    }\n  }, {\n    key: \"fromBN\",\n    value: function fromBN(num) {\n      return this.inject(num);\n    }\n  }, {\n    key: \"fromArray\",\n    value: function fromArray(data, endian) {\n      enforce(Array.isArray(data), 'data', 'array');\n      return this.fromArrayLike(data, endian);\n    }\n  }, {\n    key: \"fromBuffer\",\n    value: function fromBuffer(data, endian) {\n      enforce(Buffer.isBuffer(data), 'data', 'buffer');\n      return this.fromArrayLike(data, endian);\n    }\n  }, {\n    key: \"fromArrayLike\",\n    value: function fromArrayLike(data, endian) {\n      if (endian == null) endian = 'be';\n      enforce(data && data.length >>> 0 === data.length, 'data', 'array-like');\n      enforce(endian === 'be' || endian === 'le', 'endian', 'endianness');\n\n      if (data.length === 0) {\n        this.words[0] = 0;\n        this.length = 1;\n        this.negative = 0;\n        return this;\n      }\n\n      this.length = Math.max(2, Math.ceil(data.length / 3));\n      this.words = new Array(this.length);\n      this.negative = 0;\n\n      for (var i = 0; i < this.length; i++) {\n        this.words[i] = 0;\n      }\n\n      var left = data.length % 3;\n      var off = 0;\n      var j = 0;\n      var w = 0;\n\n      if (endian === 'be') {\n        for (var _i8 = data.length - 1; _i8 >= 2; _i8 -= 3) {\n          var _w4 = data[_i8] | data[_i8 - 1] << 8 | data[_i8 - 2] << 16;\n\n          this.words[j] |= _w4 << off & 0x3ffffff;\n          this.words[j + 1] = _w4 >>> 26 - off & 0x3ffffff;\n          off += 24;\n\n          if (off >= 26) {\n            off -= 26;\n            j += 1;\n          }\n        }\n\n        switch (left) {\n          case 2:\n            w = data[1] | data[0] << 8;\n            break;\n\n          case 1:\n            w = data[0];\n            break;\n        }\n      } else {\n        var len = data.length - left;\n\n        for (var _i9 = 0; _i9 < len; _i9 += 3) {\n          var _w5 = data[_i9] | data[_i9 + 1] << 8 | data[_i9 + 2] << 16;\n\n          this.words[j] |= _w5 << off & 0x3ffffff;\n          this.words[j + 1] = _w5 >>> 26 - off & 0x3ffffff;\n          off += 24;\n\n          if (off >= 26) {\n            off -= 26;\n            j += 1;\n          }\n        }\n\n        switch (left) {\n          case 2:\n            w = data[len] | data[len + 1] << 8;\n            break;\n\n          case 1:\n            w = data[len];\n            break;\n        }\n      }\n\n      if (left > 0) {\n        this.words[j] |= w << off & 0x3ffffff;\n        this.words[j + 1] = w >>> 26 - off & 0x3ffffff;\n      }\n\n      return this._strip();\n    }\n  }, {\n    key: \"decode\",\n    value: function decode(data, endian) {\n      return this.fromBuffer(data, endian);\n    }\n  }, {\n    key: \"from\",\n    value: function from(num, base, endian) {\n      if (num == null) return this;\n\n      if (base === 'le' || base === 'be') {\n        var _ref14 = [endian, base];\n        base = _ref14[0];\n        endian = _ref14[1];\n      }\n\n      if (typeof num === 'number') return this.fromNumber(num, endian);\n      if (typeof num === 'bigint') return this.fromBigInt(num, endian);\n      if (typeof num === 'string') return this.fromString(num, base, endian);\n\n      if (typeof num === 'object') {\n        if (BN.isBN(num)) return this.fromBN(num, endian);\n        if (num.length >>> 0 === num.length) return this.fromArrayLike(num, endian);\n      }\n\n      if (typeof num === 'boolean') return this.fromBool(num);\n      throw new TypeError('Non-numeric object passed to BN.');\n    }\n    /*\n     * Static Methods\n     */\n\n  }], [{\n    key: \"min\",\n    value: function min() {\n      var min = null;\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      for (var _i10 = 0, _args = args; _i10 < _args.length; _i10++) {\n        var num = _args[_i10];\n        enforce(BN.isBN(num), 'num', 'bignum');\n        if (!min || num.cmp(min) < 0) min = num;\n      }\n\n      return min || new BN(0);\n    }\n  }, {\n    key: \"max\",\n    value: function max() {\n      var max = null;\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      for (var _i11 = 0, _args2 = args; _i11 < _args2.length; _i11++) {\n        var num = _args2[_i11];\n        enforce(BN.isBN(num), 'num', 'bignum');\n        if (!max || num.cmp(max) > 0) max = num;\n      }\n\n      return max || new BN(0);\n    }\n  }, {\n    key: \"cmp\",\n    value: function cmp(a, b) {\n      enforce(BN.isBN(a), 'a', 'bignum');\n      return a.cmp(b);\n    }\n  }, {\n    key: \"ucmp\",\n    value: function ucmp(a, b) {\n      enforce(BN.isBN(a), 'a', 'bignum');\n      return a.ucmp(b);\n    }\n  }, {\n    key: \"red\",\n    value: function red(num) {\n      return new Red(num);\n    }\n  }, {\n    key: \"barrett\",\n    value: function barrett(num) {\n      return new Barrett(num);\n    }\n  }, {\n    key: \"mont\",\n    value: function mont(num) {\n      return new Mont(num);\n    }\n  }, {\n    key: \"_prime\",\n    value: function _prime(name) {\n      if (primes[name]) return primes[name];\n      var prime;\n      if (name === 'p192') prime = new P192();else if (name === 'p224') prime = new P224();else if (name === 'p521') prime = new P521();else if (name === 'k256') prime = new K256();else if (name === 'p25519') prime = new P25519();else if (name === 'p448') prime = new P448();else throw new Error(\"Unknown prime: \\\"\".concat(name, \"\\\".\"));\n      primes[name] = prime;\n      return prime;\n    }\n  }, {\n    key: \"prime\",\n    value: function prime(name) {\n      return BN._prime(name).p.clone();\n    }\n  }, {\n    key: \"pow\",\n    value: function pow(num, exp) {\n      if (num === 2) return BN.shift(1, exp);\n      return new BN().fromNumber(num).pown(exp);\n    }\n  }, {\n    key: \"shift\",\n    value: function shift(num, bits) {\n      if (num === 1) return new BN(0).usetn(bits, 1);\n      return new BN().fromNumber(num).ishln(bits);\n    }\n  }, {\n    key: \"mask\",\n    value: function mask(bits) {\n      return BN.shift(1, bits).isubn(1);\n    }\n  }, {\n    key: \"randomBits\",\n    value: function randomBits(rng, bits) {\n      enforce(rng != null, 'rng', 'rng');\n      enforce(bits >>> 0 === bits, 'bits', 'uint32');\n\n      if (typeof rng === 'object') {\n        enforce(typeof rng.randomBytes === 'function', 'rng', 'rng');\n        var size = bits + 7 >>> 3;\n        var total = size * 8;\n        var bytes = rng.randomBytes(size);\n        enforce(Buffer.isBuffer(bytes), 'bytes', 'buffer');\n        if (bytes.length !== size) throw new RangeError('Invalid number of bytes returned from RNG.');\n\n        var _num = BN.fromBuffer(bytes);\n\n        if (total > bits) _num.iushrn(total - bits);\n        return _num;\n      }\n\n      enforce(typeof rng === 'function', 'rng', 'rng');\n      var num = rng(bits);\n      enforce(BN.isBN(num), 'num', 'bignum');\n      range(num.negative === 0, 'RNG');\n      nonred(!num.red, 'RNG');\n      if (num.bitLength() > bits) throw new RangeError('Invalid number of bits returned from RNG.');\n      return num;\n    }\n  }, {\n    key: \"random\",\n    value: function random(rng, min, max) {\n      min = BN.cast(min, 16);\n      max = BN.cast(max, 16);\n      if (min.cmp(max) > 0) throw new RangeError('Minimum cannot be greater than maximum.');\n      var space = max.sub(min).iabs();\n      var bits = space.bitLength();\n      if (bits === 0) return min.clone();\n\n      for (;;) {\n        var num = BN.randomBits(rng, bits); // Maximum is _exclusive_!\n\n        if (num.cmp(space) >= 0) continue; // Minimum is _inclusive_!\n\n        num.iadd(min);\n        return num;\n      }\n    }\n  }, {\n    key: \"of\",\n    value: function of(num, endian) {\n      return new BN().of(num, endian);\n    }\n  }, {\n    key: \"fromNumber\",\n    value: function fromNumber(num, endian) {\n      return new BN().fromNumber(num, endian);\n    }\n  }, {\n    key: \"fromDouble\",\n    value: function fromDouble(num, endian) {\n      return new BN().fromDouble(num, endian);\n    }\n  }, {\n    key: \"fromBigInt\",\n    value: function fromBigInt(num, endian) {\n      return new BN().fromBigInt(num, endian);\n    }\n  }, {\n    key: \"fromBool\",\n    value: function fromBool(value) {\n      return new BN().fromBool(value);\n    }\n  }, {\n    key: \"fromString\",\n    value: function fromString(str, base, endian) {\n      return new BN().fromString(str, base, endian);\n    }\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(json) {\n      return new BN().fromJSON(json);\n    }\n  }, {\n    key: \"fromBN\",\n    value: function fromBN(num) {\n      return new BN().fromBN(num);\n    }\n  }, {\n    key: \"fromArray\",\n    value: function fromArray(data, endian) {\n      return new BN().fromArray(data, endian);\n    }\n  }, {\n    key: \"fromBuffer\",\n    value: function fromBuffer(data, endian) {\n      return new BN().fromBuffer(data, endian);\n    }\n  }, {\n    key: \"fromArrayLike\",\n    value: function fromArrayLike(data, endian) {\n      return new BN().fromArrayLike(data, endian);\n    }\n  }, {\n    key: \"decode\",\n    value: function decode(data, endian) {\n      return new BN().decode(data, endian);\n    }\n  }, {\n    key: \"from\",\n    value: function from(num, base, endian) {\n      return new BN().from(num, base, endian);\n    }\n  }, {\n    key: \"cast\",\n    value: function cast(num, base, endian) {\n      if (BN.isBN(num)) return num;\n      return new BN(num, base, endian);\n    }\n  }, {\n    key: \"isBN\",\n    value: function isBN(obj) {\n      return obj instanceof BN;\n    }\n  }]);\n\n  return BN;\n}();\n/*\n * Static\n */\n\n\nBN.BN = BN;\nBN.wordSize = 26;\nBN.native = 0;\n/**\n * Prime\n */\n\nvar Prime = /*#__PURE__*/function () {\n  function Prime(name, p) {\n    _classCallCheck(this, Prime);\n\n    // P = 2^N - K\n    this.name = name;\n    this.p = new BN(p, 16);\n    this.n = this.p.bitLength();\n    this.k = BN.shift(1, this.n).isub(this.p);\n    this.lo = this.p.clone();\n    this.one = this.p.clone();\n  }\n\n  _createClass(Prime, [{\n    key: \"ireduce\",\n    value: function ireduce(num) {\n      // Assumes that `num` is less than `P^2`:\n      // num = HI * (2^N - K) + HI * K + LO = HI * K + LO (mod P)\n      var neg = num.negative !== 0; // Track bits.\n\n      var bits = num.bitLength(); // Must be less than P^2.\n\n      assert(bits <= this.n * 2); // Ensure positive.\n\n      num.negative = 0; // Reduce.\n\n      while (bits > this.n) {\n        // lo = num & ((1 << n) - 1)\n        // num = num >> n\n        this.split(num, this.lo); // num = num * K\n\n        this.imulK(num); // num = num + lo\n\n        num._iadd(num, this.lo); // bits = bitlen(num)\n\n\n        bits = num.bitLength();\n      } // Final reduction.\n\n\n      var cmp = bits < this.n ? -1 : num.ucmp(this.p);\n\n      if (cmp === 0) {\n        num.words[0] = 0;\n        num.length = 1;\n      } else if (cmp > 0) {\n        num._isub(num, this.p);\n      } else {// Note: we shouldn't need to strip here.\n      } // Adjust sign.\n\n\n      if (neg && !num.isZero()) num._isub(this.p, num);\n      return num;\n    }\n  }, {\n    key: \"split\",\n    value: function split(input, out) {\n      input._split(this.n, out);\n    }\n  }, {\n    key: \"imulK\",\n    value: function imulK(num) {\n      return num.imul(this.k);\n    }\n  }]);\n\n  return Prime;\n}();\n/**\n * P192\n */\n\n\nvar P192 = /*#__PURE__*/function (_Prime) {\n  _inherits(P192, _Prime);\n\n  var _super = _createSuper(P192);\n\n  function P192() {\n    _classCallCheck(this, P192);\n\n    // 2^192 - 2^64 - 1 (= 3 mod 4)\n    return _super.call(this, 'p192', 'ffffffff ffffffff ffffffff fffffffe' + 'ffffffff ffffffff');\n  }\n\n  _createClass(P192, [{\n    key: \"imulK\",\n    value: function imulK(num) {\n      // K = 0x10000000000000001\n      // K = 2^64 + 1\n      var one = this.one.inject(num);\n      return num.iushln(64)._iadd(num, one);\n    }\n  }]);\n\n  return P192;\n}(Prime);\n/**\n * P224\n */\n\n\nvar P224 = /*#__PURE__*/function (_Prime2) {\n  _inherits(P224, _Prime2);\n\n  var _super2 = _createSuper(P224);\n\n  function P224() {\n    _classCallCheck(this, P224);\n\n    // 2^224 - 2^96 + 1 (no congruence)\n    return _super2.call(this, 'p224', 'ffffffff ffffffff ffffffff ffffffff' + '00000000 00000000 00000001');\n  }\n\n  _createClass(P224, [{\n    key: \"imulK\",\n    value: function imulK(num) {\n      // K = 0xffffffffffffffffffffffff\n      // K = 2^96 - 1\n      var one = this.one.inject(num);\n      return num.iushln(96)._isub(num, one);\n    }\n  }]);\n\n  return P224;\n}(Prime);\n/**\n * P521\n */\n\n\nvar P521 = /*#__PURE__*/function (_Prime3) {\n  _inherits(P521, _Prime3);\n\n  var _super3 = _createSuper(P521);\n\n  function P521() {\n    _classCallCheck(this, P521);\n\n    // 2^521 - 1 (= 3 mod 4)\n    return _super3.call(this, 'p521', '000001ff ffffffff ffffffff ffffffff' + 'ffffffff ffffffff ffffffff ffffffff' + 'ffffffff ffffffff ffffffff ffffffff' + 'ffffffff ffffffff ffffffff ffffffff' + 'ffffffff');\n  }\n\n  _createClass(P521, [{\n    key: \"imulK\",\n    value: function imulK(num) {\n      // K = 0x01\n      return num;\n    }\n  }]);\n\n  return P521;\n}(Prime);\n/**\n * K256\n */\n\n\nvar K256 = /*#__PURE__*/function (_Prime4) {\n  _inherits(K256, _Prime4);\n\n  var _super4 = _createSuper(K256);\n\n  function K256() {\n    _classCallCheck(this, K256);\n\n    // 2^256 - 2^32 - 977 (= 3 mod 4)\n    return _super4.call(this, 'k256', 'ffffffff ffffffff ffffffff ffffffff' + 'ffffffff ffffffff fffffffe fffffc2f');\n  }\n\n  _createClass(K256, [{\n    key: \"split\",\n    value: function split(input, output) {\n      // 256 = 9 * 26 + 22\n      var mask = 0x3fffff;\n      var len = Math.min(input.length, 9);\n\n      output._alloc(len + 1);\n\n      for (var _i12 = 0; _i12 < len; _i12++) {\n        output.words[_i12] = input.words[_i12];\n      }\n\n      output.length = len;\n\n      if (input.length <= 9) {\n        output._strip();\n\n        input.words[0] = 0;\n        input.length = 1;\n        return;\n      } // Shift by 9 limbs.\n\n\n      var prev = input.words[9];\n      var i = 10;\n      output.words[output.length++] = prev & mask;\n\n      output._strip();\n\n      for (; i < input.length; i++) {\n        var next = input.words[i] | 0;\n        input.words[i - 10] = (next & mask) << 4 | prev >>> 22;\n        prev = next;\n      }\n\n      prev >>>= 22;\n      input.words[i - 10] = prev;\n      if (prev === 0 && input.length > 10) input.length -= 10;else input.length -= 9;\n\n      input._strip(); // Unsure if we need this.\n\n    }\n  }, {\n    key: \"imulK\",\n    value: function imulK(num) {\n      // K = 0x1000003d1 = [0x40, 0x3d1]\n      // K = 2^32 + 977\n      num._expand(num.length + 2); // Bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390\n\n\n      var lo = 0;\n\n      for (var i = 0; i < num.length; i++) {\n        var w = num.words[i];\n        lo += w * 0x3d1;\n        num.words[i] = lo & 0x3ffffff;\n        lo = w * 0x40 + Math.floor(lo / 0x4000000);\n      } // Fast length reduction.\n\n\n      if (num.words[num.length - 1] === 0) {\n        num.length -= 1;\n        if (num.words[num.length - 1] === 0) num.length -= 1;\n      } // Note: we shouldn't need to strip here.\n\n\n      return num;\n    }\n  }]);\n\n  return K256;\n}(Prime);\n/**\n * P25519\n */\n\n\nvar P25519 = /*#__PURE__*/function (_Prime5) {\n  _inherits(P25519, _Prime5);\n\n  var _super5 = _createSuper(P25519);\n\n  function P25519() {\n    _classCallCheck(this, P25519);\n\n    // 2^255 - 19 (= 5 mod 8)\n    return _super5.call(this, 'p25519', '7fffffff ffffffff ffffffff ffffffff' + 'ffffffff ffffffff ffffffff ffffffed');\n  }\n\n  _createClass(P25519, [{\n    key: \"imulK\",\n    value: function imulK(num) {\n      // K = 0x13\n      var carry = 0;\n\n      for (var i = 0; i < num.length; i++) {\n        var w = num.words[i] * 0x13 + carry;\n        carry = w >>> 26;\n        num.words[i] = w & 0x3ffffff;\n      }\n\n      if (carry !== 0) {\n        num._alloc(num.length + 1);\n\n        num.words[num.length++] = carry;\n      } // Note: we shouldn't need to strip here.\n\n\n      return num;\n    }\n  }]);\n\n  return P25519;\n}(Prime);\n/**\n * P448\n */\n\n\nvar P448 = /*#__PURE__*/function (_Prime6) {\n  _inherits(P448, _Prime6);\n\n  var _super6 = _createSuper(P448);\n\n  function P448() {\n    _classCallCheck(this, P448);\n\n    // 2^448 - 2^224 - 1 (= 3 mod 4)\n    return _super6.call(this, 'p448', 'ffffffff ffffffff ffffffff ffffffff' + 'ffffffff ffffffff fffffffe ffffffff' + 'ffffffff ffffffff ffffffff ffffffff' + 'ffffffff ffffffff');\n  }\n\n  _createClass(P448, [{\n    key: \"imulK\",\n    value: function imulK(num) {\n      // K = 0x100000000000000000000000000000000000000000000000000000001\n      // K = 2^224 + 1\n      var one = this.one.inject(num);\n      return num.iushln(224)._iadd(num, one);\n    }\n  }]);\n\n  return P448;\n}(Prime);\n/**\n * Reduction Engine\n */\n\n\nvar Red = /*#__PURE__*/function () {\n  function Red(m) {\n    _classCallCheck(this, Red);\n\n    var prime = null;\n\n    if (typeof m === 'string') {\n      prime = BN._prime(m);\n      m = prime.p;\n    }\n\n    enforce(BN.isBN(m), 'm', 'bignum');\n    nonred(!m.red, 'reduction');\n    range(m.sign() > 0, 'reduction');\n    this.m = m;\n    this.prime = prime;\n    this.mb = null;\n    this.sm1 = null;\n  }\n\n  _createClass(Red, [{\n    key: \"_verify1\",\n    value: function _verify1(a) {\n      range(a.negative === 0, 'red');\n      red(a.red != null, 'red');\n    }\n  }, {\n    key: \"_verify2\",\n    value: function _verify2(a, b) {\n      range((a.negative | b.negative) === 0, 'red');\n      red(a.red != null && a.red === b.red, 'red');\n    }\n  }, {\n    key: \"mont\",\n    get: function get() {\n      return false;\n    }\n  }, {\n    key: \"coprime\",\n    get: function get() {\n      return false;\n    }\n  }, {\n    key: \"precompute\",\n    value: function precompute() {\n      // Precompute `sqrt(-1)` for primes congruent to 5 mod 8.\n      if (this.sm1 === null && this.m.andln(7) === 5) {\n        var x = new BN(2).toRed(this);\n        var e = this.m.subn(1).iushrn(2); // sqrt(-1) = 2^((p - 1) / 4) mod p\n\n        this.sm1 = this.pow(x, e);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"convertTo\",\n    value: function convertTo(num) {\n      var res = num.mod(this.m);\n      res.red = this;\n      return res;\n    }\n  }, {\n    key: \"convertFrom\",\n    value: function convertFrom(num) {\n      var res = num.clone();\n      res.red = null;\n      return res;\n    }\n  }, {\n    key: \"intTo\",\n    value: function intTo(a) {\n      return a;\n    }\n  }, {\n    key: \"intFrom\",\n    value: function intFrom(a) {\n      return a;\n    }\n  }, {\n    key: \"imod\",\n    value: function imod(a) {\n      if (this.prime) return this.prime.ireduce(a)._forceRed(this);\n      return a.imod(this.m)._forceRed(this);\n    }\n  }, {\n    key: \"iadd\",\n    value: function iadd(a, b) {\n      this._verify2(a, b);\n\n      a._iadd(a, b);\n\n      if (a.ucmp(this.m) >= 0) a._isub(a, this.m);\n      return a;\n    }\n  }, {\n    key: \"add\",\n    value: function add(a, b) {\n      if (a.length < b.length) return this.iadd(b.clone(), a);\n      return this.iadd(a.clone(), b);\n    }\n  }, {\n    key: \"iaddn\",\n    value: function iaddn(a, num) {\n      this._verify1(a);\n\n      if (num < 0) return this.isubn(a, -num);\n      if (this.m.length === 1) num %= this.m.words[0];\n\n      a._iaddn(num);\n\n      if (a.ucmp(this.m) >= 0) a._isub(a, this.m);\n      return a;\n    }\n  }, {\n    key: \"addn\",\n    value: function addn(a, num) {\n      return this.iaddn(a.clone(), num);\n    }\n  }, {\n    key: \"isub\",\n    value: function isub(a, b) {\n      this._verify2(a, b); //  0: a - a mod m == 0\n      // -1: a - b mod m == m - (b - a)\n      // +1: a - b mod m == a - b\n\n\n      var cmp = a.ucmp(b);\n\n      if (cmp === 0) {\n        a.words[0] = 0;\n        a.length = 1;\n        return a;\n      }\n\n      if (cmp < 0) {\n        a._isub(b, a);\n\n        a._isub(this.m, a);\n      } else {\n        a._isub(a, b);\n      }\n\n      return a;\n    }\n  }, {\n    key: \"sub\",\n    value: function sub(a, b) {\n      return this.isub(a.clone(), b);\n    }\n  }, {\n    key: \"isubn\",\n    value: function isubn(a, num) {\n      this._verify1(a);\n\n      if (num < 0) return this.iaddn(a, -num);\n      if (this.m.length === 1) num %= this.m.words[0]; //  <: a - b mod m == m - (b - a)\n      // >=: a - b mod m == a - b\n\n      if (a.length === 1 && a.words[0] < num) {\n        a.words[0] = num - a.words[0];\n\n        a._isub(this.m, a);\n      } else {\n        a._isubn(num);\n      }\n\n      return a;\n    }\n  }, {\n    key: \"subn\",\n    value: function subn(a, num) {\n      return this.isubn(a.clone(), num);\n    }\n  }, {\n    key: \"imul\",\n    value: function imul(a, b) {\n      this._verify2(a, b);\n\n      return this.imod(a.imul(b));\n    }\n  }, {\n    key: \"mul\",\n    value: function mul(a, b) {\n      this._verify2(a, b);\n\n      return this.imod(a.mul(b));\n    }\n  }, {\n    key: \"imuln\",\n    value: function imuln(a, num) {\n      this._verify1(a);\n\n      if (a.isZero()) return a;\n\n      if (num === 0) {\n        a.words[0] = 0;\n        a.length = 1;\n        return a;\n      }\n\n      var neg = num < 0;\n      if (neg) num = -num;\n      if (this.m.length === 1) num %= this.m.words[0];\n      a.imuln(num);\n\n      if (num <= 16) {\n        // Quick reduction.\n        while (a.ucmp(this.m) >= 0) {\n          a._isub(a, this.m);\n        }\n      } else {\n        this.imod(a);\n      }\n\n      if (neg) this.ineg(a);\n      return a;\n    }\n  }, {\n    key: \"muln\",\n    value: function muln(a, num) {\n      return this.imuln(a.clone(), num);\n    }\n  }, {\n    key: \"idiv\",\n    value: function idiv(a, b) {\n      return this.div(a, b)._move(a);\n    }\n  }, {\n    key: \"div\",\n    value: function div(a, b) {\n      return this.mul(a, this.invert(b));\n    }\n  }, {\n    key: \"idivn\",\n    value: function idivn(a, num) {\n      return this.divn(a, num)._move(a);\n    }\n  }, {\n    key: \"divn\",\n    value: function divn(a, num) {\n      return this.div(a, this.convertTo(new BN(num)));\n    }\n  }, {\n    key: \"ipow\",\n    value: function ipow(a, num) {\n      return this.pow(a, num)._move(a);\n    }\n  }, {\n    key: \"pow\",\n    value: function pow(a, num) {\n      this._verify1(a);\n\n      if (num.isNeg()) a = this.invert(a); // Small exponent.\n\n      if (num.length === 1) return this.pown(a, num.words[0]); // Call out to BigInt.\n\n      if (HAS_BIGINT && !this.prime) return this.powInt(a, num); // Otherwise, a BN implementation.\n\n      return this.powNum(a, num);\n    }\n  }, {\n    key: \"powNum\",\n    value: function powNum(a, num) {\n      // Sliding window.\n      var wnd = new Array(WND_SIZE);\n      wnd[0] = this.sqrn(a, WND_WIDTH - 1);\n      wnd[1] = this.mul(wnd[0], a);\n\n      for (var _i13 = 2; _i13 < WND_SIZE; _i13++) {\n        wnd[_i13] = this.mul(wnd[_i13 - 1], a);\n      }\n\n      var i = num.bitLength();\n      var r = new BN(1).toRed(this);\n\n      while (i >= WND_WIDTH) {\n        var pos = i - WND_WIDTH;\n        var bits = num.bits(pos, WND_WIDTH);\n\n        if (bits < WND_SIZE) {\n          r = this.sqr(r);\n          i -= 1;\n          continue;\n        }\n\n        r = this.sqrn(r, WND_WIDTH);\n        r = this.mul(r, wnd[bits & ~WND_SIZE]);\n        i = pos;\n      }\n\n      if (i > 0) {\n        var _bits = num.bits(0, i);\n\n        while (i--) {\n          r = this.sqr(r);\n          if (_bits >> i & 1) r = this.mul(r, a);\n        }\n      }\n\n      return r;\n    }\n  }, {\n    key: \"powInt\",\n    value: function powInt(a, num) {\n      if (this.mb === null) this.mb = this.m.toBigInt();\n      var x = this.intFrom(a.toBigInt());\n\n      var y = _powInt(x, num, this.mb);\n\n      var z = this.intTo(y);\n      return BN.fromBigInt(z)._forceRed(this);\n    }\n  }, {\n    key: \"sqrn\",\n    value: function sqrn(a, n) {\n      for (var i = 0; i < n; i++) {\n        a = this.sqr(a);\n      }\n\n      return a;\n    }\n  }, {\n    key: \"ipown\",\n    value: function ipown(a, num) {\n      return this.pown(a, num)._move(a);\n    }\n  }, {\n    key: \"pown\",\n    value: function pown(a, num) {\n      this._verify1(a);\n\n      if (num < 0) {\n        a = this.invert(a);\n        num = -num;\n      }\n\n      if (num === 0) return new BN(1).toRed(this);\n      if (num === 1) return a.clone();\n      var bits = countBits(num);\n      var r = a;\n\n      for (var i = bits - 2; i >= 0; i--) {\n        r = this.sqr(r);\n        if (num >> i & 1) r = this.mul(r, a);\n      }\n\n      return r;\n    }\n  }, {\n    key: \"isqr\",\n    value: function isqr(a) {\n      return this.imul(a, a);\n    }\n  }, {\n    key: \"sqr\",\n    value: function sqr(a) {\n      return this.mul(a, a);\n    }\n  }, {\n    key: \"isqrt\",\n    value: function isqrt(x) {\n      return this.sqrt(x)._move(x);\n    }\n  }, {\n    key: \"sqrt\",\n    value: function sqrt(x) {\n      this._verify1(x); // Fast case (p = 3 mod 4).\n\n\n      if (this.m.andln(3) === 3) return this.sqrt3mod4(x); // Fast case (p = 5 mod 8).\n\n      if (this.m.andln(7) === 5) {\n        if (this.sm1 != null) return this.sqrt5mod8sm1(x);\n        return this.sqrt5mod8(x);\n      } // Slow case (Tonelli-Shanks).\n\n\n      return this.sqrt0(x);\n    }\n  }, {\n    key: \"sqrt3mod4\",\n    value: function sqrt3mod4(x) {\n      var e = this.m.addn(1).iushrn(2); // (p + 1) / 4\n\n      var b = this.pow(x, e);\n      if (!this.sqr(b).eq(x)) throw new Error('X is not a square mod P.');\n      return b;\n    }\n  }, {\n    key: \"sqrt5mod8\",\n    value: function sqrt5mod8(x) {\n      // Atkin's Algorithm.\n      var one = new BN(1).toRed(this);\n      var e = this.m.ushrn(3); // (p - 5) / 8\n\n      var x2 = this.add(x, x);\n      var alpha = this.pow(x2, e);\n      var beta = this.mul(x2, this.sqr(alpha));\n      var b = this.mul(this.mul(alpha, x), this.isub(beta, one));\n      if (!this.sqr(b).eq(x)) throw new Error('X is not a square mod P.');\n      return b;\n    }\n  }, {\n    key: \"sqrt5mod8sm1\",\n    value: function sqrt5mod8sm1(x) {\n      var e = this.m.addn(3).iushrn(3); // (p + 3) / 8\n\n      var b = this.pow(x, e);\n      if (this.sqr(b).eq(x)) return b;\n      var c = this.mul(b, this.sm1);\n      if (this.sqr(c).eq(x)) return c;\n      throw new Error('X is not a square mod P.');\n    }\n  }, {\n    key: \"sqrt0\",\n    value: function sqrt0(x) {\n      if (this.m.cmpn(1) === 0 || !this.m.isOdd()) throw new Error('Invalid prime.');\n\n      switch (this.jacobi(x)) {\n        case -1:\n          throw new Error('X is not a square mod P.');\n\n        case 0:\n          return new BN(0)._forceRed(this);\n\n        case 1:\n          break;\n      }\n\n      var one = new BN(1).toRed(this);\n      var s = this.m.subn(1);\n      var e = s.zeroBits();\n      s.iushrn(e);\n      var n = new BN(2).toRed(this);\n\n      while (this.jacobi(n) !== -1) {\n        this.iadd(n, one);\n      }\n\n      var b = this.pow(x, s);\n      var g = this.pow(n, s);\n      var y = this.pow(x, s.iaddn(1).iushrn(1));\n      var k = e;\n\n      for (;;) {\n        var t = b;\n        var m = 0;\n\n        while (t.cmp(one) !== 0 && m < k) {\n          t = this.sqr(t);\n          m += 1;\n        }\n\n        if (m === 0) break;\n        assert(m < k);\n        t = this.sqrn(g, k - m - 1);\n        g = this.sqr(t);\n        y = this.mul(y, t);\n        b = this.mul(b, g);\n        k = m;\n      }\n\n      return y;\n    }\n  }, {\n    key: \"idivsqrt\",\n    value: function idivsqrt(u, v) {\n      return this.divsqrt(u, v)._move(u);\n    }\n  }, {\n    key: \"divsqrt\",\n    value: function divsqrt(u, v) {\n      this._verify2(u, v); // v = 0\n\n\n      if (v.isZero()) throw new RangeError('Not invertible.'); // p = 3 mod 4\n\n      if (this.m.andln(3) === 3) return this.divsqrt3mod4(u, v); // p = 5 mod 8\n\n      if (this.sm1 != null && this.m.andln(7) === 5) return this.divsqrt5mod8(u, v);\n      return this.sqrt(this.div(u, v));\n    }\n  }, {\n    key: \"divsqrt3mod4\",\n    value: function divsqrt3mod4(u, v) {\n      // x = u^3 * v * (u^5 * v^3)^((p - 3) / 4) mod p\n      var e = this.m.subn(3).iushrn(2);\n      var u2 = this.sqr(u);\n      var u3 = this.mul(u2, u);\n      var u5 = this.mul(u3, u2);\n      var v3 = this.mul(this.sqr(v), v);\n      var p = this.pow(this.mul(u5, v3), e);\n      var x = this.mul(this.mul(u3, v), p);\n      var c = this.mul(v, this.sqr(x));\n      if (c.cmp(u) === 0) return x;\n      throw new Error('X is not a square mod P.');\n    }\n  }, {\n    key: \"divsqrt5mod8\",\n    value: function divsqrt5mod8(u, v) {\n      // x = u * v^3 * (u * v^7)^((p - 5) / 8) mod p\n      var e = this.m.subn(5).iushrn(3);\n      var v3 = this.mul(this.sqr(v), v);\n      var v7 = this.mul(this.sqr(v3), v);\n      var p = this.pow(this.mul(u, v7), e);\n      var x = this.mul(this.mul(u, v3), p);\n      var c = this.mul(v, this.sqr(x));\n      if (c.cmp(u) === 0) return x;\n      if (this.ineg(c).cmp(u) === 0) return this.mul(x, this.sm1);\n      throw new Error('X is not a square mod P.');\n    }\n  }, {\n    key: \"isSquare\",\n    value: function isSquare(a) {\n      var symbol;\n      if (this.prime || this.coprime) symbol = this.legendre(a);else if (this.m.isOdd()) symbol = this.jacobi(a);else symbol = this.kronecker(a);\n      return Boolean(~symbol >>> 31);\n    }\n  }, {\n    key: \"ishl\",\n    value: function ishl(a, num) {\n      this._verify1(a);\n\n      return this.imod(a.iushl(num));\n    }\n  }, {\n    key: \"shl\",\n    value: function shl(a, num) {\n      return this.ishl(a.clone(), num);\n    }\n  }, {\n    key: \"ishln\",\n    value: function ishln(a, num) {\n      this._verify1(a);\n\n      a.iushln(num);\n\n      if (num <= 4) {\n        // Quick reduction.\n        while (a.ucmp(this.m) >= 0) {\n          a._isub(a, this.m);\n        }\n      } else {\n        this.imod(a);\n      }\n\n      return a;\n    }\n  }, {\n    key: \"shln\",\n    value: function shln(a, num) {\n      return this.ishln(a.clone(), num);\n    }\n  }, {\n    key: \"ineg\",\n    value: function ineg(a) {\n      this._verify1(a);\n\n      if (!a.isZero()) a._isub(this.m, a);\n      return a;\n    }\n  }, {\n    key: \"neg\",\n    value: function neg(a) {\n      return this.ineg(a.clone());\n    }\n  }, {\n    key: \"eq\",\n    value: function eq(a, b) {\n      this._verify2(a, b);\n\n      return a.ucmp(b) === 0;\n    }\n  }, {\n    key: \"eqn\",\n    value: function eqn(a, num) {\n      this._verify1(a);\n\n      if (this.m.length === 1) {\n        num %= this.m.words[0];\n        if (num < 0) num += this.m.words[0];\n        return a.ucmpn(num) === 0;\n      }\n\n      if (num < 0) {\n        this.m._isubn(-num);\n\n        var cmp = a.ucmp(this.m);\n\n        this.m._iaddn(-num);\n\n        return cmp === 0;\n      }\n\n      return a.ucmpn(num) === 0;\n    }\n  }, {\n    key: \"isHigh\",\n    value: function isHigh(a) {\n      return !this.isLow(a);\n    }\n  }, {\n    key: \"isLow\",\n    value: function isLow(a) {\n      this._verify1(a);\n\n      return a.ucmp(this.m.ushrn(1)) <= 0;\n    }\n  }, {\n    key: \"isOdd\",\n    value: function isOdd(a) {\n      this._verify1(a);\n\n      return a.isOdd();\n    }\n  }, {\n    key: \"isEven\",\n    value: function isEven(a) {\n      this._verify1(a);\n\n      return a.isEven();\n    }\n  }, {\n    key: \"legendre\",\n    value: function legendre(num) {\n      this._verify1(num);\n\n      if (this.m.isEven()) throw new Error('legendre: `num` must be odd.'); // Euler's criterion.\n\n      var e = this.m.subn(1).iushrn(1); // (p - 1) / 2\n\n      var symbol = this.pow(num, e);\n      var one = new BN(1).toRed(this);\n      var a = symbol.czero();\n      var b = symbol.ceq(one);\n      var c = symbol.ceq(this.ineg(one)); // Must be one of these.\n\n      if ((a | b | c) === 0) throw new Error('Invalid prime.'); // Cannot be multiple.\n\n      assert(a + b + c === 1); // 0, 1, or -1.\n\n      return b - c;\n    }\n  }, {\n    key: \"jacobi\",\n    value: function jacobi(a) {\n      this._verify1(a);\n\n      return a.jacobi(this.m);\n    }\n  }, {\n    key: \"kronecker\",\n    value: function kronecker(a) {\n      this._verify1(a);\n\n      return a.kronecker(this.m);\n    }\n  }, {\n    key: \"iinvert\",\n    value: function iinvert(a) {\n      return this.invert(a)._move(a);\n    }\n  }, {\n    key: \"invert\",\n    value: function invert(a) {\n      this._verify1(a);\n\n      if (this.prime) return this.imod(a._invertp(this.m));\n      return a.invert(this.m)._forceRed(this);\n    }\n  }, {\n    key: \"ifermat\",\n    value: function ifermat(a) {\n      return this.fermat(a)._move(a);\n    }\n  }, {\n    key: \"fermat\",\n    value: function fermat(a) {\n      this._verify1(a);\n\n      if (a.isZero() || this.m.cmpn(1) === 0) throw new RangeError('Not invertible.'); // Invert using fermat's little theorem.\n\n      return this.pow(a, this.m.subn(2));\n    }\n  }, {\n    key: custom,\n    value: function value() {\n      if (this.prime) return \"<Red: \".concat(this.prime.name, \">\");\n      return \"<Red: \".concat(this.m.toString(10), \">\");\n    }\n  }]);\n\n  return Red;\n}();\n/**\n * Barrett Engine\n */\n\n\nvar Barrett = /*#__PURE__*/function (_Red) {\n  _inherits(Barrett, _Red);\n\n  var _super7 = _createSuper(Barrett);\n\n  function Barrett(m) {\n    var _this;\n\n    _classCallCheck(this, Barrett);\n\n    _this = _super7.call(this, m);\n    _this.prime = null;\n    _this.n = _this.m.bitLength();\n    if (_this.n % 26 !== 0) _this.n += 26 - _this.n % 26;\n    _this.k = _this.n * 2;\n    _this.w = _this.k / 26;\n    _this.b = BN.shift(1, _this.k).div(_this.m);\n    return _this;\n  }\n\n  _createClass(Barrett, [{\n    key: \"convertTo\",\n    value: function convertTo(num) {\n      if (num.length > this.w) return _get(_getPrototypeOf(Barrett.prototype), \"convertTo\", this).call(this, num);\n      return this.imod(num.clone());\n    }\n  }, {\n    key: \"_shift\",\n    value: function _shift(q) {\n      var i = 0;\n      var j = this.w;\n\n      while (j < q.length) {\n        q.words[i++] = q.words[j++];\n      }\n\n      if (i === 0) q.words[i++] = 0;\n      q.length = i;\n    }\n  }, {\n    key: \"imod\",\n    value: function imod(a) {\n      var neg = a.negative;\n      assert(a.length <= this.w);\n      a.negative = 0;\n      var q = a.mul(this.b); // Shift right by `k` bits.\n\n      this._shift(q);\n\n      a._isub(a, q.mul(this.m));\n\n      if (a.ucmp(this.m) >= 0) a._isub(a, this.m);\n      if (neg && !a.isZero()) a._isub(this.m, a);\n      a.red = this;\n      return a;\n    }\n  }]);\n\n  return Barrett;\n}(Red);\n/**\n * Montgomery Engine\n */\n\n\nvar Mont = /*#__PURE__*/function (_Red2) {\n  _inherits(Mont, _Red2);\n\n  var _super8 = _createSuper(Mont);\n\n  function Mont(m) {\n    var _this2;\n\n    _classCallCheck(this, Mont);\n\n    _this2 = _super8.call(this, m);\n    _this2.prime = null;\n    _this2.n = _this2.m.bitLength();\n    if (_this2.n % 26 !== 0) _this2.n += 26 - _this2.n % 26;\n    _this2.r = BN.shift(1, _this2.n);\n    _this2.r2 = BN.shift(1, _this2.n * 2).imod(_this2.m);\n    _this2.ri = _this2.r._invertp(_this2.m).imod(_this2.m);\n    _this2.mi = _this2.r.mul(_this2.ri).isubn(1).div(_this2.m);\n    _this2.rib = null;\n    return _this2;\n  }\n\n  _createClass(Mont, [{\n    key: \"mont\",\n    get: function get() {\n      return true;\n    }\n  }, {\n    key: \"coprime\",\n    get: function get() {\n      return true;\n    }\n  }, {\n    key: \"convertTo\",\n    value: function convertTo(num) {\n      return this.imod(num.ushln(this.n));\n    }\n  }, {\n    key: \"convertFrom\",\n    value: function convertFrom(num) {\n      var r = this.imod(num.mul(this.ri));\n      r.red = null;\n      return r;\n    }\n  }, {\n    key: \"intTo\",\n    value: function intTo(a) {\n      return (a << BigInt(this.n)) % this.mb;\n    }\n  }, {\n    key: \"intFrom\",\n    value: function intFrom(a) {\n      if (this.rib === null) this.rib = this.ri.toBigInt();\n      return a * this.rib % this.mb;\n    }\n  }, {\n    key: \"iaddn\",\n    value: function iaddn(a, num) {\n      return this.iadd(a, this.convertTo(new BN(num)));\n    }\n  }, {\n    key: \"isubn\",\n    value: function isubn(a, num) {\n      return this.isub(a, this.convertTo(new BN(num)));\n    }\n  }, {\n    key: \"imul\",\n    value: function imul(a, b) {\n      return this.mul(a, b)._move(a);\n    }\n  }, {\n    key: \"mul\",\n    value: function mul(a, b) {\n      this._verify2(a, b);\n\n      if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);\n      var t = a.mul(b);\n      var c = t.umaskn(this.n).mul(this.mi).iumaskn(this.n);\n      var u = t.iadd(c.mul(this.m)).iushrn(this.n);\n      if (u.ucmp(this.m) >= 0) u._isub(u, this.m);\n      return u._forceRed(this);\n    }\n  }, {\n    key: \"imuln\",\n    value: function imuln(a, num) {\n      this._verify1(a);\n\n      if (a.isZero()) return a;\n\n      if (num === 0) {\n        a.words[0] = 0;\n        a.length = 1;\n        return a;\n      }\n\n      var neg = num < 0;\n      if (neg) num = -num;\n      if (this.m.length === 1) num %= this.m.words[0];\n      var bits = countBits(num); // Potentially compute with additions.\n      // This avoids an expensive division.\n\n      if (bits > 5) {\n        // Slow case (num > 31).\n        this.imul(a, this.convertTo(new BN(num)));\n      } else if ((num & num - 1) === 0) {\n        // Optimize for powers of two.\n        for (var i = 0; i < bits - 1; i++) {\n          this.iadd(a, a);\n        }\n      } else {\n        // Multiply left to right.\n        var c = a.clone();\n\n        for (var _i14 = bits - 2; _i14 >= 0; _i14--) {\n          this.iadd(a, a);\n          if (num >> _i14 & 1) this.iadd(a, c);\n        }\n      }\n\n      if (neg) this.ineg(a);\n      return a;\n    }\n  }, {\n    key: \"eqn\",\n    value: function eqn(a, num) {\n      this._verify1(a);\n\n      if (num === 0) return a.isZero();\n      return a.ucmp(this.convertTo(new BN(num))) === 0;\n    }\n  }, {\n    key: \"isLow\",\n    value: function isLow(a) {\n      this._verify1(a);\n\n      return this.convertFrom(a).ucmp(this.m.ushrn(1)) <= 0;\n    }\n  }, {\n    key: \"isOdd\",\n    value: function isOdd(a) {\n      this._verify1(a);\n\n      return this.convertFrom(a).isOdd();\n    }\n  }, {\n    key: \"isEven\",\n    value: function isEven(a) {\n      this._verify1(a);\n\n      return this.convertFrom(a).isEven();\n    }\n  }, {\n    key: \"invert\",\n    value: function invert(a) {\n      this._verify1(a); // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R\n\n\n      return this.imod(a._invertp(this.m).mul(this.r2));\n    }\n  }]);\n\n  return Mont;\n}(Red);\n/*\n * Helpers\n */\n\n\nfunction makeError(Error, msg, start) {\n  var err = new Error(msg);\n  if (Error.captureStackTrace) Error.captureStackTrace(err, start);\n  return err;\n}\n\nfunction assert(value, message) {\n  if (!value) {\n    var msg = message || 'Assertion failed.';\n    throw makeError(Error, msg, assert);\n  }\n}\n\nfunction enforce(value, name, type) {\n  if (!value) {\n    var msg = \"\\\"\".concat(name, \"\\\" must be a(n) \").concat(type, \".\");\n    throw makeError(TypeError, msg, enforce);\n  }\n}\n\nfunction range(value, name) {\n  if (!value) {\n    var msg = \"\\\"\".concat(name, \"\\\" only works with positive numbers.\");\n    throw makeError(RangeError, msg, range);\n  }\n}\n\nfunction red(value, name) {\n  if (!value) {\n    var msg = \"\\\"\".concat(name, \"\\\" only works with red numbers.\");\n    throw makeError(TypeError, msg, red);\n  }\n}\n\nfunction nonred(value, name) {\n  if (!value) {\n    var msg = \"\\\"\".concat(name, \"\\\" only works with normal numbers.\");\n    throw makeError(TypeError, msg, nonred);\n  }\n}\n\nfunction nonzero(value) {\n  if (!value) {\n    var msg = 'Cannot divide by zero.';\n    throw makeError(RangeError, msg, nonzero);\n  }\n}\n\nfunction isInteger(num) {\n  return Number.isSafeInteger(num);\n}\n\nfunction isSMI(num) {\n  return isInteger(num) && num >= -0x3ffffff && num <= 0x3ffffff;\n}\n\nfunction allocate(ArrayType, size) {\n  if (ArrayType.allocUnsafeSlow) return ArrayType.allocUnsafeSlow(size);\n  return new ArrayType(size);\n}\n\nfunction getBase(base) {\n  if (base == null) return 10;\n  if (typeof base === 'number') return base;\n\n  switch (base) {\n    case 'bin':\n      return 2;\n\n    case 'oct':\n      return 8;\n\n    case 'dec':\n      return 10;\n\n    case 'hex':\n      return 16;\n  }\n\n  return 0;\n}\n/*\n * Internal\n */\n\n\nfunction countBits(w) {\n  if (Math.clz32) return 32 - Math.clz32(w);\n  var t = w;\n  var r = 0;\n\n  if (t >= 0x1000) {\n    r += 13;\n    t >>>= 13;\n  }\n\n  if (t >= 0x40) {\n    r += 7;\n    t >>>= 7;\n  }\n\n  if (t >= 0x8) {\n    r += 4;\n    t >>>= 4;\n  }\n\n  if (t >= 0x02) {\n    r += 2;\n    t >>>= 2;\n  }\n\n  return r + t;\n}\n\nfunction _zeroBits(w) {\n  // Shortcut.\n  if (w === 0) return 26;\n  var t = w;\n  var r = 0;\n\n  if ((t & 0x1fff) === 0) {\n    r += 13;\n    t >>>= 13;\n  }\n\n  if ((t & 0x7f) === 0) {\n    r += 7;\n    t >>>= 7;\n  }\n\n  if ((t & 0xf) === 0) {\n    r += 4;\n    t >>>= 4;\n  }\n\n  if ((t & 0x3) === 0) {\n    r += 2;\n    t >>>= 2;\n  }\n\n  if ((t & 0x1) === 0) r += 1;\n  return r;\n}\n\nfunction parseHex(str, start, end) {\n  var len = Math.min(str.length, end);\n  var r = 0;\n  var z = 0;\n\n  for (var i = start; i < len; i++) {\n    var c = str.charCodeAt(i) - 48;\n    r <<= 4;\n    var b = void 0;\n\n    if (c >= 49 && c <= 54) {\n      // 'a' - 'f'\n      b = c - 49 + 0xa;\n    } else if (c >= 17 && c <= 22) {\n      // 'A' - 'F'\n      b = c - 17 + 0xa;\n    } else {\n      // '0' - '9'\n      b = c;\n    }\n\n    r |= b;\n    z |= b;\n  }\n\n  if (z & ~15) throw new Error('Invalid string.');\n  return r;\n}\n\nfunction parseBase(str, start, end, mul) {\n  var len = Math.min(str.length, end);\n  var r = 0;\n\n  for (var i = start; i < len; i++) {\n    var c = str.charCodeAt(i) - 48;\n    r *= mul;\n    var b = void 0;\n\n    if (c >= 49) {\n      // 'a'\n      b = c - 49 + 0xa;\n    } else if (c >= 17) {\n      // 'A'\n      b = c - 17 + 0xa;\n    } else {\n      // '0' - '9'\n      b = c;\n    }\n\n    if (c < 0 || c > 207 || b >= mul) throw new Error('Invalid string.');\n    r += b;\n  }\n\n  return r;\n}\n/*\n * Exponentiation (bigint)\n */\n\n\nfunction _powInt(x, e, m) {\n  // Sliding window.\n  var wnd = new Array(WND_SIZE);\n  wnd[0] = sqrn(x, WND_WIDTH - 1, m);\n  wnd[1] = wnd[0] * x;\n\n  for (var _i15 = 2; _i15 < WND_SIZE; _i15++) {\n    wnd[_i15] = wnd[_i15 - 1] * x % m;\n  }\n\n  var i = e.bitLength();\n  var r = BigInt(1);\n\n  while (i >= WND_WIDTH) {\n    var pos = i - WND_WIDTH;\n    var bits = e.bits(pos, WND_WIDTH);\n\n    if (bits < WND_SIZE) {\n      r = r * r % m;\n      i -= 1;\n      continue;\n    }\n\n    r = sqrn(r, WND_WIDTH, m);\n    r = r * wnd[bits & ~WND_SIZE] % m;\n    i = pos;\n  }\n\n  if (i > 0) {\n    var _bits2 = e.bits(0, i);\n\n    while (i--) {\n      r = r * r % m;\n      if (_bits2 >> i & 1) r = r * x % m;\n    }\n  }\n\n  return r;\n}\n\nfunction sqrn(x, n, m) {\n  for (var i = 0; i < n; i++) {\n    x = x * x % m;\n  }\n\n  return x;\n}\n/*\n * Multiplication\n */\n\n\nfunction smallMulTo(self, num, out) {\n  var len = self.length + num.length;\n  out.negative = self.negative ^ num.negative;\n\n  out._alloc(len);\n\n  out.length = len; // Peel one iteration (compiler can't\n  // do it, because of code complexity).\n\n  var a = self.words[0];\n  var b = num.words[0];\n  var r = a * b;\n  var lo = r & 0x3ffffff;\n  var carry = r / 0x4000000 | 0;\n  var k = 1;\n  out.words[0] = lo;\n\n  for (; k < out.length - 1; k++) {\n    // Sum all words with the same\n    // `i + j = k` and accumulate\n    // `ncarry`, note that ncarry\n    // could be >= 0x3ffffff.\n    var ncarry = carry >>> 26;\n    var rword = carry & 0x3ffffff;\n    var min = Math.max(0, k - self.length + 1);\n    var max = Math.min(k, num.length - 1);\n\n    for (var j = min; j <= max; j++) {\n      var i = k - j;\n      var _a = self.words[i];\n      var _b = num.words[j];\n\n      var _r3 = _a * _b + rword;\n\n      ncarry += _r3 / 0x4000000 | 0;\n      rword = _r3 & 0x3ffffff;\n    }\n\n    out.words[k] = rword | 0;\n    carry = ncarry | 0;\n  }\n\n  if (carry !== 0) out.words[k] = carry | 0;else out.length -= 1;\n  return out._strip();\n}\n\nfunction bigMulTo(self, num, out) {\n  var len = self.length + num.length;\n  out.negative = self.negative ^ num.negative;\n\n  out._alloc(len);\n\n  out.length = len;\n  var carry = 0;\n  var hncarry = 0;\n  var k = 0;\n\n  for (; k < out.length - 1; k++) {\n    // Sum all words with the same\n    // `i + j = k` and accumulate\n    // `ncarry`, note that ncarry\n    // could be >= 0x3ffffff.\n    var ncarry = hncarry;\n    hncarry = 0;\n    var rword = carry & 0x3ffffff;\n    var min = Math.max(0, k - self.length + 1);\n    var max = Math.min(k, num.length - 1);\n\n    for (var j = min; j <= max; j++) {\n      var i = k - j;\n      var a = self.words[i];\n      var b = num.words[j];\n      var r = a * b;\n      var lo = r & 0x3ffffff;\n      ncarry = ncarry + (r / 0x4000000 | 0) | 0;\n      lo = lo + rword | 0;\n      rword = lo & 0x3ffffff;\n      ncarry = ncarry + (lo >>> 26) | 0;\n      hncarry += ncarry >>> 26;\n      ncarry &= 0x3ffffff;\n    }\n\n    out.words[k] = rword;\n    carry = ncarry;\n    ncarry = hncarry;\n  }\n\n  if (carry !== 0) out.words[k] = carry;else out.length -= 1;\n  return out._strip();\n}\n\nfunction jumboMulTo(x, y, out) {\n  // v8 has a 2147483519 bit max (~256mb).\n  if (!HAS_BIGINT || x.length + y.length > 82595519) return bigMulTo(x, y, out);\n  var zero = BigInt(0);\n  var mask = BigInt(0x3ffffff);\n  var shift = BigInt(26);\n  var z = x.toBigInt() * y.toBigInt();\n  var neg = z < zero | 0;\n  if (neg) z = -z;\n  var i = 0;\n\n  while (z > zero) {\n    out.words[i++] = Number(z & mask);\n    z >>= shift;\n  }\n\n  if (i === 0) out.words[i++] = 0;\n  out.length = i;\n  out.negative = neg;\n  return out;\n}\n\nfunction comb10MulTo(self, num, out) {\n  var a = self.words;\n  var b = num.words;\n  var o = out.words;\n  var a0 = a[0] | 0;\n  var al0 = a0 & 0x1fff;\n  var ah0 = a0 >>> 13;\n  var a1 = a[1] | 0;\n  var al1 = a1 & 0x1fff;\n  var ah1 = a1 >>> 13;\n  var a2 = a[2] | 0;\n  var al2 = a2 & 0x1fff;\n  var ah2 = a2 >>> 13;\n  var a3 = a[3] | 0;\n  var al3 = a3 & 0x1fff;\n  var ah3 = a3 >>> 13;\n  var a4 = a[4] | 0;\n  var al4 = a4 & 0x1fff;\n  var ah4 = a4 >>> 13;\n  var a5 = a[5] | 0;\n  var al5 = a5 & 0x1fff;\n  var ah5 = a5 >>> 13;\n  var a6 = a[6] | 0;\n  var al6 = a6 & 0x1fff;\n  var ah6 = a6 >>> 13;\n  var a7 = a[7] | 0;\n  var al7 = a7 & 0x1fff;\n  var ah7 = a7 >>> 13;\n  var a8 = a[8] | 0;\n  var al8 = a8 & 0x1fff;\n  var ah8 = a8 >>> 13;\n  var a9 = a[9] | 0;\n  var al9 = a9 & 0x1fff;\n  var ah9 = a9 >>> 13;\n  var b0 = b[0] | 0;\n  var bl0 = b0 & 0x1fff;\n  var bh0 = b0 >>> 13;\n  var b1 = b[1] | 0;\n  var bl1 = b1 & 0x1fff;\n  var bh1 = b1 >>> 13;\n  var b2 = b[2] | 0;\n  var bl2 = b2 & 0x1fff;\n  var bh2 = b2 >>> 13;\n  var b3 = b[3] | 0;\n  var bl3 = b3 & 0x1fff;\n  var bh3 = b3 >>> 13;\n  var b4 = b[4] | 0;\n  var bl4 = b4 & 0x1fff;\n  var bh4 = b4 >>> 13;\n  var b5 = b[5] | 0;\n  var bl5 = b5 & 0x1fff;\n  var bh5 = b5 >>> 13;\n  var b6 = b[6] | 0;\n  var bl6 = b6 & 0x1fff;\n  var bh6 = b6 >>> 13;\n  var b7 = b[7] | 0;\n  var bl7 = b7 & 0x1fff;\n  var bh7 = b7 >>> 13;\n  var b8 = b[8] | 0;\n  var bl8 = b8 & 0x1fff;\n  var bh8 = b8 >>> 13;\n  var b9 = b[9] | 0;\n  var bl9 = b9 & 0x1fff;\n  var bh9 = b9 >>> 13;\n  var c = 0;\n  var lo, mid, hi;\n  out.negative = self.negative ^ num.negative;\n\n  out._alloc(20);\n\n  out.length = 19;\n  /* k = 0 */\n\n  lo = Math.imul(al0, bl0);\n  mid = Math.imul(al0, bh0);\n  mid = mid + Math.imul(ah0, bl0) | 0;\n  hi = Math.imul(ah0, bh0);\n  var w0 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n  c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;\n  w0 &= 0x3ffffff;\n  /* k = 1 */\n\n  lo = Math.imul(al1, bl0);\n  mid = Math.imul(al1, bh0);\n  mid = mid + Math.imul(ah1, bl0) | 0;\n  hi = Math.imul(ah1, bh0);\n  lo = lo + Math.imul(al0, bl1) | 0;\n  mid = mid + Math.imul(al0, bh1) | 0;\n  mid = mid + Math.imul(ah0, bl1) | 0;\n  hi = hi + Math.imul(ah0, bh1) | 0;\n  var w1 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n  c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;\n  w1 &= 0x3ffffff;\n  /* k = 2 */\n\n  lo = Math.imul(al2, bl0);\n  mid = Math.imul(al2, bh0);\n  mid = mid + Math.imul(ah2, bl0) | 0;\n  hi = Math.imul(ah2, bh0);\n  lo = lo + Math.imul(al1, bl1) | 0;\n  mid = mid + Math.imul(al1, bh1) | 0;\n  mid = mid + Math.imul(ah1, bl1) | 0;\n  hi = hi + Math.imul(ah1, bh1) | 0;\n  lo = lo + Math.imul(al0, bl2) | 0;\n  mid = mid + Math.imul(al0, bh2) | 0;\n  mid = mid + Math.imul(ah0, bl2) | 0;\n  hi = hi + Math.imul(ah0, bh2) | 0;\n  var w2 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n  c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;\n  w2 &= 0x3ffffff;\n  /* k = 3 */\n\n  lo = Math.imul(al3, bl0);\n  mid = Math.imul(al3, bh0);\n  mid = mid + Math.imul(ah3, bl0) | 0;\n  hi = Math.imul(ah3, bh0);\n  lo = lo + Math.imul(al2, bl1) | 0;\n  mid = mid + Math.imul(al2, bh1) | 0;\n  mid = mid + Math.imul(ah2, bl1) | 0;\n  hi = hi + Math.imul(ah2, bh1) | 0;\n  lo = lo + Math.imul(al1, bl2) | 0;\n  mid = mid + Math.imul(al1, bh2) | 0;\n  mid = mid + Math.imul(ah1, bl2) | 0;\n  hi = hi + Math.imul(ah1, bh2) | 0;\n  lo = lo + Math.imul(al0, bl3) | 0;\n  mid = mid + Math.imul(al0, bh3) | 0;\n  mid = mid + Math.imul(ah0, bl3) | 0;\n  hi = hi + Math.imul(ah0, bh3) | 0;\n  var w3 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n  c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;\n  w3 &= 0x3ffffff;\n  /* k = 4 */\n\n  lo = Math.imul(al4, bl0);\n  mid = Math.imul(al4, bh0);\n  mid = mid + Math.imul(ah4, bl0) | 0;\n  hi = Math.imul(ah4, bh0);\n  lo = lo + Math.imul(al3, bl1) | 0;\n  mid = mid + Math.imul(al3, bh1) | 0;\n  mid = mid + Math.imul(ah3, bl1) | 0;\n  hi = hi + Math.imul(ah3, bh1) | 0;\n  lo = lo + Math.imul(al2, bl2) | 0;\n  mid = mid + Math.imul(al2, bh2) | 0;\n  mid = mid + Math.imul(ah2, bl2) | 0;\n  hi = hi + Math.imul(ah2, bh2) | 0;\n  lo = lo + Math.imul(al1, bl3) | 0;\n  mid = mid + Math.imul(al1, bh3) | 0;\n  mid = mid + Math.imul(ah1, bl3) | 0;\n  hi = hi + Math.imul(ah1, bh3) | 0;\n  lo = lo + Math.imul(al0, bl4) | 0;\n  mid = mid + Math.imul(al0, bh4) | 0;\n  mid = mid + Math.imul(ah0, bl4) | 0;\n  hi = hi + Math.imul(ah0, bh4) | 0;\n  var w4 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n  c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;\n  w4 &= 0x3ffffff;\n  /* k = 5 */\n\n  lo = Math.imul(al5, bl0);\n  mid = Math.imul(al5, bh0);\n  mid = mid + Math.imul(ah5, bl0) | 0;\n  hi = Math.imul(ah5, bh0);\n  lo = lo + Math.imul(al4, bl1) | 0;\n  mid = mid + Math.imul(al4, bh1) | 0;\n  mid = mid + Math.imul(ah4, bl1) | 0;\n  hi = hi + Math.imul(ah4, bh1) | 0;\n  lo = lo + Math.imul(al3, bl2) | 0;\n  mid = mid + Math.imul(al3, bh2) | 0;\n  mid = mid + Math.imul(ah3, bl2) | 0;\n  hi = hi + Math.imul(ah3, bh2) | 0;\n  lo = lo + Math.imul(al2, bl3) | 0;\n  mid = mid + Math.imul(al2, bh3) | 0;\n  mid = mid + Math.imul(ah2, bl3) | 0;\n  hi = hi + Math.imul(ah2, bh3) | 0;\n  lo = lo + Math.imul(al1, bl4) | 0;\n  mid = mid + Math.imul(al1, bh4) | 0;\n  mid = mid + Math.imul(ah1, bl4) | 0;\n  hi = hi + Math.imul(ah1, bh4) | 0;\n  lo = lo + Math.imul(al0, bl5) | 0;\n  mid = mid + Math.imul(al0, bh5) | 0;\n  mid = mid + Math.imul(ah0, bl5) | 0;\n  hi = hi + Math.imul(ah0, bh5) | 0;\n  var w5 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n  c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;\n  w5 &= 0x3ffffff;\n  /* k = 6 */\n\n  lo = Math.imul(al6, bl0);\n  mid = Math.imul(al6, bh0);\n  mid = mid + Math.imul(ah6, bl0) | 0;\n  hi = Math.imul(ah6, bh0);\n  lo = lo + Math.imul(al5, bl1) | 0;\n  mid = mid + Math.imul(al5, bh1) | 0;\n  mid = mid + Math.imul(ah5, bl1) | 0;\n  hi = hi + Math.imul(ah5, bh1) | 0;\n  lo = lo + Math.imul(al4, bl2) | 0;\n  mid = mid + Math.imul(al4, bh2) | 0;\n  mid = mid + Math.imul(ah4, bl2) | 0;\n  hi = hi + Math.imul(ah4, bh2) | 0;\n  lo = lo + Math.imul(al3, bl3) | 0;\n  mid = mid + Math.imul(al3, bh3) | 0;\n  mid = mid + Math.imul(ah3, bl3) | 0;\n  hi = hi + Math.imul(ah3, bh3) | 0;\n  lo = lo + Math.imul(al2, bl4) | 0;\n  mid = mid + Math.imul(al2, bh4) | 0;\n  mid = mid + Math.imul(ah2, bl4) | 0;\n  hi = hi + Math.imul(ah2, bh4) | 0;\n  lo = lo + Math.imul(al1, bl5) | 0;\n  mid = mid + Math.imul(al1, bh5) | 0;\n  mid = mid + Math.imul(ah1, bl5) | 0;\n  hi = hi + Math.imul(ah1, bh5) | 0;\n  lo = lo + Math.imul(al0, bl6) | 0;\n  mid = mid + Math.imul(al0, bh6) | 0;\n  mid = mid + Math.imul(ah0, bl6) | 0;\n  hi = hi + Math.imul(ah0, bh6) | 0;\n  var w6 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n  c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;\n  w6 &= 0x3ffffff;\n  /* k = 7 */\n\n  lo = Math.imul(al7, bl0);\n  mid = Math.imul(al7, bh0);\n  mid = mid + Math.imul(ah7, bl0) | 0;\n  hi = Math.imul(ah7, bh0);\n  lo = lo + Math.imul(al6, bl1) | 0;\n  mid = mid + Math.imul(al6, bh1) | 0;\n  mid = mid + Math.imul(ah6, bl1) | 0;\n  hi = hi + Math.imul(ah6, bh1) | 0;\n  lo = lo + Math.imul(al5, bl2) | 0;\n  mid = mid + Math.imul(al5, bh2) | 0;\n  mid = mid + Math.imul(ah5, bl2) | 0;\n  hi = hi + Math.imul(ah5, bh2) | 0;\n  lo = lo + Math.imul(al4, bl3) | 0;\n  mid = mid + Math.imul(al4, bh3) | 0;\n  mid = mid + Math.imul(ah4, bl3) | 0;\n  hi = hi + Math.imul(ah4, bh3) | 0;\n  lo = lo + Math.imul(al3, bl4) | 0;\n  mid = mid + Math.imul(al3, bh4) | 0;\n  mid = mid + Math.imul(ah3, bl4) | 0;\n  hi = hi + Math.imul(ah3, bh4) | 0;\n  lo = lo + Math.imul(al2, bl5) | 0;\n  mid = mid + Math.imul(al2, bh5) | 0;\n  mid = mid + Math.imul(ah2, bl5) | 0;\n  hi = hi + Math.imul(ah2, bh5) | 0;\n  lo = lo + Math.imul(al1, bl6) | 0;\n  mid = mid + Math.imul(al1, bh6) | 0;\n  mid = mid + Math.imul(ah1, bl6) | 0;\n  hi = hi + Math.imul(ah1, bh6) | 0;\n  lo = lo + Math.imul(al0, bl7) | 0;\n  mid = mid + Math.imul(al0, bh7) | 0;\n  mid = mid + Math.imul(ah0, bl7) | 0;\n  hi = hi + Math.imul(ah0, bh7) | 0;\n  var w7 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n  c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;\n  w7 &= 0x3ffffff;\n  /* k = 8 */\n\n  lo = Math.imul(al8, bl0);\n  mid = Math.imul(al8, bh0);\n  mid = mid + Math.imul(ah8, bl0) | 0;\n  hi = Math.imul(ah8, bh0);\n  lo = lo + Math.imul(al7, bl1) | 0;\n  mid = mid + Math.imul(al7, bh1) | 0;\n  mid = mid + Math.imul(ah7, bl1) | 0;\n  hi = hi + Math.imul(ah7, bh1) | 0;\n  lo = lo + Math.imul(al6, bl2) | 0;\n  mid = mid + Math.imul(al6, bh2) | 0;\n  mid = mid + Math.imul(ah6, bl2) | 0;\n  hi = hi + Math.imul(ah6, bh2) | 0;\n  lo = lo + Math.imul(al5, bl3) | 0;\n  mid = mid + Math.imul(al5, bh3) | 0;\n  mid = mid + Math.imul(ah5, bl3) | 0;\n  hi = hi + Math.imul(ah5, bh3) | 0;\n  lo = lo + Math.imul(al4, bl4) | 0;\n  mid = mid + Math.imul(al4, bh4) | 0;\n  mid = mid + Math.imul(ah4, bl4) | 0;\n  hi = hi + Math.imul(ah4, bh4) | 0;\n  lo = lo + Math.imul(al3, bl5) | 0;\n  mid = mid + Math.imul(al3, bh5) | 0;\n  mid = mid + Math.imul(ah3, bl5) | 0;\n  hi = hi + Math.imul(ah3, bh5) | 0;\n  lo = lo + Math.imul(al2, bl6) | 0;\n  mid = mid + Math.imul(al2, bh6) | 0;\n  mid = mid + Math.imul(ah2, bl6) | 0;\n  hi = hi + Math.imul(ah2, bh6) | 0;\n  lo = lo + Math.imul(al1, bl7) | 0;\n  mid = mid + Math.imul(al1, bh7) | 0;\n  mid = mid + Math.imul(ah1, bl7) | 0;\n  hi = hi + Math.imul(ah1, bh7) | 0;\n  lo = lo + Math.imul(al0, bl8) | 0;\n  mid = mid + Math.imul(al0, bh8) | 0;\n  mid = mid + Math.imul(ah0, bl8) | 0;\n  hi = hi + Math.imul(ah0, bh8) | 0;\n  var w8 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n  c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;\n  w8 &= 0x3ffffff;\n  /* k = 9 */\n\n  lo = Math.imul(al9, bl0);\n  mid = Math.imul(al9, bh0);\n  mid = mid + Math.imul(ah9, bl0) | 0;\n  hi = Math.imul(ah9, bh0);\n  lo = lo + Math.imul(al8, bl1) | 0;\n  mid = mid + Math.imul(al8, bh1) | 0;\n  mid = mid + Math.imul(ah8, bl1) | 0;\n  hi = hi + Math.imul(ah8, bh1) | 0;\n  lo = lo + Math.imul(al7, bl2) | 0;\n  mid = mid + Math.imul(al7, bh2) | 0;\n  mid = mid + Math.imul(ah7, bl2) | 0;\n  hi = hi + Math.imul(ah7, bh2) | 0;\n  lo = lo + Math.imul(al6, bl3) | 0;\n  mid = mid + Math.imul(al6, bh3) | 0;\n  mid = mid + Math.imul(ah6, bl3) | 0;\n  hi = hi + Math.imul(ah6, bh3) | 0;\n  lo = lo + Math.imul(al5, bl4) | 0;\n  mid = mid + Math.imul(al5, bh4) | 0;\n  mid = mid + Math.imul(ah5, bl4) | 0;\n  hi = hi + Math.imul(ah5, bh4) | 0;\n  lo = lo + Math.imul(al4, bl5) | 0;\n  mid = mid + Math.imul(al4, bh5) | 0;\n  mid = mid + Math.imul(ah4, bl5) | 0;\n  hi = hi + Math.imul(ah4, bh5) | 0;\n  lo = lo + Math.imul(al3, bl6) | 0;\n  mid = mid + Math.imul(al3, bh6) | 0;\n  mid = mid + Math.imul(ah3, bl6) | 0;\n  hi = hi + Math.imul(ah3, bh6) | 0;\n  lo = lo + Math.imul(al2, bl7) | 0;\n  mid = mid + Math.imul(al2, bh7) | 0;\n  mid = mid + Math.imul(ah2, bl7) | 0;\n  hi = hi + Math.imul(ah2, bh7) | 0;\n  lo = lo + Math.imul(al1, bl8) | 0;\n  mid = mid + Math.imul(al1, bh8) | 0;\n  mid = mid + Math.imul(ah1, bl8) | 0;\n  hi = hi + Math.imul(ah1, bh8) | 0;\n  lo = lo + Math.imul(al0, bl9) | 0;\n  mid = mid + Math.imul(al0, bh9) | 0;\n  mid = mid + Math.imul(ah0, bl9) | 0;\n  hi = hi + Math.imul(ah0, bh9) | 0;\n  var w9 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n  c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;\n  w9 &= 0x3ffffff;\n  /* k = 10 */\n\n  lo = Math.imul(al9, bl1);\n  mid = Math.imul(al9, bh1);\n  mid = mid + Math.imul(ah9, bl1) | 0;\n  hi = Math.imul(ah9, bh1);\n  lo = lo + Math.imul(al8, bl2) | 0;\n  mid = mid + Math.imul(al8, bh2) | 0;\n  mid = mid + Math.imul(ah8, bl2) | 0;\n  hi = hi + Math.imul(ah8, bh2) | 0;\n  lo = lo + Math.imul(al7, bl3) | 0;\n  mid = mid + Math.imul(al7, bh3) | 0;\n  mid = mid + Math.imul(ah7, bl3) | 0;\n  hi = hi + Math.imul(ah7, bh3) | 0;\n  lo = lo + Math.imul(al6, bl4) | 0;\n  mid = mid + Math.imul(al6, bh4) | 0;\n  mid = mid + Math.imul(ah6, bl4) | 0;\n  hi = hi + Math.imul(ah6, bh4) | 0;\n  lo = lo + Math.imul(al5, bl5) | 0;\n  mid = mid + Math.imul(al5, bh5) | 0;\n  mid = mid + Math.imul(ah5, bl5) | 0;\n  hi = hi + Math.imul(ah5, bh5) | 0;\n  lo = lo + Math.imul(al4, bl6) | 0;\n  mid = mid + Math.imul(al4, bh6) | 0;\n  mid = mid + Math.imul(ah4, bl6) | 0;\n  hi = hi + Math.imul(ah4, bh6) | 0;\n  lo = lo + Math.imul(al3, bl7) | 0;\n  mid = mid + Math.imul(al3, bh7) | 0;\n  mid = mid + Math.imul(ah3, bl7) | 0;\n  hi = hi + Math.imul(ah3, bh7) | 0;\n  lo = lo + Math.imul(al2, bl8) | 0;\n  mid = mid + Math.imul(al2, bh8) | 0;\n  mid = mid + Math.imul(ah2, bl8) | 0;\n  hi = hi + Math.imul(ah2, bh8) | 0;\n  lo = lo + Math.imul(al1, bl9) | 0;\n  mid = mid + Math.imul(al1, bh9) | 0;\n  mid = mid + Math.imul(ah1, bl9) | 0;\n  hi = hi + Math.imul(ah1, bh9) | 0;\n  var w10 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n  c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;\n  w10 &= 0x3ffffff;\n  /* k = 11 */\n\n  lo = Math.imul(al9, bl2);\n  mid = Math.imul(al9, bh2);\n  mid = mid + Math.imul(ah9, bl2) | 0;\n  hi = Math.imul(ah9, bh2);\n  lo = lo + Math.imul(al8, bl3) | 0;\n  mid = mid + Math.imul(al8, bh3) | 0;\n  mid = mid + Math.imul(ah8, bl3) | 0;\n  hi = hi + Math.imul(ah8, bh3) | 0;\n  lo = lo + Math.imul(al7, bl4) | 0;\n  mid = mid + Math.imul(al7, bh4) | 0;\n  mid = mid + Math.imul(ah7, bl4) | 0;\n  hi = hi + Math.imul(ah7, bh4) | 0;\n  lo = lo + Math.imul(al6, bl5) | 0;\n  mid = mid + Math.imul(al6, bh5) | 0;\n  mid = mid + Math.imul(ah6, bl5) | 0;\n  hi = hi + Math.imul(ah6, bh5) | 0;\n  lo = lo + Math.imul(al5, bl6) | 0;\n  mid = mid + Math.imul(al5, bh6) | 0;\n  mid = mid + Math.imul(ah5, bl6) | 0;\n  hi = hi + Math.imul(ah5, bh6) | 0;\n  lo = lo + Math.imul(al4, bl7) | 0;\n  mid = mid + Math.imul(al4, bh7) | 0;\n  mid = mid + Math.imul(ah4, bl7) | 0;\n  hi = hi + Math.imul(ah4, bh7) | 0;\n  lo = lo + Math.imul(al3, bl8) | 0;\n  mid = mid + Math.imul(al3, bh8) | 0;\n  mid = mid + Math.imul(ah3, bl8) | 0;\n  hi = hi + Math.imul(ah3, bh8) | 0;\n  lo = lo + Math.imul(al2, bl9) | 0;\n  mid = mid + Math.imul(al2, bh9) | 0;\n  mid = mid + Math.imul(ah2, bl9) | 0;\n  hi = hi + Math.imul(ah2, bh9) | 0;\n  var w11 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n  c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;\n  w11 &= 0x3ffffff;\n  /* k = 12 */\n\n  lo = Math.imul(al9, bl3);\n  mid = Math.imul(al9, bh3);\n  mid = mid + Math.imul(ah9, bl3) | 0;\n  hi = Math.imul(ah9, bh3);\n  lo = lo + Math.imul(al8, bl4) | 0;\n  mid = mid + Math.imul(al8, bh4) | 0;\n  mid = mid + Math.imul(ah8, bl4) | 0;\n  hi = hi + Math.imul(ah8, bh4) | 0;\n  lo = lo + Math.imul(al7, bl5) | 0;\n  mid = mid + Math.imul(al7, bh5) | 0;\n  mid = mid + Math.imul(ah7, bl5) | 0;\n  hi = hi + Math.imul(ah7, bh5) | 0;\n  lo = lo + Math.imul(al6, bl6) | 0;\n  mid = mid + Math.imul(al6, bh6) | 0;\n  mid = mid + Math.imul(ah6, bl6) | 0;\n  hi = hi + Math.imul(ah6, bh6) | 0;\n  lo = lo + Math.imul(al5, bl7) | 0;\n  mid = mid + Math.imul(al5, bh7) | 0;\n  mid = mid + Math.imul(ah5, bl7) | 0;\n  hi = hi + Math.imul(ah5, bh7) | 0;\n  lo = lo + Math.imul(al4, bl8) | 0;\n  mid = mid + Math.imul(al4, bh8) | 0;\n  mid = mid + Math.imul(ah4, bl8) | 0;\n  hi = hi + Math.imul(ah4, bh8) | 0;\n  lo = lo + Math.imul(al3, bl9) | 0;\n  mid = mid + Math.imul(al3, bh9) | 0;\n  mid = mid + Math.imul(ah3, bl9) | 0;\n  hi = hi + Math.imul(ah3, bh9) | 0;\n  var w12 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n  c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;\n  w12 &= 0x3ffffff;\n  /* k = 13 */\n\n  lo = Math.imul(al9, bl4);\n  mid = Math.imul(al9, bh4);\n  mid = mid + Math.imul(ah9, bl4) | 0;\n  hi = Math.imul(ah9, bh4);\n  lo = lo + Math.imul(al8, bl5) | 0;\n  mid = mid + Math.imul(al8, bh5) | 0;\n  mid = mid + Math.imul(ah8, bl5) | 0;\n  hi = hi + Math.imul(ah8, bh5) | 0;\n  lo = lo + Math.imul(al7, bl6) | 0;\n  mid = mid + Math.imul(al7, bh6) | 0;\n  mid = mid + Math.imul(ah7, bl6) | 0;\n  hi = hi + Math.imul(ah7, bh6) | 0;\n  lo = lo + Math.imul(al6, bl7) | 0;\n  mid = mid + Math.imul(al6, bh7) | 0;\n  mid = mid + Math.imul(ah6, bl7) | 0;\n  hi = hi + Math.imul(ah6, bh7) | 0;\n  lo = lo + Math.imul(al5, bl8) | 0;\n  mid = mid + Math.imul(al5, bh8) | 0;\n  mid = mid + Math.imul(ah5, bl8) | 0;\n  hi = hi + Math.imul(ah5, bh8) | 0;\n  lo = lo + Math.imul(al4, bl9) | 0;\n  mid = mid + Math.imul(al4, bh9) | 0;\n  mid = mid + Math.imul(ah4, bl9) | 0;\n  hi = hi + Math.imul(ah4, bh9) | 0;\n  var w13 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n  c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;\n  w13 &= 0x3ffffff;\n  /* k = 14 */\n\n  lo = Math.imul(al9, bl5);\n  mid = Math.imul(al9, bh5);\n  mid = mid + Math.imul(ah9, bl5) | 0;\n  hi = Math.imul(ah9, bh5);\n  lo = lo + Math.imul(al8, bl6) | 0;\n  mid = mid + Math.imul(al8, bh6) | 0;\n  mid = mid + Math.imul(ah8, bl6) | 0;\n  hi = hi + Math.imul(ah8, bh6) | 0;\n  lo = lo + Math.imul(al7, bl7) | 0;\n  mid = mid + Math.imul(al7, bh7) | 0;\n  mid = mid + Math.imul(ah7, bl7) | 0;\n  hi = hi + Math.imul(ah7, bh7) | 0;\n  lo = lo + Math.imul(al6, bl8) | 0;\n  mid = mid + Math.imul(al6, bh8) | 0;\n  mid = mid + Math.imul(ah6, bl8) | 0;\n  hi = hi + Math.imul(ah6, bh8) | 0;\n  lo = lo + Math.imul(al5, bl9) | 0;\n  mid = mid + Math.imul(al5, bh9) | 0;\n  mid = mid + Math.imul(ah5, bl9) | 0;\n  hi = hi + Math.imul(ah5, bh9) | 0;\n  var w14 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n  c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;\n  w14 &= 0x3ffffff;\n  /* k = 15 */\n\n  lo = Math.imul(al9, bl6);\n  mid = Math.imul(al9, bh6);\n  mid = mid + Math.imul(ah9, bl6) | 0;\n  hi = Math.imul(ah9, bh6);\n  lo = lo + Math.imul(al8, bl7) | 0;\n  mid = mid + Math.imul(al8, bh7) | 0;\n  mid = mid + Math.imul(ah8, bl7) | 0;\n  hi = hi + Math.imul(ah8, bh7) | 0;\n  lo = lo + Math.imul(al7, bl8) | 0;\n  mid = mid + Math.imul(al7, bh8) | 0;\n  mid = mid + Math.imul(ah7, bl8) | 0;\n  hi = hi + Math.imul(ah7, bh8) | 0;\n  lo = lo + Math.imul(al6, bl9) | 0;\n  mid = mid + Math.imul(al6, bh9) | 0;\n  mid = mid + Math.imul(ah6, bl9) | 0;\n  hi = hi + Math.imul(ah6, bh9) | 0;\n  var w15 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n  c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;\n  w15 &= 0x3ffffff;\n  /* k = 16 */\n\n  lo = Math.imul(al9, bl7);\n  mid = Math.imul(al9, bh7);\n  mid = mid + Math.imul(ah9, bl7) | 0;\n  hi = Math.imul(ah9, bh7);\n  lo = lo + Math.imul(al8, bl8) | 0;\n  mid = mid + Math.imul(al8, bh8) | 0;\n  mid = mid + Math.imul(ah8, bl8) | 0;\n  hi = hi + Math.imul(ah8, bh8) | 0;\n  lo = lo + Math.imul(al7, bl9) | 0;\n  mid = mid + Math.imul(al7, bh9) | 0;\n  mid = mid + Math.imul(ah7, bl9) | 0;\n  hi = hi + Math.imul(ah7, bh9) | 0;\n  var w16 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n  c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;\n  w16 &= 0x3ffffff;\n  /* k = 17 */\n\n  lo = Math.imul(al9, bl8);\n  mid = Math.imul(al9, bh8);\n  mid = mid + Math.imul(ah9, bl8) | 0;\n  hi = Math.imul(ah9, bh8);\n  lo = lo + Math.imul(al8, bl9) | 0;\n  mid = mid + Math.imul(al8, bh9) | 0;\n  mid = mid + Math.imul(ah8, bl9) | 0;\n  hi = hi + Math.imul(ah8, bh9) | 0;\n  var w17 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n  c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;\n  w17 &= 0x3ffffff;\n  /* k = 18 */\n\n  lo = Math.imul(al9, bl9);\n  mid = Math.imul(al9, bh9);\n  mid = mid + Math.imul(ah9, bl9) | 0;\n  hi = Math.imul(ah9, bh9);\n  var w18 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;\n  c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;\n  w18 &= 0x3ffffff;\n  o[0] = w0;\n  o[1] = w1;\n  o[2] = w2;\n  o[3] = w3;\n  o[4] = w4;\n  o[5] = w5;\n  o[6] = w6;\n  o[7] = w7;\n  o[8] = w8;\n  o[9] = w9;\n  o[10] = w10;\n  o[11] = w11;\n  o[12] = w12;\n  o[13] = w13;\n  o[14] = w14;\n  o[15] = w15;\n  o[16] = w16;\n  o[17] = w17;\n  o[18] = w18;\n\n  if (c !== 0) {\n    o[19] = c;\n    out.length += 1;\n  } // Note: we shouldn't need to strip here.\n\n\n  return out;\n} // Polyfill comb.\n\n\nif (!Math.imul) comb10MulTo = smallMulTo;\n/*\n * Expose\n */\n\nBN.Red = Red;\nmodule.exports = BN;","map":null,"metadata":{},"sourceType":"script"}