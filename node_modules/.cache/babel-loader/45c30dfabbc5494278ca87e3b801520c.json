{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar constants = require('./constants');\n\nvar errcode = require('err-code');\n\nvar Heartbeat = /*#__PURE__*/function () {\n  /**\n   * @param {Object} gossipsub\n   * @constructor\n   */\n  function Heartbeat(gossipsub) {\n    _classCallCheck(this, Heartbeat);\n\n    this.gossipsub = gossipsub;\n  }\n\n  _createClass(Heartbeat, [{\n    key: \"start\",\n    value: function start() {\n      var _this = this;\n\n      if (this._heartbeatTimer) {\n        var errMsg = 'Heartbeat timer is already running';\n        this.gossipsub.log(errMsg);\n        throw errcode(new Error(errMsg), 'ERR_HEARTBEAT_ALREADY_RUNNING');\n      }\n\n      var heartbeat = this._heartbeat.bind(this);\n\n      var timeout = setTimeout(function () {\n        heartbeat();\n\n        _this._heartbeatTimer.runPeriodically(heartbeat, constants.GossipSubHeartbeatInterval);\n      }, constants.GossipSubHeartbeatInitialDelay);\n      this._heartbeatTimer = {\n        _onCancel: null,\n        _intervalId: null,\n        runPeriodically: function runPeriodically(fn, period) {\n          _this._heartbeatTimer._intervalId = setInterval(fn, period);\n        },\n        cancel: function cancel() {\n          clearTimeout(timeout);\n          clearInterval(_this._heartbeatTimer._intervalId);\n        }\n      };\n    }\n    /**\n     * Unmounts the gossipsub protocol and shuts down every connection\n     * @override\n     * @returns {void}\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (!this._heartbeatTimer) {\n        var errMsg = 'Heartbeat timer is not running';\n        this.gossipsub.log(errMsg);\n        throw errcode(new Error(errMsg), 'ERR_HEARTBEAT_NO_RUNNING');\n      }\n\n      this._heartbeatTimer.cancel();\n\n      this._heartbeatTimer = null;\n    }\n    /**\n     * Maintains the mesh and fanout maps in gossipsub.\n     *\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_heartbeat\",\n    value: function _heartbeat() {\n      var _this2 = this;\n\n      // flush pending control message from retries and gossip\n      // that hasn't been piggybacked since the last heartbeat\n      this.gossipsub._flush();\n      /**\n       * @type {Map<Peer, Array<String>>}\n       */\n\n\n      var tograft = new Map();\n      var toprune = new Map(); // maintain the mesh for topics we have joined\n\n      this.gossipsub.mesh.forEach(function (peers, topic) {\n        // do we have enough peers?\n        if (peers.size < constants.GossipSubDlo) {\n          var ineed = constants.GossipSubD - peers.size;\n\n          var peersSet = _this2.gossipsub._getPeers(topic, ineed);\n\n          peersSet.forEach(function (peer) {\n            // add topic peers not already in mesh\n            if (peers.has(peer)) {\n              return;\n            }\n\n            _this2.gossipsub.log('HEARTBEAT: Add mesh link to %s in %s', peer.info.id.toB58String(), topic);\n\n            peers.add(peer);\n            var peerGrafts = tograft.get(peer);\n\n            if (!peerGrafts) {\n              tograft.set(peer, [topic]);\n            } else {\n              peerGrafts.push(topic);\n            }\n          });\n        } // do we have to many peers?\n\n\n        if (peers.size > constants.GossipSubDhi) {\n          var idontneed = peers.size - constants.GossipSubD;\n          var peersArray = Array.from(peers);\n          peersArray = _this2.gossipsub._shufflePeers(peersArray);\n          peersArray = peersArray.slice(0, idontneed);\n          peersArray.forEach(function (peer) {\n            _this2.gossipsub.log('HEARTBEAT: Remove mesh link to %s in %s', peer.info.id.toB58String(), topic);\n\n            peers.delete(peer);\n            var peerPrunes = toprune.get(peer);\n\n            if (!peerPrunes) {\n              toprune.set(peer, [topic]);\n            } else {\n              peerPrunes.push(topic);\n            }\n          });\n        }\n\n        _this2.gossipsub._emitGossip(topic, peers);\n      }); // expire fanout for topics we haven't published to in a while\n\n      var now = this.gossipsub._now();\n\n      this.gossipsub.lastpub.forEach(function (lastpb, topic) {\n        if (lastpb + constants.GossipSubFanoutTTL < now) {\n          _this2.gossipsub.fanout.delete(topic);\n\n          _this2.gossipsub.lastpub.delete(topic);\n        }\n      }); // maintain our fanout for topics we are publishing but we have not joined\n\n      this.gossipsub.fanout.forEach(function (peers, topic) {\n        // checks whether our peers are still in the topic\n        peers.forEach(function (peer) {\n          if (_this2.gossipsub.topics.has(peer)) {\n            peers.delete(peer);\n          }\n        }); // do we need more peers?\n\n        if (peers.size < constants.GossipSubD) {\n          var ineed = constants.GossipSubD - peers.size;\n\n          var peersSet = _this2.gossipsub._getPeers(topic, ineed);\n\n          peersSet.forEach(function (peer) {\n            if (!peers.has(peer)) {\n              return;\n            }\n\n            peers.add(peer);\n          });\n        }\n\n        _this2.gossipsub._emitGossip(topic, peers);\n      }); // send coalesced GRAFT/PRUNE messages (will piggyback gossip)\n\n      this.gossipsub._sendGraftPrune(tograft, toprune); // advance the message history window\n\n\n      this.gossipsub.messageCache.shift();\n      this.gossipsub.emit('gossipsub:heartbeat');\n    }\n  }]);\n\n  return Heartbeat;\n}();\n\nmodule.exports = Heartbeat;","map":null,"metadata":{},"sourceType":"script"}