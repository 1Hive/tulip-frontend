{"ast":null,"code":"'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst protobuf = require('protons');\n\nconst keysPBM = protobuf(require('./keys.proto'));\n\nrequire('node-forge/lib/asn1');\n\nrequire('node-forge/lib/pbe');\n\nconst forge = require('node-forge/lib/forge');\n\nconst errcode = require('err-code');\n\nconst importer = require('./importer');\n\nexports = module.exports;\nconst supportedKeys = {\n  rsa: require('./rsa-class'),\n  ed25519: require('./ed25519-class'),\n  secp256k1: require('./secp256k1-class')(keysPBM, require('../random-bytes'))\n};\nexports.supportedKeys = supportedKeys;\nexports.keysPBM = keysPBM;\nconst ErrMissingSecp256K1 = {\n  message: 'secp256k1 support requires libp2p-crypto-secp256k1 package',\n  code: 'ERR_MISSING_PACKAGE'\n};\n\nfunction typeToKey(type) {\n  const key = supportedKeys[type.toLowerCase()];\n\n  if (!key) {\n    const supported = Object.keys(supportedKeys).join(' / ');\n    throw errcode(new Error(`invalid or unsupported key type ${type}. Must be ${supported}`), 'ERR_UNSUPPORTED_KEY_TYPE');\n  }\n\n  return key;\n}\n\nexports.keyStretcher = require('./key-stretcher');\nexports.generateEphemeralKeyPair = require('./ephemeral-keys'); // Generates a keypair of the given type and bitsize\n\nexports.generateKeyPair = async (type, bits) => {\n  // eslint-disable-line require-await\n  return typeToKey(type).generateKeyPair(bits);\n}; // Generates a keypair of the given type and bitsize\n// seed is a 32 byte uint8array\n\n\nexports.generateKeyPairFromSeed = async (type, seed, bits) => {\n  // eslint-disable-line require-await\n  const key = typeToKey(type);\n\n  if (type.toLowerCase() !== 'ed25519') {\n    throw errcode(new Error('Seed key derivation is unimplemented for RSA or secp256k1'), 'ERR_UNSUPPORTED_KEY_DERIVATION_TYPE');\n  }\n\n  return key.generateKeyPairFromSeed(seed, bits);\n}; // Converts a protobuf serialized public key into its\n// representative object\n\n\nexports.unmarshalPublicKey = buf => {\n  const decoded = keysPBM.PublicKey.decode(buf);\n  const data = decoded.Data;\n\n  switch (decoded.Type) {\n    case keysPBM.KeyType.RSA:\n      return supportedKeys.rsa.unmarshalRsaPublicKey(data);\n\n    case keysPBM.KeyType.Ed25519:\n      return supportedKeys.ed25519.unmarshalEd25519PublicKey(data);\n\n    case keysPBM.KeyType.Secp256k1:\n      if (supportedKeys.secp256k1) {\n        return supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(data);\n      } else {\n        throw errcode(new Error(ErrMissingSecp256K1.message), ErrMissingSecp256K1.code);\n      }\n\n    default:\n      typeToKey(decoded.Type);\n    // throws because type is not supported\n  }\n}; // Converts a public key object into a protobuf serialized public key\n\n\nexports.marshalPublicKey = (key, type) => {\n  type = (type || 'rsa').toLowerCase();\n  typeToKey(type); // check type\n\n  return key.bytes;\n}; // Converts a protobuf serialized private key into its\n// representative object\n\n\nexports.unmarshalPrivateKey = async buf => {\n  // eslint-disable-line require-await\n  const decoded = keysPBM.PrivateKey.decode(buf);\n  const data = decoded.Data;\n\n  switch (decoded.Type) {\n    case keysPBM.KeyType.RSA:\n      return supportedKeys.rsa.unmarshalRsaPrivateKey(data);\n\n    case keysPBM.KeyType.Ed25519:\n      return supportedKeys.ed25519.unmarshalEd25519PrivateKey(data);\n\n    case keysPBM.KeyType.Secp256k1:\n      if (supportedKeys.secp256k1) {\n        return supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(data);\n      } else {\n        throw errcode(new Error(ErrMissingSecp256K1.message), ErrMissingSecp256K1.code);\n      }\n\n    default:\n      typeToKey(decoded.Type);\n    // throws because type is not supported\n  }\n}; // Converts a private key object into a protobuf serialized private key\n\n\nexports.marshalPrivateKey = (key, type) => {\n  type = (type || 'rsa').toLowerCase();\n  typeToKey(type); // check type\n\n  return key.bytes;\n};\n/**\n *\n * @param {string} encryptedKey\n * @param {string} password\n */\n\n\nexports.import = async (encryptedKey, password) => {\n  // eslint-disable-line require-await\n  try {\n    const key = await importer.import(encryptedKey, password);\n    return exports.unmarshalPrivateKey(key);\n  } catch (_) {// Ignore and try the old pem decrypt\n  } // Only rsa supports pem right now\n\n\n  const key = forge.pki.decryptRsaPrivateKey(encryptedKey, password);\n\n  if (key === null) {\n    throw errcode(new Error('Cannot read the key, most likely the password is wrong or not a RSA key'), 'ERR_CANNOT_DECRYPT_PEM');\n  }\n\n  let der = forge.asn1.toDer(forge.pki.privateKeyToAsn1(key));\n  der = Buffer.from(der.getBytes(), 'binary');\n  return supportedKeys.rsa.unmarshalRsaPrivateKey(der);\n};","map":null,"metadata":{},"sourceType":"script"}