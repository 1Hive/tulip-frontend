{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar withIs = require('class-is');\n\nvar Topology = require('./index');\n\nvar MulticodecTopology = /*#__PURE__*/function (_Topology) {\n  _inherits(MulticodecTopology, _Topology);\n\n  var _super = _createSuper(MulticodecTopology);\n\n  /**\n   * @param {Object} props\n   * @param {number} props.min minimum needed connections (default: 0)\n   * @param {number} props.max maximum needed connections (default: Infinity)\n   * @param {Array<string>} props.multicodecs protocol multicodecs\n   * @param {Object} props.handlers\n   * @param {function} props.handlers.onConnect protocol \"onConnect\" handler\n   * @param {function} props.handlers.onDisconnect protocol \"onDisconnect\" handler\n   * @constructor\n   */\n  function MulticodecTopology(_ref) {\n    var _this;\n\n    var min = _ref.min,\n        max = _ref.max,\n        multicodecs = _ref.multicodecs,\n        handlers = _ref.handlers;\n\n    _classCallCheck(this, MulticodecTopology);\n\n    _this = _super.call(this, {\n      min: min,\n      max: max,\n      handlers: handlers\n    });\n\n    if (!multicodecs) {\n      throw new Error('one or more multicodec should be provided');\n    }\n\n    if (!handlers) {\n      throw new Error('the handlers should be provided');\n    }\n\n    if (typeof handlers.onConnect !== 'function') {\n      throw new Error('the \\'onConnect\\' handler must be provided');\n    }\n\n    if (typeof handlers.onDisconnect !== 'function') {\n      throw new Error('the \\'onDisconnect\\' handler must be provided');\n    }\n\n    _this.multicodecs = Array.isArray(multicodecs) ? multicodecs : [multicodecs];\n    _this._registrar = undefined;\n    _this._onProtocolChange = _this._onProtocolChange.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(MulticodecTopology, [{\n    key: \"registrar\",\n    set: function set(registrar) {\n      this._registrar = registrar;\n\n      this._registrar.peerStore.on('change:protocols', this._onProtocolChange); // Update topology peers\n\n\n      this._updatePeers(this._registrar.peerStore.peers.values());\n    }\n    /**\n     * Update topology.\n     * @param {Array<PeerInfo>} peerInfoIterable\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_updatePeers\",\n    value: function _updatePeers(peerInfoIterable) {\n      var _this2 = this;\n\n      var _iterator = _createForOfIteratorHelper(peerInfoIterable),\n          _step;\n\n      try {\n        var _loop = function _loop() {\n          var peerInfo = _step.value;\n\n          if (_this2.multicodecs.filter(function (multicodec) {\n            return peerInfo.protocols.has(multicodec);\n          }).length) {\n            // Add the peer regardless of whether or not there is currently a connection\n            _this2.peers.set(peerInfo.id.toB58String(), peerInfo); // If there is a connection, call _onConnect\n\n\n            var connection = _this2._registrar.getConnection(peerInfo);\n\n            connection && _this2._onConnect(peerInfo, connection);\n          } else {\n            // Remove any peers we might be tracking that are no longer of value to us\n            _this2.peers.delete(peerInfo.id.toB58String());\n          }\n        };\n\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    /**\n     * Check if a new peer support the multicodecs for this topology.\n     * @param {Object} props\n     * @param {PeerInfo} props.peerInfo\n     * @param {Array<string>} props.protocols\n     */\n\n  }, {\n    key: \"_onProtocolChange\",\n    value: function _onProtocolChange(_ref2) {\n      var _this3 = this;\n\n      var peerInfo = _ref2.peerInfo,\n          protocols = _ref2.protocols;\n      var existingPeer = this.peers.get(peerInfo.id.toB58String());\n      var hasProtocol = protocols.filter(function (protocol) {\n        return _this3.multicodecs.includes(protocol);\n      }); // Not supporting the protocol anymore?\n\n      if (existingPeer && hasProtocol.length === 0) {\n        this._onDisconnect(peerInfo);\n      } // New to protocol support\n\n\n      var _iterator2 = _createForOfIteratorHelper(protocols),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var protocol = _step2.value;\n\n          if (this.multicodecs.includes(protocol)) {\n            this._updatePeers([peerInfo]);\n\n            return;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }]);\n\n  return MulticodecTopology;\n}(Topology);\n\nmodule.exports = withIs(MulticodecTopology, {\n  className: 'MulticodecTopology',\n  symbolName: '@libp2p/js-interfaces/topology/multicodec-topology'\n});","map":null,"metadata":{},"sourceType":"script"}