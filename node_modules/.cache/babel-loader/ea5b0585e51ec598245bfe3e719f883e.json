{"ast":null,"code":"const FIFO = require('fast-fifo');\n\nmodule.exports = options => {\n  options = options || {};\n  let onEnd;\n\n  if (typeof options === 'function') {\n    onEnd = options;\n    options = {};\n  } else {\n    onEnd = options.onEnd;\n  }\n\n  let buffer = new FIFO();\n  let pushable, onNext, ended;\n\n  const waitNext = () => {\n    if (!buffer.isEmpty()) {\n      if (options.writev) {\n        let next;\n        const values = [];\n\n        while (!buffer.isEmpty()) {\n          next = buffer.shift();\n          if (next.error) throw next.error;\n          values.push(next.value);\n        }\n\n        return {\n          done: next.done,\n          value: values\n        };\n      }\n\n      const next = buffer.shift();\n      if (next.error) throw next.error;\n      return next;\n    }\n\n    if (ended) return {\n      done: true\n    };\n    return new Promise((resolve, reject) => {\n      onNext = next => {\n        onNext = null;\n\n        if (next.error) {\n          reject(next.error);\n        } else {\n          if (options.writev && !next.done) {\n            resolve({\n              done: next.done,\n              value: [next.value]\n            });\n          } else {\n            resolve(next);\n          }\n        }\n\n        return pushable;\n      };\n    });\n  };\n\n  const bufferNext = next => {\n    if (onNext) return onNext(next);\n    buffer.push(next);\n    return pushable;\n  };\n\n  const bufferError = err => {\n    buffer = new FIFO();\n    if (onNext) return onNext({\n      error: err\n    });\n    buffer.push({\n      error: err\n    });\n    return pushable;\n  };\n\n  const push = value => {\n    if (ended) return pushable;\n    return bufferNext({\n      done: false,\n      value\n    });\n  };\n\n  const end = err => {\n    if (ended) return pushable;\n    ended = true;\n    return err ? bufferError(err) : bufferNext({\n      done: true\n    });\n  };\n\n  const _return = () => {\n    buffer = new FIFO();\n    end();\n    return {\n      done: true\n    };\n  };\n\n  const _throw = err => {\n    end(err);\n    return {\n      done: true\n    };\n  };\n\n  pushable = {\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n\n    next: waitNext,\n    return: _return,\n    throw: _throw,\n    push,\n    end\n  };\n  if (!onEnd) return pushable;\n  const _pushable = pushable;\n  pushable = {\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n\n    next() {\n      return _pushable.next();\n    },\n\n    throw(err) {\n      _pushable.throw(err);\n\n      if (onEnd) {\n        onEnd(err);\n        onEnd = null;\n      }\n\n      return {\n        done: true\n      };\n    },\n\n    return() {\n      _pushable.return();\n\n      if (onEnd) {\n        onEnd();\n        onEnd = null;\n      }\n\n      return {\n        done: true\n      };\n    },\n\n    push,\n\n    end(err) {\n      _pushable.end(err);\n\n      if (onEnd) {\n        onEnd(err);\n        onEnd = null;\n      }\n\n      return pushable;\n    }\n\n  };\n  return pushable;\n};","map":null,"metadata":{},"sourceType":"script"}