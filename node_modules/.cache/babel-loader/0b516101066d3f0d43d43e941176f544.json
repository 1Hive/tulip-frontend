{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _createForOfIteratorHelper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _asyncIterator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar lp = require('it-length-prefixed');\n\nvar pipe = require('it-pipe');\n\nvar Message = require('./types/message');\n\nvar CONSTANTS = require('./constants');\n\nvar logger = require('./utils').logger;\n\nvar BITSWAP100 = '/ipfs/bitswap/1.0.0';\nvar BITSWAP110 = '/ipfs/bitswap/1.1.0';\nvar BITSWAP120 = '/ipfs/bitswap/1.2.0';\n\nvar Network = /*#__PURE__*/function () {\n  function Network(libp2p, bitswap, options, stats) {\n    _classCallCheck(this, Network);\n\n    this._log = logger(libp2p.peerInfo.id, 'network');\n    options = options || {};\n    this.libp2p = libp2p;\n    this.bitswap = bitswap;\n    this.protocols = [BITSWAP100];\n\n    if (!options.b100Only) {\n      // Latest bitswap first\n      this.protocols.unshift(BITSWAP110);\n      this.protocols.unshift(BITSWAP120);\n    }\n\n    this._stats = stats;\n    this._running = false; // bind event listeners\n\n    this._onPeerConnect = this._onPeerConnect.bind(this);\n    this._onPeerDisconnect = this._onPeerDisconnect.bind(this);\n    this._onConnection = this._onConnection.bind(this);\n  }\n\n  _createClass(Network, [{\n    key: \"start\",\n    value: function start() {\n      this._running = true;\n      this.libp2p.handle(this.protocols, this._onConnection);\n      this.libp2p.on('peer:connect', this._onPeerConnect);\n      this.libp2p.on('peer:disconnect', this._onPeerDisconnect); // All existing connections are like new ones for us\n\n      var _iterator3 = _createForOfIteratorHelper(this.libp2p.peerStore.peers.values()),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var peer = _step3.value;\n\n          if (this.libp2p.registrar.getConnection(peer)) {\n            this._onPeerConnect(peer);\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this._running = false; // Unhandle both, libp2p doesn't care if it's not already handled\n\n      this.libp2p.unhandle(this.protocols);\n      this.libp2p.removeListener('peer:connect', this._onPeerConnect);\n      this.libp2p.removeListener('peer:disconnect', this._onPeerDisconnect);\n    }\n    /**\n     * Handles both types of incoming bitswap messages\n     * @private\n     * @param {object} param0\n     * @param {string} param0.protocol The protocol the stream is running\n     * @param {Stream} param0.stream A duplex iterable stream\n     * @param {Connection} param0.connection A libp2p Connection\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_onConnection\",\n    value: function () {\n      var _onConnection2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref) {\n        var _this = this;\n\n        var protocol, stream, connection;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                protocol = _ref.protocol, stream = _ref.stream, connection = _ref.connection;\n\n                if (this._running) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 3:\n                this._log('incoming new bitswap %s connection from %s', protocol, connection.remotePeer.toB58String());\n\n                _context2.prev = 4;\n                _context2.next = 7;\n                return pipe(stream, lp.decode(), /*#__PURE__*/function () {\n                  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(source) {\n                    var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, data, message;\n\n                    return _regeneratorRuntime.wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            _iteratorNormalCompletion = true;\n                            _didIteratorError = false;\n                            _context.prev = 2;\n                            _iterator = _asyncIterator(source);\n\n                          case 4:\n                            _context.next = 6;\n                            return _iterator.next();\n\n                          case 6:\n                            _step = _context.sent;\n                            _iteratorNormalCompletion = _step.done;\n                            _context.next = 10;\n                            return _step.value;\n\n                          case 10:\n                            _value = _context.sent;\n\n                            if (_iteratorNormalCompletion) {\n                              _context.next = 28;\n                              break;\n                            }\n\n                            data = _value;\n                            _context.prev = 13;\n                            _context.next = 16;\n                            return Message.deserialize(data.slice());\n\n                          case 16:\n                            message = _context.sent;\n                            _context.next = 19;\n                            return _this.bitswap._receiveMessage(connection.remotePeer, message);\n\n                          case 19:\n                            _context.next = 25;\n                            break;\n\n                          case 21:\n                            _context.prev = 21;\n                            _context.t0 = _context[\"catch\"](13);\n\n                            _this.bitswap._receiveError(_context.t0);\n\n                            return _context.abrupt(\"break\", 28);\n\n                          case 25:\n                            _iteratorNormalCompletion = true;\n                            _context.next = 4;\n                            break;\n\n                          case 28:\n                            _context.next = 34;\n                            break;\n\n                          case 30:\n                            _context.prev = 30;\n                            _context.t1 = _context[\"catch\"](2);\n                            _didIteratorError = true;\n                            _iteratorError = _context.t1;\n\n                          case 34:\n                            _context.prev = 34;\n                            _context.prev = 35;\n\n                            if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                              _context.next = 39;\n                              break;\n                            }\n\n                            _context.next = 39;\n                            return _iterator.return();\n\n                          case 39:\n                            _context.prev = 39;\n\n                            if (!_didIteratorError) {\n                              _context.next = 42;\n                              break;\n                            }\n\n                            throw _iteratorError;\n\n                          case 42:\n                            return _context.finish(39);\n\n                          case 43:\n                            return _context.finish(34);\n\n                          case 44:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee, null, [[2, 30, 34, 44], [13, 21], [35,, 39, 43]]);\n                  }));\n\n                  return function (_x2) {\n                    return _ref2.apply(this, arguments);\n                  };\n                }());\n\n              case 7:\n                _context2.next = 12;\n                break;\n\n              case 9:\n                _context2.prev = 9;\n                _context2.t0 = _context2[\"catch\"](4);\n\n                this._log(_context2.t0);\n\n              case 12:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[4, 9]]);\n      }));\n\n      function _onConnection(_x) {\n        return _onConnection2.apply(this, arguments);\n      }\n\n      return _onConnection;\n    }()\n  }, {\n    key: \"_onPeerConnect\",\n    value: function _onPeerConnect(peerInfo) {\n      this.bitswap._onPeerConnected(peerInfo.id);\n    }\n  }, {\n    key: \"_onPeerDisconnect\",\n    value: function _onPeerDisconnect(peerInfo) {\n      this.bitswap._onPeerDisconnected(peerInfo.id);\n    }\n    /**\n     * Find providers given a `cid`.\n     *\n     * @param {CID} cid\n     * @param {number} maxProviders\n     * @param {Object} options\n     * @param {AbortSignal} options.abortSignal\n     * @returns {AsyncIterable<PeerInfo>}\n     */\n\n  }, {\n    key: \"findProviders\",\n    value: function findProviders(cid, maxProviders) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return this.libp2p.contentRouting.findProviders(cid, {\n        maxTimeout: CONSTANTS.providerRequestTimeout,\n        maxNumProviders: maxProviders,\n        signal: options.signal\n      });\n    }\n    /**\n     * Find the providers of a given `cid` and connect to them.\n     *\n     * @param {CID} cid\n     * @param {Object} options\n     * @param {AbortSignal} options.abortSignal\n     * @returns {void}\n     */\n\n  }, {\n    key: \"findAndConnect\",\n    value: function () {\n      var _findAndConnect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(cid, options) {\n        var connectAttempts, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _value2, provider;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                connectAttempts = [];\n                _iteratorNormalCompletion2 = true;\n                _didIteratorError2 = false;\n                _context3.prev = 3;\n                _iterator2 = _asyncIterator(this.findProviders(cid, CONSTANTS.maxProvidersPerRequest, options));\n\n              case 5:\n                _context3.next = 7;\n                return _iterator2.next();\n\n              case 7:\n                _step2 = _context3.sent;\n                _iteratorNormalCompletion2 = _step2.done;\n                _context3.next = 11;\n                return _step2.value;\n\n              case 11:\n                _value2 = _context3.sent;\n\n                if (_iteratorNormalCompletion2) {\n                  _context3.next = 19;\n                  break;\n                }\n\n                provider = _value2;\n\n                this._log('connecting to providers', provider.id.toB58String());\n\n                connectAttempts.push(this.connectTo(provider, options));\n\n              case 16:\n                _iteratorNormalCompletion2 = true;\n                _context3.next = 5;\n                break;\n\n              case 19:\n                _context3.next = 25;\n                break;\n\n              case 21:\n                _context3.prev = 21;\n                _context3.t0 = _context3[\"catch\"](3);\n                _didIteratorError2 = true;\n                _iteratorError2 = _context3.t0;\n\n              case 25:\n                _context3.prev = 25;\n                _context3.prev = 26;\n\n                if (!(!_iteratorNormalCompletion2 && _iterator2.return != null)) {\n                  _context3.next = 30;\n                  break;\n                }\n\n                _context3.next = 30;\n                return _iterator2.return();\n\n              case 30:\n                _context3.prev = 30;\n\n                if (!_didIteratorError2) {\n                  _context3.next = 33;\n                  break;\n                }\n\n                throw _iteratorError2;\n\n              case 33:\n                return _context3.finish(30);\n\n              case 34:\n                return _context3.finish(25);\n\n              case 35:\n                _context3.next = 37;\n                return Promise.all(connectAttempts);\n\n              case 37:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[3, 21, 25, 35], [26,, 30, 34]]);\n      }));\n\n      function findAndConnect(_x3, _x4) {\n        return _findAndConnect.apply(this, arguments);\n      }\n\n      return findAndConnect;\n    }()\n    /**\n     * Tell the network we can provide content for the passed CID\n     *\n     * @param {CID} cid\n     * @param {Object} options\n     * @param {AbortSignal} options.abortSignal\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"provide\",\n    value: function () {\n      var _provide = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(cid, options) {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this.libp2p.contentRouting.provide(cid, options);\n\n              case 2:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function provide(_x5, _x6) {\n        return _provide.apply(this, arguments);\n      }\n\n      return provide;\n    }() // Connect to the given peer\n    // Send the given msg (instance of Message) to the given peer\n\n  }, {\n    key: \"sendMessage\",\n    value: function () {\n      var _sendMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(peer, msg) {\n        var stringId, _yield$this$_dialPeer, stream, protocol, serialized;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (this._running) {\n                  _context5.next = 2;\n                  break;\n                }\n\n                throw new Error('network isn\\'t running');\n\n              case 2:\n                stringId = peer.toB58String();\n\n                this._log('sendMessage to %s', stringId, msg);\n\n                _context5.next = 6;\n                return this._dialPeer(peer);\n\n              case 6:\n                _yield$this$_dialPeer = _context5.sent;\n                stream = _yield$this$_dialPeer.stream;\n                protocol = _yield$this$_dialPeer.protocol;\n                _context5.t0 = protocol;\n                _context5.next = _context5.t0 === BITSWAP100 ? 12 : _context5.t0 === BITSWAP110 ? 14 : _context5.t0 === BITSWAP120 ? 14 : 16;\n                break;\n\n              case 12:\n                serialized = msg.serializeToBitswap100();\n                return _context5.abrupt(\"break\", 17);\n\n              case 14:\n                serialized = msg.serializeToBitswap110();\n                return _context5.abrupt(\"break\", 17);\n\n              case 16:\n                throw new Error('Unknown protocol: ' + protocol);\n\n              case 17:\n                // Note: Don't wait for writeMessage() to complete\n                writeMessage(stream, serialized, this._log);\n\n                this._updateSentStats(peer, msg.blocks);\n\n              case 19:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function sendMessage(_x7, _x8) {\n        return _sendMessage.apply(this, arguments);\n      }\n\n      return sendMessage;\n    }()\n    /**\n     * Connects to another peer\n     *\n     * @param {PeerInfo|PeerId|Multiaddr} peer\n     * @param {Object} options\n     * @param {AbortSignal} options.abortSignal\n     * @returns {Promise<Connection>}\n     */\n\n  }, {\n    key: \"connectTo\",\n    value: function () {\n      var _connectTo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(peer, options) {\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (this._running) {\n                  _context6.next = 2;\n                  break;\n                }\n\n                throw new Error('network isn\\'t running');\n\n              case 2:\n                return _context6.abrupt(\"return\", this.libp2p.dial(peer, options));\n\n              case 3:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function connectTo(_x9, _x10) {\n        return _connectTo.apply(this, arguments);\n      }\n\n      return connectTo;\n    }() // Dial to the peer and try to use the most recent Bitswap\n\n  }, {\n    key: \"_dialPeer\",\n    value: function _dialPeer(peer) {\n      return this.libp2p.dialProtocol(peer, [BITSWAP120, BITSWAP110, BITSWAP100]);\n    }\n  }, {\n    key: \"_updateSentStats\",\n    value: function _updateSentStats(peer, blocks) {\n      var _this2 = this;\n\n      var peerId = peer.toB58String();\n\n      if (this._stats) {\n        blocks.forEach(function (block) {\n          return _this2._stats.push(peerId, 'dataSent', block.data.length);\n        });\n\n        this._stats.push(peerId, 'blocksSent', blocks.size);\n      }\n    }\n  }]);\n\n  return Network;\n}();\n\nfunction writeMessage(_x11, _x12, _x13) {\n  return _writeMessage.apply(this, arguments);\n}\n\nfunction _writeMessage() {\n  _writeMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(stream, msg, log) {\n    return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            _context7.prev = 0;\n            _context7.next = 3;\n            return pipe([msg], lp.encode(), stream);\n\n          case 3:\n            _context7.next = 8;\n            break;\n\n          case 5:\n            _context7.prev = 5;\n            _context7.t0 = _context7[\"catch\"](0);\n            log(_context7.t0);\n\n          case 8:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, _callee7, null, [[0, 5]]);\n  }));\n  return _writeMessage.apply(this, arguments);\n}\n\nmodule.exports = Network;","map":null,"metadata":{},"sourceType":"script"}