{"ast":null,"code":"/*\n * Id is an object representation of a peer Id. a peer Id is a multihash\n */\n'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar mh = require('multihashes');\n\nvar CID = require('cids');\n\nvar cryptoKeys = require('libp2p-crypto/src/keys');\n\nvar withIs = require('class-is');\n\nvar _require2 = require('./proto'),\n    PeerIdProto = _require2.PeerIdProto;\n\nvar PeerId = /*#__PURE__*/function () {\n  function PeerId(id, privKey, pubKey) {\n    _classCallCheck(this, PeerId);\n\n    if (!Buffer.isBuffer(id)) {\n      throw new Error('invalid id provided');\n    }\n\n    if (privKey && pubKey && !privKey.public.bytes.equals(pubKey.bytes)) {\n      throw new Error('inconsistent arguments');\n    }\n\n    this._id = id;\n    this._idB58String = mh.toB58String(this.id);\n    this._privKey = privKey;\n    this._pubKey = pubKey;\n  }\n\n  _createClass(PeerId, [{\n    key: \"id\",\n    get: function get() {\n      return this._id;\n    },\n    set: function set(val) {\n      throw new Error('Id is immutable');\n    }\n  }, {\n    key: \"privKey\",\n    get: function get() {\n      return this._privKey;\n    },\n    set: function set(privKey) {\n      this._privKey = privKey;\n    }\n  }, {\n    key: \"pubKey\",\n    get: function get() {\n      if (this._pubKey) {\n        return this._pubKey;\n      }\n\n      if (this._privKey) {\n        return this._privKey.public;\n      }\n\n      try {\n        var decoded = mh.decode(this.id);\n\n        if (decoded.name === 'identity') {\n          this._pubKey = cryptoKeys.unmarshalPublicKey(decoded.digest);\n        }\n      } catch (_) {// Ignore, there is no valid public key\n      }\n\n      return this._pubKey;\n    },\n    set: function set(pubKey) {\n      this._pubKey = pubKey;\n    } // Return the protobuf version of the public key, matching go ipfs formatting\n\n  }, {\n    key: \"marshalPubKey\",\n    value: function marshalPubKey() {\n      if (this.pubKey) {\n        return cryptoKeys.marshalPublicKey(this.pubKey);\n      }\n    } // Return the protobuf version of the private key, matching go ipfs formatting\n\n  }, {\n    key: \"marshalPrivKey\",\n    value: function marshalPrivKey() {\n      if (this.privKey) {\n        return cryptoKeys.marshalPrivateKey(this.privKey);\n      }\n    } // Return the protobuf version of the peer-id\n\n  }, {\n    key: \"marshal\",\n    value: function marshal(excludePriv) {\n      return PeerIdProto.encode({\n        id: this.toBytes(),\n        pubKey: this.marshalPubKey(),\n        privKey: excludePriv ? null : this.marshalPrivKey()\n      });\n    }\n  }, {\n    key: \"toPrint\",\n    value: function toPrint() {\n      var pid = this.toB58String(); // All sha256 nodes start with Qm\n      // We can skip the Qm to make the peer.ID more useful\n\n      if (pid.startsWith('Qm')) {\n        pid = pid.slice(2);\n      }\n\n      var maxRunes = 6;\n\n      if (pid.length < maxRunes) {\n        maxRunes = pid.length;\n      }\n\n      return '<peer.ID ' + pid.substr(0, maxRunes) + '>';\n    } // return the jsonified version of the key, matching the formatting\n    // of go-ipfs for its config file\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        id: this.toB58String(),\n        privKey: toB64Opt(this.marshalPrivKey()),\n        pubKey: toB64Opt(this.marshalPubKey())\n      };\n    } // encode/decode functions\n\n  }, {\n    key: \"toHexString\",\n    value: function toHexString() {\n      return mh.toHexString(this.id);\n    }\n  }, {\n    key: \"toBytes\",\n    value: function toBytes() {\n      return this.id;\n    }\n  }, {\n    key: \"toB58String\",\n    value: function toB58String() {\n      return this._idB58String;\n    } // return self-describing String representation\n    // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      if (!this._idCIDString) {\n        var cid = new CID(1, 'libp2p-key', this.id, 'base32');\n        this._idCIDString = cid.toBaseEncodedString('base32');\n      }\n\n      return this._idCIDString;\n    }\n    /**\n     * Checks the equality of `this` peer against a given PeerId.\n     * @param {Buffer|PeerId} id\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"equals\",\n    value: function equals(id) {\n      if (Buffer.isBuffer(id)) {\n        return this.id.equals(id);\n      } else if (id.id) {\n        return this.id.equals(id.id);\n      } else {\n        throw new Error('not valid Id');\n      }\n    }\n    /**\n     * Checks the equality of `this` peer against a given PeerId.\n     * @deprecated Use `.equals`\n     * @param {Buffer|PeerId} id\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(id) {\n      return this.equals(id);\n    }\n    /*\n     * Check if this PeerId instance is valid (privKey -> pubKey -> Id)\n     */\n\n  }, {\n    key: \"isValid\",\n    value: function isValid() {\n      // TODO: needs better checking\n      return Boolean(this.privKey && this.privKey.public && this.privKey.public.bytes && Buffer.isBuffer(this.pubKey.bytes) && this.privKey.public.bytes.equals(this.pubKey.bytes));\n    }\n  }]);\n\n  return PeerId;\n}();\n\nvar PeerIdWithIs = withIs(PeerId, {\n  className: 'PeerId',\n  symbolName: '@libp2p/js-peer-id/PeerId'\n});\nexports = module.exports = PeerIdWithIs;\n\nvar computeDigest = function computeDigest(pubKey) {\n  if (pubKey.bytes.length <= 42) {\n    return mh.encode(pubKey.bytes, 'identity');\n  } else {\n    return pubKey.hash();\n  }\n};\n\nvar computePeerId = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(privKey, pubKey) {\n    var digest;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return computeDigest(pubKey);\n\n          case 2:\n            digest = _context.sent;\n            return _context.abrupt(\"return\", new PeerIdWithIs(digest, privKey, pubKey));\n\n          case 4:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function computePeerId(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}(); // generation\n\n\nexports.create = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(opts) {\n    var key;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            opts = opts || {};\n            opts.bits = opts.bits || 2048;\n            opts.keyType = opts.keyType || 'RSA';\n            _context2.next = 5;\n            return cryptoKeys.generateKeyPair(opts.keyType, opts.bits);\n\n          case 5:\n            key = _context2.sent;\n            return _context2.abrupt(\"return\", computePeerId(key, key.public));\n\n          case 7:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function (_x3) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nexports.createFromHexString = function (str) {\n  return new PeerIdWithIs(mh.fromHexString(str));\n};\n\nexports.createFromBytes = function (buf) {\n  return new PeerIdWithIs(buf);\n};\n\nexports.createFromB58String = function (str) {\n  return exports.createFromCID(str); // B58String is CIDv0\n};\n\nvar validMulticodec = function validMulticodec(cid) {\n  // supported: 'libp2p-key' (CIDv1) and 'dag-pb' (CIDv0 converted to CIDv1)\n  return cid.codec === 'libp2p-key' || cid.codec === 'dag-pb';\n};\n\nexports.createFromCID = function (cid) {\n  cid = CID.isCID(cid) ? cid : new CID(cid);\n  if (!validMulticodec(cid)) throw new Error('Supplied PeerID CID has invalid multicodec: ' + cid.codec);\n  return new PeerIdWithIs(cid.multihash);\n}; // Public Key input will be a buffer\n\n\nexports.createFromPubKey = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(key) {\n    var buf, pubKey;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            buf = key;\n\n            if (typeof buf === 'string') {\n              buf = Buffer.from(key, 'base64');\n            }\n\n            if (Buffer.isBuffer(buf)) {\n              _context3.next = 4;\n              break;\n            }\n\n            throw new Error('Supplied key is neither a base64 string nor a buffer');\n\n          case 4:\n            _context3.next = 6;\n            return cryptoKeys.unmarshalPublicKey(buf);\n\n          case 6:\n            pubKey = _context3.sent;\n            return _context3.abrupt(\"return\", computePeerId(null, pubKey));\n\n          case 8:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function (_x4) {\n    return _ref3.apply(this, arguments);\n  };\n}(); // Private key input will be a string\n\n\nexports.createFromPrivKey = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(key) {\n    var buf, privKey;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            buf = key;\n\n            if (typeof buf === 'string') {\n              buf = Buffer.from(key, 'base64');\n            }\n\n            if (Buffer.isBuffer(buf)) {\n              _context4.next = 4;\n              break;\n            }\n\n            throw new Error('Supplied key is neither a base64 string nor a buffer');\n\n          case 4:\n            _context4.next = 6;\n            return cryptoKeys.unmarshalPrivateKey(buf);\n\n          case 6:\n            privKey = _context4.sent;\n            return _context4.abrupt(\"return\", computePeerId(privKey, privKey.public));\n\n          case 8:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n\n  return function (_x5) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\nexports.createFromJSON = /*#__PURE__*/function () {\n  var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(obj) {\n    var id, rawPrivKey, rawPubKey, pub, privKey, privDigest, pubDigest;\n    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            id = mh.fromB58String(obj.id);\n            rawPrivKey = obj.privKey && Buffer.from(obj.privKey, 'base64');\n            rawPubKey = obj.pubKey && Buffer.from(obj.pubKey, 'base64');\n            _context5.t0 = rawPubKey;\n\n            if (!_context5.t0) {\n              _context5.next = 8;\n              break;\n            }\n\n            _context5.next = 7;\n            return cryptoKeys.unmarshalPublicKey(rawPubKey);\n\n          case 7:\n            _context5.t0 = _context5.sent;\n\n          case 8:\n            pub = _context5.t0;\n\n            if (rawPrivKey) {\n              _context5.next = 11;\n              break;\n            }\n\n            return _context5.abrupt(\"return\", new PeerIdWithIs(id, null, pub));\n\n          case 11:\n            _context5.next = 13;\n            return cryptoKeys.unmarshalPrivateKey(rawPrivKey);\n\n          case 13:\n            privKey = _context5.sent;\n            _context5.next = 16;\n            return computeDigest(privKey.public);\n\n          case 16:\n            privDigest = _context5.sent;\n\n            if (!pub) {\n              _context5.next = 21;\n              break;\n            }\n\n            _context5.next = 20;\n            return computeDigest(pub);\n\n          case 20:\n            pubDigest = _context5.sent;\n\n          case 21:\n            if (!(pub && !privDigest.equals(pubDigest))) {\n              _context5.next = 23;\n              break;\n            }\n\n            throw new Error('Public and private key do not match');\n\n          case 23:\n            if (!(id && !privDigest.equals(id))) {\n              _context5.next = 25;\n              break;\n            }\n\n            throw new Error('Id and private key do not match');\n\n          case 25:\n            return _context5.abrupt(\"return\", new PeerIdWithIs(id, privKey, pub));\n\n          case 26:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n\n  return function (_x6) {\n    return _ref5.apply(this, arguments);\n  };\n}();\n\nexports.createFromProtobuf = /*#__PURE__*/function () {\n  var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(buf) {\n    var _PeerIdProto$decode, id, privKey, pubKey, pubDigest, privDigest;\n\n    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            if (typeof buf === 'string') {\n              buf = Buffer.from(buf, 'hex');\n            }\n\n            _PeerIdProto$decode = PeerIdProto.decode(buf), id = _PeerIdProto$decode.id, privKey = _PeerIdProto$decode.privKey, pubKey = _PeerIdProto$decode.pubKey;\n\n            if (!privKey) {\n              _context6.next = 8;\n              break;\n            }\n\n            _context6.next = 5;\n            return cryptoKeys.unmarshalPrivateKey(privKey);\n\n          case 5:\n            _context6.t0 = _context6.sent;\n            _context6.next = 9;\n            break;\n\n          case 8:\n            _context6.t0 = false;\n\n          case 9:\n            privKey = _context6.t0;\n\n            if (!pubKey) {\n              _context6.next = 16;\n              break;\n            }\n\n            _context6.next = 13;\n            return cryptoKeys.unmarshalPublicKey(pubKey);\n\n          case 13:\n            _context6.t1 = _context6.sent;\n            _context6.next = 17;\n            break;\n\n          case 16:\n            _context6.t1 = false;\n\n          case 17:\n            pubKey = _context6.t1;\n\n            if (!privKey) {\n              _context6.next = 22;\n              break;\n            }\n\n            _context6.next = 21;\n            return computeDigest(privKey.public);\n\n          case 21:\n            privDigest = _context6.sent;\n\n          case 22:\n            if (!pubKey) {\n              _context6.next = 26;\n              break;\n            }\n\n            _context6.next = 25;\n            return computeDigest(pubKey);\n\n          case 25:\n            pubDigest = _context6.sent;\n\n          case 26:\n            if (!privKey) {\n              _context6.next = 31;\n              break;\n            }\n\n            if (!pubKey) {\n              _context6.next = 30;\n              break;\n            }\n\n            if (privDigest.equals(pubDigest)) {\n              _context6.next = 30;\n              break;\n            }\n\n            throw new Error('Public and private key do not match');\n\n          case 30:\n            return _context6.abrupt(\"return\", new PeerIdWithIs(privDigest, privKey, privKey.public));\n\n          case 31:\n            if (!pubKey) {\n              _context6.next = 33;\n              break;\n            }\n\n            return _context6.abrupt(\"return\", new PeerIdWithIs(pubDigest, null, pubKey));\n\n          case 33:\n            if (!id) {\n              _context6.next = 35;\n              break;\n            }\n\n            return _context6.abrupt(\"return\", new PeerIdWithIs(id));\n\n          case 35:\n            throw new Error('Protobuf did not contain any usable key material');\n\n          case 36:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n\n  return function (_x7) {\n    return _ref6.apply(this, arguments);\n  };\n}();\n\nexports.isPeerId = function (peerId) {\n  return Boolean(typeof peerId === 'object' && peerId._id && peerId._idB58String);\n};\n\nfunction toB64Opt(val) {\n  if (val) {\n    return val.toString('base64');\n  }\n}","map":null,"metadata":{},"sourceType":"script"}