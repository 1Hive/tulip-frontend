{"ast":null,"code":"const getIterator = require('get-iterator');\n\nmodule.exports = writable => async source => {\n  source = getIterator(source);\n\n  const maybeEndSource = source => {\n    if (typeof source.return === 'function') source.return();\n  };\n\n  let error = null;\n  let errCb = null;\n\n  const errorHandler = err => {\n    error = err;\n    if (errCb) errCb(err); // When the writable errors, try to end the source to exit iteration early\n\n    maybeEndSource(source);\n  };\n\n  let closeCb = null;\n  let closed = false;\n\n  const closeHandler = () => {\n    closed = true;\n    if (closeCb) closeCb();\n  };\n\n  let finishCb = null;\n  let finished = false;\n\n  const finishHandler = () => {\n    finished = true;\n    if (finishCb) finishCb();\n  };\n\n  let drainCb = null;\n\n  const drainHandler = () => {\n    if (drainCb) drainCb();\n  };\n\n  const waitForDrainOrClose = () => {\n    return new Promise((resolve, reject) => {\n      closeCb = drainCb = resolve;\n      errCb = reject;\n      writable.once('drain', drainHandler);\n    });\n  };\n\n  const waitForDone = () => {\n    // Immediately try to end the source\n    maybeEndSource(source);\n    return new Promise((resolve, reject) => {\n      if (closed || finished || error) return resolve();\n      finishCb = closeCb = resolve;\n      errCb = reject;\n    });\n  };\n\n  const cleanup = () => {\n    writable.removeListener('error', errorHandler);\n    writable.removeListener('close', closeHandler);\n    writable.removeListener('finish', finishHandler);\n    writable.removeListener('drain', drainHandler);\n  };\n\n  writable.once('error', errorHandler);\n  writable.once('close', closeHandler);\n  writable.once('finish', finishHandler);\n\n  try {\n    for await (const value of source) {\n      if (!writable.writable || writable.destroyed || error) break;\n\n      if (writable.write(value) === false) {\n        await waitForDrainOrClose();\n      }\n    }\n  } catch (err) {\n    // error is set by stream error handler so only destroy stream if source threw\n    if (!error) {\n      writable.destroy();\n    } // could we be obscuring an error here?\n\n\n    error = err;\n  }\n\n  try {\n    // We're done writing, end everything (n.b. stream may be destroyed at this point but then this is a no-op)\n    if (writable.writable) {\n      writable.end();\n    } // Wait until we close or finish. This supports halfClosed streams\n\n\n    await waitForDone(); // Notify the user an error occurred\n\n    if (error) throw error;\n  } finally {\n    // Clean up listeners\n    cleanup();\n  }\n};","map":null,"metadata":{},"sourceType":"script"}