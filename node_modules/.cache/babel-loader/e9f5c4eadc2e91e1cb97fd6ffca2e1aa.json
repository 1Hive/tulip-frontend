{"ast":null,"code":"import _typeof from\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/typeof\";import{useMemo}from'react';import{Contract as EthersContract,providers as Providers}from'ethers';import{useWallet}from'./providers/Wallet';// import { defaultEthNode } from './endpoints'\nimport{InvalidNetworkType}from'./errors';// const DEFAULT_PROVIDER = new Providers.JsonRpcProvider(defaultEthNode)\nvar DEFAULT_PROVIDER;if(!window.web3||window.web3.currentProvider.networkVersion!=='4'){var error=new InvalidNetworkType();console.log(error);}else{DEFAULT_PROVIDER=new Providers.Web3Provider(window.web3.currentProvider);}export function useContract(address,abi){var signer=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;var _useWallet=useWallet(),account=_useWallet.account,ethers=_useWallet.ethers;return useMemo(function(){// Apparently .getSigner() returns a new object every time, so we use the\n// connected account as memo dependency.\nif(!address||!ethers||!account){return null;}return getContract(address,abi,signer?ethers.getSigner():ethers);},[abi,account,address,ethers,signer]);}export function useContractReadOnly(address,abi){return useMemo(function(){if(!address){return null;}return getContract(address,abi);},[abi,address]);}export function getContract(address,abi){var provider=arguments.length>2&&arguments[2]!==undefined?arguments[2]:DEFAULT_PROVIDER;console.log(abi,_typeof(abi));return new EthersContract(address,abi,provider);}","map":{"version":3,"sources":["/Users/fabianmolina/Documents/1hive/tulip-frontend/src/web3-contracts.js"],"names":["useMemo","Contract","EthersContract","providers","Providers","useWallet","InvalidNetworkType","DEFAULT_PROVIDER","window","web3","currentProvider","networkVersion","error","console","log","Web3Provider","useContract","address","abi","signer","account","ethers","getContract","getSigner","useContractReadOnly","provider"],"mappings":"2JAAA,OAASA,OAAT,KAAwB,OAAxB,CACA,OAASC,QAAQ,GAAIC,CAAAA,cAArB,CAAqCC,SAAS,GAAIC,CAAAA,SAAlD,KAAmE,QAAnE,CACA,OAASC,SAAT,KAA0B,oBAA1B,CACA;AACA,OAASC,kBAAT,KAAmC,UAAnC,CACA;AACA,GAAIC,CAAAA,gBAAJ,CACA,GAAI,CAACC,MAAM,CAACC,IAAR,EAAgBD,MAAM,CAACC,IAAP,CAAYC,eAAZ,CAA4BC,cAA5B,GAA+C,GAAnE,CAAwE,CACtE,GAAMC,CAAAA,KAAK,CAAG,GAAIN,CAAAA,kBAAJ,EAAd,CACAO,OAAO,CAACC,GAAR,CAAYF,KAAZ,EACD,CAHD,IAGO,CACLL,gBAAgB,CAAG,GAAIH,CAAAA,SAAS,CAACW,YAAd,CAA2BP,MAAM,CAACC,IAAP,CAAYC,eAAvC,CAAnB,CACD,CAED,MAAO,SAASM,CAAAA,WAAT,CAAqBC,OAArB,CAA8BC,GAA9B,CAAkD,IAAfC,CAAAA,MAAe,2DAAN,IAAM,gBAC3Bd,SAAS,EADkB,CAC/Ce,OAD+C,YAC/CA,OAD+C,CACtCC,MADsC,YACtCA,MADsC,CAGvD,MAAOrB,CAAAA,OAAO,CAAC,UAAM,CACnB;AACA;AAEA,GAAI,CAACiB,OAAD,EAAY,CAACI,MAAb,EAAuB,CAACD,OAA5B,CAAqC,CACnC,MAAO,KAAP,CACD,CAED,MAAOE,CAAAA,WAAW,CAACL,OAAD,CAAUC,GAAV,CAAeC,MAAM,CAAGE,MAAM,CAACE,SAAP,EAAH,CAAwBF,MAA7C,CAAlB,CACD,CATa,CASX,CAACH,GAAD,CAAME,OAAN,CAAeH,OAAf,CAAwBI,MAAxB,CAAgCF,MAAhC,CATW,CAAd,CAUD,CAED,MAAO,SAASK,CAAAA,mBAAT,CAA6BP,OAA7B,CAAsCC,GAAtC,CAA2C,CAChD,MAAOlB,CAAAA,OAAO,CAAC,UAAM,CACnB,GAAI,CAACiB,OAAL,CAAc,CACZ,MAAO,KAAP,CACD,CACD,MAAOK,CAAAA,WAAW,CAACL,OAAD,CAAUC,GAAV,CAAlB,CACD,CALa,CAKX,CAACA,GAAD,CAAMD,OAAN,CALW,CAAd,CAMD,CAED,MAAO,SAASK,CAAAA,WAAT,CAAqBL,OAArB,CAA8BC,GAA9B,CAAgE,IAA7BO,CAAAA,QAA6B,2DAAlBlB,gBAAkB,CACrEM,OAAO,CAACC,GAAR,CAAYI,GAAZ,SAAwBA,GAAxB,GACA,MAAO,IAAIhB,CAAAA,cAAJ,CAAmBe,OAAnB,CAA4BC,GAA5B,CAAiCO,QAAjC,CAAP,CACD","sourcesContent":["import { useMemo } from 'react'\nimport { Contract as EthersContract, providers as Providers } from 'ethers'\nimport { useWallet } from './providers/Wallet'\n// import { defaultEthNode } from './endpoints'\nimport { InvalidNetworkType } from './errors'\n// const DEFAULT_PROVIDER = new Providers.JsonRpcProvider(defaultEthNode)\nlet DEFAULT_PROVIDER\nif (!window.web3 || window.web3.currentProvider.networkVersion !== '4') {\n  const error = new InvalidNetworkType()\n  console.log(error)\n} else {\n  DEFAULT_PROVIDER = new Providers.Web3Provider(window.web3.currentProvider)\n}\n\nexport function useContract(address, abi, signer = true) {\n  const { account, ethers } = useWallet()\n\n  return useMemo(() => {\n    // Apparently .getSigner() returns a new object every time, so we use the\n    // connected account as memo dependency.\n\n    if (!address || !ethers || !account) {\n      return null\n    }\n\n    return getContract(address, abi, signer ? ethers.getSigner() : ethers)\n  }, [abi, account, address, ethers, signer])\n}\n\nexport function useContractReadOnly(address, abi) {\n  return useMemo(() => {\n    if (!address) {\n      return null\n    }\n    return getContract(address, abi)\n  }, [abi, address])\n}\n\nexport function getContract(address, abi, provider = DEFAULT_PROVIDER) {\n  console.log(abi, typeof abi)\n  return new EthersContract(address, abi, provider)\n}\n"]},"metadata":{},"sourceType":"module"}