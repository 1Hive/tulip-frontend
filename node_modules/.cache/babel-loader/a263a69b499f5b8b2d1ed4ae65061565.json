{"ast":null,"code":"'use strict';\n\nconst {\n  DAGNode,\n  DAGLink\n} = require('ipld-dag-pb');\n\nconst CID = require('cids');\n\nconst log = require('debug')('ipfs:mfs:core:utils:remove-link');\n\nconst UnixFS = require('ipfs-unixfs');\n\nconst {\n  generatePath,\n  updateHamtDirectory\n} = require('./hamt-utils');\n\nconst errCode = require('err-code');\n\nconst mc = require('multicodec');\n\nconst mh = require('multihashes');\n\nconst removeLink = async (context, options) => {\n  if (!options.parentCid && !options.parent) {\n    throw errCode(new Error('No parent node or CID passed to removeLink'), 'EINVALIDPARENT');\n  }\n\n  if (options.parentCid && !CID.isCID(options.parentCid)) {\n    throw errCode(new Error('Invalid CID passed to removeLink'), 'EINVALIDPARENTCID');\n  }\n\n  if (!options.parent) {\n    log(`Loading parent node ${options.parentCid}`);\n    options.parent = await context.ipld.get(options.parentCid);\n  }\n\n  if (!options.name) {\n    throw errCode(new Error('No child name passed to removeLink'), 'EINVALIDCHILDNAME');\n  }\n\n  const meta = UnixFS.unmarshal(options.parent.Data);\n\n  if (meta.type === 'hamt-sharded-directory') {\n    log(`Removing ${options.name} from sharded directory`);\n    return removeFromShardedDirectory(context, options);\n  }\n\n  log(`Removing link ${options.name} regular directory`);\n  return removeFromDirectory(context, options);\n};\n\nconst removeFromDirectory = async (context, options) => {\n  const hashAlg = mh.names[options.hashAlg];\n  options.parent.rmLink(options.name);\n  const cid = await context.ipld.put(options.parent, mc.DAG_PB, {\n    cidVersion: options.cidVersion,\n    hashAlg\n  });\n  log(`Updated regular directory ${cid}`);\n  return {\n    node: options.parent,\n    cid\n  };\n};\n\nconst removeFromShardedDirectory = async (context, options) => {\n  const {\n    rootBucket,\n    path\n  } = await generatePath(context, options.name, options.parent);\n  await rootBucket.del(options.name);\n  const {\n    node\n  } = await updateShard(context, path, {\n    name: options.name,\n    cid: options.cid,\n    size: options.size,\n    hashAlg: options.hashAlg,\n    cidVersion: options.cidVersion,\n    flush: options.flush\n  }, options);\n  return updateHamtDirectory(context, node.Links, rootBucket, options);\n};\n\nconst updateShard = async (context, positions, child, options) => {\n  const {\n    bucket,\n    prefix,\n    node\n  } = positions.pop();\n  const link = node.Links.find(link => link.Name.substring(0, 2) === prefix);\n\n  if (!link) {\n    throw errCode(new Error(`No link found with prefix ${prefix} for file ${child.name}`), 'ERR_NOT_FOUND');\n  }\n\n  if (link.Name === `${prefix}${child.name}`) {\n    log(`Removing existing link ${link.Name}`);\n    node.rmLink(link.Name);\n    await bucket.del(child.name);\n    return updateHamtDirectory(context, node.Links, bucket, options);\n  }\n\n  log(`Descending into sub-shard ${link.Name} for ${prefix}${child.name}`);\n  const result = await updateShard(context, positions, child, options);\n  let newName = prefix;\n\n  if (result.node.Links.length === 1) {\n    log(`Removing subshard for ${prefix}`); // convert shard back to normal dir\n\n    result.cid = result.node.Links[0].Hash;\n    result.node = result.node.Links[0];\n    newName = `${prefix}${result.node.Name.substring(2)}`;\n  }\n\n  log(`Updating shard ${prefix} with name ${newName}`);\n  const size = DAGNode.isDAGNode(result.node) ? result.node.size : result.node.Tsize;\n  return updateShardParent(context, bucket, node, prefix, newName, size, result.cid, options);\n};\n\nconst updateShardParent = (context, bucket, parent, oldName, newName, size, cid, options) => {\n  parent.rmLink(oldName);\n  parent.addLink(new DAGLink(newName, size, cid));\n  return updateHamtDirectory(context, parent.Links, bucket, options);\n};\n\nmodule.exports = removeLink;","map":null,"metadata":{},"sourceType":"script"}