{"ast":null,"code":"import { toMs } from './date-utils';\nimport { bigNum } from '../lib/math-utils';\nimport { getOutcomeNumber } from './crvoting-utils';\nimport * as DisputesTypes from '../types/dispute-status-types';\nimport { getTermEndTime, getTermStartTime } from './court-utils';\nimport { getVoidedDisputesByCourt } from '../flagged-disputes/voided-disputes';\nimport { getPrecedenceCampaignDisputesByCourt } from '../flagged-disputes/precedence-campaign-disputes';\nexport const FINAL_ROUND_WEIGHT_PRECISION = bigNum(1000);\nexport const PCT_BASE = bigNum(10000);\nexport function transformRoundDataAttributes(round) {\n  const {\n    vote,\n    appeal\n  } = round;\n  return { ...round,\n    createdAt: toMs(parseInt(round.createdAt, 10)),\n    draftTermId: parseInt(round.draftTermId, 10),\n    delayedTerms: parseInt(round.delayedTerms, 10),\n    number: parseInt(round.number),\n    jurors: round.jurors.map(juror => ({ ...juror,\n      commitmentDate: toMs(parseInt(juror.commitmentDate || 0, 10)),\n      revealDate: toMs(parseInt(juror.revealDate || 0, 10)),\n      weight: parseInt(juror.weight, 10)\n    })),\n    vote: vote ? { ...vote,\n      winningOutcome: getOutcomeNumber(vote.winningOutcome)\n    } : null,\n    appeal: appeal ? { ...appeal,\n      appealedRuling: parseInt(appeal.appealedRuling, 10),\n      opposedRuling: parseInt(appeal.opposedRuling, 10),\n      createdAt: toMs(parseInt(appeal.createdAt)),\n      confirmedAt: toMs(parseInt(appeal.confirmedAt || 0))\n    } : null,\n    state: DisputesTypes.convertFromString(round.state)\n  };\n}\n/**\r\n * Parses metadata of the given dispute\r\n\r\n * Disputes metadata comes in two forms:\r\n *        1 - Raw disputes: metadata is usually a JSON object containing `description` and `metadata` where the later is the metadata uri.\r\n *        2 - Disputables: there's no useful information in `metadata` itself, in this case we'll get the dispute information from the `disputable` attr.\r\n *  Note that this function is meant to parse only dispute description and metadata uri (in case it exists). More relevant information will be processed elsewhere.\r\n * @param {Object} dispute Dispute in question\r\n * @returns {Array<String>} Array where the first item is the dispute description and second item is the metadata uri if it exists\r\n */\n\nfunction parseMetadata(dispute) {\n  if (dispute.disputable) {\n    return [`${dispute.disputable.title} Action # ${dispute.disputable.actionId}`];\n  }\n\n  try {\n    const {\n      description,\n      metadata\n    } = JSON.parse(dispute.metadata);\n    return [description, metadata];\n  } catch (error) {\n    // if is not a json return the metadata as the description\n    return [dispute.metadata];\n  }\n}\n\nexport function transformDisputeDataAttributes(dispute) {\n  const [description, metadataUri] = parseMetadata(dispute);\n  const transformedDispute = { ...dispute,\n    createdAt: toMs(parseInt(dispute.createdAt, 10)),\n    description,\n    metadataUri,\n    rounds: dispute.rounds.map(transformRoundDataAttributes),\n    state: DisputesTypes.convertFromString(dispute.state),\n    status: DisputesTypes.convertFromString(dispute.state) === DisputesTypes.Phase.Ruled ? DisputesTypes.Status.Closed : DisputesTypes.Status.Open\n  }; // If the dispute is part of the precedence campaign we will flag it as such\n\n  const precedenceCamapignDisputes = getPrecedenceCampaignDisputesByCourt();\n  const isPartOfPrecedenceCampaign = precedenceCamapignDisputes.has(dispute.id);\n  transformedDispute.marksPrecedent = isPartOfPrecedenceCampaign; // If the dispute is voided we will override certain data\n\n  const voidedDisputes = getVoidedDisputesByCourt();\n  const voidedDispute = voidedDisputes.get(dispute.id);\n  return voidedDispute ? overrideVoidedDispute(transformedDispute, voidedDispute) : transformedDispute;\n}\n\nfunction overrideVoidedDispute(dispute, voidedDispute) {\n  return { ...dispute,\n    evidences: [],\n    metadata: '',\n    status: DisputesTypes.Status.Voided,\n    voidedDescription: voidedDispute.description,\n    voidedLink: voidedDispute.link,\n    voidedText: voidedDispute.text\n  };\n}\n/**\r\n * @param {Object} dispute The dispute to query the current phase and next transition of\r\n * @param {Number} currentTerm The court current term\r\n * @param {Object} courtConfig The court configuration\r\n * @returns {Object} Current phase and next phase transition for the given dispute\r\n */\n\n\nexport function getPhaseAndTransition(dispute, currentTerm, courtConfig) {\n  if (!dispute) return null;\n  let phase;\n  let nextTransition;\n  const {\n    state\n  } = dispute;\n  const lastRound = dispute.rounds[dispute.lastRoundId];\n  const {\n    number\n  } = lastRound; // Dispute already ruled\n\n  if (state === DisputesTypes.Phase.Ruled) {\n    phase = DisputesTypes.Phase.ClaimRewards;\n    return {\n      phase,\n      roundId: number,\n      maxAppealReached: hasDisputeReachedMaxAppeals(dispute, courtConfig)\n    };\n  } // Evidence submission\n\n\n  if (state === DisputesTypes.Phase.Evidence) {\n    const evidenceSubmissionEndTerm = getEvidenceSubmissionEndTerm(dispute, courtConfig);\n    const evidenceSubmissionEndTime = getTermEndTime(evidenceSubmissionEndTerm, courtConfig);\n\n    if (currentTerm > evidenceSubmissionEndTerm) {\n      phase = DisputesTypes.Phase.JuryDrafting;\n    } else {\n      phase = state;\n      nextTransition = evidenceSubmissionEndTime;\n    }\n\n    return {\n      phase,\n      nextTransition,\n      roundId: number\n    };\n  } // Jury Drafting phase\n\n\n  if (state === DisputesTypes.Phase.JuryDrafting) {\n    // When a new round is created, it could happen that the draft term has not been reached yet\n    // because the confirm appeal phase of the previous round has not yet ended\n    if (currentTerm < lastRound.draftTermId) {\n      const draftStartTime = getTermStartTime(lastRound.draftTermId, courtConfig);\n      phase = DisputesTypes.Phase.NotStarted;\n      nextTransition = draftStartTime;\n    } else {\n      phase = DisputesTypes.Phase.JuryDrafting;\n    }\n\n    return {\n      phase,\n      nextTransition,\n      roundId: number\n    };\n  } // Adjudicating\n\n\n  if (state === DisputesTypes.Phase.Adjudicating) {\n    let currentAdjudicationPhase = getAdjudicationPhase(dispute, lastRound, currentTerm, courtConfig);\n    const {\n      phase,\n      phaseEndTerm\n    } = currentAdjudicationPhase;\n\n    if (phase === DisputesTypes.Phase.Ended) {\n      currentAdjudicationPhase = { ...currentAdjudicationPhase,\n        phase: DisputesTypes.Phase.ExecuteRuling\n      };\n    }\n\n    const nextTransition = phaseEndTerm ? getTermEndTime(phaseEndTerm, courtConfig) : null;\n    return { ...currentAdjudicationPhase,\n      roundId: number,\n      nextTransition\n    };\n  }\n}\n/**\r\n * Tells the adjudication state of a dispute's round at a certain time.\r\n * @param {Object} dispute Dispute to query the adjudication round of\r\n * @param {Object} round The round that is being queried\r\n * @param {Number} termId The term at which to query the dispute's adjudication phase\r\n * @param {Object} courtConfig The court configuration\r\n * @returns {Object} The adjudication phase of the requested round at the given time\r\n */\n\nexport function getAdjudicationPhase(dispute, round, termId, courtConfig) {\n  const {\n    commitTerms,\n    revealTerms,\n    appealTerms,\n    appealConfirmationTerms\n  } = courtConfig;\n  const {\n    draftTermId,\n    delayedTerms,\n    number: roundId\n  } = round;\n  const draftEndTerm = draftTermId + delayedTerms;\n  const maxAppealReached = hasDisputeReachedMaxAppeals(dispute, courtConfig); // When voting period has not yet started there are two possible cases:\n  //   * We are at the last possible round so adjudication phase hasn't started\n  //   * We are not in an adjudication phase so it is invalid\n\n  if (termId < draftEndTerm) {\n    if (maxAppealReached) {\n      return {\n        phase: DisputesTypes.Phase.NotStarted,\n        phaseEndTerm: draftEndTerm,\n        roundId\n      };\n    }\n\n    return {\n      phase: DisputesTypes.Phase.Invalid,\n      roundId\n    };\n  } // Jurors can commit their votes between when the commit phase term starts and ends\n  // Note that the commit start term is the same as the draft end term\n\n\n  const commitEndTerm = draftEndTerm + commitTerms - 1;\n\n  if (termId <= commitEndTerm) {\n    return {\n      phase: DisputesTypes.Phase.VotingPeriod,\n      phaseEndTerm: commitEndTerm,\n      maxAppealReached,\n      roundId\n    };\n  } // Jurors can reveal their votes between when the reveal phase term starts and ends\n\n\n  const revealEndTerm = commitEndTerm + revealTerms;\n\n  if (termId <= revealEndTerm) {\n    return {\n      phase: DisputesTypes.Phase.RevealVote,\n      phaseEndTerm: revealEndTerm,\n      maxAppealReached,\n      roundId\n    };\n  } // If the max number of appeals has been reached, then the last round is the final round and can be considered ended\n\n\n  if (maxAppealReached) {\n    return {\n      phase: DisputesTypes.Phase.Ended,\n      maxAppealReached,\n      roundId\n    };\n  } // If the last round was not appealed yet, check if the confirmation period has started or not\n\n\n  const isLastRoundAppealed = !!round.appeal && round.appeal.appealedRuling !== 0;\n  const appealEndTerm = revealEndTerm + appealTerms;\n\n  if (!isLastRoundAppealed) {\n    // If given term is before the appeal confirmation start term, then the last round can still be appealed. Otherwise, it is ended.\n    if (termId <= appealEndTerm) {\n      return {\n        phase: DisputesTypes.Phase.AppealRuling,\n        phaseEndTerm: appealEndTerm,\n        roundId\n      };\n    } else {\n      return {\n        phase: DisputesTypes.Phase.Ended,\n        roundId\n      };\n    }\n  } // If the last round was appealed and the given term is before the appeal confirmation end term, then the last round appeal can still be\n  // confirmed. Note that if the round being checked was already appealed and confirmed, it won't be the last round, thus it will be caught\n  // above by the first check and considered 'Ended'.\n\n\n  const appealConfirmationEndTerm = appealEndTerm + appealConfirmationTerms;\n\n  if (termId < appealConfirmationEndTerm) {\n    return {\n      phase: DisputesTypes.Phase.ConfirmAppeal,\n      phaseEndTerm: appealConfirmationEndTerm,\n      roundId\n    };\n  } // If non of the above conditions have been met, the last round is considered ended\n\n\n  return {\n    phase: DisputesTypes.Phase.Ended,\n    roundId\n  };\n}\n/**\r\n * Terminology here will be:\r\n *        Last round => last round actually reached in a dispute\r\n *        Final round => max possible round for a dispute (when the max appeals for a given dispute is reached)\r\n * @param {Object} round The round to get the phases from\r\n * @param {Object} currentPhase The dispute's current phase\r\n * @param {Number} currentTerm The court current term\r\n * @param {Object} courtConfig The court configuration\r\n * @returns {Array} Array of all `round` phases.\r\n */\n\nexport function getRoundPhasesAndTime(round, currentPhase, currentTerm, courtConfig) {\n  const {\n    commitTerms,\n    revealTerms,\n    appealTerms,\n    appealConfirmationTerms\n  } = courtConfig;\n  const {\n    draftTermId,\n    delayedTerms,\n    number: roundId,\n    vote,\n    appeal\n  } = round;\n  const isCurrentRound = roundId === currentPhase.roundId;\n  const {\n    winningOutcome\n  } = vote || {};\n  const draftStartTime = getTermStartTime(draftTermId, courtConfig); // Case where we are in a next round and has not yet started\n\n  if (isCurrentRound && currentPhase.phase === DisputesTypes.Phase.NotStarted) {\n    return [{\n      phase: DisputesTypes.Phase.NotStarted,\n      endTime: draftStartTime,\n      roundId,\n      active: true\n    }];\n  }\n\n  const draftEndTerm = draftTermId + delayedTerms; // Note that the commit start term is the same as the draft end term\n\n  const votingEndTerm = draftEndTerm + commitTerms - 1;\n  const revealEndTerm = votingEndTerm + revealTerms;\n  const appealEndTerm = revealEndTerm + appealTerms;\n  const confirmAppealEndTerm = appealEndTerm + appealConfirmationTerms;\n  const roundAppealed = !!appeal;\n  const roundAppealConfirmed = roundAppealed && appeal.opposedRuling > 0;\n  const roundPhasesAndTime = [{\n    // Jurors can be drafted at any time, so we'll only set the\n    // `endTime` when the drafting phase has already passed\n    phase: DisputesTypes.Phase.JuryDrafting,\n    endTime: DisputesTypes.Phase.JuryDrafting !== currentPhase.phase ? getTermEndTime(draftEndTerm, courtConfig) : null,\n    active: isCurrentRound && DisputesTypes.Phase.JuryDrafting === currentPhase.phase,\n    roundId\n  }, {\n    phase: DisputesTypes.Phase.VotingPeriod,\n    endTime: getTermEndTime(votingEndTerm, courtConfig),\n    active: isCurrentRound && DisputesTypes.Phase.VotingPeriod === currentPhase.phase,\n    roundId\n  }, {\n    phase: DisputesTypes.Phase.RevealVote,\n    endTime: getTermEndTime(revealEndTerm, courtConfig),\n    active: isCurrentRound && DisputesTypes.Phase.RevealVote === currentPhase.phase,\n    roundId,\n    outcome: winningOutcome,\n    showOutcome: currentTerm > revealEndTerm\n  }, {\n    // If the round was appealed we know it's a past phase and must update the endTime for the time this took effect (appeal.createdAt)\n    // If it wasn't appealed we have two cases:\n    //       - It's a past phase so in that case the endTime will be the time at where it's supposed to end if taking the full appealTerms duration\n    //       - It's the dispute active phase (the round can still be appealed) so the endTime will be used to tell the timer remaining time before the appeal phase is closed\n    phase: DisputesTypes.Phase.AppealRuling,\n    endTime: roundAppealed ? appeal.createdAt : getTermEndTime(appealEndTerm, courtConfig),\n    active: isCurrentRound && DisputesTypes.Phase.AppealRuling === currentPhase.phase,\n    roundId,\n    outcome: roundAppealed ? appeal.appealedRuling : null,\n    showOutcome: roundAppealed || currentTerm > appealEndTerm // If the round was appealed, we'll show the outcome (appeal ruling),\n    // If it wasn't appealed then we'll show a \"Nobodoy appealed\" message\n\n  }, {\n    // If the round was appeal confirmed we know it's a past phase and must update the endTime for the time this took effect (appeal.confirmedAt)\n    // If it wasn't appeal confirmed we have two cases:\n    //       - It's a past phase so in that case the endTime will be the time at where it's supposed to end if taking the full confirmAppealTerms duration\n    //       - It's the dispute active phase (the round can still be appeal confirmed) so the endTime will be used to tell the timer remaining time before the confirm appeal phase is closed\n    phase: DisputesTypes.Phase.ConfirmAppeal,\n    endTime: roundAppealConfirmed ? appeal.confirmedAt : getTermEndTime(confirmAppealEndTerm, courtConfig),\n    active: isCurrentRound && DisputesTypes.Phase.ConfirmAppeal === currentPhase.phase,\n    roundId,\n    outcome: roundAppealConfirmed ? appeal.opposedRuling : null,\n    showOutcome: roundAppealConfirmed || currentTerm > confirmAppealEndTerm\n  }]; // If it's not the last round means that the dispute reached the next appeal round\n  // so we show all possible phases\n\n  if (roundId < currentPhase.roundId) {\n    return roundPhasesAndTime;\n  } // If it's the last round and has already ended (show past phases)\n\n\n  if (currentPhase.phase === DisputesTypes.Phase.ExecuteRuling || currentPhase.phase === DisputesTypes.Phase.ClaimRewards) {\n    // In the final round (maxAppealedReached), there's no drafting phase and appealing is not possible\n    // so we only must show Voting and Revealing\n    if (currentPhase.maxAppealReached) {\n      return roundPhasesAndTime.slice(1, 3);\n    } // If round not appealed\n\n\n    if (!roundAppealed) {\n      return roundPhasesAndTime.slice(0, 4);\n    }\n\n    return roundPhasesAndTime;\n  } // Find the last round current phase\n\n\n  const currentPhaseIndex = roundPhasesAndTime.findIndex(phase => phase.phase === currentPhase.phase); // When round has not yet ended\n\n  return roundPhasesAndTime.slice(currentPhase.maxAppealReached ? 1 : 0, currentPhaseIndex + 1);\n}\n/**\r\n *\r\n * @param {Object} dispute The dispute in question\r\n * @param {Object} courtConfig The court configuration\r\n * @returns {Number} The end time of the evidence submission phase in ms\r\n */\n\nexport function getEvidenceSubmissionEndTerm(dispute, courtConfig) {\n  const firstRound = dispute.rounds[0]; // If the evidence period is closed before the full `evidenceTerms` period,\n  // the draftTermId for the first round is updated to the term this happened.\n\n  return firstRound.draftTermId - 1;\n}\n/**\r\n * Tells whether the dispute has reached the maximum number of rounds possible\r\n * @param {Object} dispute The dispute in question\r\n * @param {Object} courtConfig The court configuration\r\n * @returns {Boolean} True if dispute has reached maximum number of rounds possible\r\n */\n\nfunction hasDisputeReachedMaxAppeals(dispute, courtConfig) {\n  const {\n    maxRegularAppealRounds\n  } = courtConfig;\n  const numberOfRounds = dispute.rounds.length;\n  return numberOfRounds > maxRegularAppealRounds;\n}\n/**\r\n * @param {Object} dispute The dispute to get the last round from\r\n * @returns {Object} dispute's last round\r\n */\n\n\nexport function getDisputeLastRound(dispute) {\n  return dispute.rounds[dispute.lastRoundId];\n}\n/**\r\n *\r\n * @param {Object} round Round to calculate fees from\r\n * @param {Object} courtConfig The court configuration\r\n * @returns {BigNum} The total fees for the round\r\n */\n\nexport function getRoundFees(round, courtConfig) {\n  const {\n    draftFee,\n    settleFee,\n    jurorFee,\n    finalRoundReduction,\n    maxRegularAppealRounds\n  } = courtConfig; // Final round\n\n  if (round.number === maxRegularAppealRounds) {\n    return jurorFee.mul(round.jurorsNumber).div(FINAL_ROUND_WEIGHT_PRECISION.mul(finalRoundReduction)).div(PCT_BASE);\n  } // Regular round\n\n\n  return draftFee.add(settleFee).add(jurorFee).mul(round.jurorsNumber);\n}\n/**\r\n *\r\n * @param {BigNum} minActiveBalance The minimum active balance required to become an active juror\r\n * @param {BigNum} penaltyPct Percentage (against PCT_BASE) of min active tokens balance to be locked to each drafted juror\r\n * @param {BigNum} weight Weight computed for a juror on a round\r\n * @returns {BigNum} The amount that will be locked each time a juror is drafted\r\n */\n\nexport function getDraftLockAmount(minActiveBalance, penaltyPct, weight) {\n  return minActiveBalance.mul(penaltyPct).div(PCT_BASE).mul(weight);\n}","map":{"version":3,"sources":["/Users/fabianmolina/Documents/1hive/tulip-frontend/src/utils/dispute-utils.js"],"names":["toMs","bigNum","getOutcomeNumber","DisputesTypes","getTermEndTime","getTermStartTime","getVoidedDisputesByCourt","getPrecedenceCampaignDisputesByCourt","FINAL_ROUND_WEIGHT_PRECISION","PCT_BASE","transformRoundDataAttributes","round","vote","appeal","createdAt","parseInt","draftTermId","delayedTerms","number","jurors","map","juror","commitmentDate","revealDate","weight","winningOutcome","appealedRuling","opposedRuling","confirmedAt","state","convertFromString","parseMetadata","dispute","disputable","title","actionId","description","metadata","JSON","parse","error","transformDisputeDataAttributes","metadataUri","transformedDispute","rounds","status","Phase","Ruled","Status","Closed","Open","precedenceCamapignDisputes","isPartOfPrecedenceCampaign","has","id","marksPrecedent","voidedDisputes","voidedDispute","get","overrideVoidedDispute","evidences","Voided","voidedDescription","voidedLink","link","voidedText","text","getPhaseAndTransition","currentTerm","courtConfig","phase","nextTransition","lastRound","lastRoundId","ClaimRewards","roundId","maxAppealReached","hasDisputeReachedMaxAppeals","Evidence","evidenceSubmissionEndTerm","getEvidenceSubmissionEndTerm","evidenceSubmissionEndTime","JuryDrafting","draftStartTime","NotStarted","Adjudicating","currentAdjudicationPhase","getAdjudicationPhase","phaseEndTerm","Ended","ExecuteRuling","termId","commitTerms","revealTerms","appealTerms","appealConfirmationTerms","draftEndTerm","Invalid","commitEndTerm","VotingPeriod","revealEndTerm","RevealVote","isLastRoundAppealed","appealEndTerm","AppealRuling","appealConfirmationEndTerm","ConfirmAppeal","getRoundPhasesAndTime","currentPhase","isCurrentRound","endTime","active","votingEndTerm","confirmAppealEndTerm","roundAppealed","roundAppealConfirmed","roundPhasesAndTime","outcome","showOutcome","slice","currentPhaseIndex","findIndex","firstRound","maxRegularAppealRounds","numberOfRounds","length","getDisputeLastRound","getRoundFees","draftFee","settleFee","jurorFee","finalRoundReduction","mul","jurorsNumber","div","add","getDraftLockAmount","minActiveBalance","penaltyPct"],"mappings":"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","sourcesContent":["import { toMs } from './date-utils'\r\nimport { bigNum } from '../lib/math-utils'\r\nimport { getOutcomeNumber } from './crvoting-utils'\r\nimport * as DisputesTypes from '../types/dispute-status-types'\r\nimport { getTermEndTime, getTermStartTime } from './court-utils'\r\nimport { getVoidedDisputesByCourt } from '../flagged-disputes/voided-disputes'\r\nimport { getPrecedenceCampaignDisputesByCourt } from '../flagged-disputes/precedence-campaign-disputes'\r\n\r\nexport const FINAL_ROUND_WEIGHT_PRECISION = bigNum(1000)\r\nexport const PCT_BASE = bigNum(10000)\r\n\r\nexport function transformRoundDataAttributes(round) {\r\n  const { vote, appeal } = round\r\n\r\n  return {\r\n    ...round,\r\n    createdAt: toMs(parseInt(round.createdAt, 10)),\r\n    draftTermId: parseInt(round.draftTermId, 10),\r\n    delayedTerms: parseInt(round.delayedTerms, 10),\r\n    number: parseInt(round.number),\r\n    jurors: round.jurors.map(juror => ({\r\n      ...juror,\r\n      commitmentDate: toMs(parseInt(juror.commitmentDate || 0, 10)),\r\n      revealDate: toMs(parseInt(juror.revealDate || 0, 10)),\r\n      weight: parseInt(juror.weight, 10),\r\n    })),\r\n    vote: vote\r\n      ? {\r\n          ...vote,\r\n          winningOutcome: getOutcomeNumber(vote.winningOutcome),\r\n        }\r\n      : null,\r\n    appeal: appeal\r\n      ? {\r\n          ...appeal,\r\n          appealedRuling: parseInt(appeal.appealedRuling, 10),\r\n          opposedRuling: parseInt(appeal.opposedRuling, 10),\r\n          createdAt: toMs(parseInt(appeal.createdAt)),\r\n          confirmedAt: toMs(parseInt(appeal.confirmedAt || 0)),\r\n        }\r\n      : null,\r\n    state: DisputesTypes.convertFromString(round.state),\r\n  }\r\n}\r\n\r\n/**\r\n * Parses metadata of the given dispute\r\n\r\n * Disputes metadata comes in two forms:\r\n *        1 - Raw disputes: metadata is usually a JSON object containing `description` and `metadata` where the later is the metadata uri.\r\n *        2 - Disputables: there's no useful information in `metadata` itself, in this case we'll get the dispute information from the `disputable` attr.\r\n *  Note that this function is meant to parse only dispute description and metadata uri (in case it exists). More relevant information will be processed elsewhere.\r\n * @param {Object} dispute Dispute in question\r\n * @returns {Array<String>} Array where the first item is the dispute description and second item is the metadata uri if it exists\r\n */\r\nfunction parseMetadata(dispute) {\r\n  if (dispute.disputable) {\r\n    return [\r\n      `${dispute.disputable.title} Action # ${dispute.disputable.actionId}`,\r\n    ]\r\n  }\r\n\r\n  try {\r\n    const { description, metadata } = JSON.parse(dispute.metadata)\r\n    return [description, metadata]\r\n  } catch (error) {\r\n    // if is not a json return the metadata as the description\r\n    return [dispute.metadata]\r\n  }\r\n}\r\n\r\nexport function transformDisputeDataAttributes(dispute) {\r\n  const [description, metadataUri] = parseMetadata(dispute)\r\n\r\n  const transformedDispute = {\r\n    ...dispute,\r\n    createdAt: toMs(parseInt(dispute.createdAt, 10)),\r\n    description,\r\n    metadataUri,\r\n    rounds: dispute.rounds.map(transformRoundDataAttributes),\r\n    state: DisputesTypes.convertFromString(dispute.state),\r\n    status:\r\n      DisputesTypes.convertFromString(dispute.state) ===\r\n      DisputesTypes.Phase.Ruled\r\n        ? DisputesTypes.Status.Closed\r\n        : DisputesTypes.Status.Open,\r\n  }\r\n\r\n  // If the dispute is part of the precedence campaign we will flag it as such\r\n  const precedenceCamapignDisputes = getPrecedenceCampaignDisputesByCourt()\r\n  const isPartOfPrecedenceCampaign = precedenceCamapignDisputes.has(dispute.id)\r\n  transformedDispute.marksPrecedent = isPartOfPrecedenceCampaign\r\n\r\n  // If the dispute is voided we will override certain data\r\n  const voidedDisputes = getVoidedDisputesByCourt()\r\n  const voidedDispute = voidedDisputes.get(dispute.id)\r\n\r\n  return voidedDispute\r\n    ? overrideVoidedDispute(transformedDispute, voidedDispute)\r\n    : transformedDispute\r\n}\r\n\r\nfunction overrideVoidedDispute(dispute, voidedDispute) {\r\n  return {\r\n    ...dispute,\r\n    evidences: [],\r\n    metadata: '',\r\n    status: DisputesTypes.Status.Voided,\r\n    voidedDescription: voidedDispute.description,\r\n    voidedLink: voidedDispute.link,\r\n    voidedText: voidedDispute.text,\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Object} dispute The dispute to query the current phase and next transition of\r\n * @param {Number} currentTerm The court current term\r\n * @param {Object} courtConfig The court configuration\r\n * @returns {Object} Current phase and next phase transition for the given dispute\r\n */\r\nexport function getPhaseAndTransition(dispute, currentTerm, courtConfig) {\r\n  if (!dispute) return null\r\n\r\n  let phase\r\n  let nextTransition\r\n\r\n  const { state } = dispute\r\n  const lastRound = dispute.rounds[dispute.lastRoundId]\r\n  const { number } = lastRound\r\n\r\n  // Dispute already ruled\r\n  if (state === DisputesTypes.Phase.Ruled) {\r\n    phase = DisputesTypes.Phase.ClaimRewards\r\n    return {\r\n      phase,\r\n      roundId: number,\r\n      maxAppealReached: hasDisputeReachedMaxAppeals(dispute, courtConfig),\r\n    }\r\n  }\r\n\r\n  // Evidence submission\r\n  if (state === DisputesTypes.Phase.Evidence) {\r\n    const evidenceSubmissionEndTerm = getEvidenceSubmissionEndTerm(\r\n      dispute,\r\n      courtConfig\r\n    )\r\n    const evidenceSubmissionEndTime = getTermEndTime(\r\n      evidenceSubmissionEndTerm,\r\n      courtConfig\r\n    )\r\n\r\n    if (currentTerm > evidenceSubmissionEndTerm) {\r\n      phase = DisputesTypes.Phase.JuryDrafting\r\n    } else {\r\n      phase = state\r\n      nextTransition = evidenceSubmissionEndTime\r\n    }\r\n    return { phase, nextTransition, roundId: number }\r\n  }\r\n\r\n  // Jury Drafting phase\r\n  if (state === DisputesTypes.Phase.JuryDrafting) {\r\n    // When a new round is created, it could happen that the draft term has not been reached yet\r\n    // because the confirm appeal phase of the previous round has not yet ended\r\n    if (currentTerm < lastRound.draftTermId) {\r\n      const draftStartTime = getTermStartTime(\r\n        lastRound.draftTermId,\r\n        courtConfig\r\n      )\r\n\r\n      phase = DisputesTypes.Phase.NotStarted\r\n      nextTransition = draftStartTime\r\n    } else {\r\n      phase = DisputesTypes.Phase.JuryDrafting\r\n    }\r\n    return { phase, nextTransition, roundId: number }\r\n  }\r\n\r\n  // Adjudicating\r\n  if (state === DisputesTypes.Phase.Adjudicating) {\r\n    let currentAdjudicationPhase = getAdjudicationPhase(\r\n      dispute,\r\n      lastRound,\r\n      currentTerm,\r\n      courtConfig\r\n    )\r\n\r\n    const { phase, phaseEndTerm } = currentAdjudicationPhase\r\n    if (phase === DisputesTypes.Phase.Ended) {\r\n      currentAdjudicationPhase = {\r\n        ...currentAdjudicationPhase,\r\n        phase: DisputesTypes.Phase.ExecuteRuling,\r\n      }\r\n    }\r\n\r\n    const nextTransition = phaseEndTerm\r\n      ? getTermEndTime(phaseEndTerm, courtConfig)\r\n      : null\r\n\r\n    return { ...currentAdjudicationPhase, roundId: number, nextTransition }\r\n  }\r\n}\r\n\r\n/**\r\n * Tells the adjudication state of a dispute's round at a certain time.\r\n * @param {Object} dispute Dispute to query the adjudication round of\r\n * @param {Object} round The round that is being queried\r\n * @param {Number} termId The term at which to query the dispute's adjudication phase\r\n * @param {Object} courtConfig The court configuration\r\n * @returns {Object} The adjudication phase of the requested round at the given time\r\n */\r\nexport function getAdjudicationPhase(dispute, round, termId, courtConfig) {\r\n  const {\r\n    commitTerms,\r\n    revealTerms,\r\n    appealTerms,\r\n    appealConfirmationTerms,\r\n  } = courtConfig\r\n\r\n  const { draftTermId, delayedTerms, number: roundId } = round\r\n\r\n  const draftEndTerm = draftTermId + delayedTerms\r\n  const maxAppealReached = hasDisputeReachedMaxAppeals(dispute, courtConfig)\r\n\r\n  // When voting period has not yet started there are two possible cases:\r\n  //   * We are at the last possible round so adjudication phase hasn't started\r\n  //   * We are not in an adjudication phase so it is invalid\r\n  if (termId < draftEndTerm) {\r\n    if (maxAppealReached) {\r\n      return {\r\n        phase: DisputesTypes.Phase.NotStarted,\r\n        phaseEndTerm: draftEndTerm,\r\n        roundId,\r\n      }\r\n    }\r\n\r\n    return {\r\n      phase: DisputesTypes.Phase.Invalid,\r\n      roundId,\r\n    }\r\n  }\r\n\r\n  // Jurors can commit their votes between when the commit phase term starts and ends\r\n  // Note that the commit start term is the same as the draft end term\r\n  const commitEndTerm = draftEndTerm + commitTerms - 1\r\n  if (termId <= commitEndTerm) {\r\n    return {\r\n      phase: DisputesTypes.Phase.VotingPeriod,\r\n      phaseEndTerm: commitEndTerm,\r\n      maxAppealReached,\r\n      roundId,\r\n    }\r\n  }\r\n\r\n  // Jurors can reveal their votes between when the reveal phase term starts and ends\r\n  const revealEndTerm = commitEndTerm + revealTerms\r\n  if (termId <= revealEndTerm) {\r\n    return {\r\n      phase: DisputesTypes.Phase.RevealVote,\r\n      phaseEndTerm: revealEndTerm,\r\n      maxAppealReached,\r\n      roundId,\r\n    }\r\n  }\r\n\r\n  // If the max number of appeals has been reached, then the last round is the final round and can be considered ended\r\n  if (maxAppealReached) {\r\n    return { phase: DisputesTypes.Phase.Ended, maxAppealReached, roundId }\r\n  }\r\n\r\n  // If the last round was not appealed yet, check if the confirmation period has started or not\r\n  const isLastRoundAppealed =\r\n    !!round.appeal && round.appeal.appealedRuling !== 0\r\n  const appealEndTerm = revealEndTerm + appealTerms\r\n\r\n  if (!isLastRoundAppealed) {\r\n    // If given term is before the appeal confirmation start term, then the last round can still be appealed. Otherwise, it is ended.\r\n    if (termId <= appealEndTerm) {\r\n      return {\r\n        phase: DisputesTypes.Phase.AppealRuling,\r\n        phaseEndTerm: appealEndTerm,\r\n        roundId,\r\n      }\r\n    } else {\r\n      return {\r\n        phase: DisputesTypes.Phase.Ended,\r\n        roundId,\r\n      }\r\n    }\r\n  }\r\n\r\n  // If the last round was appealed and the given term is before the appeal confirmation end term, then the last round appeal can still be\r\n  // confirmed. Note that if the round being checked was already appealed and confirmed, it won't be the last round, thus it will be caught\r\n  // above by the first check and considered 'Ended'.\r\n  const appealConfirmationEndTerm = appealEndTerm + appealConfirmationTerms\r\n\r\n  if (termId < appealConfirmationEndTerm) {\r\n    return {\r\n      phase: DisputesTypes.Phase.ConfirmAppeal,\r\n      phaseEndTerm: appealConfirmationEndTerm,\r\n      roundId,\r\n    }\r\n  }\r\n\r\n  // If non of the above conditions have been met, the last round is considered ended\r\n  return {\r\n    phase: DisputesTypes.Phase.Ended,\r\n    roundId,\r\n  }\r\n}\r\n\r\n/**\r\n * Terminology here will be:\r\n *        Last round => last round actually reached in a dispute\r\n *        Final round => max possible round for a dispute (when the max appeals for a given dispute is reached)\r\n * @param {Object} round The round to get the phases from\r\n * @param {Object} currentPhase The dispute's current phase\r\n * @param {Number} currentTerm The court current term\r\n * @param {Object} courtConfig The court configuration\r\n * @returns {Array} Array of all `round` phases.\r\n */\r\nexport function getRoundPhasesAndTime(\r\n  round,\r\n  currentPhase,\r\n  currentTerm,\r\n  courtConfig\r\n) {\r\n  const {\r\n    commitTerms,\r\n    revealTerms,\r\n    appealTerms,\r\n    appealConfirmationTerms,\r\n  } = courtConfig\r\n\r\n  const { draftTermId, delayedTerms, number: roundId, vote, appeal } = round\r\n  const isCurrentRound = roundId === currentPhase.roundId\r\n  const { winningOutcome } = vote || {}\r\n\r\n  const draftStartTime = getTermStartTime(draftTermId, courtConfig)\r\n\r\n  // Case where we are in a next round and has not yet started\r\n  if (isCurrentRound && currentPhase.phase === DisputesTypes.Phase.NotStarted) {\r\n    return [\r\n      {\r\n        phase: DisputesTypes.Phase.NotStarted,\r\n        endTime: draftStartTime,\r\n        roundId,\r\n        active: true,\r\n      },\r\n    ]\r\n  }\r\n\r\n  const draftEndTerm = draftTermId + delayedTerms\r\n  // Note that the commit start term is the same as the draft end term\r\n  const votingEndTerm = draftEndTerm + commitTerms - 1\r\n  const revealEndTerm = votingEndTerm + revealTerms\r\n  const appealEndTerm = revealEndTerm + appealTerms\r\n  const confirmAppealEndTerm = appealEndTerm + appealConfirmationTerms\r\n\r\n  const roundAppealed = !!appeal\r\n  const roundAppealConfirmed = roundAppealed && appeal.opposedRuling > 0\r\n\r\n  const roundPhasesAndTime = [\r\n    {\r\n      // Jurors can be drafted at any time, so we'll only set the\r\n      // `endTime` when the drafting phase has already passed\r\n      phase: DisputesTypes.Phase.JuryDrafting,\r\n      endTime:\r\n        DisputesTypes.Phase.JuryDrafting !== currentPhase.phase\r\n          ? getTermEndTime(draftEndTerm, courtConfig)\r\n          : null,\r\n      active:\r\n        isCurrentRound &&\r\n        DisputesTypes.Phase.JuryDrafting === currentPhase.phase,\r\n      roundId,\r\n    },\r\n    {\r\n      phase: DisputesTypes.Phase.VotingPeriod,\r\n      endTime: getTermEndTime(votingEndTerm, courtConfig),\r\n      active:\r\n        isCurrentRound &&\r\n        DisputesTypes.Phase.VotingPeriod === currentPhase.phase,\r\n      roundId,\r\n    },\r\n    {\r\n      phase: DisputesTypes.Phase.RevealVote,\r\n      endTime: getTermEndTime(revealEndTerm, courtConfig),\r\n      active:\r\n        isCurrentRound && DisputesTypes.Phase.RevealVote === currentPhase.phase,\r\n      roundId,\r\n      outcome: winningOutcome,\r\n      showOutcome: currentTerm > revealEndTerm,\r\n    },\r\n    {\r\n      // If the round was appealed we know it's a past phase and must update the endTime for the time this took effect (appeal.createdAt)\r\n      // If it wasn't appealed we have two cases:\r\n      //       - It's a past phase so in that case the endTime will be the time at where it's supposed to end if taking the full appealTerms duration\r\n      //       - It's the dispute active phase (the round can still be appealed) so the endTime will be used to tell the timer remaining time before the appeal phase is closed\r\n      phase: DisputesTypes.Phase.AppealRuling,\r\n      endTime: roundAppealed\r\n        ? appeal.createdAt\r\n        : getTermEndTime(appealEndTerm, courtConfig),\r\n      active:\r\n        isCurrentRound &&\r\n        DisputesTypes.Phase.AppealRuling === currentPhase.phase,\r\n      roundId,\r\n      outcome: roundAppealed ? appeal.appealedRuling : null,\r\n      showOutcome: roundAppealed || currentTerm > appealEndTerm,\r\n      // If the round was appealed, we'll show the outcome (appeal ruling),\r\n      // If it wasn't appealed then we'll show a \"Nobodoy appealed\" message\r\n    },\r\n    {\r\n      // If the round was appeal confirmed we know it's a past phase and must update the endTime for the time this took effect (appeal.confirmedAt)\r\n      // If it wasn't appeal confirmed we have two cases:\r\n      //       - It's a past phase so in that case the endTime will be the time at where it's supposed to end if taking the full confirmAppealTerms duration\r\n      //       - It's the dispute active phase (the round can still be appeal confirmed) so the endTime will be used to tell the timer remaining time before the confirm appeal phase is closed\r\n      phase: DisputesTypes.Phase.ConfirmAppeal,\r\n      endTime: roundAppealConfirmed\r\n        ? appeal.confirmedAt\r\n        : getTermEndTime(confirmAppealEndTerm, courtConfig),\r\n      active:\r\n        isCurrentRound &&\r\n        DisputesTypes.Phase.ConfirmAppeal === currentPhase.phase,\r\n      roundId,\r\n      outcome: roundAppealConfirmed ? appeal.opposedRuling : null,\r\n      showOutcome: roundAppealConfirmed || currentTerm > confirmAppealEndTerm,\r\n    },\r\n  ]\r\n\r\n  // If it's not the last round means that the dispute reached the next appeal round\r\n  // so we show all possible phases\r\n  if (roundId < currentPhase.roundId) {\r\n    return roundPhasesAndTime\r\n  }\r\n\r\n  // If it's the last round and has already ended (show past phases)\r\n  if (\r\n    currentPhase.phase === DisputesTypes.Phase.ExecuteRuling ||\r\n    currentPhase.phase === DisputesTypes.Phase.ClaimRewards\r\n  ) {\r\n    // In the final round (maxAppealedReached), there's no drafting phase and appealing is not possible\r\n    // so we only must show Voting and Revealing\r\n    if (currentPhase.maxAppealReached) {\r\n      return roundPhasesAndTime.slice(1, 3)\r\n    }\r\n\r\n    // If round not appealed\r\n    if (!roundAppealed) {\r\n      return roundPhasesAndTime.slice(0, 4)\r\n    }\r\n\r\n    return roundPhasesAndTime\r\n  }\r\n\r\n  // Find the last round current phase\r\n  const currentPhaseIndex = roundPhasesAndTime.findIndex(\r\n    phase => phase.phase === currentPhase.phase\r\n  )\r\n\r\n  // When round has not yet ended\r\n  return roundPhasesAndTime.slice(\r\n    currentPhase.maxAppealReached ? 1 : 0,\r\n    currentPhaseIndex + 1\r\n  )\r\n}\r\n\r\n/**\r\n *\r\n * @param {Object} dispute The dispute in question\r\n * @param {Object} courtConfig The court configuration\r\n * @returns {Number} The end time of the evidence submission phase in ms\r\n */\r\nexport function getEvidenceSubmissionEndTerm(dispute, courtConfig) {\r\n  const firstRound = dispute.rounds[0]\r\n\r\n  // If the evidence period is closed before the full `evidenceTerms` period,\r\n  // the draftTermId for the first round is updated to the term this happened.\r\n  return firstRound.draftTermId - 1\r\n}\r\n\r\n/**\r\n * Tells whether the dispute has reached the maximum number of rounds possible\r\n * @param {Object} dispute The dispute in question\r\n * @param {Object} courtConfig The court configuration\r\n * @returns {Boolean} True if dispute has reached maximum number of rounds possible\r\n */\r\nfunction hasDisputeReachedMaxAppeals(dispute, courtConfig) {\r\n  const { maxRegularAppealRounds } = courtConfig\r\n  const numberOfRounds = dispute.rounds.length\r\n  return numberOfRounds > maxRegularAppealRounds\r\n}\r\n\r\n/**\r\n * @param {Object} dispute The dispute to get the last round from\r\n * @returns {Object} dispute's last round\r\n */\r\nexport function getDisputeLastRound(dispute) {\r\n  return dispute.rounds[dispute.lastRoundId]\r\n}\r\n\r\n/**\r\n *\r\n * @param {Object} round Round to calculate fees from\r\n * @param {Object} courtConfig The court configuration\r\n * @returns {BigNum} The total fees for the round\r\n */\r\nexport function getRoundFees(round, courtConfig) {\r\n  const {\r\n    draftFee,\r\n    settleFee,\r\n    jurorFee,\r\n    finalRoundReduction,\r\n    maxRegularAppealRounds,\r\n  } = courtConfig\r\n\r\n  // Final round\r\n  if (round.number === maxRegularAppealRounds) {\r\n    return jurorFee\r\n      .mul(round.jurorsNumber)\r\n      .div(FINAL_ROUND_WEIGHT_PRECISION.mul(finalRoundReduction))\r\n      .div(PCT_BASE)\r\n  }\r\n\r\n  // Regular round\r\n  return draftFee\r\n    .add(settleFee)\r\n    .add(jurorFee)\r\n    .mul(round.jurorsNumber)\r\n}\r\n\r\n/**\r\n *\r\n * @param {BigNum} minActiveBalance The minimum active balance required to become an active juror\r\n * @param {BigNum} penaltyPct Percentage (against PCT_BASE) of min active tokens balance to be locked to each drafted juror\r\n * @param {BigNum} weight Weight computed for a juror on a round\r\n * @returns {BigNum} The amount that will be locked each time a juror is drafted\r\n */\r\nexport function getDraftLockAmount(minActiveBalance, penaltyPct, weight) {\r\n  return minActiveBalance\r\n    .mul(penaltyPct)\r\n    .div(PCT_BASE)\r\n    .mul(weight)\r\n}\r\n"]},"metadata":{},"sourceType":"module"}