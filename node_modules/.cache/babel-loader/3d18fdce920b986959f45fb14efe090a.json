{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _toConsumableArray = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar pMap = require('p-map');\n\nvar GSet = require('./g-set');\n\nvar Entry = require('./entry');\n\nvar LogIO = require('./log-io');\n\nvar LogError = require('./log-errors');\n\nvar Clock = require('./lamport-clock');\n\nvar Sorting = require('./log-sorting');\n\nvar LastWriteWins = Sorting.LastWriteWins,\n    NoZeroes = Sorting.NoZeroes;\n\nvar AccessController = require('./default-access-controller');\n\nvar _require = require('./utils'),\n    isDefined = _require.isDefined,\n    findUniques = _require.findUniques;\n\nvar EntryIndex = require('./entry-index');\n\nvar randomId = function randomId() {\n  return new Date().getTime().toString();\n};\n\nvar getHash = function getHash(e) {\n  return e.hash;\n};\n\nvar flatMap = function flatMap(res, acc) {\n  return res.concat(acc);\n};\n\nvar getNextPointers = function getNextPointers(entry) {\n  return entry.next;\n};\n\nvar maxClockTimeReducer = function maxClockTimeReducer(res, acc) {\n  return Math.max(res, acc.clock.time);\n};\n\nvar uniqueEntriesReducer = function uniqueEntriesReducer(res, acc) {\n  res[acc.hash] = acc;\n  return res;\n};\n/**\n * Log.\n *\n * @description\n * Log implements a G-Set CRDT and adds ordering.\n *\n * From:\n * \"A comprehensive study of Convergent and Commutative Replicated Data Types\"\n * https://hal.inria.fr/inria-00555588\n */\n\n\nvar Log = /*#__PURE__*/function (_GSet) {\n  _inherits(Log, _GSet);\n\n  var _super = _createSuper(Log);\n\n  /**\n   * Create a new Log instance\n   * @param {IPFS} ipfs An IPFS instance\n   * @param {Object} identity Identity (https://github.com/orbitdb/orbit-db-identity-provider/blob/master/src/identity.js)\n   * @param {Object} options\n   * @param {string} options.logId ID of the log\n   * @param {Object} options.access AccessController (./default-access-controller)\n   * @param {Array<Entry>} options.entries An Array of Entries from which to create the log\n   * @param {Array<Entry>} options.heads Set the heads of the log\n   * @param {Clock} options.clock Set the clock of the log\n   * @param {Function} options.sortFn The sort function - by default LastWriteWins\n   * @return {Log} The log instance\n   */\n  function Log(ipfs, identity) {\n    var _this;\n\n    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        logId = _ref.logId,\n        access = _ref.access,\n        entries = _ref.entries,\n        heads = _ref.heads,\n        clock = _ref.clock,\n        sortFn = _ref.sortFn,\n        concurrency = _ref.concurrency;\n\n    _classCallCheck(this, Log);\n\n    if (!isDefined(ipfs)) {\n      throw LogError.IPFSNotDefinedError();\n    }\n\n    if (!isDefined(identity)) {\n      throw new Error('Identity is required');\n    }\n\n    if (!isDefined(access)) {\n      access = new AccessController();\n    }\n\n    if (isDefined(entries) && !Array.isArray(entries)) {\n      throw new Error('\\'entries\\' argument must be an array of Entry instances');\n    }\n\n    if (isDefined(heads) && !Array.isArray(heads)) {\n      throw new Error('\\'heads\\' argument must be an array');\n    }\n\n    if (!isDefined(sortFn)) {\n      sortFn = LastWriteWins;\n    }\n\n    _this = _super.call(this);\n    _this._sortFn = NoZeroes(sortFn);\n    _this._storage = ipfs;\n    _this._id = logId || randomId(); // Access Controller\n\n    _this._access = access; // Identity\n\n    _this._identity = identity; // Add entries to the internal cache\n\n    var uniqueEntries = (entries || []).reduce(uniqueEntriesReducer, {});\n    _this._entryIndex = new EntryIndex(uniqueEntries);\n    entries = Object.values(uniqueEntries) || []; // Set heads if not passed as an argument\n\n    heads = heads || Log.findHeads(entries);\n    _this._headsIndex = heads.reduce(uniqueEntriesReducer, {}); // Index of all next pointers in this log\n\n    _this._nextsIndex = {};\n\n    var addToNextsIndex = function addToNextsIndex(e) {\n      return e.next.forEach(function (a) {\n        return _this._nextsIndex[a] = e.hash;\n      });\n    };\n\n    entries.forEach(addToNextsIndex); // Set the length, we calculate the length manually internally\n\n    _this._length = entries.length; // Set the clock\n\n    var maxTime = Math.max(clock ? clock.time : 0, _this.heads.reduce(maxClockTimeReducer, 0)); // Take the given key as the clock id is it's a Key instance,\n    // otherwise if key was given, take whatever it is,\n    // and if it was null, take the given id as the clock id\n\n    _this._clock = new Clock(_this._identity.publicKey, maxTime);\n    _this.joinConcurrency = concurrency || 16;\n    return _this;\n  }\n  /**\n   * Returns the ID of the log.\n   * @returns {string}\n   */\n\n\n  _createClass(Log, [{\n    key: \"id\",\n    get: function get() {\n      return this._id;\n    }\n    /**\n     * Returns the clock of the log.\n     * @returns {string}\n     */\n\n  }, {\n    key: \"clock\",\n    get: function get() {\n      return this._clock;\n    }\n    /**\n     * Returns the length of the log.\n     * @return {number} Length\n     */\n\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this._length;\n    }\n    /**\n     * Returns the values in the log.\n     * @returns {Array<Entry>}\n     */\n\n  }, {\n    key: \"values\",\n    get: function get() {\n      return Object.values(this.traverse(this.heads)).reverse();\n    }\n    /**\n     * Returns an array of heads as hashes.\n     * @returns {Array<string>}\n     */\n\n  }, {\n    key: \"heads\",\n    get: function get() {\n      return Object.values(this._headsIndex).sort(this._sortFn).reverse();\n    }\n    /**\n     * Returns an array of Entry objects that reference entries which\n     * are not in the log currently.\n     * @returns {Array<Entry>}\n     */\n\n  }, {\n    key: \"tails\",\n    get: function get() {\n      return Log.findTails(this.values);\n    }\n    /**\n     * Returns an array of hashes that are referenced by entries which\n     * are not in the log currently.\n     * @returns {Array<string>} Array of hashes\n     */\n\n  }, {\n    key: \"tailHashes\",\n    get: function get() {\n      return Log.findTailHashes(this.values);\n    }\n    /**\n     * Set the identity for the log\n     * @param {Identity} [identity] The identity to be set\n     */\n\n  }, {\n    key: \"setIdentity\",\n    value: function setIdentity(identity) {\n      this._identity = identity; // Find the latest clock from the heads\n\n      var time = Math.max(this.clock.time, this.heads.reduce(maxClockTimeReducer, 0));\n      this._clock = new Clock(this._identity.publicKey, time);\n    }\n    /**\n     * Find an entry.\n     * @param {string} [hash] The hashes of the entry\n     * @returns {Entry|undefined}\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(hash) {\n      return this._entryIndex.get(hash);\n    }\n    /**\n     * Checks if a entry is part of the log\n     * @param {string} hash The hash of the entry\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"has\",\n    value: function has(entry) {\n      return this._entryIndex.get(entry.hash || entry) !== undefined;\n    }\n  }, {\n    key: \"traverse\",\n    value: function traverse(rootEntries) {\n      var _this2 = this;\n\n      var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n      var endHash = arguments.length > 2 ? arguments[2] : undefined;\n      // Sort the given given root entries and use as the starting stack\n      var stack = rootEntries.sort(this._sortFn).reverse(); // Cache for checking if we've processed an entry already\n\n      var traversed = {}; // End result\n\n      var result = {};\n      var count = 0; // Named function for getting an entry from the log\n\n      var getEntry = function getEntry(e) {\n        return _this2.get(e);\n      }; // Add an entry to the stack and traversed nodes index\n\n\n      var addToStack = function addToStack(entry) {\n        // If we've already processed the entry, don't add it to the stack\n        if (!entry || traversed[entry.hash]) {\n          return;\n        } // Add the entry in front of the stack and sort\n\n\n        stack = [entry].concat(_toConsumableArray(stack)).sort(_this2._sortFn).reverse(); // Add to the cache of processed entries\n\n        traversed[entry.hash] = true;\n      };\n\n      var addEntry = function addEntry(rootEntry) {\n        result[rootEntry.hash] = rootEntry;\n        traversed[rootEntry.hash] = true;\n        count++;\n      }; // Start traversal\n      // Process stack until it's empty (traversed the full log)\n      // or when we have the requested amount of entries\n      // If requested entry amount is -1, traverse all\n\n\n      while (stack.length > 0 && (count < amount || amount < 0)) {\n        // eslint-disable-line no-unmodified-loop-condition\n        // Get the next element from the stack\n        var entry = stack.shift(); // Add to the result\n\n        addEntry(entry); // If it is the specified end hash, break out of the while loop\n\n        if (endHash && endHash === entry.hash) break; // Add entry's next references to the stack\n\n        var entries = entry.next.map(getEntry);\n        var defined = entries.filter(isDefined);\n        defined.forEach(addToStack);\n      }\n\n      stack = [];\n      traversed = {}; // End result\n\n      return result;\n    }\n    /**\n     * Append an entry to the log.\n     * @param {Entry} entry Entry to add\n     * @return {Log} New Log containing the appended value\n     */\n\n  }, {\n    key: \"append\",\n    value: function () {\n      var _append = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(data) {\n        var _this3 = this;\n\n        var pointerCount,\n            pin,\n            newTime,\n            all,\n            getEveryPow2,\n            references,\n            nexts,\n            isNext,\n            refs,\n            entry,\n            canAppend,\n            _args = arguments;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                pointerCount = _args.length > 1 && _args[1] !== undefined ? _args[1] : 1;\n                pin = _args.length > 2 && _args[2] !== undefined ? _args[2] : false;\n                // Update the clock (find the latest clock)\n                newTime = Math.max(this.clock.time, this.heads.reduce(maxClockTimeReducer, 0)) + 1;\n                this._clock = new Clock(this.clock.id, newTime);\n                all = Object.values(this.traverse(this.heads, Math.max(pointerCount, this.heads.length))); // If pointer count is 4, returns 2\n                // If pointer count is 8, returns 3 references\n                // If pointer count is 512, returns 9 references\n                // If pointer count is 2048, returns 11 references\n\n                getEveryPow2 = function getEveryPow2(maxDistance) {\n                  var entries = new Set();\n\n                  for (var i = 1; i <= maxDistance; i *= 2) {\n                    var index = Math.min(i - 1, all.length - 1);\n                    entries.add(all[index]);\n                  }\n\n                  return entries;\n                };\n\n                references = getEveryPow2(Math.min(pointerCount, all.length)); // Always include the last known reference\n\n                if (all.length < pointerCount && all[all.length - 1]) {\n                  references.add(all[all.length - 1]);\n                } // Create the next pointers from heads\n\n\n                nexts = Object.keys(this.heads.reverse().reduce(uniqueEntriesReducer, {}));\n\n                isNext = function isNext(e) {\n                  return !nexts.includes(e);\n                }; // Delete the heads from the refs\n\n\n                refs = Array.from(references).map(getHash).filter(isNext); // @TODO: Split Entry.create into creating object, checking permission, signing and then posting to IPFS\n                // Create the entry and add it to the internal cache\n\n                _context.next = 13;\n                return Entry.create(this._storage, this._identity, this.id, data, nexts, this.clock, refs, pin);\n\n              case 13:\n                entry = _context.sent;\n                _context.next = 16;\n                return this._access.canAppend(entry, this._identity.provider);\n\n              case 16:\n                canAppend = _context.sent;\n\n                if (canAppend) {\n                  _context.next = 19;\n                  break;\n                }\n\n                throw new Error(\"Could not append entry, key \\\"\".concat(this._identity.id, \"\\\" is not allowed to write to the log\"));\n\n              case 19:\n                this._entryIndex.set(entry.hash, entry);\n\n                nexts.forEach(function (e) {\n                  return _this3._nextsIndex[e] = entry.hash;\n                });\n                this._headsIndex = {};\n                this._headsIndex[entry.hash] = entry; // Update the length\n\n                this._length++;\n                return _context.abrupt(\"return\", entry);\n\n              case 25:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function append(_x) {\n        return _append.apply(this, arguments);\n      }\n\n      return append;\n    }()\n    /*\n     * Creates a javscript iterator over log entries\n     *\n     * @param {Object} options\n     * @param {string|Array} options.gt Beginning hash of the iterator, non-inclusive\n     * @param {string|Array} options.gte Beginning hash of the iterator, inclusive\n     * @param {string|Array} options.lt Ending hash of the iterator, non-inclusive\n     * @param {string|Array} options.lte Ending hash of the iterator, inclusive\n     * @param {amount} options.amount Number of entried to return to / from the gte / lte hash\n     * @returns {Symbol.Iterator} Iterator object containing log entries\n     *\n     * @examples\n     *\n     * (async () => {\n     *   log1 = new Log(ipfs, testIdentity, { logId: 'X' })\n     *\n     *   for (let i = 0; i <= 100; i++) {\n     *     await log1.append('entry' + i)\n     *   }\n     *\n     *   let it = log1.iterator({\n     *     lte: 'zdpuApFd5XAPkCTmSx7qWQmQzvtdJPtx2K5p9to6ytCS79bfk',\n     *     amount: 10\n     *   })\n     *\n     *   [...it].length // 10\n     * })()\n     *\n     *\n     */\n\n  }, {\n    key: \"iterator\",\n    value: function iterator() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref2$gt = _ref2.gt,\n          gt = _ref2$gt === void 0 ? undefined : _ref2$gt,\n          _ref2$gte = _ref2.gte,\n          gte = _ref2$gte === void 0 ? undefined : _ref2$gte,\n          _ref2$lt = _ref2.lt,\n          lt = _ref2$lt === void 0 ? undefined : _ref2$lt,\n          _ref2$lte = _ref2.lte,\n          lte = _ref2$lte === void 0 ? undefined : _ref2$lte,\n          _ref2$amount = _ref2.amount,\n          amount = _ref2$amount === void 0 ? -1 : _ref2$amount;\n\n      if (amount === 0) return /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      })();\n      if (typeof lte === 'string') lte = [this.get(lte)];\n      if (typeof lt === 'string') lt = [this.get(this.get(lt).next)];\n      if (lte && !Array.isArray(lte)) throw LogError.LtOrLteMustBeStringOrArray();\n      if (lt && !Array.isArray(lt)) throw LogError.LtOrLteMustBeStringOrArray();\n      var start = (lte || lt || this.heads).filter(isDefined);\n      var endHash = gte ? this.get(gte).hash : gt ? this.get(gt).hash : null;\n      var count = endHash ? -1 : amount || -1;\n      var entries = this.traverse(start, count, endHash);\n      var entryValues = Object.values(entries); // Strip off last entry if gt is non-inclusive\n\n      if (gt) entryValues.pop(); // Deal with the amount argument working backwards from gt/gte\n\n      if ((gt || gte) && amount > -1) {\n        entryValues = entryValues.slice(entryValues.length - amount, entryValues.length);\n      }\n\n      return /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var i;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.t0 = _regeneratorRuntime.keys(entryValues);\n\n              case 1:\n                if ((_context3.t1 = _context3.t0()).done) {\n                  _context3.next = 7;\n                  break;\n                }\n\n                i = _context3.t1.value;\n                _context3.next = 5;\n                return entryValues[i];\n\n              case 5:\n                _context3.next = 1;\n                break;\n\n              case 7:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      })();\n    }\n    /**\n     * Join two logs.\n     *\n     * Joins another log into this one.\n     *\n     * @param {Log} log Log to join with this Log\n     * @param {number} [size=-1] Max size of the joined log\n     * @returns {Promise<Log>} This Log instance\n     * @example\n     * await log1.join(log2)\n     */\n\n  }, {\n    key: \"join\",\n    value: function () {\n      var _join = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(log) {\n        var _this4 = this;\n\n        var size,\n            newItems,\n            identityProvider,\n            permitted,\n            verify,\n            entriesToJoin,\n            addToNextsIndex,\n            notReferencedByNewItems,\n            notInCurrentNexts,\n            nextsFromNewItems,\n            mergedHeads,\n            tmp,\n            maxClock,\n            _args7 = arguments;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                size = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : -1;\n\n                if (isDefined(log)) {\n                  _context7.next = 3;\n                  break;\n                }\n\n                throw LogError.LogNotDefinedError();\n\n              case 3:\n                if (Log.isLog(log)) {\n                  _context7.next = 5;\n                  break;\n                }\n\n                throw LogError.NotALogError();\n\n              case 5:\n                if (!(this.id !== log.id)) {\n                  _context7.next = 7;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\");\n\n              case 7:\n                // Get the difference of the logs\n                newItems = Log.difference(log, this);\n                identityProvider = this._identity.provider; // Verify if entries are allowed to be added to the log and throws if\n                // there's an invalid entry\n\n                permitted = /*#__PURE__*/function () {\n                  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(entry) {\n                    var canAppend;\n                    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n                      while (1) {\n                        switch (_context4.prev = _context4.next) {\n                          case 0:\n                            _context4.next = 2;\n                            return _this4._access.canAppend(entry, identityProvider);\n\n                          case 2:\n                            canAppend = _context4.sent;\n\n                            if (canAppend) {\n                              _context4.next = 5;\n                              break;\n                            }\n\n                            throw new Error(\"Could not append entry, key \\\"\".concat(entry.identity.id, \"\\\" is not allowed to write to the log\"));\n\n                          case 5:\n                          case \"end\":\n                            return _context4.stop();\n                        }\n                      }\n                    }, _callee4);\n                  }));\n\n                  return function permitted(_x3) {\n                    return _ref3.apply(this, arguments);\n                  };\n                }(); // Verify signature for each entry and throws if there's an invalid signature\n\n\n                verify = /*#__PURE__*/function () {\n                  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(entry) {\n                    var isValid, publicKey;\n                    return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n                      while (1) {\n                        switch (_context5.prev = _context5.next) {\n                          case 0:\n                            _context5.next = 2;\n                            return Entry.verify(identityProvider, entry);\n\n                          case 2:\n                            isValid = _context5.sent;\n                            publicKey = entry.identity ? entry.identity.publicKey : entry.key;\n\n                            if (isValid) {\n                              _context5.next = 6;\n                              break;\n                            }\n\n                            throw new Error(\"Could not validate signature \\\"\".concat(entry.sig, \"\\\" for entry \\\"\").concat(entry.hash, \"\\\" and key \\\"\").concat(publicKey, \"\\\"\"));\n\n                          case 6:\n                          case \"end\":\n                            return _context5.stop();\n                        }\n                      }\n                    }, _callee5);\n                  }));\n\n                  return function verify(_x4) {\n                    return _ref4.apply(this, arguments);\n                  };\n                }();\n\n                entriesToJoin = Object.values(newItems);\n                _context7.next = 14;\n                return pMap(entriesToJoin, /*#__PURE__*/function () {\n                  var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(e) {\n                    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n                      while (1) {\n                        switch (_context6.prev = _context6.next) {\n                          case 0:\n                            _context6.next = 2;\n                            return permitted(e);\n\n                          case 2:\n                            _context6.next = 4;\n                            return verify(e);\n\n                          case 4:\n                          case \"end\":\n                            return _context6.stop();\n                        }\n                      }\n                    }, _callee6);\n                  }));\n\n                  return function (_x5) {\n                    return _ref5.apply(this, arguments);\n                  };\n                }(), {\n                  concurrency: this.joinConcurrency\n                });\n\n              case 14:\n                // Update the internal next pointers index\n                addToNextsIndex = function addToNextsIndex(e) {\n                  var entry = _this4.get(e.hash);\n\n                  if (!entry) _this4._length++;\n                  /* istanbul ignore else */\n\n                  e.next.forEach(function (a) {\n                    return _this4._nextsIndex[a] = e.hash;\n                  });\n                };\n\n                Object.values(newItems).forEach(addToNextsIndex); // Update the internal entry index\n\n                this._entryIndex.add(newItems); // Merge the heads\n\n\n                notReferencedByNewItems = function notReferencedByNewItems(e) {\n                  return !nextsFromNewItems.find(function (a) {\n                    return a === e.hash;\n                  });\n                };\n\n                notInCurrentNexts = function notInCurrentNexts(e) {\n                  return !_this4._nextsIndex[e.hash];\n                };\n\n                nextsFromNewItems = Object.values(newItems).map(getNextPointers).reduce(flatMap, []);\n                mergedHeads = Log.findHeads(Object.values(Object.assign({}, this._headsIndex, log._headsIndex))).filter(notReferencedByNewItems).filter(notInCurrentNexts).reduce(uniqueEntriesReducer, {});\n                this._headsIndex = mergedHeads; // Slice to the requested size\n\n                if (size > -1) {\n                  tmp = this.values;\n                  tmp = tmp.slice(-size);\n                  this._entryIndex = null;\n                  this._entryIndex = new EntryIndex(tmp.reduce(uniqueEntriesReducer, {}));\n                  this._headsIndex = Log.findHeads(tmp).reduce(uniqueEntriesReducer, {});\n                  this._length = this._entryIndex.length;\n                } // Find the latest clock from the heads\n\n\n                maxClock = Object.values(this._headsIndex).reduce(maxClockTimeReducer, 0);\n                this._clock = new Clock(this.clock.id, Math.max(this.clock.time, maxClock));\n                return _context7.abrupt(\"return\", this);\n\n              case 26:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function join(_x2) {\n        return _join.apply(this, arguments);\n      }\n\n      return join;\n    }()\n    /**\n     * Get the log in JSON format.\n     * @returns {Object} An object with the id and heads properties\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        id: this.id,\n        heads: this.heads.sort(this._sortFn) // default sorting\n        .reverse() // we want the latest as the first element\n        .map(getHash) // return only the head hashes\n\n      };\n    }\n    /**\n     * Get the log in JSON format as a snapshot.\n     * @returns {Object} An object with the id, heads and value properties\n     */\n\n  }, {\n    key: \"toSnapshot\",\n    value: function toSnapshot() {\n      return {\n        id: this.id,\n        heads: this.heads,\n        values: this.values\n      };\n    }\n    /**\n     * Get the log as a Buffer.\n     * @returns {Buffer}\n     */\n\n  }, {\n    key: \"toBuffer\",\n    value: function toBuffer() {\n      return Buffer.from(JSON.stringify(this.toJSON()));\n    }\n    /**\n     * Returns the log entries as a formatted string.\n     * @returns {string}\n     * @example\n     * two\n     * └─one\n     *   └─three\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString(payloadMapper) {\n      var _this5 = this;\n\n      return this.values.slice().reverse().map(function (e, idx) {\n        var parents = Entry.findChildren(e, _this5.values);\n        var len = parents.length;\n        var padding = new Array(Math.max(len - 1, 0));\n        padding = len > 1 ? padding.fill('  ') : padding;\n        padding = len > 0 ? padding.concat(['└─']) : padding;\n        /* istanbul ignore next */\n\n        return padding.join('') + (payloadMapper ? payloadMapper(e.payload) : e.payload);\n      }).join('\\n');\n    }\n    /**\n     * Check whether an object is a Log instance.\n     * @param {Object} log An object to check\n     * @returns {boolean}\n     */\n\n  }, {\n    key: \"toMultihash\",\n    value:\n    /**\n     * Get the log's multihash.\n     * @returns {Promise<string>} Multihash of the Log as Base58 encoded string.\n     */\n    function toMultihash() {\n      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          format = _ref6.format;\n\n      return LogIO.toMultihash(this._storage, this, {\n        format: format\n      });\n    }\n    /**\n     * Create a log from a hashes.\n     * @param {IPFS} ipfs An IPFS instance\n     * @param {Identity} identity The identity instance\n     * @param {string} hash The log hash\n     * @param {Object} options\n     * @param {AccessController} options.access The access controller instance\n     * @param {number} options.length How many items to include in the log\n     * @param {Array<Entry>} options.exclude Entries to not fetch (cached)\n     * @param {function(hash, entry, parent, depth)} options.onProgressCallback\n     * @param {Function} options.sortFn The sort function - by default LastWriteWins\n     * @returns {Promise<Log>}\n     */\n\n  }], [{\n    key: \"isLog\",\n    value: function isLog(log) {\n      return log.id !== undefined && log.heads !== undefined && log._entryIndex !== undefined;\n    }\n  }, {\n    key: \"fromMultihash\",\n    value: function () {\n      var _fromMultihash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(ipfs, identity, hash) {\n        var _ref7,\n            access,\n            _ref7$length,\n            length,\n            _ref7$exclude,\n            exclude,\n            timeout,\n            concurrency,\n            sortFn,\n            onProgressCallback,\n            _yield$LogIO$fromMult,\n            logId,\n            entries,\n            heads,\n            _args8 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _ref7 = _args8.length > 3 && _args8[3] !== undefined ? _args8[3] : {}, access = _ref7.access, _ref7$length = _ref7.length, length = _ref7$length === void 0 ? -1 : _ref7$length, _ref7$exclude = _ref7.exclude, exclude = _ref7$exclude === void 0 ? [] : _ref7$exclude, timeout = _ref7.timeout, concurrency = _ref7.concurrency, sortFn = _ref7.sortFn, onProgressCallback = _ref7.onProgressCallback;\n                _context8.next = 3;\n                return LogIO.fromMultihash(ipfs, hash, {\n                  length: length,\n                  exclude: exclude,\n                  timeout: timeout,\n                  onProgressCallback: onProgressCallback,\n                  concurrency: concurrency,\n                  sortFn: sortFn\n                });\n\n              case 3:\n                _yield$LogIO$fromMult = _context8.sent;\n                logId = _yield$LogIO$fromMult.logId;\n                entries = _yield$LogIO$fromMult.entries;\n                heads = _yield$LogIO$fromMult.heads;\n                return _context8.abrupt(\"return\", new Log(ipfs, identity, {\n                  logId: logId,\n                  access: access,\n                  entries: entries,\n                  heads: heads,\n                  sortFn: sortFn\n                }));\n\n              case 8:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8);\n      }));\n\n      function fromMultihash(_x6, _x7, _x8) {\n        return _fromMultihash.apply(this, arguments);\n      }\n\n      return fromMultihash;\n    }()\n    /**\n     * Create a log from a single entry's hash.\n     * @param {IPFS} ipfs An IPFS instance\n     * @param {Identity} identity The identity instance\n     * @param {string} hash The entry's hash\n     * @param {Object} options\n     * @param {string} options.logId The ID of the log\n     * @param {AccessController} options.access The access controller instance\n     * @param {number} options.length How many entries to include in the log\n     * @param {Array<Entry>} options.exclude Entries to not fetch (cached)\n     * @param {function(hash, entry, parent, depth)} options.onProgressCallback\n     * @param {Function} options.sortFn The sort function - by default LastWriteWins\n     * @return {Promise<Log>} New Log\n     */\n\n  }, {\n    key: \"fromEntryHash\",\n    value: function () {\n      var _fromEntryHash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(ipfs, identity, hash) {\n        var _ref8,\n            logId,\n            access,\n            _ref8$length,\n            length,\n            _ref8$exclude,\n            exclude,\n            timeout,\n            concurrency,\n            sortFn,\n            onProgressCallback,\n            _yield$LogIO$fromEntr,\n            entries,\n            _args9 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _ref8 = _args9.length > 3 && _args9[3] !== undefined ? _args9[3] : {}, logId = _ref8.logId, access = _ref8.access, _ref8$length = _ref8.length, length = _ref8$length === void 0 ? -1 : _ref8$length, _ref8$exclude = _ref8.exclude, exclude = _ref8$exclude === void 0 ? [] : _ref8$exclude, timeout = _ref8.timeout, concurrency = _ref8.concurrency, sortFn = _ref8.sortFn, onProgressCallback = _ref8.onProgressCallback;\n                _context9.next = 3;\n                return LogIO.fromEntryHash(ipfs, hash, {\n                  length: length,\n                  exclude: exclude,\n                  timeout: timeout,\n                  concurrency: concurrency,\n                  onProgressCallback: onProgressCallback\n                });\n\n              case 3:\n                _yield$LogIO$fromEntr = _context9.sent;\n                entries = _yield$LogIO$fromEntr.entries;\n                return _context9.abrupt(\"return\", new Log(ipfs, identity, {\n                  logId: logId,\n                  access: access,\n                  entries: entries,\n                  sortFn: sortFn\n                }));\n\n              case 6:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9);\n      }));\n\n      function fromEntryHash(_x9, _x10, _x11) {\n        return _fromEntryHash.apply(this, arguments);\n      }\n\n      return fromEntryHash;\n    }()\n    /**\n     * Create a log from a Log Snapshot JSON.\n     * @param {IPFS} ipfs An IPFS instance\n     * @param {Identity} identity The identity instance\n     * @param {Object} json Log snapshot as JSON object\n     * @param {Object} options\n     * @param {AccessController} options.access The access controller instance\n     * @param {number} options.length How many entries to include in the log\n     * @param {function(hash, entry, parent, depth)} [options.onProgressCallback]\n     * @param {Function} options.sortFn The sort function - by default LastWriteWins\n     * @return {Promise<Log>} New Log\n     */\n\n  }, {\n    key: \"fromJSON\",\n    value: function () {\n      var _fromJSON = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(ipfs, identity, json) {\n        var _ref9,\n            access,\n            _ref9$length,\n            length,\n            timeout,\n            sortFn,\n            onProgressCallback,\n            _yield$LogIO$fromJSON,\n            logId,\n            entries,\n            _args10 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                _ref9 = _args10.length > 3 && _args10[3] !== undefined ? _args10[3] : {}, access = _ref9.access, _ref9$length = _ref9.length, length = _ref9$length === void 0 ? -1 : _ref9$length, timeout = _ref9.timeout, sortFn = _ref9.sortFn, onProgressCallback = _ref9.onProgressCallback;\n                _context10.next = 3;\n                return LogIO.fromJSON(ipfs, json, {\n                  length: length,\n                  timeout: timeout,\n                  onProgressCallback: onProgressCallback\n                });\n\n              case 3:\n                _yield$LogIO$fromJSON = _context10.sent;\n                logId = _yield$LogIO$fromJSON.logId;\n                entries = _yield$LogIO$fromJSON.entries;\n                return _context10.abrupt(\"return\", new Log(ipfs, identity, {\n                  logId: logId,\n                  access: access,\n                  entries: entries,\n                  sortFn: sortFn\n                }));\n\n              case 7:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10);\n      }));\n\n      function fromJSON(_x12, _x13, _x14) {\n        return _fromJSON.apply(this, arguments);\n      }\n\n      return fromJSON;\n    }()\n    /**\n     * Create a new log from an Entry instance.\n     * @param {IPFS} ipfs An IPFS instance\n     * @param {Identity} identity The identity instance\n     * @param {Entry|Array<Entry>} sourceEntries An Entry or an array of entries to fetch a log from\n     * @param {Object} options\n     * @param {AccessController} options.access The access controller instance\n     * @param {number} options.length How many entries to include. Default: infinite.\n     * @param {Array<Entry>} options.exclude Entries to not fetch (cached)\n     * @param {function(hash, entry, parent, depth)} [options.onProgressCallback]\n     * @param {Function} options.sortFn The sort function - by default LastWriteWins\n     * @return {Promise<Log>} New Log\n     */\n\n  }, {\n    key: \"fromEntry\",\n    value: function () {\n      var _fromEntry = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(ipfs, identity, sourceEntries) {\n        var _ref10,\n            access,\n            _ref10$length,\n            length,\n            _ref10$exclude,\n            exclude,\n            timeout,\n            concurrency,\n            sortFn,\n            onProgressCallback,\n            _yield$LogIO$fromEntr2,\n            logId,\n            entries,\n            _args11 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                _ref10 = _args11.length > 3 && _args11[3] !== undefined ? _args11[3] : {}, access = _ref10.access, _ref10$length = _ref10.length, length = _ref10$length === void 0 ? -1 : _ref10$length, _ref10$exclude = _ref10.exclude, exclude = _ref10$exclude === void 0 ? [] : _ref10$exclude, timeout = _ref10.timeout, concurrency = _ref10.concurrency, sortFn = _ref10.sortFn, onProgressCallback = _ref10.onProgressCallback;\n                _context11.next = 3;\n                return LogIO.fromEntry(ipfs, sourceEntries, {\n                  length: length,\n                  exclude: exclude,\n                  timeout: timeout,\n                  concurrency: concurrency,\n                  onProgressCallback: onProgressCallback\n                });\n\n              case 3:\n                _yield$LogIO$fromEntr2 = _context11.sent;\n                logId = _yield$LogIO$fromEntr2.logId;\n                entries = _yield$LogIO$fromEntr2.entries;\n                return _context11.abrupt(\"return\", new Log(ipfs, identity, {\n                  logId: logId,\n                  access: access,\n                  entries: entries,\n                  sortFn: sortFn\n                }));\n\n              case 7:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11);\n      }));\n\n      function fromEntry(_x15, _x16, _x17) {\n        return _fromEntry.apply(this, arguments);\n      }\n\n      return fromEntry;\n    }()\n    /**\n     * Find heads from a collection of entries.\n     *\n     * Finds entries that are the heads of this collection,\n     * ie. entries that are not referenced by other entries.\n     *\n     * @param {Array<Entry>} entries Entries to search heads from\n     * @returns {Array<Entry>}\n     */\n\n  }, {\n    key: \"findHeads\",\n    value: function findHeads(entries) {\n      var indexReducer = function indexReducer(res, entry, idx, arr) {\n        var addToResult = function addToResult(e) {\n          return res[e] = entry.hash;\n        };\n\n        entry.next.forEach(addToResult);\n        return res;\n      };\n\n      var items = entries.reduce(indexReducer, {});\n\n      var exists = function exists(e) {\n        return items[e.hash] === undefined;\n      };\n\n      var compareIds = function compareIds(a, b) {\n        return a.clock.id > b.clock.id;\n      };\n\n      return entries.filter(exists).sort(compareIds);\n    } // Find entries that point to another entry that is not in the\n    // input array\n\n  }, {\n    key: \"findTails\",\n    value: function findTails(entries) {\n      // Reverse index { next -> entry }\n      var reverseIndex = {}; // Null index containing entries that have no parents (nexts)\n\n      var nullIndex = []; // Hashes for all entries for quick lookups\n\n      var hashes = {}; // Hashes of all next entries\n\n      var nexts = [];\n\n      var addToIndex = function addToIndex(e) {\n        if (e.next.length === 0) {\n          nullIndex.push(e);\n        }\n\n        var addToReverseIndex = function addToReverseIndex(a) {\n          /* istanbul ignore else */\n          if (!reverseIndex[a]) reverseIndex[a] = [];\n          reverseIndex[a].push(e);\n        }; // Add all entries and their parents to the reverse index\n\n\n        e.next.forEach(addToReverseIndex); // Get all next references\n\n        nexts = nexts.concat(e.next); // Get the hashes of input entries\n\n        hashes[e.hash] = true;\n      }; // Create our indices\n\n\n      entries.forEach(addToIndex);\n\n      var addUniques = function addUniques(res, entries, idx, arr) {\n        return res.concat(findUniques(entries, 'hash'));\n      };\n\n      var exists = function exists(e) {\n        return hashes[e] === undefined;\n      };\n\n      var findFromReverseIndex = function findFromReverseIndex(e) {\n        return reverseIndex[e];\n      }; // Drop hashes that are not in the input entries\n\n\n      var tails = nexts // For every hash in nexts:\n      .filter(exists) // Remove undefineds and nulls\n      .map(findFromReverseIndex) // Get the Entry from the reverse index\n      .reduce(addUniques, []) // Flatten the result and take only uniques\n      .concat(nullIndex); // Combine with tails the have no next refs (ie. first-in-their-chain)\n\n      return findUniques(tails, 'hash').sort(Entry.compare);\n    } // Find the hashes to entries that are not in a collection\n    // but referenced by other entries\n\n  }, {\n    key: \"findTailHashes\",\n    value: function findTailHashes(entries) {\n      var hashes = {};\n\n      var addToIndex = function addToIndex(e) {\n        return hashes[e.hash] = true;\n      };\n\n      var reduceTailHashes = function reduceTailHashes(res, entry, idx, arr) {\n        var addToResult = function addToResult(e) {\n          /* istanbul ignore else */\n          if (hashes[e] === undefined) {\n            res.splice(0, 0, e);\n          }\n        };\n\n        entry.next.reverse().forEach(addToResult);\n        return res;\n      };\n\n      entries.forEach(addToIndex);\n      return entries.reduce(reduceTailHashes, []);\n    }\n  }, {\n    key: \"difference\",\n    value: function difference(a, b) {\n      var stack = Object.keys(a._headsIndex);\n      var traversed = {};\n      var res = {};\n\n      var pushToStack = function pushToStack(hash) {\n        if (!traversed[hash] && !b.get(hash)) {\n          stack.push(hash);\n          traversed[hash] = true;\n        }\n      };\n\n      while (stack.length > 0) {\n        var hash = stack.shift();\n        var entry = a.get(hash);\n\n        if (entry && !b.get(hash) && entry.id === b.id) {\n          res[entry.hash] = entry;\n          traversed[entry.hash] = true;\n          entry.next.forEach(pushToStack);\n        }\n      }\n\n      return res;\n    }\n  }]);\n\n  return Log;\n}(GSet);\n\nmodule.exports = Log;\nmodule.exports.Sorting = Sorting;\nmodule.exports.Entry = Entry;\nmodule.exports.AccessController = AccessController;","map":null,"metadata":{},"sourceType":"script"}