{"ast":null,"code":"const node = require('./node');\n\nconst browser = require('./browser');\n\nconst {\n  default: Queue\n} = require('p-queue');\n\nconst {\n  timeout\n} = require('promise-timeout');\n\nconst observe = require('observable-webworkers');\n\nconst mutexes = {};\nlet implementation;\n\nfunction createReleaseable(queue, options) {\n  let res;\n  const p = new Promise(resolve => {\n    res = resolve;\n  });\n  queue.add(() => timeout((() => {\n    return new Promise(resolve => {\n      res(() => {\n        resolve();\n      });\n    });\n  })(), options.timeout));\n  return p;\n}\n\nconst createMutex = (name, options) => {\n  if (implementation.isWorker) {\n    return {\n      readLock: implementation.readLock(name, options),\n      writeLock: implementation.writeLock(name, options)\n    };\n  }\n\n  const masterQueue = new Queue({\n    concurrency: 1\n  });\n  let readQueue = null;\n  return {\n    readLock: () => {\n      // If there's already a read queue, just add the task to it\n      if (readQueue) {\n        return createReleaseable(readQueue, options);\n      } // Create a new read queue\n\n\n      readQueue = new Queue({\n        concurrency: options.concurrency,\n        autoStart: false\n      });\n      const localReadQueue = readQueue; // Add the task to the read queue\n\n      const readPromise = createReleaseable(readQueue, options);\n      masterQueue.add(() => {\n        // Start the task only once the master queue has completed processing\n        // any previous tasks\n        localReadQueue.start(); // Once all the tasks in the read queue have completed, remove it so\n        // that the next read lock will occur after any write locks that were\n        // started in the interim\n\n        return localReadQueue.onIdle().then(() => {\n          if (readQueue === localReadQueue) {\n            readQueue = null;\n          }\n        });\n      });\n      return readPromise;\n    },\n    writeLock: () => {\n      // Remove the read queue reference, so that any later read locks will be\n      // added to a new queue that starts after this write lock has been\n      // released\n      readQueue = null;\n      return createReleaseable(masterQueue, options);\n    }\n  };\n};\n\nconst defaultOptions = {\n  concurrency: Infinity,\n  timeout: 84600000,\n  global: global,\n  singleProcess: false\n};\n\nmodule.exports = (name, options) => {\n  if (!options) {\n    options = {};\n  }\n\n  if (typeof name === 'object') {\n    options = name;\n    name = 'lock';\n  }\n\n  if (!name) {\n    name = 'lock';\n  }\n\n  options = Object.assign({}, defaultOptions, options);\n\n  if (!implementation) {\n    implementation = node(options) || browser(options);\n\n    if (!implementation.isWorker) {\n      // we are master, set up worker requests\n      implementation.on('requestReadLock', (name, fn) => {\n        if (!mutexes[name]) {\n          return;\n        }\n\n        mutexes[name].readLock().then(release => fn().finally(() => release()));\n      });\n      implementation.on('requestWriteLock', async (name, fn) => {\n        if (!mutexes[name]) {\n          return;\n        }\n\n        mutexes[name].writeLock().then(release => fn().finally(() => release()));\n      });\n    }\n  }\n\n  if (!mutexes[name]) {\n    mutexes[name] = createMutex(name, options);\n  }\n\n  return mutexes[name];\n};\n\nmodule.exports.Worker = function (script, Impl) {\n  Impl = Impl || global.Worker;\n  let worker;\n\n  try {\n    worker = new Impl(script);\n  } catch (error) {\n    if (error.message.includes('not a constructor')) {\n      worker = Impl(script);\n    }\n  }\n\n  if (!worker) {\n    throw new Error('Could not create Worker from', Impl);\n  }\n\n  observe(worker);\n  return worker;\n};","map":null,"metadata":{},"sourceType":"script"}