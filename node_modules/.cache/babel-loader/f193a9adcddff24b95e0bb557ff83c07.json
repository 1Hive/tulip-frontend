{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar protobuf = require('protons');\n\nvar keysPBM = protobuf(require('./keys.proto'));\n\nrequire('node-forge/lib/asn1');\n\nrequire('node-forge/lib/pbe');\n\nvar forge = require('node-forge/lib/forge');\n\nvar errcode = require('err-code');\n\nvar importer = require('./importer');\n\nexports = module.exports;\nvar supportedKeys = {\n  rsa: require('./rsa-class'),\n  ed25519: require('./ed25519-class'),\n  secp256k1: require('./secp256k1-class')(keysPBM, require('../random-bytes'))\n};\nexports.supportedKeys = supportedKeys;\nexports.keysPBM = keysPBM;\nvar ErrMissingSecp256K1 = {\n  message: 'secp256k1 support requires libp2p-crypto-secp256k1 package',\n  code: 'ERR_MISSING_PACKAGE'\n};\n\nfunction typeToKey(type) {\n  var key = supportedKeys[type.toLowerCase()];\n\n  if (!key) {\n    var supported = Object.keys(supportedKeys).join(' / ');\n    throw errcode(new Error(\"invalid or unsupported key type \".concat(type, \". Must be \").concat(supported)), 'ERR_UNSUPPORTED_KEY_TYPE');\n  }\n\n  return key;\n}\n\nexports.keyStretcher = require('./key-stretcher');\nexports.generateEphemeralKeyPair = require('./ephemeral-keys'); // Generates a keypair of the given type and bitsize\n\nexports.generateKeyPair = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(type, bits) {\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            return _context.abrupt(\"return\", typeToKey(type).generateKeyPair(bits));\n\n          case 1:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function (_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}(); // Generates a keypair of the given type and bitsize\n// seed is a 32 byte uint8array\n\n\nexports.generateKeyPairFromSeed = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(type, seed, bits) {\n    var key;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            // eslint-disable-line require-await\n            key = typeToKey(type);\n\n            if (!(type.toLowerCase() !== 'ed25519')) {\n              _context2.next = 3;\n              break;\n            }\n\n            throw errcode(new Error('Seed key derivation is unimplemented for RSA or secp256k1'), 'ERR_UNSUPPORTED_KEY_DERIVATION_TYPE');\n\n          case 3:\n            return _context2.abrupt(\"return\", key.generateKeyPairFromSeed(seed, bits));\n\n          case 4:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function (_x3, _x4, _x5) {\n    return _ref2.apply(this, arguments);\n  };\n}(); // Converts a protobuf serialized public key into its\n// representative object\n\n\nexports.unmarshalPublicKey = function (buf) {\n  var decoded = keysPBM.PublicKey.decode(buf);\n  var data = decoded.Data;\n\n  switch (decoded.Type) {\n    case keysPBM.KeyType.RSA:\n      return supportedKeys.rsa.unmarshalRsaPublicKey(data);\n\n    case keysPBM.KeyType.Ed25519:\n      return supportedKeys.ed25519.unmarshalEd25519PublicKey(data);\n\n    case keysPBM.KeyType.Secp256k1:\n      if (supportedKeys.secp256k1) {\n        return supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(data);\n      } else {\n        throw errcode(new Error(ErrMissingSecp256K1.message), ErrMissingSecp256K1.code);\n      }\n\n    default:\n      typeToKey(decoded.Type);\n    // throws because type is not supported\n  }\n}; // Converts a public key object into a protobuf serialized public key\n\n\nexports.marshalPublicKey = function (key, type) {\n  type = (type || 'rsa').toLowerCase();\n  typeToKey(type); // check type\n\n  return key.bytes;\n}; // Converts a protobuf serialized private key into its\n// representative object\n\n\nexports.unmarshalPrivateKey = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(buf) {\n    var decoded, data;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            // eslint-disable-line require-await\n            decoded = keysPBM.PrivateKey.decode(buf);\n            data = decoded.Data;\n            _context3.t0 = decoded.Type;\n            _context3.next = _context3.t0 === keysPBM.KeyType.RSA ? 5 : _context3.t0 === keysPBM.KeyType.Ed25519 ? 6 : _context3.t0 === keysPBM.KeyType.Secp256k1 ? 7 : 12;\n            break;\n\n          case 5:\n            return _context3.abrupt(\"return\", supportedKeys.rsa.unmarshalRsaPrivateKey(data));\n\n          case 6:\n            return _context3.abrupt(\"return\", supportedKeys.ed25519.unmarshalEd25519PrivateKey(data));\n\n          case 7:\n            if (!supportedKeys.secp256k1) {\n              _context3.next = 11;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(data));\n\n          case 11:\n            throw errcode(new Error(ErrMissingSecp256K1.message), ErrMissingSecp256K1.code);\n\n          case 12:\n            typeToKey(decoded.Type);\n\n          case 13:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function (_x6) {\n    return _ref3.apply(this, arguments);\n  };\n}(); // Converts a private key object into a protobuf serialized private key\n\n\nexports.marshalPrivateKey = function (key, type) {\n  type = (type || 'rsa').toLowerCase();\n  typeToKey(type); // check type\n\n  return key.bytes;\n};\n/**\n *\n * @param {string} encryptedKey\n * @param {string} password\n */\n\n\nexports.import = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(encryptedKey, password) {\n    var _key, key, der;\n\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.prev = 0;\n            _context4.next = 3;\n            return importer.import(encryptedKey, password);\n\n          case 3:\n            _key = _context4.sent;\n            return _context4.abrupt(\"return\", exports.unmarshalPrivateKey(_key));\n\n          case 7:\n            _context4.prev = 7;\n            _context4.t0 = _context4[\"catch\"](0);\n\n          case 9:\n            // Only rsa supports pem right now\n            key = forge.pki.decryptRsaPrivateKey(encryptedKey, password);\n\n            if (!(key === null)) {\n              _context4.next = 12;\n              break;\n            }\n\n            throw errcode(new Error('Cannot read the key, most likely the password is wrong or not a RSA key'), 'ERR_CANNOT_DECRYPT_PEM');\n\n          case 12:\n            der = forge.asn1.toDer(forge.pki.privateKeyToAsn1(key));\n            der = Buffer.from(der.getBytes(), 'binary');\n            return _context4.abrupt(\"return\", supportedKeys.rsa.unmarshalRsaPrivateKey(der));\n\n          case 15:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4, null, [[0, 7]]);\n  }));\n\n  return function (_x7, _x8) {\n    return _ref4.apply(this, arguments);\n  };\n}();","map":null,"metadata":{},"sourceType":"script"}