{"ast":null,"code":"'use strict';\n\nconst AbortController = require('abort-controller');\n\nconst anySignal = require('any-signal');\n\nconst debug = require('debug');\n\nconst errCode = require('err-code');\n\nconst log = debug('libp2p:dialer:request');\nlog.error = debug('libp2p:dialer:request:error');\n\nconst FIFO = require('p-fifo');\n\nconst pAny = require('p-any');\n\nclass DialRequest {\n  /**\n   * Manages running the `dialAction` on multiple provided `addrs` in parallel\n   * up to a maximum determined by the number of tokens returned\n   * from `dialer.getTokens`. Once a DialRequest is created, it can be\n   * started using `DialRequest.run(options)`. Once a single dial has succeeded,\n   * all other dials in the request will be cancelled.\n   * @param {object} options\n   * @param {Multiaddr[]} options.addrs\n   * @param {function(Multiaddr):Promise<Connection>} options.dialAction\n   * @param {Dialer} options.dialer\n   */\n  constructor({\n    addrs,\n    dialAction,\n    dialer\n  }) {\n    this.addrs = addrs;\n    this.dialer = dialer;\n    this.dialAction = dialAction;\n  }\n  /**\n   * @async\n   * @param {object} options\n   * @param {AbortSignal} options.signal An AbortController signal\n   * @returns {Connection}\n   */\n\n\n  async run(options) {\n    const tokens = this.dialer.getTokens(this.addrs.length); // If no tokens are available, throw\n\n    if (tokens.length < 1) {\n      throw errCode(new Error('No dial tokens available'), 'ERR_NO_DIAL_TOKENS');\n    }\n\n    const tokenHolder = new FIFO();\n    tokens.forEach(token => tokenHolder.push(token));\n    const dialAbortControllers = this.addrs.map(() => new AbortController());\n    let completedDials = 0;\n\n    try {\n      return await pAny(this.addrs.map(async (addr, i) => {\n        const token = await tokenHolder.shift(); // get token\n\n        let conn;\n\n        try {\n          const signal = dialAbortControllers[i].signal;\n          conn = await this.dialAction(addr, { ...options,\n            signal: anySignal([signal, options.signal])\n          }); // Remove the successful AbortController so it is not aborted\n\n          dialAbortControllers.splice(i, 1);\n        } finally {\n          completedDials++; // If we have more or equal dials remaining than tokens, recycle the token, otherwise release it\n\n          if (this.addrs.length - completedDials >= tokens.length) {\n            tokenHolder.push(token);\n          } else {\n            this.dialer.releaseToken(tokens.splice(tokens.indexOf(token), 1)[0]);\n          }\n        }\n\n        return conn;\n      }));\n    } finally {\n      dialAbortControllers.map(c => c.abort()); // success/failure happened, abort everything else\n\n      tokens.forEach(token => this.dialer.releaseToken(token)); // release tokens back to the dialer\n    }\n  }\n\n}\n\nmodule.exports.DialRequest = DialRequest;","map":null,"metadata":{},"sourceType":"script"}