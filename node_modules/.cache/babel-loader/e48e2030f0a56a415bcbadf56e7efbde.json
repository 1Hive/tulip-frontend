{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar PeerInfo = require('peer-info');\n\nvar PeerId = require('peer-id');\n\nvar protons = require('protons');\n\nvar _require = require('libp2p-record'),\n    Record = _require.Record;\n\nvar _require2 = require('buffer'),\n    Buffer = _require2.Buffer;\n\nvar pbm = protons(require('./dht.proto'));\nvar MESSAGE_TYPE = pbm.Message.MessageType;\nvar CONNECTION_TYPE = pbm.Message.ConnectionType;\n/**\n * Represents a single DHT control message.\n */\n\nvar Message = /*#__PURE__*/function () {\n  /**\n   * @param {MessageType} type\n   * @param {Buffer} key\n   * @param {number} level\n   */\n  function Message(type, key, level) {\n    _classCallCheck(this, Message);\n\n    if (key && !Buffer.isBuffer(key)) {\n      throw new Error('Key must be a buffer');\n    }\n\n    this.type = type;\n    this.key = key;\n    this._clusterLevelRaw = level;\n    this.closerPeers = [];\n    this.providerPeers = [];\n    this.record = null;\n  }\n  /**\n   * @type {number}\n   */\n\n\n  _createClass(Message, [{\n    key: \"clusterLevel\",\n    get: function get() {\n      var level = this._clusterLevelRaw - 1;\n\n      if (level < 0) {\n        return 0;\n      }\n\n      return level;\n    },\n    set: function set(level) {\n      this._clusterLevelRaw = level;\n    }\n    /**\n     * Encode into protobuf\n     * @returns {Buffer}\n     */\n\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      var obj = {\n        key: this.key,\n        type: this.type,\n        clusterLevelRaw: this._clusterLevelRaw,\n        closerPeers: this.closerPeers.map(toPbPeer),\n        providerPeers: this.providerPeers.map(toPbPeer)\n      };\n\n      if (this.record) {\n        if (Buffer.isBuffer(this.record)) {\n          obj.record = this.record;\n        } else {\n          obj.record = this.record.serialize();\n        }\n      }\n\n      return pbm.Message.encode(obj);\n    }\n    /**\n     * Decode from protobuf\n     *\n     * @param {Buffer} raw\n     * @returns {Message}\n     */\n\n  }], [{\n    key: \"deserialize\",\n    value: function deserialize(raw) {\n      var dec = pbm.Message.decode(raw);\n      var msg = new Message(dec.type, dec.key, dec.clusterLevelRaw);\n      msg.closerPeers = dec.closerPeers.map(fromPbPeer);\n      msg.providerPeers = dec.providerPeers.map(fromPbPeer);\n\n      if (dec.record) {\n        msg.record = Record.deserialize(dec.record);\n      }\n\n      return msg;\n    }\n  }]);\n\n  return Message;\n}();\n\nMessage.TYPES = MESSAGE_TYPE;\nMessage.CONNECTION_TYPES = CONNECTION_TYPE;\n\nfunction toPbPeer(peer) {\n  var res = {\n    id: peer.id.id,\n    addrs: peer.multiaddrs.toArray().map(function (m) {\n      return m.buffer;\n    })\n  };\n\n  if (peer.isConnected()) {\n    res.connection = CONNECTION_TYPE.CONNECTED;\n  } else {\n    res.connection = CONNECTION_TYPE.NOT_CONNECTED;\n  }\n\n  return res;\n}\n\nfunction fromPbPeer(peer) {\n  var info = new PeerInfo(new PeerId(peer.id));\n  peer.addrs.forEach(function (a) {\n    return info.multiaddrs.add(a);\n  });\n  return info;\n}\n\nmodule.exports = Message;","map":null,"metadata":{},"sourceType":"script"}