{"ast":null,"code":"'use strict';\n\nconst NanoDate = require('timestamp-nano');\n\nconst {\n  Key\n} = require('interface-datastore');\n\nconst crypto = require('libp2p-crypto');\n\nconst PeerId = require('peer-id');\n\nconst multihash = require('multihashes');\n\nconst errCode = require('err-code');\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst multibase = require('multibase');\n\nconst debug = require('debug');\n\nconst log = debug('jsipns');\nlog.error = debug('jsipns:error');\n\nconst ipnsEntryProto = require('./pb/ipns.proto');\n\nconst {\n  parseRFC3339\n} = require('./utils');\n\nconst ERRORS = require('./errors');\n\nconst ID_MULTIHASH_CODE = multihash.names.id;\nconst namespace = '/ipns/';\n/**\n * IPNS entry\n * @typedef {Object} IpnsEntry\n * @property {string} value - value to be stored in the record\n * @property {Buffer} signature - signature of the record\n * @property {number} validityType - Type of validation being used\n * @property {string} validity - expiration datetime for the record in RFC3339 format\n * @property {number} sequence - number representing the version of the record\n */\n\n/**\n * Creates a new ipns entry and signs it with the given private key.\n * The ipns entry validity should follow the [RFC3339]{@link https://www.ietf.org/rfc/rfc3339.txt} with nanoseconds precision.\n * Note: This function does not embed the public key. If you want to do that, use `EmbedPublicKey`.\n *\n * @param {Object} privateKey private key for signing the record.\n * @param {string} value value to be stored in the record.\n * @param {number} seq number representing the current version of the record.\n * @param {number|string} lifetime lifetime of the record (in milliseconds).\n * @returns {Promise<IpnsEntry>} entry\n */\n\nconst create = (privateKey, value, seq, lifetime) => {\n  // Validity in ISOString with nanoseconds precision and validity type EOL\n  const isoValidity = new NanoDate(Date.now() + Number(lifetime)).toString();\n  const validityType = ipnsEntryProto.ValidityType.EOL;\n  return _create(privateKey, value, seq, isoValidity, validityType);\n};\n/**\n * Same as create(), but instead of generating a new Date, it receives the intended expiration time\n * WARNING: nano precision is not standard, make sure the value in seconds is 9 orders of magnitude lesser than the one provided.\n * @param {Object} privateKey private key for signing the record.\n * @param {string} value value to be stored in the record.\n * @param {number} seq number representing the current version of the record.\n * @param {string} expiration expiration datetime for record in the [RFC3339]{@link https://www.ietf.org/rfc/rfc3339.txt} with nanoseconds precision.\n * @returns {Promise<IpnsEntry>} entry\n */\n\n\nconst createWithExpiration = (privateKey, value, seq, expiration) => {\n  const validityType = ipnsEntryProto.ValidityType.EOL;\n  return _create(privateKey, value, seq, expiration, validityType);\n};\n\nconst _create = async (privateKey, value, seq, isoValidity, validityType) => {\n  const signature = await sign(privateKey, value, validityType, isoValidity);\n  const entry = {\n    value: value,\n    signature: signature,\n    validityType: validityType,\n    validity: isoValidity,\n    sequence: seq\n  };\n  log(`ipns entry for ${value} created`);\n  return entry;\n};\n/**\n * Validates the given ipns entry against the given public key.\n *\n * @param {Object} publicKey public key for validating the record.\n * @param {IpnsEntry} entry ipns entry record.\n * @returns {Promise}\n */\n\n\nconst validate = async (publicKey, entry) => {\n  const {\n    value,\n    validityType,\n    validity\n  } = entry;\n  const dataForSignature = ipnsEntryDataForSig(value, validityType, validity); // Validate Signature\n\n  let isValid;\n\n  try {\n    isValid = await publicKey.verify(dataForSignature, entry.signature);\n  } catch (err) {\n    isValid = false;\n  }\n\n  if (!isValid) {\n    log.error('record signature verification failed');\n    throw errCode(new Error('record signature verification failed'), ERRORS.ERR_SIGNATURE_VERIFICATION);\n  } // Validate according to the validity type\n\n\n  if (validityType === ipnsEntryProto.ValidityType.EOL) {\n    let validityDate;\n\n    try {\n      validityDate = parseRFC3339(validity.toString());\n    } catch (e) {\n      log.error('unrecognized validity format (not an rfc3339 format)');\n      throw errCode(new Error('unrecognized validity format (not an rfc3339 format)'), ERRORS.ERR_UNRECOGNIZED_FORMAT);\n    }\n\n    if (validityDate < Date.now()) {\n      log.error('record has expired');\n      throw errCode(new Error('record has expired'), ERRORS.ERR_IPNS_EXPIRED_RECORD);\n    }\n  } else if (validityType) {\n    log.error('unrecognized validity type');\n    throw errCode(new Error('unrecognized validity type'), ERRORS.ERR_UNRECOGNIZED_VALIDITY);\n  }\n\n  log(`ipns entry for ${value} is valid`);\n};\n/**\n * Embed the given public key in the given entry. While not strictly required,\n * some nodes (eg. DHT servers) may reject IPNS entries that don't embed their\n * public keys as they may not be able to validate them efficiently.\n * As a consequence of nodes needing to validade a record upon receipt, they need\n * the public key associated with it. For olde RSA keys, it is easier if we just\n * send this as part of the record itself. For newer ed25519 keys, the public key\n * can be embedded in the peerId.\n *\n * @param {Object} publicKey public key to embed.\n * @param {Object} entry ipns entry record.\n * @return {IpnsEntry} entry with public key embedded\n */\n\n\nconst embedPublicKey = async (publicKey, entry) => {\n  if (!publicKey || !publicKey.bytes || !entry) {\n    const error = new Error('one or more of the provided parameters are not defined');\n    log.error(error);\n    throw errCode(error, ERRORS.ERR_UNDEFINED_PARAMETER);\n  } // Create a peer id from the public key.\n\n\n  let peerId;\n\n  try {\n    peerId = await PeerId.createFromPubKey(publicKey.bytes);\n  } catch (err) {\n    throw errCode(err, ERRORS.ERR_PEER_ID_FROM_PUBLIC_KEY);\n  } // Try to extract the public key from the ID. If we can, no need to embed it\n\n\n  let extractedPublicKey;\n\n  try {\n    extractedPublicKey = extractPublicKeyFromId(peerId);\n  } catch (err) {\n    log.error(err);\n    throw errCode(err, ERRORS.ERR_PUBLIC_KEY_FROM_ID);\n  }\n\n  if (extractedPublicKey) {\n    return null;\n  } // If we failed to extract the public key from the peer ID, embed it in the record.\n\n\n  try {\n    entry.pubKey = crypto.keys.marshalPublicKey(publicKey);\n  } catch (err) {\n    log.error(err);\n    throw err;\n  }\n\n  return entry;\n};\n/**\n * Extracts a public key matching `pid` from the ipns record.\n *\n * @param {Object} peerId peer identifier object.\n * @param {IpnsEntry} entry ipns entry record.\n * @returns {Object} the public key\n */\n\n\nconst extractPublicKey = (peerId, entry) => {\n  if (!entry || !peerId) {\n    const error = new Error('one or more of the provided parameters are not defined');\n    log.error(error);\n    throw errCode(error, ERRORS.ERR_UNDEFINED_PARAMETER);\n  }\n\n  if (entry.pubKey) {\n    let pubKey;\n\n    try {\n      pubKey = crypto.keys.unmarshalPublicKey(entry.pubKey);\n    } catch (err) {\n      log.error(err);\n      throw err;\n    }\n\n    return pubKey;\n  }\n\n  if (peerId.pubKey) {\n    return peerId.pubKey;\n  }\n\n  throw Object.assign(new Error('no public key is available'), {\n    code: ERRORS.ERR_UNDEFINED_PARAMETER\n  });\n}; // rawStdEncoding with RFC4648\n\n\nconst rawStdEncoding = key => multibase.encode('base32', key).toString().slice(1).toUpperCase();\n/**\n * Get key for storing the record locally.\n * Format: /ipns/${base32(<HASH>)}\n *\n * @param {Buffer} key peer identifier object.\n * @returns {string}\n */\n\n\nconst getLocalKey = key => new Key(`/ipns/${rawStdEncoding(key)}`);\n/**\n * Get key for sharing the record in the routing mechanism.\n * Format: ${base32(/ipns/<HASH>)}, ${base32(/pk/<HASH>)}\n *\n * @param {Buffer} pid peer identifier represented by the multihash of the public key as Buffer.\n * @returns {Object} containing the `nameKey` and the `ipnsKey`.\n */\n\n\nconst getIdKeys = pid => {\n  const pkBuffer = Buffer.from('/pk/');\n  const ipnsBuffer = Buffer.from('/ipns/');\n  return {\n    routingPubKey: new Key(Buffer.concat([pkBuffer, pid]), false),\n    // Added on https://github.com/ipfs/js-ipns/pull/8#issue-213857876 (pkKey will be deprecated in a future release)\n    pkKey: new Key(rawStdEncoding(Buffer.concat([pkBuffer, pid]))),\n    routingKey: new Key(Buffer.concat([ipnsBuffer, pid]), false),\n    // Added on https://github.com/ipfs/js-ipns/pull/6#issue-213631461 (ipnsKey will be deprecated in a future release)\n    ipnsKey: new Key(rawStdEncoding(Buffer.concat([ipnsBuffer, pid])))\n  };\n}; // Sign ipns record data\n\n\nconst sign = (privateKey, value, validityType, validity) => {\n  try {\n    const dataForSignature = ipnsEntryDataForSig(value, validityType, validity);\n    return privateKey.sign(dataForSignature);\n  } catch (error) {\n    log.error('record signature creation failed');\n    throw errCode(new Error('record signature creation failed: ' + error.message), ERRORS.ERR_SIGNATURE_CREATION);\n  }\n}; // Utility for getting the validity type code name of a validity\n\n\nconst getValidityType = validityType => {\n  if (validityType.toString() === '0') {\n    return 'EOL';\n  }\n\n  const error = new Error(`unrecognized validity type ${validityType.toString()}`);\n  log.error(error);\n  throw errCode(error, ERRORS.ERR_UNRECOGNIZED_VALIDITY);\n}; // Utility for creating the record data for being signed\n\n\nconst ipnsEntryDataForSig = (value, validityType, validity) => {\n  const valueBuffer = Buffer.from(value);\n  const validityTypeBuffer = Buffer.from(getValidityType(validityType));\n  const validityBuffer = Buffer.from(validity);\n  return Buffer.concat([valueBuffer, validityBuffer, validityTypeBuffer]);\n}; // Utility for extracting the public key from a peer-id\n\n\nconst extractPublicKeyFromId = peerId => {\n  const decodedId = multihash.decode(peerId.id);\n\n  if (decodedId.code !== ID_MULTIHASH_CODE) {\n    return null;\n  }\n\n  return crypto.keys.unmarshalPublicKey(decodedId.digest);\n};\n\nconst marshal = ipnsEntryProto.encode;\nconst unmarshal = ipnsEntryProto.decode;\nconst validator = {\n  validate: async (marshalledData, key) => {\n    const receivedEntry = unmarshal(marshalledData);\n    const bufferId = key.slice('/ipns/'.length);\n    const peerId = PeerId.createFromBytes(bufferId); // extract public key\n\n    const pubKey = extractPublicKey(peerId, receivedEntry); // Record validation\n\n    await validate(pubKey, receivedEntry);\n    return true;\n  },\n  select: (dataA, dataB) => {\n    const entryA = unmarshal(dataA);\n    const entryB = unmarshal(dataB);\n    return entryA.sequence > entryB.sequence ? 0 : 1;\n  }\n};\nmodule.exports = {\n  // create ipns entry record\n  create,\n  // create ipns entry record specifying the expiration time\n  createWithExpiration,\n  // validate ipns entry record\n  validate,\n  // embed public key in the record\n  embedPublicKey,\n  // extract public key from the record\n  extractPublicKey,\n  // get key for storing the entry locally\n  getLocalKey,\n  // get keys for routing\n  getIdKeys,\n  // marshal\n  marshal,\n  // unmarshal\n  unmarshal,\n  // validator\n  validator,\n  // namespace\n  namespace,\n  namespaceLength: namespace.length\n};","map":null,"metadata":{},"sourceType":"script"}