{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _createForOfIteratorHelper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar defaultMigrations = require('../migrations');\n\nvar repoVersion = require('./repo/version');\n\nvar repoLock = require('./repo/lock');\n\nvar errors = require('./errors');\n\nvar log = require('debug')('repo-migrations:migrator');\n\nexports.getCurrentRepoVersion = repoVersion.getVersion;\nexports.errors = errors;\n/**\n * Returns the version of latest migration.\n * If no migrations are present returns 0.\n *\n * @param {array?} migrations - Array of migrations to consider. If undefined, the bundled migrations are used. Mainly for testing purpose.\n * @returns {int}\n */\n\nfunction getLatestMigrationVersion(migrations) {\n  migrations = migrations || defaultMigrations;\n\n  if (!Array.isArray(migrations) || migrations.length === 0) {\n    return 0;\n  }\n\n  return migrations[migrations.length - 1].version;\n}\n\nexports.getLatestMigrationVersion = getLatestMigrationVersion;\n/**\n * Main function to execute forward migrations.\n * It acquire lock on the provided path before doing any migrations.\n *\n * Signature of the progress callback is: function(migrationObject: object, currentMigrationNumber: int, totalMigrationsCount: int)\n *\n * @param {string} path - Path to initialized (!) JS-IPFS repo\n * @param {int} toVersion - Version to which the repo should be migrated.\n * @param {Object} options - Options for migration\n * @param {boolean?} options.ignoreLock - Won't lock the repo for applying the migrations. Use with caution.\n * @param {object?} options.repoOptions - Options that are passed to migrations, that can use them to correctly construct datastore. Options are same like for IPFSRepo.\n * @param {function?} options.onProgress - Callback which will be called after each executed migration to report progress\n * @param {boolean?} options.isDryRun - Allows to simulate the execution of the migrations without any effect.\n * @param {array?} options.migrations - Array of migrations to migrate. If undefined, the bundled migrations are used. Mainly for testing purpose.\n * @returns {Promise<void>}\n */\n\nfunction migrate(_x, _x2, _x3) {\n  return _migrate.apply(this, arguments);\n}\n\nfunction _migrate() {\n  _migrate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(path, toVersion, _ref) {\n    var _ref$ignoreLock, ignoreLock, repoOptions, onProgress, _ref$isDryRun, isDryRun, migrations, currentVersion, lock, counter, totalMigrations, _iterator2, _step2, migration, lastSuccessfullyMigratedVersion;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _ref$ignoreLock = _ref.ignoreLock, ignoreLock = _ref$ignoreLock === void 0 ? false : _ref$ignoreLock, repoOptions = _ref.repoOptions, onProgress = _ref.onProgress, _ref$isDryRun = _ref.isDryRun, isDryRun = _ref$isDryRun === void 0 ? false : _ref$isDryRun, migrations = _ref.migrations;\n            migrations = migrations || defaultMigrations;\n\n            onProgress = onProgress || function () {};\n\n            if (path) {\n              _context.next = 5;\n              break;\n            }\n\n            throw new errors.RequiredParameterError('Path argument is required!');\n\n          case 5:\n            if (toVersion) {\n              _context.next = 7;\n              break;\n            }\n\n            throw new errors.RequiredParameterError('toVersion argument is required!');\n\n          case 7:\n            if (!(!Number.isInteger(toVersion) || toVersion <= 0)) {\n              _context.next = 9;\n              break;\n            }\n\n            throw new errors.InvalidValueError('Version has to be positive integer!');\n\n          case 9:\n            _context.next = 11;\n            return repoVersion.getVersion(path);\n\n          case 11:\n            currentVersion = _context.sent;\n\n            if (!(currentVersion === toVersion)) {\n              _context.next = 15;\n              break;\n            }\n\n            log('Nothing to migrate.');\n            return _context.abrupt(\"return\");\n\n          case 15:\n            if (!(currentVersion > toVersion)) {\n              _context.next = 17;\n              break;\n            }\n\n            throw new errors.InvalidValueError(\"Current repo's version (\".concat(currentVersion, \") is higher then toVersion (\").concat(toVersion, \"), you probably wanted to revert it?\"));\n\n          case 17:\n            verifyAvailableMigrations(migrations, currentVersion, toVersion);\n\n            if (!(!isDryRun && !ignoreLock)) {\n              _context.next = 22;\n              break;\n            }\n\n            _context.next = 21;\n            return repoLock.lock(currentVersion, path);\n\n          case 21:\n            lock = _context.sent;\n\n          case 22:\n            _context.prev = 22;\n            counter = 0;\n            totalMigrations = toVersion - currentVersion;\n            _iterator2 = _createForOfIteratorHelper(migrations);\n            _context.prev = 26;\n\n            _iterator2.s();\n\n          case 28:\n            if ((_step2 = _iterator2.n()).done) {\n              _context.next = 54;\n              break;\n            }\n\n            migration = _step2.value;\n\n            if (!(toVersion !== undefined && migration.version > toVersion)) {\n              _context.next = 32;\n              break;\n            }\n\n            return _context.abrupt(\"break\", 54);\n\n          case 32:\n            if (!(migration.version <= currentVersion)) {\n              _context.next = 34;\n              break;\n            }\n\n            return _context.abrupt(\"continue\", 52);\n\n          case 34:\n            counter++;\n            log(\"Migrating version \".concat(migration.version));\n            _context.prev = 36;\n\n            if (isDryRun) {\n              _context.next = 40;\n              break;\n            }\n\n            _context.next = 40;\n            return migration.migrate(path, repoOptions);\n\n          case 40:\n            _context.next = 50;\n            break;\n\n          case 42:\n            _context.prev = 42;\n            _context.t0 = _context[\"catch\"](36);\n            lastSuccessfullyMigratedVersion = migration.version - 1;\n            log(\"An exception was raised during execution of migration. Setting the repo's version to last successfully migrated version: \".concat(lastSuccessfullyMigratedVersion));\n            _context.next = 48;\n            return repoVersion.setVersion(path, lastSuccessfullyMigratedVersion);\n\n          case 48:\n            _context.t0.message = \"During migration to version \".concat(migration.version, \" exception was raised: \").concat(_context.t0.message);\n            throw _context.t0;\n\n          case 50:\n            onProgress(migration, counter, totalMigrations); // Reports on migration process\n\n            log(\"Migrating to version \".concat(migration.version, \" finished\"));\n\n          case 52:\n            _context.next = 28;\n            break;\n\n          case 54:\n            _context.next = 59;\n            break;\n\n          case 56:\n            _context.prev = 56;\n            _context.t1 = _context[\"catch\"](26);\n\n            _iterator2.e(_context.t1);\n\n          case 59:\n            _context.prev = 59;\n\n            _iterator2.f();\n\n            return _context.finish(59);\n\n          case 62:\n            if (isDryRun) {\n              _context.next = 65;\n              break;\n            }\n\n            _context.next = 65;\n            return repoVersion.setVersion(path, toVersion || getLatestMigrationVersion(migrations));\n\n          case 65:\n            log('Repo successfully migrated ', toVersion !== undefined ? \"to version \".concat(toVersion, \"!\") : 'to latest version!');\n\n          case 66:\n            _context.prev = 66;\n\n            if (!(!isDryRun && !ignoreLock)) {\n              _context.next = 70;\n              break;\n            }\n\n            _context.next = 70;\n            return lock.close();\n\n          case 70:\n            return _context.finish(66);\n\n          case 71:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[22,, 66, 71], [26, 56, 59, 62], [36, 42]]);\n  }));\n  return _migrate.apply(this, arguments);\n}\n\nexports.migrate = migrate;\n/**\n * Main function to execute backward migration (reversion).\n * It acquire lock on the provided path before doing any migrations.\n *\n * Signature of the progress callback is: function(migrationObject: object, currentMigrationNumber: int, totalMigrationsCount: int)\n *\n * @param {string} path - Path to initialized (!) JS-IPFS repo\n * @param {int} toVersion - Version to which the repo will be reverted.\n * @param {Object} options - Options for the reversion\n * @param {function?} options.onProgress - Callback which will be called after each reverted migration to report progress\n * @param {object?} options.repoOptions - Options that are passed to migrations, that can use them to correctly construct datastore. Options are same like for IPFSRepo.\n * @param {boolean?} options.isDryRun - Allows to simulate the execution of the reversion without any effects. Make sense to utilize onProgress with this argument.\n * @param {boolean?} options.ignoreLock - Won't lock the repo for reverting the migrations. Use with caution.\n * @param {array?} options.migrations - Array of migrations to migrate. If undefined, the bundled migrations are used. Mainly for testing purpose.\n * @returns {Promise<void>}\n */\n\nfunction revert(_x4, _x5, _x6) {\n  return _revert.apply(this, arguments);\n}\n\nfunction _revert() {\n  _revert = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(path, toVersion, _ref2) {\n    var _ref2$ignoreLock, ignoreLock, repoOptions, onProgress, _ref2$isDryRun, isDryRun, migrations, currentVersion, lock, counter, totalMigrations, reversedMigrationArray, _iterator3, _step3, migration, lastSuccessfullyRevertedVersion;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _ref2$ignoreLock = _ref2.ignoreLock, ignoreLock = _ref2$ignoreLock === void 0 ? false : _ref2$ignoreLock, repoOptions = _ref2.repoOptions, onProgress = _ref2.onProgress, _ref2$isDryRun = _ref2.isDryRun, isDryRun = _ref2$isDryRun === void 0 ? false : _ref2$isDryRun, migrations = _ref2.migrations;\n            migrations = migrations || defaultMigrations;\n\n            onProgress = onProgress || function () {};\n\n            if (path) {\n              _context2.next = 5;\n              break;\n            }\n\n            throw new errors.RequiredParameterError('Path argument is required!');\n\n          case 5:\n            if (toVersion) {\n              _context2.next = 7;\n              break;\n            }\n\n            throw new errors.RequiredParameterError('When reverting migrations, you have to specify to which version to revert!');\n\n          case 7:\n            if (!(!Number.isInteger(toVersion) || toVersion <= 0)) {\n              _context2.next = 9;\n              break;\n            }\n\n            throw new errors.InvalidValueError('Version has to be positive integer!');\n\n          case 9:\n            _context2.next = 11;\n            return repoVersion.getVersion(path);\n\n          case 11:\n            currentVersion = _context2.sent;\n\n            if (!(currentVersion === toVersion)) {\n              _context2.next = 15;\n              break;\n            }\n\n            log('Nothing to revert.');\n            return _context2.abrupt(\"return\");\n\n          case 15:\n            if (!(currentVersion < toVersion)) {\n              _context2.next = 17;\n              break;\n            }\n\n            throw new errors.InvalidValueError(\"Current repo's version (\".concat(currentVersion, \") is lower then toVersion (\").concat(toVersion, \"), you probably wanted to migrate it?\"));\n\n          case 17:\n            verifyAvailableMigrations(migrations, toVersion, currentVersion, true);\n\n            if (!(!isDryRun && !ignoreLock)) {\n              _context2.next = 22;\n              break;\n            }\n\n            _context2.next = 21;\n            return repoLock.lock(currentVersion, path);\n\n          case 21:\n            lock = _context2.sent;\n\n          case 22:\n            log(\"Reverting from version \".concat(currentVersion, \" to \").concat(toVersion));\n            _context2.prev = 23;\n            counter = 0;\n            totalMigrations = currentVersion - toVersion;\n            reversedMigrationArray = migrations.slice().reverse();\n            _iterator3 = _createForOfIteratorHelper(reversedMigrationArray);\n            _context2.prev = 28;\n\n            _iterator3.s();\n\n          case 30:\n            if ((_step3 = _iterator3.n()).done) {\n              _context2.next = 56;\n              break;\n            }\n\n            migration = _step3.value;\n\n            if (!(migration.version <= toVersion)) {\n              _context2.next = 34;\n              break;\n            }\n\n            return _context2.abrupt(\"break\", 56);\n\n          case 34:\n            if (!(migration.version > currentVersion)) {\n              _context2.next = 36;\n              break;\n            }\n\n            return _context2.abrupt(\"continue\", 54);\n\n          case 36:\n            counter++;\n            log(\"Reverting migration version \".concat(migration.version));\n            _context2.prev = 38;\n\n            if (isDryRun) {\n              _context2.next = 42;\n              break;\n            }\n\n            _context2.next = 42;\n            return migration.revert(path, repoOptions);\n\n          case 42:\n            _context2.next = 52;\n            break;\n\n          case 44:\n            _context2.prev = 44;\n            _context2.t0 = _context2[\"catch\"](38);\n            lastSuccessfullyRevertedVersion = migration.version;\n            log(\"An exception was raised during execution of migration. Setting the repo's version to last successfully reverted version: \".concat(lastSuccessfullyRevertedVersion));\n            _context2.next = 50;\n            return repoVersion.setVersion(path, lastSuccessfullyRevertedVersion);\n\n          case 50:\n            _context2.t0.message = \"During reversion to version \".concat(migration.version, \" exception was raised: \").concat(_context2.t0.message);\n            throw _context2.t0;\n\n          case 52:\n            onProgress(migration, counter, totalMigrations); // Reports on migration process\n\n            log(\"Reverting to version \".concat(migration.version, \" finished\"));\n\n          case 54:\n            _context2.next = 30;\n            break;\n\n          case 56:\n            _context2.next = 61;\n            break;\n\n          case 58:\n            _context2.prev = 58;\n            _context2.t1 = _context2[\"catch\"](28);\n\n            _iterator3.e(_context2.t1);\n\n          case 61:\n            _context2.prev = 61;\n\n            _iterator3.f();\n\n            return _context2.finish(61);\n\n          case 64:\n            if (isDryRun) {\n              _context2.next = 67;\n              break;\n            }\n\n            _context2.next = 67;\n            return repoVersion.setVersion(path, toVersion);\n\n          case 67:\n            log(\"All migrations successfully reverted to version \".concat(toVersion, \"!\"));\n\n          case 68:\n            _context2.prev = 68;\n\n            if (!(!isDryRun && !ignoreLock)) {\n              _context2.next = 72;\n              break;\n            }\n\n            _context2.next = 72;\n            return lock.close();\n\n          case 72:\n            return _context2.finish(68);\n\n          case 73:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[23,, 68, 73], [28, 58, 61, 64], [38, 44]]);\n  }));\n  return _revert.apply(this, arguments);\n}\n\nexports.revert = revert;\n/**\n * Function checks if all migrations in given range are available.\n *\n * @param {array} migrations\n * @param {int} fromVersion\n * @param {int} toVersion\n * @param {boolean} checkReversibility - Will additionally checks if all the migrations in the range are reversible\n * @returns {void}\n */\n\nfunction verifyAvailableMigrations(migrations, fromVersion, toVersion) {\n  var checkReversibility = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var migrationCounter = 0;\n\n  var _iterator = _createForOfIteratorHelper(migrations),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var migration = _step.value;\n\n      if (migration.version > toVersion) {\n        break;\n      }\n\n      if (migration.version > fromVersion) {\n        if (checkReversibility && !migration.revert) {\n          throw new errors.NonReversibleMigrationError(\"It is not possible to revert to version \".concat(fromVersion, \" because migration version \").concat(migration.version, \" is not reversible. Cancelling reversion.\"));\n        }\n\n        migrationCounter++;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (migrationCounter !== toVersion - fromVersion) {\n    throw new errors.InvalidValueError(\"The ipfs-repo-migrations package does not have all migration to migrate from version \".concat(fromVersion, \" to \").concat(toVersion));\n  }\n}","map":null,"metadata":{},"sourceType":"script"}