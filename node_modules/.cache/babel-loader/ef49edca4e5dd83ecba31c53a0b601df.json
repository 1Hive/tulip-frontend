{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _constants = require(\"../constants\");\n\nvar _utils = require(\"../utils\");\n\nvar _wallet = require(\"@ethersproject/wallet\");\n\nvar _contracts = require(\"@ethersproject/contracts\");\n\nvar providers = _interopRequireWildcard(require(\"@ethersproject/providers\"));\n\nvar _jsSha = require(\"js-sha256\");\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nconst ERC1271_ABI = ['function isValidSignature(bytes _messageHash, bytes _signature) public view returns (bytes4 magicValue)'];\nconst MAGIC_ERC1271_VALUE = '0x20c13b0b';\n\nconst isEthAddress = address => /^0x[a-fA-F0-9]{40}$/.test(address);\n\nfunction getEthersProvider(chainId) {\n  const network = providers.getNetwork(chainId);\n  if (!network._defaultProvider) throw new Error(`Network with chainId ${chainId} is not supported`);\n  return network._defaultProvider(providers);\n}\n\nasync function getChainId(provider) {\n  const payload = (0, _utils.encodeRpcCall)('eth_chainId', []);\n  const chainIdHex = await safeSend(payload, provider);\n  return parseInt(chainIdHex, 16);\n}\n\nasync function getCode(address, provider) {\n  const payload = (0, _utils.encodeRpcCall)('eth_getCode', [address, 'latest']);\n  const code = await safeSend(payload, provider);\n  return code;\n}\n\nasync function safeSend(data, provider) {\n  const send = (Boolean(provider.sendAsync) ? provider.sendAsync : provider.send).bind(provider);\n  return new Promise((resolve, reject) => {\n    send(data, function (err, result) {\n      if (err) reject(err);else if (result.error) reject(result.error);else resolve(result.result);\n    });\n  });\n}\n\nasync function createEthLink(did, address, provider, opts = {}) {\n  const {\n    message,\n    timestamp\n  } = (0, _utils.getConsentMessage)(did, !opts.skipTimestamp);\n  const hexMessage = '0x' + Buffer.from(message, 'utf8').toString('hex');\n  const payload = (0, _utils.encodeRpcCall)('personal_sign', [hexMessage, address]);\n  const signature = await safeSend(payload, provider);\n  const proof = {\n    version: 1,\n    type: _constants.ADDRESS_TYPES.ethereumEOA,\n    message,\n    signature,\n    address\n  };\n  if (!opts.skipTimestamp) proof.timestamp = timestamp;\n  return proof;\n}\n\nasync function createErc1271Link(did, address, provider, opts) {\n  const res = await createEthLink(did, address, provider, opts);\n  const chainId = await getChainId(provider);\n  return Object.assign(res, {\n    type: _constants.ADDRESS_TYPES.erc1271,\n    chainId\n  });\n}\n\nasync function typeDetector(address) {\n  return isEthAddress(address) ? _constants.ADDRESS_TYPES.ethereum : false;\n}\n\nasync function isERC1271(address, provider) {\n  const bytecode = await getCode(address, provider).catch(() => null);\n  return bytecode && bytecode !== '0x' && bytecode !== '0x0' && bytecode !== '0x00';\n}\n\nasync function createLink(did, address, type, provider, opts) {\n  address = address.toLowerCase();\n\n  if (!(await isERC1271(address, provider))) {\n    return createEthLink(did, address, provider, opts);\n  } else {\n    return createErc1271Link(did, address, provider, opts);\n  }\n}\n\nasync function validateEoaLink(proof) {\n  const recoveredAddr = (0, _wallet.verifyMessage)(proof.message, proof.signature).toLowerCase();\n\n  if (proof.address && proof.address !== recoveredAddr) {\n    return null;\n  } else {\n    proof.address = recoveredAddr;\n  }\n\n  return proof;\n}\n\nasync function validateErc1271Link(proof) {\n  const provider = getEthersProvider(proof.chainId);\n  const contract = new _contracts.Contract(proof.address, ERC1271_ABI, provider);\n  const message = '0x' + Buffer.from(proof.message, 'utf8').toString('hex');\n  const returnValue = await contract.isValidSignature(message, proof.signature);\n  return returnValue === MAGIC_ERC1271_VALUE ? proof : null;\n}\n\nasync function validateLink(proof) {\n  if (proof.type === _constants.ADDRESS_TYPES.ethereumEOA) {\n    return validateEoaLink(proof);\n  } else if (proof.type === _constants.ADDRESS_TYPES.erc1271) {\n    return validateErc1271Link(proof);\n  }\n}\n\nasync function authenticate(message, address, provider) {\n  if (address) address = address.toLowerCase();\n  if (provider.isAuthereum) return provider.signMessageWithSigningKey(text);\n  const hexMessage = '0x' + Buffer.from(message, 'utf8').toString('hex');\n  const payload = (0, _utils.encodeRpcCall)('personal_sign', [hexMessage, address]);\n  const signature = await safeSend(payload, provider);\n\n  if (address) {\n    const recoveredAddr = (0, _wallet.verifyMessage)(message, signature).toLowerCase();\n    if (address !== recoveredAddr) throw new Error('Provider returned signature from different account than requested');\n  }\n\n  return `0x${(0, _jsSha.sha256)(signature.slice(2))}`;\n}\n\nvar _default = {\n  authenticate,\n  validateLink,\n  createLink,\n  typeDetector,\n  isERC1271\n};\nexports.default = _default;","map":null,"metadata":{},"sourceType":"script"}