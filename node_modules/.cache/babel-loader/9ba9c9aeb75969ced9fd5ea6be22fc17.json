{"ast":null,"code":"'use strict';\n\nconst debug = require('debug');\n\nconst errcode = require('err-code');\n\nconst mergeOptions = require('merge-options');\n\nconst CID = require('cids');\n\nconst isDomain = require('is-domain-name');\n\nconst log = debug('ipfs:name:resolve');\nlog.error = debug('ipfs:name:resolve:error');\n\nconst {\n  OFFLINE_ERROR,\n  withTimeoutOption\n} = require('../../utils');\n\nconst appendRemainder = async (result, remainder) => {\n  result = await result;\n\n  if (remainder.length) {\n    return result + '/' + remainder.join('/');\n  }\n\n  return result;\n};\n/**\n * @typedef { import(\"../index\") } IPFS\n */\n\n/**\n * IPNS - Inter-Planetary Naming System\n *\n * @param {IPFS} self\n * @returns {Object}\n */\n\n\nmodule.exports = ({\n  dns,\n  ipns,\n  peerInfo,\n  isOnline,\n  options: constructorOptions\n}) => {\n  /**\n   * Given a key, query the DHT for its best value.\n   *\n   * @param {String} name ipns name to resolve. Defaults to your node's peerID.\n   * @param {Object} options ipfs resolve options.\n   * @param {boolean} options.nocache do not use cached entries.\n   * @param {boolean} options.recursive resolve until the result is not an IPNS name.\n   * @param {function(Error)} [callback]\n   * @returns {Promise|void}\n   */\n  return withTimeoutOption(async function* resolve(name, options) {\n    // eslint-disable-line require-await\n    options = mergeOptions({\n      nocache: false,\n      recursive: true\n    }, options || {});\n    const {\n      offline\n    } = constructorOptions; // TODO: params related logic should be in the core implementation\n\n    if (offline && options.nocache) {\n      throw errcode(new Error('cannot specify both offline and nocache'), 'ERR_NOCACHE_AND_OFFLINE');\n    } // Set node id as name for being resolved, if it is not received\n\n\n    if (!name) {\n      name = peerInfo.id.toB58String();\n    }\n\n    if (!name.startsWith('/ipns/')) {\n      name = `/ipns/${name}`;\n    }\n\n    const [namespace, hash, ...remainder] = name.slice(1).split('/');\n\n    try {\n      new CID(hash); // eslint-disable-line no-new\n    } catch (err) {\n      // lets check if we have a domain ex. /ipns/ipfs.io and resolve with dns\n      if (isDomain(hash)) {\n        yield appendRemainder(dns(hash, options), remainder);\n        return;\n      }\n\n      log.error(err);\n      throw errcode(new Error('Invalid IPNS name'), 'ERR_IPNS_INVALID_NAME');\n    } // multihash is valid lets resolve with IPNS\n    // IPNS resolve needs a online daemon\n\n\n    if (!isOnline() && !offline) {\n      throw errcode(new Error(OFFLINE_ERROR), 'OFFLINE_ERROR');\n    } // TODO: convert ipns.resolve to return an iterator\n\n\n    yield appendRemainder(ipns.resolve(`/${namespace}/${hash}`, options), remainder);\n  });\n};","map":null,"metadata":{},"sourceType":"script"}