{"ast":null,"code":"/*!\n * chacha20.js - chacha20 for bcrypto\n * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Resources\n *   https://en.wikipedia.org/wiki/Chacha20\n *   https://tools.ietf.org/html/rfc7539#section-2\n *   https://cr.yp.to/chacha.html\n */\n'use strict';\n\nconst assert = require('../internal/assert');\n/*\n * Constants\n */\n\n\nconst BIG_ENDIAN = new Int8Array(new Int16Array([1]).buffer)[0] === 0;\n/**\n * ChaCha20\n */\n\nclass ChaCha20 {\n  /**\n   * Create a ChaCha20 context.\n   * @constructor\n   */\n  constructor() {\n    this.state = new Uint32Array(16);\n    this.stream = new Uint32Array(16);\n    this.bytes = new Uint8Array(this.stream.buffer);\n    this.pos = -1;\n    if (BIG_ENDIAN) this.bytes = Buffer.alloc(64);\n  }\n  /**\n   * Initialize chacha20 with a key, nonce, and counter.\n   * @param {Buffer} key\n   * @param {Buffer} nonce\n   * @param {Number} counter\n   */\n\n\n  init(key, nonce, counter) {\n    if (counter == null) counter = 0;\n    assert(Buffer.isBuffer(key));\n    assert(Buffer.isBuffer(nonce));\n    assert(Number.isSafeInteger(counter));\n    if (key.length !== 16 && key.length !== 32) throw new RangeError('Invalid key size.');\n\n    if (nonce.length >= 24) {\n      key = ChaCha20.derive(key, nonce.slice(0, 16));\n      nonce = nonce.slice(16);\n    }\n\n    this.state[0] = 0x61707865;\n    this.state[1] = key.length < 32 ? 0x3120646e : 0x3320646e;\n    this.state[2] = key.length < 32 ? 0x79622d36 : 0x79622d32;\n    this.state[3] = 0x6b206574;\n    this.state[4] = readU32(key, 0);\n    this.state[5] = readU32(key, 4);\n    this.state[6] = readU32(key, 8);\n    this.state[7] = readU32(key, 12);\n    this.state[8] = readU32(key, 16 % key.length);\n    this.state[9] = readU32(key, 20 % key.length);\n    this.state[10] = readU32(key, 24 % key.length);\n    this.state[11] = readU32(key, 28 % key.length);\n    this.state[12] = counter >>> 0;\n\n    if (nonce.length === 8) {\n      this.state[13] = counter / 0x100000000 >>> 0;\n      this.state[14] = readU32(nonce, 0);\n      this.state[15] = readU32(nonce, 4);\n    } else if (nonce.length === 12) {\n      this.state[13] = readU32(nonce, 0);\n      this.state[14] = readU32(nonce, 4);\n      this.state[15] = readU32(nonce, 8);\n    } else if (nonce.length === 16) {\n      this.state[12] = readU32(nonce, 0);\n      this.state[13] = readU32(nonce, 4);\n      this.state[14] = readU32(nonce, 8);\n      this.state[15] = readU32(nonce, 12);\n    } else {\n      throw new RangeError('Invalid nonce size.');\n    }\n\n    this.pos = 0;\n    return this;\n  }\n  /**\n   * Encrypt/decrypt data.\n   * @param {Buffer} data - Will be mutated.\n   * @returns {Buffer}\n   */\n\n\n  encrypt(data) {\n    assert(Buffer.isBuffer(data));\n    if (this.pos === -1) throw new Error('Context is not initialized.');\n\n    for (let i = 0; i < data.length; i++) {\n      if ((this.pos & 63) === 0) {\n        this._block();\n\n        this.pos = 0;\n      }\n\n      data[i] ^= this.bytes[this.pos++];\n    }\n\n    return data;\n  }\n  /**\n   * Stir the stream.\n   */\n\n\n  _block() {\n    for (let i = 0; i < 16; i++) this.stream[i] = this.state[i];\n\n    for (let i = 0; i < 10; i++) {\n      qround(this.stream, 0, 4, 8, 12);\n      qround(this.stream, 1, 5, 9, 13);\n      qround(this.stream, 2, 6, 10, 14);\n      qround(this.stream, 3, 7, 11, 15);\n      qround(this.stream, 0, 5, 10, 15);\n      qround(this.stream, 1, 6, 11, 12);\n      qround(this.stream, 2, 7, 8, 13);\n      qround(this.stream, 3, 4, 9, 14);\n    }\n\n    for (let i = 0; i < 16; i++) this.stream[i] += this.state[i];\n\n    if (BIG_ENDIAN) {\n      for (let i = 0; i < 16; i++) writeU32(this.bytes, this.stream[i], i * 4);\n    }\n\n    this.state[12] += 1;\n    if (this.state[12] === 0) this.state[13] += 1;\n  }\n  /**\n   * Destroy context.\n   */\n\n\n  destroy() {\n    for (let i = 0; i < 16; i++) {\n      this.state[i] = 0;\n      this.stream[i] = 0;\n    }\n\n    if (BIG_ENDIAN) {\n      for (let i = 0; i < 64; i++) this.bytes[i] = 0;\n    }\n\n    this.pos = -1;\n    return this;\n  }\n  /**\n   * Derive key with XChaCha20.\n   * @param {Buffer} key\n   * @param {Buffer} nonce\n   * @returns {Buffer}\n   */\n\n\n  static derive(key, nonce) {\n    assert(Buffer.isBuffer(key));\n    assert(Buffer.isBuffer(nonce));\n    if (key.length !== 16 && key.length !== 32) throw new RangeError('Invalid key size.');\n    if (nonce.length !== 16) throw new RangeError('Invalid nonce size.');\n    const state = new Uint32Array(16);\n    state[0] = 0x61707865;\n    state[1] = key.length < 32 ? 0x3120646e : 0x3320646e;\n    state[2] = key.length < 32 ? 0x79622d36 : 0x79622d32;\n    state[3] = 0x6b206574;\n    state[4] = readU32(key, 0);\n    state[5] = readU32(key, 4);\n    state[6] = readU32(key, 8);\n    state[7] = readU32(key, 12);\n    state[8] = readU32(key, 16 % key.length);\n    state[9] = readU32(key, 20 % key.length);\n    state[10] = readU32(key, 24 % key.length);\n    state[11] = readU32(key, 28 % key.length);\n    state[12] = readU32(nonce, 0);\n    state[13] = readU32(nonce, 4);\n    state[14] = readU32(nonce, 8);\n    state[15] = readU32(nonce, 12);\n\n    for (let i = 0; i < 10; i++) {\n      qround(state, 0, 4, 8, 12);\n      qround(state, 1, 5, 9, 13);\n      qround(state, 2, 6, 10, 14);\n      qround(state, 3, 7, 11, 15);\n      qround(state, 0, 5, 10, 15);\n      qround(state, 1, 6, 11, 12);\n      qround(state, 2, 7, 8, 13);\n      qround(state, 3, 4, 9, 14);\n    }\n\n    const out = Buffer.alloc(32);\n    writeU32(out, state[0], 0);\n    writeU32(out, state[1], 4);\n    writeU32(out, state[2], 8);\n    writeU32(out, state[3], 12);\n    writeU32(out, state[12], 16);\n    writeU32(out, state[13], 20);\n    writeU32(out, state[14], 24);\n    writeU32(out, state[15], 28);\n    return out;\n  }\n\n}\n/*\n * Static\n */\n\n\nChaCha20.native = 0;\n/*\n * Helpers\n */\n\nfunction qround(x, a, b, c, d) {\n  x[a] += x[b];\n  x[d] = rotl32(x[d] ^ x[a], 16);\n  x[c] += x[d];\n  x[b] = rotl32(x[b] ^ x[c], 12);\n  x[a] += x[b];\n  x[d] = rotl32(x[d] ^ x[a], 8);\n  x[c] += x[d];\n  x[b] = rotl32(x[b] ^ x[c], 7);\n}\n\nfunction rotl32(w, b) {\n  return w << b | w >>> 32 - b;\n}\n\nfunction readU32(data, off) {\n  return data[off++] + data[off++] * 0x100 + data[off++] * 0x10000 + data[off] * 0x1000000;\n}\n\nfunction writeU32(dst, num, off) {\n  dst[off++] = num;\n  num >>>= 8;\n  dst[off++] = num;\n  num >>>= 8;\n  dst[off++] = num;\n  num >>>= 8;\n  dst[off++] = num;\n  return off;\n}\n/*\n * Expose\n */\n\n\nmodule.exports = ChaCha20;","map":null,"metadata":{},"sourceType":"script"}