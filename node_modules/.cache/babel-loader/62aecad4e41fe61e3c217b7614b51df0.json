{"ast":null,"code":"'use strict';\n\nconst Block = require('ipld-block');\n\nconst CID = require('cids');\n\nconst {\n  getName\n} = require('multicodec');\n\nconst vd = require('varint-decoder');\n\nconst multihashing = require('multihashing-async');\n\nconst {\n  isMapEqual\n} = require('../../utils');\n\nconst {\n  Message\n} = require('./message.proto');\n\nconst Entry = require('./entry');\n\nclass BitswapMessage {\n  constructor(full) {\n    this.full = full;\n    this.wantlist = new Map();\n    this.blocks = new Map();\n    this.blockPresences = new Map();\n    this.pendingBytes = 0;\n  }\n\n  get empty() {\n    return this.blocks.size === 0 && this.wantlist.size === 0 && this.blockPresences.size === 0;\n  }\n\n  addEntry(cid, priority, wantType, cancel, sendDontHave) {\n    if (wantType == null) {\n      wantType = BitswapMessage.WantType.Block;\n    }\n\n    const cidStr = cid.toString('base58btc');\n    const entry = this.wantlist.get(cidStr);\n\n    if (entry) {\n      // Only change priority if want is of the same type\n      if (entry.wantType === wantType) {\n        entry.priority = priority;\n      } // Only change from \"dont cancel\" to \"do cancel\"\n\n\n      if (cancel) {\n        entry.cancel = Boolean(cancel);\n      } // Only change from \"dont send\" to \"do send\" DONT_HAVE\n\n\n      if (sendDontHave) {\n        entry.sendDontHave = Boolean(sendDontHave);\n      } // want-block overrides existing want-have\n\n\n      if (wantType === BitswapMessage.WantType.Block && entry.wantType === BitswapMessage.WantType.Have) {\n        entry.wantType = wantType;\n      }\n    } else {\n      this.wantlist.set(cidStr, new Entry(cid, priority, wantType, cancel, sendDontHave));\n    }\n  }\n\n  addBlock(block) {\n    const cidStr = block.cid.toString('base58btc');\n    this.blocks.set(cidStr, block);\n  }\n\n  addHave(cid) {\n    const cidStr = cid.toString('base58btc');\n\n    if (!this.blockPresences.has(cidStr)) {\n      this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.Have);\n    }\n  }\n\n  addDontHave(cid) {\n    const cidStr = cid.toString('base58btc');\n\n    if (!this.blockPresences.has(cidStr)) {\n      this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.DontHave);\n    }\n  }\n\n  cancel(cid) {\n    const cidStr = cid.toString('base58btc');\n    this.wantlist.delete(cidStr);\n    this.addEntry(cid, 0, BitswapMessage.WantType.Block, true, false);\n  }\n\n  setPendingBytes(size) {\n    this.pendingBytes = size;\n  }\n  /*\n   * Serializes to Bitswap Message protobuf of\n   * version 1.0.0\n   */\n\n\n  serializeToBitswap100() {\n    const msg = {\n      wantlist: {\n        entries: Array.from(this.wantlist.values()).map(entry => {\n          return {\n            block: entry.cid.buffer,\n            // cid\n            priority: Number(entry.priority),\n            cancel: Boolean(entry.cancel)\n          };\n        })\n      },\n      blocks: Array.from(this.blocks.values()).map(block => block.data)\n    };\n\n    if (this.full) {\n      msg.wantlist.full = true;\n    }\n\n    return Message.encode(msg);\n  }\n  /*\n   * Serializes to Bitswap Message protobuf of\n   * version 1.1.0\n   */\n\n\n  serializeToBitswap110() {\n    const msg = {\n      wantlist: {\n        entries: Array.from(this.wantlist.values()).map(entry => {\n          return {\n            block: entry.cid.buffer,\n            // cid\n            priority: Number(entry.priority),\n            wantType: entry.wantType,\n            cancel: Boolean(entry.cancel),\n            sendDontHave: Boolean(entry.sendDontHave)\n          };\n        })\n      },\n      blockPresences: [],\n      payload: []\n    };\n\n    if (this.full) {\n      msg.wantlist.full = true;\n    }\n\n    this.blocks.forEach(block => {\n      msg.payload.push({\n        prefix: block.cid.prefix,\n        data: block.data\n      });\n    });\n\n    for (const [cidStr, bpType] of this.blockPresences) {\n      msg.blockPresences.push({\n        cid: new CID(cidStr).buffer,\n        type: bpType\n      });\n    }\n\n    if (this.pendingBytes > 0) {\n      msg.pendingBytes = this.pendingBytes;\n    }\n\n    return Message.encode(msg);\n  }\n\n  equals(other) {\n    if (this.full !== other.full || this.pendingBytes !== other.pendingBytes || !isMapEqual(this.wantlist, other.wantlist) || !isMapEqual(this.blocks, other.blocks) || !isMapEqual(this.blockPresences, other.blockPresences)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  get [Symbol.toStringTag]() {\n    const list = Array.from(this.wantlist.keys());\n    const blocks = Array.from(this.blocks.keys());\n    return `BitswapMessage <full: ${this.full}, list: ${list}, blocks: ${blocks}>`;\n  }\n\n}\n\nBitswapMessage.deserialize = async raw => {\n  const decoded = Message.decode(raw);\n  const isFull = decoded.wantlist && decoded.wantlist.full || false;\n  const msg = new BitswapMessage(isFull);\n\n  if (decoded.wantlist) {\n    decoded.wantlist.entries.forEach(entry => {\n      // note: entry.block is the CID here\n      const cid = new CID(entry.block);\n      msg.addEntry(cid, entry.priority, entry.wantType, entry.cancel, entry.sendDontHave);\n    });\n  }\n\n  if (decoded.blockPresences) {\n    decoded.blockPresences.forEach(blockPresence => {\n      const cid = new CID(blockPresence.cid);\n\n      if (blockPresence.type === BitswapMessage.BlockPresenceType.Have) {\n        msg.addHave(cid);\n      } else {\n        msg.addDontHave(cid);\n      }\n    });\n  } // Bitswap 1.0.0\n  // decoded.blocks are just the byte arrays\n\n\n  if (decoded.blocks.length > 0) {\n    await Promise.all(decoded.blocks.map(async b => {\n      const hash = await multihashing(b, 'sha2-256');\n      const cid = new CID(hash);\n      msg.addBlock(new Block(b, cid));\n    }));\n    return msg;\n  } // Bitswap 1.1.0\n\n\n  if (decoded.payload.length > 0) {\n    await Promise.all(decoded.payload.map(async p => {\n      if (!p.prefix || !p.data) {\n        return;\n      }\n\n      const values = vd(p.prefix);\n      const cidVersion = values[0];\n      const multicodec = values[1];\n      const hashAlg = values[2]; // const hashLen = values[3] // We haven't need to use this so far\n\n      const hash = await multihashing(p.data, hashAlg);\n      const cid = new CID(cidVersion, getName(multicodec), hash);\n      msg.addBlock(new Block(p.data, cid));\n    }));\n    msg.setPendingBytes(decoded.pendingBytes);\n    return msg;\n  }\n\n  return msg;\n};\n\nBitswapMessage.blockPresenceSize = cid => {\n  // It's ok if this is not exactly right: it's used to estimate the size of\n  // the HAVE / DONT_HAVE on the wire, but when doing that calculation we leave\n  // plenty of padding under the maximum message size.\n  // (It's more important for this to be fast).\n  return cid.buffer.length + 1;\n};\n\nBitswapMessage.Entry = Entry;\nBitswapMessage.WantType = {\n  Block: Message.Wantlist.WantType.Block,\n  Have: Message.Wantlist.WantType.Have\n};\nBitswapMessage.BlockPresenceType = {\n  Have: Message.BlockPresenceType.Have,\n  DontHave: Message.BlockPresenceType.DontHave\n};\nmodule.exports = BitswapMessage;","map":null,"metadata":{},"sourceType":"script"}