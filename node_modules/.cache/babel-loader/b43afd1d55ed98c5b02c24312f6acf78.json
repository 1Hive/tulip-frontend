{"ast":null,"code":"'use strict';\n\nconst BufferList = require('bl/BufferList');\n\nconst {\n  create\n} = require('rabin-wasm');\n\nconst errcode = require('err-code');\n\nmodule.exports = async function* rabinChunker(source, options) {\n  const rabin = jsRabin();\n  let min, max, avg;\n\n  if (options.minChunkSize && options.maxChunkSize && options.avgChunkSize) {\n    avg = options.avgChunkSize;\n    min = options.minChunkSize;\n    max = options.maxChunkSize;\n  } else if (!options.avgChunkSize) {\n    throw errcode(new Error('please specify an average chunk size'), 'ERR_INVALID_AVG_CHUNK_SIZE');\n  } else {\n    avg = options.avgChunkSize;\n    min = avg / 3;\n    max = avg + avg / 2;\n  } // validate min/max/avg in the same way as go\n\n\n  if (min < 16) {\n    throw errcode(new Error('rabin min must be greater than 16'), 'ERR_INVALID_MIN_CHUNK_SIZE');\n  }\n\n  if (max < min) {\n    max = min;\n  }\n\n  if (avg < min) {\n    avg = min;\n  }\n\n  const sizepow = Math.floor(Math.log2(avg));\n\n  for await (const chunk of rabin(source, {\n    min: min,\n    max: max,\n    bits: sizepow,\n    window: options.window,\n    polynomial: options.polynomial\n  })) {\n    yield chunk;\n  }\n};\n\nconst jsRabin = () => {\n  return async function* (source, options) {\n    const r = await create(options.bits, options.min, options.max, options.window);\n    const buffers = new BufferList();\n\n    for await (const chunk of source) {\n      buffers.append(chunk);\n      const sizes = r.fingerprint(chunk);\n\n      for (let i = 0; i < sizes.length; i++) {\n        var size = sizes[i];\n        var buf = buffers.slice(0, size);\n        buffers.consume(size);\n        yield buf;\n      }\n    }\n\n    if (buffers.length) {\n      yield buffers.slice(0);\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"script"}