{"ast":null,"code":"var _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _createForOfIteratorHelper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _awaitAsyncGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _wrapAsyncGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar getIterator = require('get-iterator');\n\nvar AbortError = require('./AbortError'); // Wrap an iterator to make it abortable, allow cleanup when aborted via onAbort\n\n\nvar toAbortableSource = function toAbortableSource(source, signal, options) {\n  return toMultiAbortableSource(source, Array.isArray(signal) ? signal : [{\n    signal: signal,\n    options: options\n  }]);\n};\n\nvar toMultiAbortableSource = function toMultiAbortableSource(source, signals) {\n  source = getIterator(source);\n  signals = signals.map(function (_ref) {\n    var signal = _ref.signal,\n        options = _ref.options;\n    return {\n      signal: signal,\n      options: options || {}\n    };\n  });\n\n  function abortable() {\n    return _abortable.apply(this, arguments);\n  }\n\n  function _abortable() {\n    _abortable = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var nextAbortHandler, abortHandler, _iterator, _step, _signal2, result, _iterator2, _step2, _step2$value, signal, options, abortMessage, abortCode, abort, _iterator3, _step3, _signal, aborter, isKnownAborter, _iterator4, _step4, _signal3;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              abortHandler = function abortHandler() {\n                if (nextAbortHandler) nextAbortHandler();\n              };\n\n              _iterator = _createForOfIteratorHelper(signals);\n\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  _signal2 = _step.value.signal;\n\n                  _signal2.addEventListener('abort', abortHandler);\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n\n            case 3:\n              if (!true) {\n                _context.next = 52;\n                break;\n              }\n\n              result = void 0;\n              _context.prev = 5;\n              _iterator2 = _createForOfIteratorHelper(signals);\n              _context.prev = 7;\n\n              _iterator2.s();\n\n            case 9:\n              if ((_step2 = _iterator2.n()).done) {\n                _context.next = 16;\n                break;\n              }\n\n              _step2$value = _step2.value, signal = _step2$value.signal, options = _step2$value.options;\n\n              if (!signal.aborted) {\n                _context.next = 14;\n                break;\n              }\n\n              abortMessage = options.abortMessage, abortCode = options.abortCode;\n              throw new AbortError(abortMessage, abortCode);\n\n            case 14:\n              _context.next = 9;\n              break;\n\n            case 16:\n              _context.next = 21;\n              break;\n\n            case 18:\n              _context.prev = 18;\n              _context.t0 = _context[\"catch\"](7);\n\n              _iterator2.e(_context.t0);\n\n            case 21:\n              _context.prev = 21;\n\n              _iterator2.f();\n\n              return _context.finish(21);\n\n            case 24:\n              abort = new Promise(function (resolve, reject) {\n                nextAbortHandler = function nextAbortHandler() {\n                  var _signals$find = signals.find(function (_ref2) {\n                    var signal = _ref2.signal;\n                    return signal.aborted;\n                  }),\n                      options = _signals$find.options;\n\n                  var abortMessage = options.abortMessage,\n                      abortCode = options.abortCode;\n                  reject(new AbortError(abortMessage, abortCode));\n                };\n              }); // Race the iterator and the abort signals\n\n              _context.next = 27;\n              return _awaitAsyncGenerator(Promise.race([abort, source.next()]));\n\n            case 27:\n              result = _context.sent;\n              nextAbortHandler = null;\n              _context.next = 46;\n              break;\n\n            case 31:\n              _context.prev = 31;\n              _context.t1 = _context[\"catch\"](5);\n              _iterator3 = _createForOfIteratorHelper(signals);\n\n              try {\n                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                  _signal = _step3.value.signal;\n\n                  _signal.removeEventListener('abort', abortHandler);\n                } // Might not have been aborted by a known signal\n\n              } catch (err) {\n                _iterator3.e(err);\n              } finally {\n                _iterator3.f();\n              }\n\n              aborter = signals.find(function (_ref3) {\n                var signal = _ref3.signal;\n                return signal.aborted;\n              });\n              isKnownAborter = _context.t1.type === 'aborted' && aborter;\n\n              if (!(isKnownAborter && aborter.options.onAbort)) {\n                _context.next = 40;\n                break;\n              }\n\n              _context.next = 40;\n              return _awaitAsyncGenerator(aborter.options.onAbort(source));\n\n            case 40:\n              if (!(typeof source.return === 'function')) {\n                _context.next = 43;\n                break;\n              }\n\n              _context.next = 43;\n              return _awaitAsyncGenerator(source.return());\n\n            case 43:\n              if (!(isKnownAborter && aborter.options.returnOnAbort)) {\n                _context.next = 45;\n                break;\n              }\n\n              return _context.abrupt(\"return\");\n\n            case 45:\n              throw _context.t1;\n\n            case 46:\n              if (!result.done) {\n                _context.next = 48;\n                break;\n              }\n\n              return _context.abrupt(\"break\", 52);\n\n            case 48:\n              _context.next = 50;\n              return result.value;\n\n            case 50:\n              _context.next = 3;\n              break;\n\n            case 52:\n              _iterator4 = _createForOfIteratorHelper(signals);\n\n              try {\n                for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                  _signal3 = _step4.value.signal;\n\n                  _signal3.removeEventListener('abort', abortHandler);\n                }\n              } catch (err) {\n                _iterator4.e(err);\n              } finally {\n                _iterator4.f();\n              }\n\n            case 54:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[5, 31], [7, 18, 21, 24]]);\n    }));\n    return _abortable.apply(this, arguments);\n  }\n\n  return abortable();\n};\n\nvar toAbortableSink = function toAbortableSink(sink, signal, options) {\n  return toMultiAbortableSink(sink, Array.isArray(signal) ? signal : [{\n    signal: signal,\n    options: options\n  }]);\n};\n\nvar toMultiAbortableSink = function toMultiAbortableSink(sink, signals) {\n  return function (source) {\n    return sink(toMultiAbortableSource(source, signals));\n  };\n};\n\nvar toAbortableDuplex = function toAbortableDuplex(duplex, signal, options) {\n  return toMultiAbortableDuplex(duplex, Array.isArray(signal) ? signal : [{\n    signal: signal,\n    options: options\n  }]);\n};\n\nvar toMultiAbortableDuplex = function toMultiAbortableDuplex(duplex, signals) {\n  return {\n    sink: toMultiAbortableSink(duplex.sink, signals),\n    source: toMultiAbortableSource(duplex.source, signals)\n  };\n};\n\nmodule.exports = toAbortableSource;\nmodule.exports.AbortError = AbortError;\nmodule.exports.source = toAbortableSource;\nmodule.exports.sink = toAbortableSink;\nmodule.exports.transform = toAbortableSink;\nmodule.exports.duplex = toAbortableDuplex;","map":null,"metadata":{},"sourceType":"script"}