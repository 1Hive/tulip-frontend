{"ast":null,"code":"'use strict';\n\nconst multiaddr = require('multiaddr');\n\nconst errCode = require('err-code');\n\nconst TimeoutController = require('timeout-abort-controller');\n\nconst anySignal = require('any-signal');\n\nconst PeerId = require('peer-id');\n\nconst PeerInfo = require('peer-info');\n\nconst debug = require('debug');\n\nconst log = debug('libp2p:dialer');\nlog.error = debug('libp2p:dialer:error');\n\nconst {\n  DialRequest\n} = require('./dial-request');\n\nconst {\n  codes\n} = require('../errors');\n\nconst {\n  DIAL_TIMEOUT,\n  MAX_PARALLEL_DIALS,\n  MAX_PER_PEER_DIALS\n} = require('../constants');\n\nclass Dialer {\n  /**\n   * @constructor\n   * @param {object} options\n   * @param {TransportManager} options.transportManager\n   * @param {Peerstore} peerStore\n   * @param {number} options.concurrency Number of max concurrent dials. Defaults to `MAX_PARALLEL_DIALS`\n   * @param {number} options.timeout How long a dial attempt is allowed to take. Defaults to `DIAL_TIMEOUT`\n   */\n  constructor({\n    transportManager,\n    peerStore,\n    concurrency = MAX_PARALLEL_DIALS,\n    timeout = DIAL_TIMEOUT,\n    perPeerLimit = MAX_PER_PEER_DIALS\n  }) {\n    this.transportManager = transportManager;\n    this.peerStore = peerStore;\n    this.concurrency = concurrency;\n    this.timeout = timeout;\n    this.perPeerLimit = perPeerLimit;\n    this.tokens = [...new Array(concurrency)].map((_, index) => index);\n    this._pendingDials = new Map();\n  }\n  /**\n   * Clears any pending dials\n   */\n\n\n  destroy() {\n    for (const dial of this._pendingDials.values()) {\n      try {\n        dial.controller.abort();\n      } catch (err) {\n        log.error(err);\n      }\n    }\n\n    this._pendingDials.clear();\n  }\n  /**\n   * Connects to a given `PeerId` or `Multiaddr` by dialing all of its known addresses.\n   * The dial to the first address that is successfully able to upgrade a connection\n   * will be used.\n   *\n   * @param {PeerInfo|Multiaddr} peer The peer to dial\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] An AbortController signal\n   * @returns {Promise<Connection>}\n   */\n\n\n  async connectToPeer(peer, options = {}) {\n    const dialTarget = this._createDialTarget(peer);\n\n    if (dialTarget.addrs.length === 0) {\n      throw errCode(new Error('The dial request has no addresses'), codes.ERR_NO_VALID_ADDRESSES);\n    }\n\n    const pendingDial = this._pendingDials.get(dialTarget.id) || this._createPendingDial(dialTarget, options);\n\n    try {\n      const connection = await pendingDial.promise;\n      log('dial succeeded to %s', dialTarget.id);\n      return connection;\n    } catch (err) {\n      // Error is a timeout\n      if (pendingDial.controller.signal.aborted) {\n        err.code = codes.ERR_TIMEOUT;\n      }\n\n      log.error(err);\n      throw err;\n    } finally {\n      pendingDial.destroy();\n    }\n  }\n  /**\n   * @typedef DialTarget\n   * @property {string} id\n   * @property {Multiaddr[]} addrs\n   */\n\n  /**\n   * Creates a DialTarget. The DialTarget is used to create and track\n   * the DialRequest to a given peer.\n   * @private\n   * @param {PeerInfo|Multiaddr} peer A PeerId or Multiaddr\n   * @returns {DialTarget}\n   */\n\n\n  _createDialTarget(peer) {\n    const dialable = Dialer.getDialable(peer);\n\n    if (multiaddr.isMultiaddr(dialable)) {\n      return {\n        id: dialable.toString(),\n        addrs: [dialable]\n      };\n    }\n\n    const addrs = this.peerStore.multiaddrsForPeer(dialable);\n    return {\n      id: dialable.id.toB58String(),\n      addrs\n    };\n  }\n  /**\n   * @typedef PendingDial\n   * @property {DialRequest} dialRequest\n   * @property {TimeoutController} controller\n   * @property {Promise} promise\n   * @property {function():void} destroy\n   */\n\n  /**\n   * Creates a PendingDial that wraps the underlying DialRequest\n   * @private\n   * @param {DialTarget} dialTarget\n   * @param {object} [options]\n   * @param {AbortSignal} [options.signal] An AbortController signal\n   * @returns {PendingDial}\n   */\n\n\n  _createPendingDial(dialTarget, options) {\n    const dialAction = (addr, options) => {\n      if (options.signal.aborted) throw errCode(new Error('already aborted'), codes.ERR_ALREADY_ABORTED);\n      return this.transportManager.dial(addr, options);\n    };\n\n    const dialRequest = new DialRequest({\n      addrs: dialTarget.addrs,\n      dialAction,\n      dialer: this\n    }); // Combine the timeout signal and options.signal, if provided\n\n    const timeoutController = new TimeoutController(this.timeout);\n    const signals = [timeoutController.signal];\n    options.signal && signals.push(options.signal);\n    const signal = anySignal(signals);\n    const pendingDial = {\n      dialRequest,\n      controller: timeoutController,\n      promise: dialRequest.run({ ...options,\n        signal\n      }),\n      destroy: () => {\n        timeoutController.clear();\n\n        this._pendingDials.delete(dialTarget.id);\n      }\n    };\n\n    this._pendingDials.set(dialTarget.id, pendingDial);\n\n    return pendingDial;\n  }\n\n  getTokens(num) {\n    const total = Math.min(num, this.perPeerLimit, this.tokens.length);\n    const tokens = this.tokens.splice(0, total);\n    log('%d tokens request, returning %d, %d remaining', num, total, this.tokens.length);\n    return tokens;\n  }\n\n  releaseToken(token) {\n    // Guard against duplicate releases\n    if (this.tokens.indexOf(token) > -1) return;\n    log('token %d released', token);\n    this.tokens.push(token);\n  }\n  /**\n   * Converts the given `peer` into a `PeerInfo` or `Multiaddr`.\n   * @static\n   * @param {PeerInfo|PeerId|Multiaddr|string} peer\n   * @returns {PeerInfo|Multiaddr}\n   */\n\n\n  static getDialable(peer) {\n    if (PeerInfo.isPeerInfo(peer)) return peer;\n\n    if (typeof peer === 'string') {\n      peer = multiaddr(peer);\n    }\n\n    let addr;\n\n    if (multiaddr.isMultiaddr(peer)) {\n      addr = peer;\n\n      try {\n        peer = PeerId.createFromCID(peer.getPeerId());\n      } catch (err) {\n        throw errCode(new Error('The multiaddr did not contain a valid peer id'), codes.ERR_INVALID_PEER);\n      }\n    }\n\n    if (PeerId.isPeerId(peer)) {\n      peer = new PeerInfo(peer);\n    }\n\n    addr && peer.multiaddrs.add(addr);\n    return peer;\n  }\n\n}\n\nmodule.exports = Dialer;","map":null,"metadata":{},"sourceType":"script"}