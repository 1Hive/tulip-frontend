{"ast":null,"code":"/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _slicedToArray = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _require = require('ipld-dag-pb'),\n    DAGNode = _require.DAGNode,\n    DAGLink = _require.DAGLink;\n\nvar CID = require('cids');\n\nvar _require2 = require('p-queue'),\n    Queue = _require2.default;\n\nvar _require3 = require('interface-datastore'),\n    Key = _require3.Key;\n\nvar errCode = require('err-code');\n\nvar multicodec = require('multicodec');\n\nvar dagCborLinks = require('dag-cbor-links');\n\nvar debug = require('debug');\n\nvar _require4 = require('buffer'),\n    Buffer = _require4.Buffer;\n\nvar _require5 = require('../../../utils/cid'),\n    cidToString = _require5.cidToString;\n\nvar createPinSet = require('./pin-set');\n\nvar _require6 = require('interface-datastore'),\n    Errors = _require6.Errors;\n\nvar ERR_NOT_FOUND = Errors.notFoundError().code; // arbitrary limit to the number of concurrent dag operations\n\nvar WALK_DAG_CONCURRENCY_LIMIT = 300;\nvar IS_PINNED_WITH_TYPE_CONCURRENCY_LIMIT = 300;\nvar PIN_DS_KEY = new Key('/local/pins');\n\nfunction invalidPinTypeErr(type) {\n  var errMsg = \"Invalid type '\".concat(type, \"', must be one of {direct, indirect, recursive, all}\");\n  return errCode(new Error(errMsg), 'ERR_INVALID_PIN_TYPE');\n}\n\nvar PinTypes = {\n  direct: 'direct',\n  recursive: 'recursive',\n  indirect: 'indirect',\n  all: 'all'\n};\n\nvar PinManager = /*#__PURE__*/function () {\n  function PinManager(repo, dag) {\n    _classCallCheck(this, PinManager);\n\n    this.repo = repo;\n    this.dag = dag;\n    this.log = debug('ipfs:pin');\n    this.pinset = createPinSet(dag);\n    this.directPins = new Set();\n    this.recursivePins = new Set();\n  }\n\n  _createClass(PinManager, [{\n    key: \"_walkDag\",\n    value: function () {\n      var _walkDag2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref) {\n        var _this = this;\n\n        var cid, _ref$preload, preload, _ref$onCid, onCid, walk, queue;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                cid = _ref.cid, _ref$preload = _ref.preload, preload = _ref$preload === void 0 ? false : _ref$preload, _ref$onCid = _ref.onCid, onCid = _ref$onCid === void 0 ? function () {} : _ref$onCid;\n\n                if (!CID.isCID(cid)) {\n                  cid = new CID(cid);\n                }\n\n                walk = function walk(cid) {\n                  return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n                    var _yield$_this$dag$get, node, _iterator, _step, _step$value, _, childCid;\n\n                    return _regeneratorRuntime.wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            _context.next = 2;\n                            return _this.dag.get(cid, {\n                              preload: preload\n                            });\n\n                          case 2:\n                            _yield$_this$dag$get = _context.sent;\n                            node = _yield$_this$dag$get.value;\n                            onCid(cid);\n\n                            if (cid.codec === 'dag-pb') {\n                              queue.addAll(node.Links.map(function (link) {\n                                return walk(link.Hash);\n                              }));\n                            } else if (cid.codec === 'dag-cbor') {\n                              _iterator = _createForOfIteratorHelper(dagCborLinks(node));\n\n                              try {\n                                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                                  _step$value = _slicedToArray(_step.value, 2), _ = _step$value[0], childCid = _step$value[1];\n                                  // eslint-disable-line no-unused-vars\n                                  queue.add(walk(childCid));\n                                }\n                              } catch (err) {\n                                _iterator.e(err);\n                              } finally {\n                                _iterator.f();\n                              }\n                            }\n\n                          case 6:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee);\n                  }));\n                };\n\n                queue = new Queue({\n                  concurrency: WALK_DAG_CONCURRENCY_LIMIT\n                });\n                queue.add(walk(cid));\n                _context2.next = 7;\n                return queue.onIdle();\n\n              case 7:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function _walkDag(_x) {\n        return _walkDag2.apply(this, arguments);\n      }\n\n      return _walkDag;\n    }()\n  }, {\n    key: \"directKeys\",\n    value: function directKeys() {\n      return Array.from(this.directPins, function (key) {\n        return new CID(key).buffer;\n      });\n    }\n  }, {\n    key: \"recursiveKeys\",\n    value: function recursiveKeys() {\n      return Array.from(this.recursivePins, function (key) {\n        return new CID(key).buffer;\n      });\n    }\n  }, {\n    key: \"getIndirectKeys\",\n    value: function () {\n      var _getIndirectKeys = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(_ref3) {\n        var _this2 = this;\n\n        var preload, indirectKeys, _iterator2, _step2, multihash;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                preload = _ref3.preload;\n                indirectKeys = new Set();\n                _iterator2 = _createForOfIteratorHelper(this.recursiveKeys());\n                _context3.prev = 3;\n\n                _iterator2.s();\n\n              case 5:\n                if ((_step2 = _iterator2.n()).done) {\n                  _context3.next = 11;\n                  break;\n                }\n\n                multihash = _step2.value;\n                _context3.next = 9;\n                return this._walkDag({\n                  cid: new CID(multihash),\n                  preload: preload || false,\n                  onCid: function onCid(cid) {\n                    cid = cid.toString(); // recursive pins pre-empt indirect pins\n\n                    if (!_this2.recursivePins.has(cid)) {\n                      indirectKeys.add(cid);\n                    }\n                  }\n                });\n\n              case 9:\n                _context3.next = 5;\n                break;\n\n              case 11:\n                _context3.next = 16;\n                break;\n\n              case 13:\n                _context3.prev = 13;\n                _context3.t0 = _context3[\"catch\"](3);\n\n                _iterator2.e(_context3.t0);\n\n              case 16:\n                _context3.prev = 16;\n\n                _iterator2.f();\n\n                return _context3.finish(16);\n\n              case 19:\n                return _context3.abrupt(\"return\", Array.from(indirectKeys));\n\n              case 20:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[3, 13, 16, 19]]);\n      }));\n\n      function getIndirectKeys(_x2) {\n        return _getIndirectKeys.apply(this, arguments);\n      }\n\n      return getIndirectKeys;\n    }() // Encode and write pin key sets to the datastore:\n    // a DAGLink for each of the recursive and direct pinsets\n    // a DAGNode holding those as DAGLinks, a kind of root pin\n\n  }, {\n    key: \"flushPins\",\n    value: function () {\n      var _flushPins = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var _yield$Promise$all, _yield$Promise$all2, dLink, rLink, rootNode, rootCid;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return Promise.all([// create a DAGLink to the node with direct pins\n                this.pinset.storeSet(this.directKeys()).then(function (result) {\n                  return new DAGLink(PinTypes.direct, result.node.size, result.cid);\n                }), // create a DAGLink to the node with recursive pins\n                this.pinset.storeSet(this.recursiveKeys()).then(function (result) {\n                  return new DAGLink(PinTypes.recursive, result.node.size, result.cid);\n                }), // the pin-set nodes link to a special 'empty' node, so make sure it exists\n                this.dag.put(new DAGNode(Buffer.alloc(0)), {\n                  version: 0,\n                  format: multicodec.DAG_PB,\n                  hashAlg: multicodec.SHA2_256,\n                  preload: false\n                })]);\n\n              case 2:\n                _yield$Promise$all = _context4.sent;\n                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n                dLink = _yield$Promise$all2[0];\n                rLink = _yield$Promise$all2[1];\n                // create a root node with DAGLinks to the direct and recursive DAGs\n                rootNode = new DAGNode(Buffer.alloc(0), [dLink, rLink]);\n                _context4.next = 9;\n                return this.dag.put(rootNode, {\n                  version: 0,\n                  format: multicodec.DAG_PB,\n                  hashAlg: multicodec.SHA2_256,\n                  preload: false\n                });\n\n              case 9:\n                rootCid = _context4.sent;\n                _context4.next = 12;\n                return this.repo.datastore.put(PIN_DS_KEY, rootCid.buffer);\n\n              case 12:\n                this.log(\"Flushed pins with root: \".concat(rootCid));\n\n              case 13:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function flushPins() {\n        return _flushPins.apply(this, arguments);\n      }\n\n      return flushPins;\n    }()\n  }, {\n    key: \"load\",\n    value: function () {\n      var _load = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        var has, mh, pinRoot, _yield$Promise$all3, _yield$Promise$all4, rKeys, dKeys;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this.repo.datastore.has(PIN_DS_KEY);\n\n              case 2:\n                has = _context5.sent;\n\n                if (has) {\n                  _context5.next = 5;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\");\n\n              case 5:\n                _context5.next = 7;\n                return this.repo.datastore.get(PIN_DS_KEY);\n\n              case 7:\n                mh = _context5.sent;\n                _context5.next = 10;\n                return this.dag.get(new CID(mh), '', {\n                  preload: false\n                });\n\n              case 10:\n                pinRoot = _context5.sent;\n                _context5.next = 13;\n                return Promise.all([this.pinset.loadSet(pinRoot.value, PinTypes.recursive), this.pinset.loadSet(pinRoot.value, PinTypes.direct)]);\n\n              case 13:\n                _yield$Promise$all3 = _context5.sent;\n                _yield$Promise$all4 = _slicedToArray(_yield$Promise$all3, 2);\n                rKeys = _yield$Promise$all4[0];\n                dKeys = _yield$Promise$all4[1];\n                this.directPins = new Set(dKeys.map(function (k) {\n                  return cidToString(k);\n                }));\n                this.recursivePins = new Set(rKeys.map(function (k) {\n                  return cidToString(k);\n                }));\n                this.log('Loaded pins from the datastore');\n\n              case 20:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function load() {\n        return _load.apply(this, arguments);\n      }\n\n      return load;\n    }()\n  }, {\n    key: \"isPinnedWithType\",\n    value: function () {\n      var _isPinnedWithType = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(multihash, type) {\n        var _this3 = this;\n\n        var key, recursive, direct, all, queue, cid;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                key = cidToString(multihash);\n                recursive = PinTypes.recursive, direct = PinTypes.direct, all = PinTypes.all; // recursive\n\n                if (!((type === recursive || type === all) && this.recursivePins.has(key))) {\n                  _context7.next = 4;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", {\n                  key: key,\n                  pinned: true,\n                  reason: recursive\n                });\n\n              case 4:\n                if (!(type === recursive)) {\n                  _context7.next = 6;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", {\n                  key: key,\n                  pinned: false\n                });\n\n              case 6:\n                if (!((type === direct || type === all) && this.directPins.has(key))) {\n                  _context7.next = 8;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", {\n                  key: key,\n                  pinned: true,\n                  reason: direct\n                });\n\n              case 8:\n                if (!(type === direct)) {\n                  _context7.next = 10;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", {\n                  key: key,\n                  pinned: false\n                });\n\n              case 10:\n                // indirect (default)\n                // check each recursive key to see if multihash is under it\n                // arbitrary limit, enables handling 1000s of pins.\n                queue = new Queue({\n                  concurrency: IS_PINNED_WITH_TYPE_CONCURRENCY_LIMIT\n                });\n                queue.addAll(this.recursiveKeys().map(function (childKey) {\n                  childKey = new CID(childKey);\n                  return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n                    var has;\n                    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n                      while (1) {\n                        switch (_context6.prev = _context6.next) {\n                          case 0:\n                            _context6.next = 2;\n                            return _this3.pinset.hasDescendant(childKey, key);\n\n                          case 2:\n                            has = _context6.sent;\n\n                            if (has) {\n                              cid = childKey;\n                              queue.clear();\n                            }\n\n                          case 4:\n                          case \"end\":\n                            return _context6.stop();\n                        }\n                      }\n                    }, _callee6);\n                  }));\n                }));\n                _context7.next = 14;\n                return queue.onIdle();\n\n              case 14:\n                return _context7.abrupt(\"return\", {\n                  key: key,\n                  pinned: Boolean(cid),\n                  reason: cid\n                });\n\n              case 15:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function isPinnedWithType(_x3, _x4) {\n        return _isPinnedWithType.apply(this, arguments);\n      }\n\n      return isPinnedWithType;\n    }() // Gets CIDs of blocks used internally by the pinner\n\n  }, {\n    key: \"getInternalBlocks\",\n    value: function () {\n      var _getInternalBlocks = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n        var mh, cid, obj, cids;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.prev = 0;\n                _context8.next = 3;\n                return this.repo.datastore.get(PIN_DS_KEY);\n\n              case 3:\n                mh = _context8.sent;\n                _context8.next = 12;\n                break;\n\n              case 6:\n                _context8.prev = 6;\n                _context8.t0 = _context8[\"catch\"](0);\n\n                if (!(_context8.t0.code === ERR_NOT_FOUND)) {\n                  _context8.next = 11;\n                  break;\n                }\n\n                this.log('No pinned blocks');\n                return _context8.abrupt(\"return\", []);\n\n              case 11:\n                throw new Error(\"Could not get pin sets root from datastore: \".concat(_context8.t0.message));\n\n              case 12:\n                cid = new CID(mh);\n                _context8.next = 15;\n                return this.dag.get(cid, '', {\n                  preload: false\n                });\n\n              case 15:\n                obj = _context8.sent;\n                _context8.next = 18;\n                return this.pinset.getInternalCids(obj.value);\n\n              case 18:\n                cids = _context8.sent;\n                return _context8.abrupt(\"return\", cids.concat(cid));\n\n              case 20:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this, [[0, 6]]);\n      }));\n\n      function getInternalBlocks() {\n        return _getInternalBlocks.apply(this, arguments);\n      }\n\n      return getInternalBlocks;\n    }()\n  }, {\n    key: \"fetchCompleteDag\",\n    value: function () {\n      var _fetchCompleteDag = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(cid, options) {\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.next = 2;\n                return this._walkDag({\n                  cid: cid,\n                  preload: options.preload\n                });\n\n              case 2:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function fetchCompleteDag(_x5, _x6) {\n        return _fetchCompleteDag.apply(this, arguments);\n      }\n\n      return fetchCompleteDag;\n    }() // Returns an error if the pin type is invalid\n\n  }], [{\n    key: \"checkPinType\",\n    value: function checkPinType(type) {\n      if (typeof type !== 'string' || !Object.keys(PinTypes).includes(type)) {\n        return invalidPinTypeErr(type);\n      }\n    }\n  }]);\n\n  return PinManager;\n}();\n\nPinManager.PinTypes = PinTypes;\nmodule.exports = PinManager;","map":null,"metadata":{},"sourceType":"script"}