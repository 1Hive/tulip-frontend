{"ast":null,"code":"class JSBI extends Array {\n  constructor(a, b) {\n    if (a > JSBI.__kMaxLength) throw new RangeError(\"Maximum BigInt size exceeded\");\n    super(a), this.sign = b;\n  }\n\n  static BigInt(a) {\n    var b = Math.floor,\n        c = Number.isFinite;\n\n    if (\"number\" == typeof a) {\n      if (0 === a) return JSBI.__zero();\n      if ((0 | a) === a) return 0 > a ? JSBI.__oneDigit(-a, !0) : JSBI.__oneDigit(a, !1);\n      if (!c(a) || b(a) !== a) throw new RangeError(\"The number \" + a + \" cannot be converted to BigInt because it is not an integer\");\n      return JSBI.__fromDouble(a);\n    }\n\n    if (\"string\" == typeof a) {\n      const b = JSBI.__fromString(a);\n\n      if (null === b) throw new SyntaxError(\"Cannot convert \" + a + \" to a BigInt\");\n      return b;\n    }\n\n    if (\"boolean\" == typeof a) return !0 === a ? JSBI.__oneDigit(1, !1) : JSBI.__zero();\n\n    if (\"object\" == typeof a) {\n      if (a.constructor === JSBI) return a;\n\n      const b = JSBI.__toPrimitive(a);\n\n      return JSBI.BigInt(b);\n    }\n\n    throw new TypeError(\"Cannot convert \" + a + \" to a BigInt\");\n  }\n\n  toDebugString() {\n    const a = [\"BigInt[\"];\n\n    for (const b of this) a.push((b ? (b >>> 0).toString(16) : b) + \", \");\n\n    return a.push(\"]\"), a.join(\"\");\n  }\n\n  toString(a = 10) {\n    if (2 > a || 36 < a) throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n    return 0 === this.length ? \"0\" : 0 == (a & a - 1) ? JSBI.__toStringBasePowerOfTwo(this, a) : JSBI.__toStringGeneric(this, a, !1);\n  }\n\n  static toNumber(a) {\n    var b = Math.clz32;\n    const c = a.length;\n    if (0 === c) return 0;\n\n    if (1 === c) {\n      const b = a.__unsignedDigit(0);\n\n      return a.sign ? -b : b;\n    }\n\n    const d = a.__digit(c - 1),\n          e = b(d),\n          f = 32 * c - e;\n\n    if (1024 < f) return a.sign ? -Infinity : 1 / 0;\n    let g = f - 1,\n        h = d,\n        i = c - 1;\n    const j = e + 1;\n    let k = 32 === j ? 0 : h << j;\n    k >>>= 12;\n    const l = j - 12;\n    let m = 12 <= j ? 0 : h << 20 + j,\n        n = 20 + j;\n    0 < l && 0 < i && (i--, h = a.__digit(i), k |= h >>> 32 - l, m = h << l, n = l), 0 < n && 0 < i && (i--, h = a.__digit(i), m |= h >>> 32 - n, n -= 32);\n\n    const o = JSBI.__decideRounding(a, n, i, h);\n\n    if ((1 === o || 0 === o && 1 == (1 & m)) && (m = m + 1 >>> 0, 0 == m && (k++, 0 != k >>> 20 && (k = 0, g++, 1023 < g)))) return a.sign ? -Infinity : 1 / 0;\n    const p = a.sign ? -2147483648 : 0;\n    return g = g + 1023 << 20, JSBI.__kBitConversionInts[1] = p | g | k, JSBI.__kBitConversionInts[0] = m, JSBI.__kBitConversionDouble[0];\n  }\n\n  static unaryMinus(a) {\n    if (0 === a.length) return a;\n\n    const b = a.__copy();\n\n    return b.sign = !a.sign, b;\n  }\n\n  static bitwiseNot(a) {\n    return a.sign ? JSBI.__absoluteSubOne(a).__trim() : JSBI.__absoluteAddOne(a, !0);\n  }\n\n  static exponentiate(a, b) {\n    if (b.sign) throw new RangeError(\"Exponent must be positive\");\n    if (0 === b.length) return JSBI.__oneDigit(1, !1);\n    if (0 === a.length) return a;\n    if (1 === a.length && 1 === a.__digit(0)) return a.sign && 0 == (1 & b.__digit(0)) ? JSBI.unaryMinus(a) : a;\n    if (1 < b.length) throw new RangeError(\"BigInt too big\");\n\n    let c = b.__unsignedDigit(0);\n\n    if (1 === c) return a;\n    if (c >= JSBI.__kMaxLengthBits) throw new RangeError(\"BigInt too big\");\n\n    if (1 === a.length && 2 === a.__digit(0)) {\n      const b = 1 + (c >>> 5),\n            d = a.sign && 0 != (1 & c),\n            e = new JSBI(b, d);\n\n      e.__initializeDigits();\n\n      const f = 1 << (31 & c);\n      return e.__setDigit(b - 1, f), e;\n    }\n\n    let d = null,\n        e = a;\n\n    for (0 != (1 & c) && (d = a), c >>= 1; 0 !== c; c >>= 1) e = JSBI.multiply(e, e), 0 != (1 & c) && (null === d ? d = e : d = JSBI.multiply(d, e));\n\n    return d;\n  }\n\n  static multiply(a, b) {\n    if (0 === a.length) return a;\n    if (0 === b.length) return b;\n    let c = a.length + b.length;\n    32 <= a.__clzmsd() + b.__clzmsd() && c--;\n    const d = new JSBI(c, a.sign !== b.sign);\n\n    d.__initializeDigits();\n\n    for (let c = 0; c < a.length; c++) JSBI.__multiplyAccumulate(b, a.__digit(c), d, c);\n\n    return d.__trim();\n  }\n\n  static divide(a, b) {\n    if (0 === b.length) throw new RangeError(\"Division by zero\");\n    if (0 > JSBI.__absoluteCompare(a, b)) return JSBI.__zero();\n\n    const c = a.sign !== b.sign,\n          d = b.__unsignedDigit(0);\n\n    let e;\n\n    if (1 === b.length && 65535 >= d) {\n      if (1 === d) return c === a.sign ? a : JSBI.unaryMinus(a);\n      e = JSBI.__absoluteDivSmall(a, d, null);\n    } else e = JSBI.__absoluteDivLarge(a, b, !0, !1);\n\n    return e.sign = c, e.__trim();\n  }\n\n  static remainder(a, b) {\n    if (0 === b.length) throw new RangeError(\"Division by zero\");\n    if (0 > JSBI.__absoluteCompare(a, b)) return a;\n\n    const c = b.__unsignedDigit(0);\n\n    if (1 === b.length && 65535 >= c) {\n      if (1 === c) return JSBI.__zero();\n\n      const b = JSBI.__absoluteModSmall(a, c);\n\n      return 0 === b ? JSBI.__zero() : JSBI.__oneDigit(b, a.sign);\n    }\n\n    const d = JSBI.__absoluteDivLarge(a, b, !1, !0);\n\n    return d.sign = a.sign, d.__trim();\n  }\n\n  static add(a, b) {\n    const c = a.sign;\n    return c === b.sign ? JSBI.__absoluteAdd(a, b, c) : 0 <= JSBI.__absoluteCompare(a, b) ? JSBI.__absoluteSub(a, b, c) : JSBI.__absoluteSub(b, a, !c);\n  }\n\n  static subtract(a, b) {\n    const c = a.sign;\n    return c === b.sign ? 0 <= JSBI.__absoluteCompare(a, b) ? JSBI.__absoluteSub(a, b, c) : JSBI.__absoluteSub(b, a, !c) : JSBI.__absoluteAdd(a, b, c);\n  }\n\n  static leftShift(a, b) {\n    return 0 === b.length || 0 === a.length ? a : b.sign ? JSBI.__rightShiftByAbsolute(a, b) : JSBI.__leftShiftByAbsolute(a, b);\n  }\n\n  static signedRightShift(a, b) {\n    return 0 === b.length || 0 === a.length ? a : b.sign ? JSBI.__leftShiftByAbsolute(a, b) : JSBI.__rightShiftByAbsolute(a, b);\n  }\n\n  static unsignedRightShift() {\n    throw new TypeError(\"BigInts have no unsigned right shift; use >> instead\");\n  }\n\n  static lessThan(a, b) {\n    return 0 > JSBI.__compareToBigInt(a, b);\n  }\n\n  static lessThanOrEqual(a, b) {\n    return 0 >= JSBI.__compareToBigInt(a, b);\n  }\n\n  static greaterThan(a, b) {\n    return 0 < JSBI.__compareToBigInt(a, b);\n  }\n\n  static greaterThanOrEqual(a, b) {\n    return 0 <= JSBI.__compareToBigInt(a, b);\n  }\n\n  static equal(a, b) {\n    if (a.sign !== b.sign) return !1;\n    if (a.length !== b.length) return !1;\n\n    for (let c = 0; c < a.length; c++) if (a.__digit(c) !== b.__digit(c)) return !1;\n\n    return !0;\n  }\n\n  static notEqual(a, b) {\n    return !JSBI.equal(a, b);\n  }\n\n  static bitwiseAnd(a, b) {\n    var c = Math.max;\n    if (!a.sign && !b.sign) return JSBI.__absoluteAnd(a, b).__trim();\n\n    if (a.sign && b.sign) {\n      const d = c(a.length, b.length) + 1;\n\n      let e = JSBI.__absoluteSubOne(a, d);\n\n      const f = JSBI.__absoluteSubOne(b);\n\n      return e = JSBI.__absoluteOr(e, f, e), JSBI.__absoluteAddOne(e, !0, e).__trim();\n    }\n\n    return a.sign && ([a, b] = [b, a]), JSBI.__absoluteAndNot(a, JSBI.__absoluteSubOne(b)).__trim();\n  }\n\n  static bitwiseXor(a, b) {\n    var c = Math.max;\n    if (!a.sign && !b.sign) return JSBI.__absoluteXor(a, b).__trim();\n\n    if (a.sign && b.sign) {\n      const d = c(a.length, b.length),\n            e = JSBI.__absoluteSubOne(a, d),\n            f = JSBI.__absoluteSubOne(b);\n\n      return JSBI.__absoluteXor(e, f, e).__trim();\n    }\n\n    const d = c(a.length, b.length) + 1;\n    a.sign && ([a, b] = [b, a]);\n\n    let e = JSBI.__absoluteSubOne(b, d);\n\n    return e = JSBI.__absoluteXor(e, a, e), JSBI.__absoluteAddOne(e, !0, e).__trim();\n  }\n\n  static bitwiseOr(a, b) {\n    var c = Math.max;\n    const d = c(a.length, b.length);\n    if (!a.sign && !b.sign) return JSBI.__absoluteOr(a, b).__trim();\n\n    if (a.sign && b.sign) {\n      let c = JSBI.__absoluteSubOne(a, d);\n\n      const e = JSBI.__absoluteSubOne(b);\n\n      return c = JSBI.__absoluteAnd(c, e, c), JSBI.__absoluteAddOne(c, !0, c).__trim();\n    }\n\n    a.sign && ([a, b] = [b, a]);\n\n    let e = JSBI.__absoluteSubOne(b, d);\n\n    return e = JSBI.__absoluteAndNot(e, a, e), JSBI.__absoluteAddOne(e, !0, e).__trim();\n  }\n\n  static asIntN(a, b) {\n    if (0 === b.length) return b;\n    if (0 === a) return JSBI.__zero();\n    if (a >= JSBI.__kMaxLengthBits) return b;\n    const c = a + 31 >>> 5;\n    if (b.length < c) return b;\n\n    const d = b.__unsignedDigit(c - 1),\n          e = 1 << (31 & a - 1);\n\n    if (b.length === c && d < e) return b;\n    if (!((d & e) === e)) return JSBI.__truncateToNBits(a, b);\n    if (!b.sign) return JSBI.__truncateAndSubFromPowerOfTwo(a, b, !0);\n\n    if (0 == (d & e - 1)) {\n      for (let d = c - 2; 0 <= d; d--) if (0 !== b.__digit(d)) return JSBI.__truncateAndSubFromPowerOfTwo(a, b, !1);\n\n      return b.length === c && d === e ? b : JSBI.__truncateToNBits(a, b);\n    }\n\n    return JSBI.__truncateAndSubFromPowerOfTwo(a, b, !1);\n  }\n\n  static asUintN(a, b) {\n    if (0 === b.length) return b;\n    if (0 === a) return JSBI.__zero();\n\n    if (b.sign) {\n      if (a > JSBI.__kMaxLengthBits) throw new RangeError(\"BigInt too big\");\n      return JSBI.__truncateAndSubFromPowerOfTwo(a, b, !1);\n    }\n\n    if (a >= JSBI.__kMaxLengthBits) return b;\n    const c = a + 31 >>> 5;\n    if (b.length < c) return b;\n    const d = 31 & a;\n\n    if (b.length == c) {\n      if (0 == d) return b;\n\n      const a = b.__digit(c - 1);\n\n      if (0 == a >>> d) return b;\n    }\n\n    return JSBI.__truncateToNBits(a, b);\n  }\n\n  static ADD(a, b) {\n    if (a = JSBI.__toPrimitive(a), b = JSBI.__toPrimitive(b), \"string\" == typeof a) return \"string\" != typeof b && (b = b.toString()), a + b;\n    if (\"string\" == typeof b) return a.toString() + b;\n    if (a = JSBI.__toNumeric(a), b = JSBI.__toNumeric(b), JSBI.__isBigInt(a) && JSBI.__isBigInt(b)) return JSBI.add(a, b);\n    if (\"number\" == typeof a && \"number\" == typeof b) return a + b;\n    throw new TypeError(\"Cannot mix BigInt and other types, use explicit conversions\");\n  }\n\n  static LT(a, b) {\n    return JSBI.__compare(a, b, 0);\n  }\n\n  static LE(a, b) {\n    return JSBI.__compare(a, b, 1);\n  }\n\n  static GT(a, b) {\n    return JSBI.__compare(a, b, 2);\n  }\n\n  static GE(a, b) {\n    return JSBI.__compare(a, b, 3);\n  }\n\n  static EQ(a, b) {\n    for (;;) {\n      if (JSBI.__isBigInt(a)) return JSBI.__isBigInt(b) ? JSBI.equal(a, b) : JSBI.EQ(b, a);\n\n      if (\"number\" == typeof a) {\n        if (JSBI.__isBigInt(b)) return JSBI.__equalToNumber(b, a);\n        if (\"object\" != typeof b) return a == b;\n        b = JSBI.__toPrimitive(b);\n      } else if (\"string\" == typeof a) {\n        if (JSBI.__isBigInt(b)) return a = JSBI.__fromString(a), null !== a && JSBI.equal(a, b);\n        if (\"object\" != typeof b) return a == b;\n        b = JSBI.__toPrimitive(b);\n      } else if (\"boolean\" == typeof a) {\n        if (JSBI.__isBigInt(b)) return JSBI.__equalToNumber(b, +a);\n        if (\"object\" != typeof b) return a == b;\n        b = JSBI.__toPrimitive(b);\n      } else if (\"symbol\" == typeof a) {\n        if (JSBI.__isBigInt(b)) return !1;\n        if (\"object\" != typeof b) return a == b;\n        b = JSBI.__toPrimitive(b);\n      } else if (\"object\" == typeof a) {\n        if (\"object\" == typeof b && b.constructor !== JSBI) return a == b;\n        a = JSBI.__toPrimitive(a);\n      } else return a == b;\n    }\n  }\n\n  static NE(a, b) {\n    return !JSBI.EQ(a, b);\n  }\n\n  static __zero() {\n    return new JSBI(0, !1);\n  }\n\n  static __oneDigit(a, b) {\n    const c = new JSBI(1, b);\n    return c.__setDigit(0, a), c;\n  }\n\n  __copy() {\n    const a = new JSBI(this.length, this.sign);\n\n    for (let b = 0; b < this.length; b++) a[b] = this[b];\n\n    return a;\n  }\n\n  __trim() {\n    let a = this.length,\n        b = this[a - 1];\n\n    for (; 0 === b;) a--, b = this[a - 1], this.pop();\n\n    return 0 === a && (this.sign = !1), this;\n  }\n\n  __initializeDigits() {\n    for (let a = 0; a < this.length; a++) this[a] = 0;\n  }\n\n  static __decideRounding(a, b, c, d) {\n    if (0 < b) return -1;\n    let e;\n    if (0 > b) e = -b - 1;else {\n      if (0 === c) return -1;\n      c--, d = a.__digit(c), e = 31;\n    }\n    let f = 1 << e;\n    if (0 == (d & f)) return -1;\n    if (f -= 1, 0 != (d & f)) return 1;\n\n    for (; 0 < c;) if (c--, 0 !== a.__digit(c)) return 1;\n\n    return 0;\n  }\n\n  static __fromDouble(a) {\n    JSBI.__kBitConversionDouble[0] = a;\n    const b = 2047 & JSBI.__kBitConversionInts[1] >>> 20,\n          c = b - 1023,\n          d = (c >>> 5) + 1,\n          e = new JSBI(d, 0 > a);\n    let f = 1048575 & JSBI.__kBitConversionInts[1] | 1048576,\n        g = JSBI.__kBitConversionInts[0];\n    const h = 20,\n          i = 31 & c;\n    let j,\n        k = 0;\n\n    if (i < 20) {\n      const a = h - i;\n      k = a + 32, j = f >>> a, f = f << 32 - a | g >>> a, g <<= 32 - a;\n    } else if (i === 20) k = 32, j = f, f = g;else {\n      const a = i - h;\n      k = 32 - a, j = f << a | g >>> 32 - a, f = g << a;\n    }\n\n    e.__setDigit(d - 1, j);\n\n    for (let b = d - 2; 0 <= b; b--) 0 < k ? (k -= 32, j = f, f = g) : j = 0, e.__setDigit(b, j);\n\n    return e.__trim();\n  }\n\n  static __isWhitespace(a) {\n    return !!(13 >= a && 9 <= a) || (159 >= a ? 32 == a : 131071 >= a ? 160 == a || 5760 == a : 196607 >= a ? (a &= 131071, 10 >= a || 40 == a || 41 == a || 47 == a || 95 == a || 4096 == a) : 65279 == a);\n  }\n\n  static __fromString(a, b = 0) {\n    let c = 0;\n    const e = a.length;\n    let f = 0;\n    if (f === e) return JSBI.__zero();\n    let g = a.charCodeAt(f);\n\n    for (; JSBI.__isWhitespace(g);) {\n      if (++f === e) return JSBI.__zero();\n      g = a.charCodeAt(f);\n    }\n\n    if (43 === g) {\n      if (++f === e) return null;\n      g = a.charCodeAt(f), c = 1;\n    } else if (45 === g) {\n      if (++f === e) return null;\n      g = a.charCodeAt(f), c = -1;\n    }\n\n    if (0 === b) {\n      if (b = 10, 48 === g) {\n        if (++f === e) return JSBI.__zero();\n\n        if (g = a.charCodeAt(f), 88 === g || 120 === g) {\n          if (b = 16, ++f === e) return null;\n          g = a.charCodeAt(f);\n        } else if (79 === g || 111 === g) {\n          if (b = 8, ++f === e) return null;\n          g = a.charCodeAt(f);\n        } else if (66 === g || 98 === g) {\n          if (b = 2, ++f === e) return null;\n          g = a.charCodeAt(f);\n        }\n      }\n    } else if (16 === b && 48 === g) {\n      if (++f === e) return JSBI.__zero();\n\n      if (g = a.charCodeAt(f), 88 === g || 120 === g) {\n        if (++f === e) return null;\n        g = a.charCodeAt(f);\n      }\n    }\n\n    for (; 48 === g;) {\n      if (++f === e) return JSBI.__zero();\n      g = a.charCodeAt(f);\n    }\n\n    const h = e - f;\n    let i = JSBI.__kMaxBitsPerChar[b],\n        j = JSBI.__kBitsPerCharTableMultiplier - 1;\n    if (h > 1073741824 / i) return null;\n    const k = i * h + j >>> JSBI.__kBitsPerCharTableShift,\n          l = new JSBI(k + 31 >>> 5, !1),\n          n = 10 > b ? b : 10,\n          o = 10 < b ? b - 10 : 0;\n\n    if (0 == (b & b - 1)) {\n      i >>= JSBI.__kBitsPerCharTableShift;\n      const b = [],\n            c = [];\n      let d = !1;\n\n      do {\n        let h = 0,\n            j = 0;\n\n        for (;;) {\n          let b;\n          if (g - 48 >>> 0 < n) b = g - 48;else if ((32 | g) - 97 >>> 0 < o) b = (32 | g) - 87;else {\n            d = !0;\n            break;\n          }\n\n          if (j += i, h = h << i | b, ++f === e) {\n            d = !0;\n            break;\n          }\n\n          if (g = a.charCodeAt(f), 32 < j + i) break;\n        }\n\n        b.push(h), c.push(j);\n      } while (!d);\n\n      JSBI.__fillFromParts(l, b, c);\n    } else {\n      l.__initializeDigits();\n\n      let c = !1,\n          h = 0;\n\n      do {\n        let k = 0,\n            p = 1;\n\n        for (;;) {\n          let i;\n          if (g - 48 >>> 0 < n) i = g - 48;else if ((32 | g) - 97 >>> 0 < o) i = (32 | g) - 87;else {\n            c = !0;\n            break;\n          }\n          const d = p * b;\n          if (4294967295 < d) break;\n\n          if (p = d, k = k * b + i, h++, ++f === e) {\n            c = !0;\n            break;\n          }\n\n          g = a.charCodeAt(f);\n        }\n\n        j = 32 * JSBI.__kBitsPerCharTableMultiplier - 1;\n        const q = i * h + j >>> JSBI.__kBitsPerCharTableShift + 5;\n\n        l.__inplaceMultiplyAdd(p, k, q);\n      } while (!c);\n    }\n\n    if (f !== e) {\n      if (!JSBI.__isWhitespace(g)) return null;\n\n      for (f++; f < e; f++) if (g = a.charCodeAt(f), !JSBI.__isWhitespace(g)) return null;\n    }\n\n    return 0 != c && 10 !== b ? null : (l.sign = -1 == c, l.__trim());\n  }\n\n  static __fillFromParts(a, b, c) {\n    let d = 0,\n        e = 0,\n        f = 0;\n\n    for (let g = b.length - 1; 0 <= g; g--) {\n      const h = b[g],\n            i = c[g];\n      e |= h << f, f += i, 32 === f ? (a.__setDigit(d++, e), f = 0, e = 0) : 32 < f && (a.__setDigit(d++, e), f -= 32, e = h >>> i - f);\n    }\n\n    if (0 !== e) {\n      if (d >= a.length) throw new Error(\"implementation bug\");\n\n      a.__setDigit(d++, e);\n    }\n\n    for (; d < a.length; d++) a.__setDigit(d, 0);\n  }\n\n  static __toStringBasePowerOfTwo(a, b) {\n    var c = Math.clz32;\n    const d = a.length;\n    let e = b - 1;\n    e = (85 & e >>> 1) + (85 & e), e = (51 & e >>> 2) + (51 & e), e = (15 & e >>> 4) + (15 & e);\n\n    const f = e,\n          g = b - 1,\n          h = a.__digit(d - 1),\n          i = c(h);\n\n    let j = 0 | (32 * d - i + f - 1) / f;\n    if (a.sign && j++, 268435456 < j) throw new Error(\"string too long\");\n    const k = Array(j);\n    let l = j - 1,\n        m = 0,\n        n = 0;\n\n    for (let c = 0; c < d - 1; c++) {\n      const b = a.__digit(c),\n            d = (m | b << n) & g;\n\n      k[l--] = JSBI.__kConversionChars[d];\n      const e = f - n;\n\n      for (m = b >>> e, n = 32 - e; n >= f;) k[l--] = JSBI.__kConversionChars[m & g], m >>>= f, n -= f;\n    }\n\n    const o = (m | h << n) & g;\n\n    for (k[l--] = JSBI.__kConversionChars[o], m = h >>> f - n; 0 !== m;) k[l--] = JSBI.__kConversionChars[m & g], m >>>= f;\n\n    if (a.sign && (k[l--] = \"-\"), -1 != l) throw new Error(\"implementation bug\");\n    return k.join(\"\");\n  }\n\n  static __toStringGeneric(a, b, c) {\n    var d = Math.clz32;\n    const e = a.length;\n    if (0 === e) return \"\";\n\n    if (1 === e) {\n      let d = a.__unsignedDigit(0).toString(b);\n\n      return !1 === c && a.sign && (d = \"-\" + d), d;\n    }\n\n    const f = 32 * e - d(a.__digit(e - 1)),\n          g = JSBI.__kMaxBitsPerChar[b],\n          h = g - 1;\n    let i = f * JSBI.__kBitsPerCharTableMultiplier;\n    i += h - 1, i = 0 | i / h;\n    const j = i + 1 >> 1,\n          k = JSBI.exponentiate(JSBI.__oneDigit(b, !1), JSBI.__oneDigit(j, !1));\n    let l, m;\n\n    const n = k.__unsignedDigit(0);\n\n    if (1 === k.length && 65535 >= n) {\n      l = new JSBI(a.length, !1), l.__initializeDigits();\n      let c = 0;\n\n      for (let b = 2 * a.length - 1; 0 <= b; b--) {\n        const d = c << 16 | a.__halfDigit(b);\n\n        l.__setHalfDigit(b, 0 | d / n), c = 0 | d % n;\n      }\n\n      m = c.toString(b);\n    } else {\n      const c = JSBI.__absoluteDivLarge(a, k, !0, !0);\n\n      l = c.quotient;\n\n      const d = c.remainder.__trim();\n\n      m = JSBI.__toStringGeneric(d, b, !0);\n    }\n\n    l.__trim();\n\n    let o = JSBI.__toStringGeneric(l, b, !0);\n\n    for (; m.length < j;) m = \"0\" + m;\n\n    return !1 === c && a.sign && (o = \"-\" + o), o + m;\n  }\n\n  static __unequalSign(a) {\n    return a ? -1 : 1;\n  }\n\n  static __absoluteGreater(a) {\n    return a ? -1 : 1;\n  }\n\n  static __absoluteLess(a) {\n    return a ? 1 : -1;\n  }\n\n  static __compareToBigInt(a, b) {\n    const c = a.sign;\n    if (c !== b.sign) return JSBI.__unequalSign(c);\n\n    const d = JSBI.__absoluteCompare(a, b);\n\n    return 0 < d ? JSBI.__absoluteGreater(c) : 0 > d ? JSBI.__absoluteLess(c) : 0;\n  }\n\n  static __compareToNumber(a, b) {\n    if (b | !0) {\n      const c = a.sign,\n            d = 0 > b;\n      if (c !== d) return JSBI.__unequalSign(c);\n\n      if (0 === a.length) {\n        if (d) throw new Error(\"implementation bug\");\n        return 0 === b ? 0 : -1;\n      }\n\n      if (1 < a.length) return JSBI.__absoluteGreater(c);\n\n      const e = Math.abs(b),\n            f = a.__unsignedDigit(0);\n\n      return f > e ? JSBI.__absoluteGreater(c) : f < e ? JSBI.__absoluteLess(c) : 0;\n    }\n\n    return JSBI.__compareToDouble(a, b);\n  }\n\n  static __compareToDouble(a, b) {\n    var c = Math.clz32;\n    if (b !== b) return b;\n    if (b === 1 / 0) return -1;\n    if (b === -Infinity) return 1;\n    const d = a.sign;\n    if (d !== 0 > b) return JSBI.__unequalSign(d);\n    if (0 === b) throw new Error(\"implementation bug: should be handled elsewhere\");\n    if (0 === a.length) return -1;\n    JSBI.__kBitConversionDouble[0] = b;\n    const e = 2047 & JSBI.__kBitConversionInts[1] >>> 20;\n    if (2047 == e) throw new Error(\"implementation bug: handled elsewhere\");\n    const f = e - 1023;\n    if (0 > f) return JSBI.__absoluteGreater(d);\n    const g = a.length;\n\n    let h = a.__digit(g - 1);\n\n    const i = c(h),\n          j = 32 * g - i,\n          k = f + 1;\n    if (j < k) return JSBI.__absoluteLess(d);\n    if (j > k) return JSBI.__absoluteGreater(d);\n    let l = 1048576 | 1048575 & JSBI.__kBitConversionInts[1],\n        m = JSBI.__kBitConversionInts[0];\n    const n = 20,\n          o = 31 - i;\n    if (o !== (j - 1) % 31) throw new Error(\"implementation bug\");\n    let p,\n        q = 0;\n\n    if (20 > o) {\n      const a = n - o;\n      q = a + 32, p = l >>> a, l = l << 32 - a | m >>> a, m <<= 32 - a;\n    } else if (20 === o) q = 32, p = l, l = m;else {\n      const a = o - n;\n      q = 32 - a, p = l << a | m >>> 32 - a, l = m << a;\n    }\n\n    if (h >>>= 0, p >>>= 0, h > p) return JSBI.__absoluteGreater(d);\n    if (h < p) return JSBI.__absoluteLess(d);\n\n    for (let c = g - 2; 0 <= c; c--) {\n      0 < q ? (q -= 32, p = l >>> 0, l = m, m = 0) : p = 0;\n\n      const b = a.__unsignedDigit(c);\n\n      if (b > p) return JSBI.__absoluteGreater(d);\n      if (b < p) return JSBI.__absoluteLess(d);\n    }\n\n    if (0 !== l || 0 !== m) {\n      if (0 === q) throw new Error(\"implementation bug\");\n      return JSBI.__absoluteLess(d);\n    }\n\n    return 0;\n  }\n\n  static __equalToNumber(a, b) {\n    var c = Math.abs;\n    return b | 0 === b ? 0 === b ? 0 === a.length : 1 === a.length && a.sign === 0 > b && a.__unsignedDigit(0) === c(b) : 0 === JSBI.__compareToDouble(a, b);\n  }\n\n  static __comparisonResultToBool(a, b) {\n    switch (b) {\n      case 0:\n        return 0 > a;\n\n      case 1:\n        return 0 >= a;\n\n      case 2:\n        return 0 < a;\n\n      case 3:\n        return 0 <= a;\n    }\n\n    throw new Error(\"unreachable\");\n  }\n\n  static __compare(a, b, c) {\n    if (a = JSBI.__toPrimitive(a), b = JSBI.__toPrimitive(b), \"string\" == typeof a && \"string\" == typeof b) switch (c) {\n      case 0:\n        return a < b;\n\n      case 1:\n        return a <= b;\n\n      case 2:\n        return a > b;\n\n      case 3:\n        return a >= b;\n    }\n    if (JSBI.__isBigInt(a) && \"string\" == typeof b) return b = JSBI.__fromString(b), null !== b && JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(a, b), c);\n    if (\"string\" == typeof a && JSBI.__isBigInt(b)) return a = JSBI.__fromString(a), null !== a && JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(a, b), c);\n\n    if (a = JSBI.__toNumeric(a), b = JSBI.__toNumeric(b), JSBI.__isBigInt(a)) {\n      if (JSBI.__isBigInt(b)) return JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(a, b), c);\n      if (\"number\" != typeof b) throw new Error(\"implementation bug\");\n      return JSBI.__comparisonResultToBool(JSBI.__compareToNumber(a, b), c);\n    }\n\n    if (\"number\" != typeof a) throw new Error(\"implementation bug\");\n    if (JSBI.__isBigInt(b)) return JSBI.__comparisonResultToBool(JSBI.__compareToNumber(b, a), 2 ^ c);\n    if (\"number\" != typeof b) throw new Error(\"implementation bug\");\n    return 0 === c ? a < b : 1 === c ? a <= b : 2 === c ? a > b : 3 === c ? a >= b : void 0;\n  }\n\n  __clzmsd() {\n    return Math.clz32(this[this.length - 1]);\n  }\n\n  static __absoluteAdd(a, b, c) {\n    if (a.length < b.length) return JSBI.__absoluteAdd(b, a, c);\n    if (0 === a.length) return a;\n    if (0 === b.length) return a.sign === c ? a : JSBI.unaryMinus(a);\n    let d = a.length;\n    (0 === a.__clzmsd() || b.length === a.length && 0 === b.__clzmsd()) && d++;\n    const e = new JSBI(d, c);\n    let f = 0,\n        g = 0;\n\n    for (; g < b.length; g++) {\n      const c = b.__digit(g),\n            d = a.__digit(g),\n            h = (65535 & d) + (65535 & c) + f,\n            i = (d >>> 16) + (c >>> 16) + (h >>> 16);\n\n      f = i >>> 16, e.__setDigit(g, 65535 & h | i << 16);\n    }\n\n    for (; g < a.length; g++) {\n      const b = a.__digit(g),\n            c = (65535 & b) + f,\n            d = (b >>> 16) + (c >>> 16);\n\n      f = d >>> 16, e.__setDigit(g, 65535 & c | d << 16);\n    }\n\n    return g < e.length && e.__setDigit(g, f), e.__trim();\n  }\n\n  static __absoluteSub(a, b, c) {\n    if (0 === a.length) return a;\n    if (0 === b.length) return a.sign === c ? a : JSBI.unaryMinus(a);\n    const d = new JSBI(a.length, c);\n    let e = 0,\n        f = 0;\n\n    for (; f < b.length; f++) {\n      const c = a.__digit(f),\n            g = b.__digit(f),\n            h = (65535 & c) - (65535 & g) - e;\n\n      e = 1 & h >>> 16;\n      const i = (c >>> 16) - (g >>> 16) - e;\n      e = 1 & i >>> 16, d.__setDigit(f, 65535 & h | i << 16);\n    }\n\n    for (; f < a.length; f++) {\n      const b = a.__digit(f),\n            c = (65535 & b) - e;\n\n      e = 1 & c >>> 16;\n      const g = (b >>> 16) - e;\n      e = 1 & g >>> 16, d.__setDigit(f, 65535 & c | g << 16);\n    }\n\n    return d.__trim();\n  }\n\n  static __absoluteAddOne(a, b, c = null) {\n    const d = a.length;\n    null === c ? c = new JSBI(d, b) : c.sign = b;\n    let e = !0;\n\n    for (let f, g = 0; g < d; g++) {\n      f = a.__digit(g);\n      const b = -1 === f;\n      e && (f = 0 | f + 1), e = b, c.__setDigit(g, f);\n    }\n\n    return e && c.__setDigitGrow(d, 1), c;\n  }\n\n  static __absoluteSubOne(a, b) {\n    const c = a.length;\n    b = b || c;\n    const d = new JSBI(b, !1);\n    let e = !0;\n\n    for (let f, g = 0; g < c; g++) {\n      f = a.__digit(g);\n      const b = 0 === f;\n      e && (f = 0 | f - 1), e = b, d.__setDigit(g, f);\n    }\n\n    for (let e = c; e < b; e++) d.__setDigit(e, 0);\n\n    return d;\n  }\n\n  static __absoluteAnd(a, b, c = null) {\n    let d = a.length,\n        e = b.length,\n        f = e;\n\n    if (d < e) {\n      f = d;\n      const c = a,\n            g = d;\n      a = b, d = e, b = c, e = g;\n    }\n\n    let g = f;\n    null === c ? c = new JSBI(g, !1) : g = c.length;\n    let h = 0;\n\n    for (; h < f; h++) c.__setDigit(h, a.__digit(h) & b.__digit(h));\n\n    for (; h < g; h++) c.__setDigit(h, 0);\n\n    return c;\n  }\n\n  static __absoluteAndNot(a, b, c = null) {\n    const d = a.length,\n          e = b.length;\n    let f = e;\n    d < e && (f = d);\n    let g = d;\n    null === c ? c = new JSBI(g, !1) : g = c.length;\n    let h = 0;\n\n    for (; h < f; h++) c.__setDigit(h, a.__digit(h) & ~b.__digit(h));\n\n    for (; h < d; h++) c.__setDigit(h, a.__digit(h));\n\n    for (; h < g; h++) c.__setDigit(h, 0);\n\n    return c;\n  }\n\n  static __absoluteOr(a, b, c = null) {\n    let d = a.length,\n        e = b.length,\n        f = e;\n\n    if (d < e) {\n      f = d;\n      const c = a,\n            g = d;\n      a = b, d = e, b = c, e = g;\n    }\n\n    let g = d;\n    null === c ? c = new JSBI(g, !1) : g = c.length;\n    let h = 0;\n\n    for (; h < f; h++) c.__setDigit(h, a.__digit(h) | b.__digit(h));\n\n    for (; h < d; h++) c.__setDigit(h, a.__digit(h));\n\n    for (; h < g; h++) c.__setDigit(h, 0);\n\n    return c;\n  }\n\n  static __absoluteXor(a, b, c = null) {\n    let d = a.length,\n        e = b.length,\n        f = e;\n\n    if (d < e) {\n      f = d;\n      const c = a,\n            g = d;\n      a = b, d = e, b = c, e = g;\n    }\n\n    let g = d;\n    null === c ? c = new JSBI(g, !1) : g = c.length;\n    let h = 0;\n\n    for (; h < f; h++) c.__setDigit(h, a.__digit(h) ^ b.__digit(h));\n\n    for (; h < d; h++) c.__setDigit(h, a.__digit(h));\n\n    for (; h < g; h++) c.__setDigit(h, 0);\n\n    return c;\n  }\n\n  static __absoluteCompare(a, b) {\n    const c = a.length - b.length;\n    if (0 != c) return c;\n    let d = a.length - 1;\n\n    for (; 0 <= d && a.__digit(d) === b.__digit(d);) d--;\n\n    return 0 > d ? 0 : a.__unsignedDigit(d) > b.__unsignedDigit(d) ? 1 : -1;\n  }\n\n  static __multiplyAccumulate(a, b, c, d) {\n    var e = Math.imul;\n    if (0 === b) return;\n    const f = 65535 & b,\n          g = b >>> 16;\n    let h = 0,\n        j = 0,\n        k = 0;\n\n    for (let l = 0; l < a.length; l++, d++) {\n      let b = c.__digit(d),\n          i = 65535 & b,\n          m = b >>> 16;\n\n      const n = a.__digit(l),\n            o = 65535 & n,\n            p = n >>> 16,\n            q = e(o, f),\n            r = e(o, g),\n            s = e(p, f),\n            t = e(p, g);\n\n      i += j + (65535 & q), m += k + h + (i >>> 16) + (q >>> 16) + (65535 & r) + (65535 & s), h = m >>> 16, j = (r >>> 16) + (s >>> 16) + (65535 & t) + h, h = j >>> 16, j &= 65535, k = t >>> 16, b = 65535 & i | m << 16, c.__setDigit(d, b);\n    }\n\n    for (; 0 != h || 0 !== j || 0 !== k; d++) {\n      let a = c.__digit(d);\n\n      const b = (65535 & a) + j,\n            e = (a >>> 16) + (b >>> 16) + k + h;\n      j = 0, k = 0, h = e >>> 16, a = 65535 & b | e << 16, c.__setDigit(d, a);\n    }\n  }\n\n  static __internalMultiplyAdd(a, b, c, d, e) {\n    var f = Math.imul;\n    let g = c,\n        h = 0;\n\n    for (let j = 0; j < d; j++) {\n      const c = a.__digit(j),\n            d = f(65535 & c, b),\n            i = (65535 & d) + h + g;\n\n      g = i >>> 16;\n      const k = f(c >>> 16, b),\n            l = (65535 & k) + (d >>> 16) + g;\n      g = l >>> 16, h = k >>> 16, e.__setDigit(j, l << 16 | 65535 & i);\n    }\n\n    if (e.length > d) for (e.__setDigit(d++, g + h); d < e.length;) e.__setDigit(d++, 0);else if (0 !== g + h) throw new Error(\"implementation bug\");\n  }\n\n  __inplaceMultiplyAdd(a, b, c) {\n    var e = Math.imul;\n    c > this.length && (c = this.length);\n    const f = 65535 & a,\n          g = a >>> 16;\n    let h = 0,\n        j = 65535 & b,\n        k = b >>> 16;\n\n    for (let l = 0; l < c; l++) {\n      const a = this.__digit(l),\n            b = 65535 & a,\n            c = a >>> 16,\n            d = e(b, f),\n            i = e(b, g),\n            m = e(c, f),\n            n = e(c, g),\n            o = j + (65535 & d),\n            p = k + h + (o >>> 16) + (d >>> 16) + (65535 & i) + (65535 & m);\n\n      j = (i >>> 16) + (m >>> 16) + (65535 & n) + (p >>> 16), h = j >>> 16, j &= 65535, k = n >>> 16;\n\n      this.__setDigit(l, 65535 & o | p << 16);\n    }\n\n    if (0 != h || 0 !== j || 0 !== k) throw new Error(\"implementation bug\");\n  }\n\n  static __absoluteDivSmall(a, b, c) {\n    null === c && (c = new JSBI(a.length, !1));\n    let d = 0;\n\n    for (let e, f = 2 * a.length - 1; 0 <= f; f -= 2) {\n      e = (d << 16 | a.__halfDigit(f)) >>> 0;\n      const g = 0 | e / b;\n      d = 0 | e % b, e = (d << 16 | a.__halfDigit(f - 1)) >>> 0;\n      const h = 0 | e / b;\n      d = 0 | e % b, c.__setDigit(f >>> 1, g << 16 | h);\n    }\n\n    return c;\n  }\n\n  static __absoluteModSmall(a, b) {\n    let c = 0;\n\n    for (let d = 2 * a.length - 1; 0 <= d; d--) {\n      const e = (c << 16 | a.__halfDigit(d)) >>> 0;\n      c = 0 | e % b;\n    }\n\n    return c;\n  }\n\n  static __absoluteDivLarge(a, b, d, e) {\n    var f = Math.imul;\n\n    const g = b.__halfDigitLength(),\n          h = b.length,\n          c = a.__halfDigitLength() - g;\n\n    let i = null;\n    d && (i = new JSBI(c + 2 >>> 1, !1), i.__initializeDigits());\n    const k = new JSBI(g + 2 >>> 1, !1);\n\n    k.__initializeDigits();\n\n    const l = JSBI.__clz16(b.__halfDigit(g - 1));\n\n    0 < l && (b = JSBI.__specialLeftShift(b, l, 0));\n\n    const m = JSBI.__specialLeftShift(a, l, 1),\n          n = b.__halfDigit(g - 1);\n\n    let o = 0;\n\n    for (let l, p = c; 0 <= p; p--) {\n      l = 65535;\n\n      const a = m.__halfDigit(p + g);\n\n      if (a !== n) {\n        const c = (a << 16 | m.__halfDigit(p + g - 1)) >>> 0;\n        l = 0 | c / n;\n        let d = 0 | c % n;\n\n        const e = b.__halfDigit(g - 2),\n              h = m.__halfDigit(p + g - 2);\n\n        for (; f(l, e) >>> 0 > (d << 16 | h) >>> 0 && (l--, d += n, !(65535 < d)););\n      }\n\n      JSBI.__internalMultiplyAdd(b, l, 0, h, k);\n\n      let e = m.__inplaceSub(k, p, g + 1);\n\n      0 !== e && (e = m.__inplaceAdd(b, p, g), m.__setHalfDigit(p + g, m.__halfDigit(p + g) + e), l--), d && (1 & p ? o = l << 16 : i.__setDigit(p >>> 1, o | l));\n    }\n\n    return e ? (m.__inplaceRightShift(l), d ? {\n      quotient: i,\n      remainder: m\n    } : m) : d ? i : void 0;\n  }\n\n  static __clz16(a) {\n    return Math.clz32(a) - 16;\n  }\n\n  __inplaceAdd(a, b, c) {\n    let d = 0;\n\n    for (let e = 0; e < c; e++) {\n      const c = this.__halfDigit(b + e) + a.__halfDigit(e) + d;\n      d = c >>> 16, this.__setHalfDigit(b + e, c);\n    }\n\n    return d;\n  }\n\n  __inplaceSub(a, b, c) {\n    let d = 0;\n\n    if (1 & b) {\n      b >>= 1;\n\n      let e = this.__digit(b),\n          f = 65535 & e,\n          g = 0;\n\n      for (; g < c - 1 >>> 1; g++) {\n        const c = a.__digit(g),\n              h = (e >>> 16) - (65535 & c) - d;\n\n        d = 1 & h >>> 16, this.__setDigit(b + g, h << 16 | 65535 & f), e = this.__digit(b + g + 1), f = (65535 & e) - (c >>> 16) - d, d = 1 & f >>> 16;\n      }\n\n      const h = a.__digit(g),\n            i = (e >>> 16) - (65535 & h) - d;\n\n      d = 1 & i >>> 16, this.__setDigit(b + g, i << 16 | 65535 & f);\n      if (b + g + 1 >= this.length) throw new RangeError(\"out of bounds\");\n      0 == (1 & c) && (e = this.__digit(b + g + 1), f = (65535 & e) - (h >>> 16) - d, d = 1 & f >>> 16, this.__setDigit(b + a.length, 4294901760 & e | 65535 & f));\n    } else {\n      b >>= 1;\n      let e = 0;\n\n      for (; e < a.length - 1; e++) {\n        const c = this.__digit(b + e),\n              f = a.__digit(e),\n              g = (65535 & c) - (65535 & f) - d;\n\n        d = 1 & g >>> 16;\n        const h = (c >>> 16) - (f >>> 16) - d;\n        d = 1 & h >>> 16, this.__setDigit(b + e, h << 16 | 65535 & g);\n      }\n\n      const f = this.__digit(b + e),\n            g = a.__digit(e),\n            h = (65535 & f) - (65535 & g) - d;\n\n      d = 1 & h >>> 16;\n      let i = 0;\n      0 == (1 & c) && (i = (f >>> 16) - (g >>> 16) - d, d = 1 & i >>> 16), this.__setDigit(b + e, i << 16 | 65535 & h);\n    }\n\n    return d;\n  }\n\n  __inplaceRightShift(a) {\n    if (0 === a) return;\n    let b = this.__digit(0) >>> a;\n    const c = this.length - 1;\n\n    for (let e = 0; e < c; e++) {\n      const c = this.__digit(e + 1);\n\n      this.__setDigit(e, c << 32 - a | b), b = c >>> a;\n    }\n\n    this.__setDigit(c, b);\n  }\n\n  static __specialLeftShift(a, b, c) {\n    const d = a.length,\n          e = new JSBI(d + c, !1);\n\n    if (0 === b) {\n      for (let b = 0; b < d; b++) e.__setDigit(b, a.__digit(b));\n\n      return 0 < c && e.__setDigit(d, 0), e;\n    }\n\n    let f = 0;\n\n    for (let g = 0; g < d; g++) {\n      const c = a.__digit(g);\n\n      e.__setDigit(g, c << b | f), f = c >>> 32 - b;\n    }\n\n    return 0 < c && e.__setDigit(d, f), e;\n  }\n\n  static __leftShiftByAbsolute(a, b) {\n    const c = JSBI.__toShiftAmount(b);\n\n    if (0 > c) throw new RangeError(\"BigInt too big\");\n    const e = c >>> 5,\n          f = 31 & c,\n          g = a.length,\n          h = 0 !== f && 0 != a.__digit(g - 1) >>> 32 - f,\n          j = g + e + (h ? 1 : 0),\n          k = new JSBI(j, a.sign);\n\n    if (0 === f) {\n      let b = 0;\n\n      for (; b < e; b++) k.__setDigit(b, 0);\n\n      for (; b < j; b++) k.__setDigit(b, a.__digit(b - e));\n    } else {\n      let b = 0;\n\n      for (let a = 0; a < e; a++) k.__setDigit(a, 0);\n\n      for (let c = 0; c < g; c++) {\n        const g = a.__digit(c);\n\n        k.__setDigit(c + e, g << f | b), b = g >>> 32 - f;\n      }\n\n      if (h) k.__setDigit(g + e, b);else if (0 != b) throw new Error(\"implementation bug\");\n    }\n\n    return k.__trim();\n  }\n\n  static __rightShiftByAbsolute(a, b) {\n    const c = a.length,\n          d = a.sign,\n          e = JSBI.__toShiftAmount(b);\n\n    if (0 > e) return JSBI.__rightShiftByMaximum(d);\n    const f = e >>> 5,\n          g = 31 & e;\n    let h = c - f;\n    if (0 >= h) return JSBI.__rightShiftByMaximum(d);\n    let i = !1;\n\n    if (d) {\n      if (0 != (a.__digit(f) & (1 << g) - 1)) i = !0;else for (let b = 0; b < f; b++) if (0 !== a.__digit(b)) {\n        i = !0;\n        break;\n      }\n    }\n\n    if (i && 0 === g) {\n      const b = a.__digit(c - 1);\n\n      0 == ~b && h++;\n    }\n\n    let j = new JSBI(h, d);\n    if (0 === g) for (let b = f; b < c; b++) j.__setDigit(b - f, a.__digit(b));else {\n      let b = a.__digit(f) >>> g;\n      const d = c - f - 1;\n\n      for (let c = 0; c < d; c++) {\n        const e = a.__digit(c + f + 1);\n\n        j.__setDigit(c, e << 32 - g | b), b = e >>> g;\n      }\n\n      j.__setDigit(d, b);\n    }\n    return i && (j = JSBI.__absoluteAddOne(j, !0, j)), j.__trim();\n  }\n\n  static __rightShiftByMaximum(a) {\n    return a ? JSBI.__oneDigit(1, !0) : JSBI.__zero();\n  }\n\n  static __toShiftAmount(a) {\n    if (1 < a.length) return -1;\n\n    const b = a.__unsignedDigit(0);\n\n    return b > JSBI.__kMaxLengthBits ? -1 : b;\n  }\n\n  static __toPrimitive(a, b = \"default\") {\n    if (\"object\" != typeof a) return a;\n    if (a.constructor === JSBI) return a;\n    const c = a[Symbol.toPrimitive];\n\n    if (c) {\n      const a = c(b);\n      if (\"object\" != typeof a) return a;\n      throw new TypeError(\"Cannot convert object to primitive value\");\n    }\n\n    const d = a.valueOf;\n\n    if (d) {\n      const b = d.call(a);\n      if (\"object\" != typeof b) return b;\n    }\n\n    const e = a.toString;\n\n    if (e) {\n      const b = e.call(a);\n      if (\"object\" != typeof b) return b;\n    }\n\n    throw new TypeError(\"Cannot convert object to primitive value\");\n  }\n\n  static __toNumeric(a) {\n    return JSBI.__isBigInt(a) ? a : +a;\n  }\n\n  static __isBigInt(a) {\n    return \"object\" == typeof a && a.constructor === JSBI;\n  }\n\n  static __truncateToNBits(a, b) {\n    const c = a + 31 >>> 5,\n          d = new JSBI(c, b.sign),\n          e = c - 1;\n\n    for (let c = 0; c < e; c++) d.__setDigit(c, b.__digit(c));\n\n    let f = b.__digit(e);\n\n    if (0 != (31 & a)) {\n      const b = 32 - (31 & a);\n      f = f << b >>> b;\n    }\n\n    return d.__setDigit(e, f), d.__trim();\n  }\n\n  static __truncateAndSubFromPowerOfTwo(a, b, c) {\n    var d = Math.min;\n    const e = a + 31 >>> 5,\n          f = new JSBI(e, c);\n    let g = 0;\n    const h = e - 1;\n    let j = 0;\n\n    for (const e = d(h, b.length); g < e; g++) {\n      const a = b.__digit(g),\n            c = 0 - (65535 & a) - j;\n\n      j = 1 & c >>> 16;\n      const d = 0 - (a >>> 16) - j;\n      j = 1 & d >>> 16, f.__setDigit(g, 65535 & c | d << 16);\n    }\n\n    for (; g < h; g++) f.__setDigit(g, 0 | -j);\n\n    let k = h < b.length ? b.__digit(h) : 0;\n    const l = 31 & a;\n    let m;\n\n    if (0 == l) {\n      const a = 0 - (65535 & k) - j;\n      j = 1 & a >>> 16;\n      const b = 0 - (k >>> 16) - j;\n      m = 65535 & a | b << 16;\n    } else {\n      const a = 32 - l;\n      k = k << a >>> a;\n      const b = 1 << 32 - a,\n            c = (65535 & b) - (65535 & k) - j;\n      j = 1 & c >>> 16;\n      const d = (b >>> 16) - (k >>> 16) - j;\n      m = 65535 & c | d << 16, m &= b - 1;\n    }\n\n    return f.__setDigit(h, m), f.__trim();\n  }\n\n  __digit(a) {\n    return this[a];\n  }\n\n  __unsignedDigit(a) {\n    return this[a] >>> 0;\n  }\n\n  __setDigit(a, b) {\n    this[a] = 0 | b;\n  }\n\n  __setDigitGrow(a, b) {\n    this[a] = 0 | b;\n  }\n\n  __halfDigitLength() {\n    const a = this.length;\n    return 65535 >= this.__unsignedDigit(a - 1) ? 2 * a - 1 : 2 * a;\n  }\n\n  __halfDigit(a) {\n    return 65535 & this[a >>> 1] >>> ((1 & a) << 4);\n  }\n\n  __setHalfDigit(a, b) {\n    const c = a >>> 1,\n          d = this.__digit(c),\n          e = 1 & a ? 65535 & d | b << 16 : 4294901760 & d | 65535 & b;\n\n    this.__setDigit(c, e);\n  }\n\n  static __digitPow(a, b) {\n    let c = 1;\n\n    for (; 0 < b;) 1 & b && (c *= a), b >>>= 1, a *= a;\n\n    return c;\n  }\n\n}\n\nJSBI.__kMaxLength = 33554432, JSBI.__kMaxLengthBits = JSBI.__kMaxLength << 5, JSBI.__kMaxBitsPerChar = [0, 0, 32, 51, 64, 75, 83, 90, 96, 102, 107, 111, 115, 119, 122, 126, 128, 131, 134, 136, 139, 141, 143, 145, 147, 149, 151, 153, 154, 156, 158, 159, 160, 162, 163, 165, 166], JSBI.__kBitsPerCharTableShift = 5, JSBI.__kBitsPerCharTableMultiplier = 1 << JSBI.__kBitsPerCharTableShift, JSBI.__kConversionChars = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"], JSBI.__kBitConversionBuffer = new ArrayBuffer(8), JSBI.__kBitConversionDouble = new Float64Array(JSBI.__kBitConversionBuffer), JSBI.__kBitConversionInts = new Int32Array(JSBI.__kBitConversionBuffer);\n/**\n * Re-maps a number from one range to another.\n *\n * In the example above, the number '25' is converted from a value in the range\n * 0..100 into a value that ranges from the left edge (0) to the right edge\n * (width) of the screen. Numbers outside the range are not clamped to 0 and 1,\n * because out-of-range values are often intentional and useful.\n *\n * From Processing.js\n *\n * @param {Number} value        The incoming value to be converted\n * @param {Number} istart       Lower bound of the value's current range\n * @param {Number} istop        Upper bound of the value's current range\n * @param {Number} ostart       Lower bound of the value's target range\n * @param {Number} ostop        Upper bound of the value's target range\n * @returns {Number}\n */\n\nfunction map(value, istart, istop, ostart, ostop) {\n  return ostart + (ostop - ostart) * ((value - istart) / (istop - istart));\n}\n/**\n * Normalizes a number from another range into a value between 0 and 1.\n *\n * Identical to map(value, low, high, 0, 1)\n * Numbers outside the range are not clamped to 0 and 1, because out-of-range\n * values are often intentional and useful.\n *\n * From Processing.js\n *\n * @param {Number} aNumber    The incoming value to be converted\n * @param {Number} low        Lower bound of the value's current range\n * @param {Number} high       Upper bound of the value's current range\n * @returns {Number}\n */\n\n\nfunction norm(aNumber, low, high) {\n  return (aNumber - low) / (high - low);\n}\n/**\n * Calculates a number between two numbers at a specific increment. The\n * progress parameter is the amount to interpolate between the two values where\n * 0.0 equal to the first point, 0.1 is very near the first point, 0.5 is\n * half-way in between, etc. The lerp function is convenient for creating\n * motion along a straight path and for drawing dotted lines.\n *\n * From Processing.js\n *\n * @param {Number} progress     between 0.0 and 1.0\n * @param {Number} value1       first value\n * @param {Number} value2       second value\n * @returns {Number}\n */\n\n\nfunction lerp(progress, value1, value2) {\n  return (value2 - value1) * progress + value1;\n}\n/**\n * Constrains a value to not exceed a maximum and minimum value.\n *\n * From Processing.js\n *\n * @param {Number} value   the value to constrain\n * @param {Number} value   minimum limit\n * @param {Number} value   maximum limit\n * @returns {Number}\n */\n\n\nfunction clamp(value) {\n  var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  return Math.min(max, Math.max(min, value));\n}\n/**\n * Returns a random integer between min (included) and max (excluded)\n * Note: Using Math.round() would give a non-uniform distribution\n *\n * From Mozilla MDN\n *\n * @param {Number} min    The minimum number (included)\n * @param {Number} max    The maximum number (excluded)\n * @returns {Number}\n */\n\n\nfunction randomInt(min, max) {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min)) + min;\n}\n/**\n * Random number between two values.\n *\n * From Mozilla MDN\n *\n * @param {Number} min The minimum number (included)\n * @param {Number} max The maximum number (excluded)\n * @returns {Number}\n */\n\n\nfunction random() {\n  var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  return Math.floor(Math.random() * (max - min)) + min;\n}\n/**\n * Divide and round two big integers.\n *\n * @param {BigInt|string|number} dividend Integer to be divided + rounded\n * @param {BigInt|string|number} divisor  Divisor\n * @returns {string}\n */\n\n\nfunction divideRoundBigInt(dividend, divisor) {\n  dividend = JSBI.BigInt(String(dividend));\n  divisor = JSBI.BigInt(String(divisor));\n  return JSBI.divide(JSBI.add(dividend, JSBI.divide(divisor, JSBI.BigInt(2))), divisor).toString();\n}\n\nexport { JSBI as J, random as a, clamp as c, divideRoundBigInt as d, lerp as l, map as m, norm as n, randomInt as r };","map":null,"metadata":{},"sourceType":"module"}