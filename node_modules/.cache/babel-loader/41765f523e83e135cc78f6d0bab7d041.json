{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _objectSpread = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar EventEmitter = require('events');\n\nvar debug = require('debug');\n\nvar log = debug('libp2p:webrtc-star:listener');\nlog.error = debug('libp2p:webrtc-star:listener:error');\n\nvar multiaddr = require('multiaddr');\n\nvar io = require('socket.io-client');\n\nvar SimplePeer = require('simple-peer');\n\nvar pDefer = require('p-defer');\n\nvar toConnection = require('./socket-to-conn');\n\nvar _require = require('./utils'),\n    cleanUrlSIO = _require.cleanUrlSIO;\n\nvar _require2 = require('./constants'),\n    CODE_P2P = _require2.CODE_P2P;\n\nvar sioOptions = {\n  transports: ['websocket'],\n  'force new connection': true\n};\n\nmodule.exports = function (_ref, WebRTCStar) {\n  var handler = _ref.handler,\n      upgrader = _ref.upgrader;\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var listener = new EventEmitter();\n  var listeningAddr;\n  listener.__connections = [];\n\n  listener.listen = function (ma) {\n    var defer = pDefer();\n    listeningAddr = ma;\n\n    if (!ma.protoCodes().includes(CODE_P2P) && upgrader.localPeer) {\n      WebRTCStar._signallingAddr = ma.encapsulate(\"/p2p/\".concat(upgrader.localPeer.toB58String()));\n    } else {\n      WebRTCStar._signallingAddr = ma;\n    }\n\n    var sioUrl = cleanUrlSIO(ma);\n    log('Dialing to Signalling Server on: ' + sioUrl);\n    listener.io = io.connect(sioUrl, sioOptions);\n\n    var incommingDial = function incommingDial(offer) {\n      if (offer.answer || offer.err) {\n        return;\n      }\n\n      var spOptions = _objectSpread({\n        trickle: false\n      }, options); // Use custom WebRTC implementation\n\n\n      if (WebRTCStar.wrtc) {\n        spOptions.wrtc = WebRTCStar.wrtc;\n      }\n\n      var channel = new SimplePeer(spOptions);\n\n      var onError = function onError(err) {\n        log.error('incoming connectioned errored', err);\n      };\n\n      channel.on('error', onError);\n      channel.once('close', function () {\n        channel.removeListener('error', onError);\n      });\n      channel.once('signal', function (signal) {\n        offer.signal = signal;\n        offer.answer = true;\n        listener.io.emit('ss-handshake', offer);\n      });\n      channel.signal(offer.signal);\n      channel.once('connect', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var maConn, conn;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                maConn = toConnection(channel);\n                log('new inbound connection %s', maConn.remoteAddr);\n                _context.prev = 2;\n                _context.next = 5;\n                return upgrader.upgradeInbound(maConn);\n\n              case 5:\n                conn = _context.sent;\n                _context.next = 12;\n                break;\n\n              case 8:\n                _context.prev = 8;\n                _context.t0 = _context[\"catch\"](2);\n                log.error('inbound connection failed to upgrade', _context.t0);\n                return _context.abrupt(\"return\", maConn.close());\n\n              case 12:\n                if (!conn.remoteAddr) {\n                  try {\n                    conn.remoteAddr = ma.decapsulateCode(CODE_P2P).encapsulate(\"/p2p/\".concat(conn.remotePeer.toB58String()));\n                  } catch (err) {\n                    log.error('could not determine remote address', err);\n                  }\n                }\n\n                log('inbound connection %s upgraded', maConn.remoteAddr);\n                trackConn(listener, maConn);\n                listener.emit('connection', conn);\n                handler(conn);\n\n              case 17:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[2, 8]]);\n      })));\n    };\n\n    listener.io.once('connect_error', function (err) {\n      return defer.reject(err);\n    });\n    listener.io.once('error', function (err) {\n      listener.emit('error', err);\n      listener.emit('close');\n    });\n    listener.io.on('ws-handshake', incommingDial);\n    listener.io.on('ws-peer', WebRTCStar._peerDiscovered);\n    listener.io.on('connect', function () {\n      listener.io.emit('ss-join', WebRTCStar._signallingAddr.toString());\n    });\n    listener.io.once('connect', function () {\n      listener.emit('listening');\n      defer.resolve();\n    });\n    return defer.promise;\n  };\n\n  listener.close = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            listener.io && listener.io.emit('ss-leave');\n            _context2.next = 3;\n            return Promise.all(listener.__connections.map(function (maConn) {\n              return maConn.close();\n            }));\n\n          case 3:\n            listener.emit('close');\n\n          case 4:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  listener.getAddrs = function () {\n    return [listeningAddr];\n  };\n\n  WebRTCStar.listenersRefs[multiaddr.toString()] = listener;\n  return listener;\n};\n\nfunction trackConn(listener, maConn) {\n  listener.__connections.push(maConn);\n\n  var untrackConn = function untrackConn() {\n    listener.__connections = listener.__connections.filter(function (c) {\n      return c !== maConn;\n    });\n  };\n\n  maConn.conn.once('close', untrackConn);\n}","map":null,"metadata":{},"sourceType":"script"}