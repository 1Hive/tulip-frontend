{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _require = require('interface-datastore'),\n    Key = _require.Key;\n\nvar _require2 = require('libp2p-record'),\n    Record = _require2.Record;\n\nvar _require3 = require('buffer'),\n    Buffer = _require3.Buffer;\n\nvar _require4 = require('./utils'),\n    encodeBase32 = _require4.encodeBase32;\n\nvar errcode = require('err-code');\n\nvar debug = require('debug');\n\nvar log = debug('ipfs:ipns:offline-datastore');\nlog.error = debug('ipfs:ipns:offline-datastore:error'); // Offline datastore aims to mimic the same encoding as routing when storing records\n// to the local datastore\n\nvar OfflineDatastore = /*#__PURE__*/function () {\n  function OfflineDatastore(repo) {\n    _classCallCheck(this, OfflineDatastore);\n\n    this._repo = repo;\n  }\n  /**\n   * Put a value to the local datastore indexed by the received key properly encoded.\n   * @param {Buffer} key identifier of the value.\n   * @param {Buffer} value value to be stored.\n   * @param {function(Error)} callback\n   * @returns {void}\n   */\n\n\n  _createClass(OfflineDatastore, [{\n    key: \"put\",\n    value: function () {\n      var _put = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(key, value) {\n        var routingKey, record;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (Buffer.isBuffer(key)) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw errcode(new Error('Offline datastore key must be a buffer'), 'ERR_INVALID_KEY');\n\n              case 2:\n                if (Buffer.isBuffer(value)) {\n                  _context.next = 4;\n                  break;\n                }\n\n                throw errcode(new Error('Offline datastore value must be a buffer'), 'ERR_INVALID_VALUE');\n\n              case 4:\n                _context.prev = 4;\n                routingKey = this._routingKey(key);\n                _context.next = 12;\n                break;\n\n              case 8:\n                _context.prev = 8;\n                _context.t0 = _context[\"catch\"](4);\n                log.error(_context.t0);\n                throw errcode(new Error('Not possible to generate the routing key'), 'ERR_GENERATING_ROUTING_KEY');\n\n              case 12:\n                // Marshal to libp2p record as the DHT does\n                record = new Record(key, value);\n                return _context.abrupt(\"return\", this._repo.datastore.put(routingKey, record.serialize()));\n\n              case 14:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[4, 8]]);\n      }));\n\n      function put(_x, _x2) {\n        return _put.apply(this, arguments);\n      }\n\n      return put;\n    }()\n    /**\n     * Get a value from the local datastore indexed by the received key properly encoded.\n     * @param {Buffer} key identifier of the value to be obtained.\n     * @param {function(Error, Buffer)} callback\n     * @returns {void}\n     */\n\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(key) {\n        var routingKey, res, record;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (Buffer.isBuffer(key)) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                throw errcode(new Error('Offline datastore key must be a buffer'), 'ERR_INVALID_KEY');\n\n              case 2:\n                _context2.prev = 2;\n                routingKey = this._routingKey(key);\n                _context2.next = 10;\n                break;\n\n              case 6:\n                _context2.prev = 6;\n                _context2.t0 = _context2[\"catch\"](2);\n                log.error(_context2.t0);\n                throw errcode(new Error('Not possible to generate the routing key'), 'ERR_GENERATING_ROUTING_KEY');\n\n              case 10:\n                _context2.next = 12;\n                return this._repo.datastore.get(routingKey);\n\n              case 12:\n                res = _context2.sent;\n                _context2.prev = 13;\n                record = Record.deserialize(res);\n                _context2.next = 21;\n                break;\n\n              case 17:\n                _context2.prev = 17;\n                _context2.t1 = _context2[\"catch\"](13);\n                log.error(_context2.t1);\n                throw _context2.t1;\n\n              case 21:\n                return _context2.abrupt(\"return\", record.value);\n\n              case 22:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[2, 6], [13, 17]]);\n      }));\n\n      function get(_x3) {\n        return _get.apply(this, arguments);\n      }\n\n      return get;\n    }() // encode key properly - base32(/ipns/{cid})\n\n  }, {\n    key: \"_routingKey\",\n    value: function _routingKey(key) {\n      return new Key('/' + encodeBase32(key), false);\n    }\n  }]);\n\n  return OfflineDatastore;\n}();\n\nexports = module.exports = OfflineDatastore;","map":null,"metadata":{},"sourceType":"script"}