{"ast":null,"code":"'use strict';\n\nconst Big = require('bignumber.js');\n\nconst parseDuration = require('parse-duration');\n\nconst errCode = require('err-code');\n\nconst {\n  withTimeoutOption\n} = require('../../utils');\n\nfunction getBandwidthStats(libp2p, opts) {\n  let stats;\n\n  if (opts.peer) {\n    stats = libp2p.metrics.forPeer(opts.peer);\n  } else if (opts.proto) {\n    stats = libp2p.metrics.forProtocol(opts.proto);\n  } else {\n    stats = libp2p.metrics.global;\n  }\n\n  if (!stats) {\n    return {\n      totalIn: new Big(0),\n      totalOut: new Big(0),\n      rateIn: new Big(0),\n      rateOut: new Big(0)\n    };\n  }\n\n  const {\n    movingAverages,\n    snapshot\n  } = stats;\n  return {\n    totalIn: snapshot.dataReceived,\n    totalOut: snapshot.dataSent,\n    rateIn: new Big(movingAverages.dataReceived[60000].movingAverage() / 60),\n    rateOut: new Big(movingAverages.dataSent[60000].movingAverage() / 60)\n  };\n}\n\nmodule.exports = ({\n  libp2p\n}) => {\n  return withTimeoutOption(async function* (options) {\n    options = options || {};\n\n    if (!options.poll) {\n      yield getBandwidthStats(libp2p, options);\n      return;\n    }\n\n    let interval = options.interval || 1000;\n\n    try {\n      interval = typeof interval === 'string' ? parseDuration(interval) : interval;\n      if (!interval || interval < 0) throw new Error('invalid poll interval');\n    } catch (err) {\n      throw errCode(err, 'ERR_INVALID_POLL_INTERVAL');\n    }\n\n    let timeoutId;\n\n    try {\n      while (true) {\n        yield getBandwidthStats(libp2p, options); // eslint-disable-next-line no-loop-func\n\n        await new Promise(resolve => {\n          timeoutId = setTimeout(resolve, interval);\n        });\n      }\n    } finally {\n      clearTimeout(timeoutId);\n    }\n  });\n};","map":null,"metadata":{},"sourceType":"script"}