{"ast":null,"code":"'use strict';\n\nvar _defineProperty = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _asyncGeneratorDelegate = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate\");\n\nvar _asyncIterator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar _awaitAsyncGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _wrapAsyncGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar log = require('debug')('ipfs:mfs:write');\n\nvar importer = require('ipfs-unixfs-importer');\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar stat = require('./stat');\n\nvar mkdir = require('./mkdir');\n\nvar addLink = require('./utils/add-link');\n\nvar applyDefaultOptions = require('./utils/apply-default-options');\n\nvar createLock = require('./utils/create-lock');\n\nvar toAsyncIterator = require('./utils/to-async-iterator');\n\nvar toMfsPath = require('./utils/to-mfs-path');\n\nvar toPathComponents = require('./utils/to-path-components');\n\nvar toTrail = require('./utils/to-trail');\n\nvar updateTree = require('./utils/update-tree');\n\nvar updateMfsRoot = require('./utils/update-mfs-root');\n\nvar errCode = require('err-code');\n\nvar _require2 = require('../../utils'),\n    MFS_MAX_CHUNK_SIZE = _require2.MFS_MAX_CHUNK_SIZE;\n\nvar last = require('it-last');\n\nvar _require3 = require('../../utils'),\n    withTimeoutOption = _require3.withTimeoutOption;\n\nvar defaultOptions = {\n  offset: 0,\n  // the offset in the file to begin writing\n  length: undefined,\n  // how many bytes from the incoming buffer to write\n  create: false,\n  // whether to create the file if it does not exist\n  truncate: false,\n  // whether to truncate the file first\n  rawLeaves: false,\n  reduceSingleLeafToSelf: false,\n  cidVersion: 0,\n  hashAlg: 'sha2-256',\n  parents: false,\n  // whether to create intermediate directories if they do not exist\n  progress: function progress() {},\n  strategy: 'trickle',\n  flush: true,\n  leafType: 'raw',\n  shardSplitThreshold: 1000,\n  mode: undefined,\n  mtime: undefined\n};\n\nmodule.exports = function (context) {\n  return withTimeoutOption( /*#__PURE__*/function () {\n    var _mfsWrite = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(path, content, options) {\n      var source, destination, parent;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              options = applyDefaultOptions(options, defaultOptions);\n              log('Reading source, destination and parent');\n              _context2.next = 4;\n              return createLock().readLock( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n                return _regeneratorRuntime.wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        _context.next = 2;\n                        return toAsyncIterator(content, options);\n\n                      case 2:\n                        source = _context.sent;\n                        _context.next = 5;\n                        return toMfsPath(context, path);\n\n                      case 5:\n                        destination = _context.sent;\n                        _context.next = 8;\n                        return toMfsPath(context, destination.mfsDirectory);\n\n                      case 8:\n                        parent = _context.sent;\n\n                      case 9:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee);\n              })))();\n\n            case 4:\n              log('Read source, destination and parent');\n\n              if (!(!options.parents && !parent.exists)) {\n                _context2.next = 7;\n                break;\n              }\n\n              throw errCode(new Error('directory does not exist'), 'ERR_NO_EXIST');\n\n            case 7:\n              if (!(!options.create && !destination.exists)) {\n                _context2.next = 9;\n                break;\n              }\n\n              throw errCode(new Error('file does not exist'), 'ERR_NO_EXIST');\n\n            case 9:\n              return _context2.abrupt(\"return\", updateOrImport(context, path, source, destination, options));\n\n            case 10:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    function mfsWrite(_x4, _x5, _x6) {\n      return _mfsWrite.apply(this, arguments);\n    }\n\n    return mfsWrite;\n  }());\n};\n\nvar updateOrImport = /*#__PURE__*/function () {\n  var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(context, path, source, destination, options) {\n    var child;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.next = 2;\n            return write(context, source, destination, options);\n\n          case 2:\n            child = _context4.sent;\n            _context4.next = 5;\n            return createLock().writeLock( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n              var pathComponents, fileName, parentExists, updatedPath, trail, parent, parentNode, result, newRootCid;\n              return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                while (1) {\n                  switch (_context3.prev = _context3.next) {\n                    case 0:\n                      pathComponents = toPathComponents(path);\n                      fileName = pathComponents.pop();\n                      parentExists = false;\n                      _context3.prev = 3;\n                      _context3.next = 6;\n                      return stat(context)(\"/\".concat(pathComponents.join('/')), options);\n\n                    case 6:\n                      parentExists = true;\n                      _context3.next = 13;\n                      break;\n\n                    case 9:\n                      _context3.prev = 9;\n                      _context3.t0 = _context3[\"catch\"](3);\n\n                      if (!(_context3.t0.code !== 'ERR_NOT_FOUND')) {\n                        _context3.next = 13;\n                        break;\n                      }\n\n                      throw _context3.t0;\n\n                    case 13:\n                      if (parentExists) {\n                        _context3.next = 16;\n                        break;\n                      }\n\n                      _context3.next = 16;\n                      return mkdir(context)(\"/\".concat(pathComponents.join('/')), options);\n\n                    case 16:\n                      _context3.next = 18;\n                      return toMfsPath(context, path);\n\n                    case 18:\n                      updatedPath = _context3.sent;\n                      _context3.next = 21;\n                      return toTrail(context, updatedPath.mfsDirectory, options);\n\n                    case 21:\n                      trail = _context3.sent;\n                      parent = trail[trail.length - 1];\n\n                      if (parent.type.includes('directory')) {\n                        _context3.next = 25;\n                        break;\n                      }\n\n                      throw errCode(new Error(\"cannot write to \".concat(parent.name, \": Not a directory\")), 'ERR_NOT_A_DIRECTORY');\n\n                    case 25:\n                      _context3.next = 27;\n                      return context.ipld.get(parent.cid);\n\n                    case 27:\n                      parentNode = _context3.sent;\n                      _context3.next = 30;\n                      return addLink(context, {\n                        parent: parentNode,\n                        name: fileName,\n                        cid: child.cid,\n                        size: child.size,\n                        flush: options.flush,\n                        shardSplitThreshold: options.shardSplitThreshold,\n                        hashAlg: options.hashAlg,\n                        cidVersion: options.cidVersion\n                      });\n\n                    case 30:\n                      result = _context3.sent;\n                      parent.cid = result.cid; // update the tree with the new child\n\n                      _context3.next = 34;\n                      return updateTree(context, trail, options);\n\n                    case 34:\n                      newRootCid = _context3.sent;\n                      _context3.next = 37;\n                      return updateMfsRoot(context, newRootCid);\n\n                    case 37:\n                    case \"end\":\n                      return _context3.stop();\n                  }\n                }\n              }, _callee3, null, [[3, 9]]);\n            })))();\n\n          case 5:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n\n  return function updateOrImport(_x7, _x8, _x9, _x10, _x11) {\n    return _ref5.apply(this, arguments);\n  };\n}();\n\nvar write = /*#__PURE__*/function () {\n  var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(context, source, destination, options) {\n    var sources, extra, content, mode, mtime, result;\n    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            if (destination.exists) {\n              log(\"Overwriting file \".concat(destination.cid, \" offset \").concat(options.offset, \" length \").concat(options.length));\n            } else {\n              log(\"Writing file offset \".concat(options.offset, \" length \").concat(options.length));\n            }\n\n            sources = []; // pad start of file if necessary\n\n            if (options.offset > 0) {\n              if (destination.unixfs) {\n                log(\"Writing first \".concat(options.offset, \" bytes of original file\"));\n                sources.push(function () {\n                  return destination.content({\n                    offset: 0,\n                    length: options.offset\n                  });\n                });\n\n                if (destination.unixfs.fileSize() < options.offset) {\n                  extra = options.offset - destination.unixfs.fileSize();\n                  log(\"Writing zeros for extra \".concat(extra, \" bytes\"));\n                  sources.push(asyncZeroes(extra));\n                }\n              } else {\n                log(\"Writing zeros for first \".concat(options.offset, \" bytes\"));\n                sources.push(asyncZeroes(options.offset));\n              }\n            }\n\n            sources.push(limitAsyncStreamBytes(source, options.length));\n            content = countBytesStreamed(catAsyncIterators(sources), function (bytesWritten) {\n              if (destination.unixfs && !options.truncate) {\n                // if we've done reading from the new source and we are not going\n                // to truncate the file, add the end of the existing file to the output\n                var fileSize = destination.unixfs.fileSize();\n\n                if (fileSize > bytesWritten) {\n                  log(\"Writing last \".concat(fileSize - bytesWritten, \" of \").concat(fileSize, \" bytes from original file starting at offset \").concat(bytesWritten));\n                  return destination.content({\n                    offset: bytesWritten\n                  });\n                } else {\n                  log('Not writing last bytes from original file');\n                }\n              }\n\n              return _defineProperty({}, Symbol.asyncIterator, _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n                return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n                  while (1) {\n                    switch (_context5.prev = _context5.next) {\n                      case 0:\n                      case \"end\":\n                        return _context5.stop();\n                    }\n                  }\n                }, _callee5);\n              })));\n            });\n\n            if (options.mode !== undefined && options.mode !== null) {\n              mode = options.mode;\n            } else if (destination && destination.unixfs) {\n              mode = destination.unixfs.mode;\n            }\n\n            if (options.mtime !== undefined && options.mtine !== null) {\n              mtime = options.mtime;\n            } else if (destination && destination.unixfs) {\n              mtime = destination.unixfs.mtime;\n            }\n\n            _context6.next = 9;\n            return last(importer([{\n              content: content,\n              // persist mode & mtime if set previously\n              mode: mode,\n              mtime: mtime\n            }], context.block, {\n              progress: options.progress,\n              hashAlg: options.hashAlg,\n              cidVersion: options.cidVersion,\n              strategy: options.strategy,\n              rawLeaves: options.rawLeaves,\n              reduceSingleLeafToSelf: options.reduceSingleLeafToSelf,\n              leafType: options.leafType,\n              pin: false\n            }));\n\n          case 9:\n            result = _context6.sent;\n            log(\"Wrote \".concat(result.cid));\n            return _context6.abrupt(\"return\", {\n              cid: result.cid,\n              size: result.size\n            });\n\n          case 12:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, _callee6);\n  }));\n\n  return function write(_x12, _x13, _x14, _x15) {\n    return _ref7.apply(this, arguments);\n  };\n}();\n\nvar limitAsyncStreamBytes = function limitAsyncStreamBytes(stream, limit) {\n  return /*#__PURE__*/function () {\n    var _limitAsyncStreamBytes2 = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n      var emitted, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, buf;\n\n      return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              emitted = 0;\n              _iteratorNormalCompletion = true;\n              _didIteratorError = false;\n              _context7.prev = 3;\n              _iterator = _asyncIterator(stream);\n\n            case 5:\n              _context7.next = 7;\n              return _awaitAsyncGenerator(_iterator.next());\n\n            case 7:\n              _step = _context7.sent;\n              _iteratorNormalCompletion = _step.done;\n              _context7.next = 11;\n              return _awaitAsyncGenerator(_step.value);\n\n            case 11:\n              _value = _context7.sent;\n\n              if (_iteratorNormalCompletion) {\n                _context7.next = 24;\n                break;\n              }\n\n              buf = _value;\n              emitted += buf.length;\n\n              if (!(emitted > limit)) {\n                _context7.next = 19;\n                break;\n              }\n\n              _context7.next = 18;\n              return buf.slice(0, limit - emitted);\n\n            case 18:\n              return _context7.abrupt(\"return\");\n\n            case 19:\n              _context7.next = 21;\n              return buf;\n\n            case 21:\n              _iteratorNormalCompletion = true;\n              _context7.next = 5;\n              break;\n\n            case 24:\n              _context7.next = 30;\n              break;\n\n            case 26:\n              _context7.prev = 26;\n              _context7.t0 = _context7[\"catch\"](3);\n              _didIteratorError = true;\n              _iteratorError = _context7.t0;\n\n            case 30:\n              _context7.prev = 30;\n              _context7.prev = 31;\n\n              if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                _context7.next = 35;\n                break;\n              }\n\n              _context7.next = 35;\n              return _awaitAsyncGenerator(_iterator.return());\n\n            case 35:\n              _context7.prev = 35;\n\n              if (!_didIteratorError) {\n                _context7.next = 38;\n                break;\n              }\n\n              throw _iteratorError;\n\n            case 38:\n              return _context7.finish(35);\n\n            case 39:\n              return _context7.finish(30);\n\n            case 40:\n            case \"end\":\n              return _context7.stop();\n          }\n        }\n      }, _callee7, null, [[3, 26, 30, 40], [31,, 35, 39]]);\n    }));\n\n    function _limitAsyncStreamBytes() {\n      return _limitAsyncStreamBytes2.apply(this, arguments);\n    }\n\n    return _limitAsyncStreamBytes;\n  }();\n};\n\nvar asyncZeroes = function asyncZeroes(count) {\n  var chunkSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : MFS_MAX_CHUNK_SIZE;\n  var buf = Buffer.alloc(chunkSize, 0);\n\n  var stream = _defineProperty({}, Symbol.asyncIterator, /*#__PURE__*/_regeneratorRuntime.mark(function _asyncZeroes() {\n    return _regeneratorRuntime.wrap(function _asyncZeroes$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            if (!true) {\n              _context8.next = 5;\n              break;\n            }\n\n            _context8.next = 3;\n            return buf.slice();\n\n          case 3:\n            _context8.next = 0;\n            break;\n\n          case 5:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, _asyncZeroes);\n  }));\n\n  return limitAsyncStreamBytes(stream, count);\n};\n\nvar catAsyncIterators = /*#__PURE__*/function () {\n  var _ref2 = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(sources) {\n    var i;\n    return _regeneratorRuntime.wrap(function _callee8$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            i = 0;\n\n          case 1:\n            if (!(i < sources.length)) {\n              _context9.next = 6;\n              break;\n            }\n\n            return _context9.delegateYield(_asyncGeneratorDelegate(_asyncIterator(sources[i]()), _awaitAsyncGenerator), \"t0\", 3);\n\n          case 3:\n            i++;\n            _context9.next = 1;\n            break;\n\n          case 6:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, _callee8);\n  }));\n\n  return function catAsyncIterators(_x) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nvar countBytesStreamed = /*#__PURE__*/function () {\n  var _ref3 = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(source, notify) {\n    var wrote, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _value2, buf, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, _value3, _buf;\n\n    return _regeneratorRuntime.wrap(function _callee9$(_context10) {\n      while (1) {\n        switch (_context10.prev = _context10.next) {\n          case 0:\n            wrote = 0;\n            _iteratorNormalCompletion2 = true;\n            _didIteratorError2 = false;\n            _context10.prev = 3;\n            _iterator2 = _asyncIterator(source);\n\n          case 5:\n            _context10.next = 7;\n            return _awaitAsyncGenerator(_iterator2.next());\n\n          case 7:\n            _step2 = _context10.sent;\n            _iteratorNormalCompletion2 = _step2.done;\n            _context10.next = 11;\n            return _awaitAsyncGenerator(_step2.value);\n\n          case 11:\n            _value2 = _context10.sent;\n\n            if (_iteratorNormalCompletion2) {\n              _context10.next = 20;\n              break;\n            }\n\n            buf = _value2;\n            wrote += buf.length;\n            _context10.next = 17;\n            return buf;\n\n          case 17:\n            _iteratorNormalCompletion2 = true;\n            _context10.next = 5;\n            break;\n\n          case 20:\n            _context10.next = 26;\n            break;\n\n          case 22:\n            _context10.prev = 22;\n            _context10.t0 = _context10[\"catch\"](3);\n            _didIteratorError2 = true;\n            _iteratorError2 = _context10.t0;\n\n          case 26:\n            _context10.prev = 26;\n            _context10.prev = 27;\n\n            if (!(!_iteratorNormalCompletion2 && _iterator2.return != null)) {\n              _context10.next = 31;\n              break;\n            }\n\n            _context10.next = 31;\n            return _awaitAsyncGenerator(_iterator2.return());\n\n          case 31:\n            _context10.prev = 31;\n\n            if (!_didIteratorError2) {\n              _context10.next = 34;\n              break;\n            }\n\n            throw _iteratorError2;\n\n          case 34:\n            return _context10.finish(31);\n\n          case 35:\n            return _context10.finish(26);\n\n          case 36:\n            _iteratorNormalCompletion3 = true;\n            _didIteratorError3 = false;\n            _context10.prev = 38;\n            _iterator3 = _asyncIterator(notify(wrote));\n\n          case 40:\n            _context10.next = 42;\n            return _awaitAsyncGenerator(_iterator3.next());\n\n          case 42:\n            _step3 = _context10.sent;\n            _iteratorNormalCompletion3 = _step3.done;\n            _context10.next = 46;\n            return _awaitAsyncGenerator(_step3.value);\n\n          case 46:\n            _value3 = _context10.sent;\n\n            if (_iteratorNormalCompletion3) {\n              _context10.next = 55;\n              break;\n            }\n\n            _buf = _value3;\n            wrote += _buf.length;\n            _context10.next = 52;\n            return _buf;\n\n          case 52:\n            _iteratorNormalCompletion3 = true;\n            _context10.next = 40;\n            break;\n\n          case 55:\n            _context10.next = 61;\n            break;\n\n          case 57:\n            _context10.prev = 57;\n            _context10.t1 = _context10[\"catch\"](38);\n            _didIteratorError3 = true;\n            _iteratorError3 = _context10.t1;\n\n          case 61:\n            _context10.prev = 61;\n            _context10.prev = 62;\n\n            if (!(!_iteratorNormalCompletion3 && _iterator3.return != null)) {\n              _context10.next = 66;\n              break;\n            }\n\n            _context10.next = 66;\n            return _awaitAsyncGenerator(_iterator3.return());\n\n          case 66:\n            _context10.prev = 66;\n\n            if (!_didIteratorError3) {\n              _context10.next = 69;\n              break;\n            }\n\n            throw _iteratorError3;\n\n          case 69:\n            return _context10.finish(66);\n\n          case 70:\n            return _context10.finish(61);\n\n          case 71:\n          case \"end\":\n            return _context10.stop();\n        }\n      }\n    }, _callee9, null, [[3, 22, 26, 36], [27,, 31, 35], [38, 57, 61, 71], [62,, 66, 70]]);\n  }));\n\n  return function countBytesStreamed(_x2, _x3) {\n    return _ref3.apply(this, arguments);\n  };\n}();","map":null,"metadata":{},"sourceType":"script"}