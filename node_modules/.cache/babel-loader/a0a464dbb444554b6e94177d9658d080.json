{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar Bucket = require('hamt-sharding/src/bucket');\n\nvar multihashing = require('multihashing-async'); // FIXME: this is copy/pasted from ipfs-unixfs-importer/src/dir-sharded.js\n\n\nvar hashFn = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(value) {\n    var hash, justHash, length, result, i;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return multihashing(Buffer.from(value, 'utf8'), 'murmur3-128');\n\n          case 2:\n            hash = _context.sent;\n            // Multihashing inserts preamble of 2 bytes. Remove it.\n            // Also, murmur3 outputs 128 bit but, accidently, IPFS Go's\n            // implementation only uses the first 64, so we must do the same\n            // for parity..\n            justHash = hash.slice(2, 10);\n            length = justHash.length;\n            result = Buffer.alloc(length); // TODO: invert buffer because that's how Go impl does it\n\n            for (i = 0; i < length; i++) {\n              result[length - i - 1] = justHash[i];\n            }\n\n            return _context.abrupt(\"return\", result);\n\n          case 8:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function hashFn(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nhashFn.code = 0x22; // TODO: get this from multihashing-async?\n\nvar addLinksToHamtBucket = function addLinksToHamtBucket(links, bucket, rootBucket) {\n  return Promise.all(links.map(function (link) {\n    if (link.Name.length === 2) {\n      var pos = parseInt(link.Name, 16);\n      return bucket._putObjectAt(pos, new Bucket({\n        hashFn: hashFn\n      }, bucket, pos));\n    }\n\n    return rootBucket.put(link.Name.substring(2), true);\n  }));\n};\n\nvar toPrefix = function toPrefix(position) {\n  return position.toString('16').toUpperCase().padStart(2, '0').substring(0, 2);\n};\n\nvar toBucketPath = function toBucketPath(position) {\n  var bucket = position.bucket;\n  var path = [];\n\n  while (bucket._parent) {\n    path.push(bucket);\n    bucket = bucket._parent;\n  }\n\n  path.push(bucket);\n  return path.reverse();\n};\n\nvar findShardCid = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(node, name, ipld, context, options) {\n    var position, prefix, bucketPath, link;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            if (!context) {\n              context = {\n                rootBucket: new Bucket({\n                  hashFn: hashFn\n                }),\n                hamtDepth: 1\n              };\n              context.lastBucket = context.rootBucket;\n            }\n\n            _context2.next = 3;\n            return addLinksToHamtBucket(node.Links, context.lastBucket, context.rootBucket);\n\n          case 3:\n            _context2.next = 5;\n            return context.rootBucket._findNewBucketAndPos(name);\n\n          case 5:\n            position = _context2.sent;\n            prefix = toPrefix(position.pos);\n            bucketPath = toBucketPath(position);\n\n            if (bucketPath.length > context.hamtDepth) {\n              context.lastBucket = bucketPath[context.hamtDepth];\n              prefix = toPrefix(context.lastBucket._posAtParent);\n            }\n\n            link = node.Links.find(function (link) {\n              var entryPrefix = link.Name.substring(0, 2);\n              var entryName = link.Name.substring(2);\n\n              if (entryPrefix !== prefix) {\n                // not the entry or subshard we're looking for\n                return;\n              }\n\n              if (entryName && entryName !== name) {\n                // not the entry we're looking for\n                return;\n              }\n\n              return true;\n            });\n\n            if (link) {\n              _context2.next = 12;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", null);\n\n          case 12:\n            if (!(link.Name.substring(2) === name)) {\n              _context2.next = 14;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", link.Hash);\n\n          case 14:\n            context.hamtDepth++;\n            _context2.next = 17;\n            return ipld.get(link.Hash, options);\n\n          case 17:\n            node = _context2.sent;\n            return _context2.abrupt(\"return\", findShardCid(node, name, ipld, context, options));\n\n          case 19:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function findShardCid(_x2, _x3, _x4, _x5, _x6) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nmodule.exports = findShardCid;","map":null,"metadata":{},"sourceType":"script"}