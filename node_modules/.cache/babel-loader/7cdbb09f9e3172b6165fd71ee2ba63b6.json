{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar pSeries = require('p-series');\n\nvar PeerMonitor = require('ipfs-pubsub-peer-monitor');\n\nvar Logger = require('logplease');\n\nvar logger = Logger.create(\"pubsub\", {\n  color: Logger.Colors.Yellow\n});\nLogger.setLogLevel('ERROR');\nvar maxTopicsOpen = 256;\nvar topicsOpenCount = 0;\n\nvar IPFSPubsub = /*#__PURE__*/function () {\n  function IPFSPubsub(ipfs, id) {\n    _classCallCheck(this, IPFSPubsub);\n\n    this._ipfs = ipfs;\n    this._id = id;\n    this._subscriptions = {};\n    if (this._ipfs.pubsub === null) logger.error(\"The provided version of ipfs doesn't have pubsub support. Messages will not be exchanged.\");\n    this._handleMessage = this._handleMessage.bind(this); // Bump up the number of listeners we can have open,\n    // ie. number of databases replicating\n\n    if (this._ipfs.setMaxListeners) this._ipfs.setMaxListeners(maxTopicsOpen);\n  }\n\n  _createClass(IPFSPubsub, [{\n    key: \"subscribe\",\n    value: function () {\n      var _subscribe = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(topic, onMessageCallback, onNewPeerCallback) {\n        var _this = this;\n\n        var options,\n            topicMonitor,\n            _args = arguments;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                options = _args.length > 3 && _args[3] !== undefined ? _args[3] : {};\n\n                if (!(!this._subscriptions[topic] && this._ipfs.pubsub)) {\n                  _context.next = 11;\n                  break;\n                }\n\n                _context.next = 4;\n                return this._ipfs.pubsub.subscribe(topic, this._handleMessage, options);\n\n              case 4:\n                topicMonitor = new PeerMonitor(this._ipfs.pubsub, topic);\n                topicMonitor.on('join', function (peer) {\n                  logger.debug(\"Peer joined \".concat(topic, \":\"));\n                  logger.debug(peer);\n\n                  if (_this._subscriptions[topic]) {\n                    onNewPeerCallback(topic, peer);\n                  } else {\n                    logger.warn('Peer joined a room we don\\'t have a subscription for');\n                    logger.warn(topic, peer);\n                  }\n                });\n                topicMonitor.on('leave', function (peer) {\n                  return logger.debug(\"Peer \".concat(peer, \" left \").concat(topic));\n                });\n                topicMonitor.on('error', function (e) {\n                  return logger.error(e);\n                });\n                this._subscriptions[topic] = {\n                  topicMonitor: topicMonitor,\n                  onMessage: onMessageCallback,\n                  onNewPeer: onNewPeerCallback\n                };\n                topicsOpenCount++;\n                logger.debug(\"Topics open:\", topicsOpenCount);\n\n              case 11:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function subscribe(_x, _x2, _x3) {\n        return _subscribe.apply(this, arguments);\n      }\n\n      return subscribe;\n    }()\n  }, {\n    key: \"unsubscribe\",\n    value: function () {\n      var _unsubscribe = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(hash) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!this._subscriptions[hash]) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                _context2.next = 3;\n                return this._ipfs.pubsub.unsubscribe(hash, this._handleMessage);\n\n              case 3:\n                this._subscriptions[hash].topicMonitor.stop();\n\n                delete this._subscriptions[hash];\n                logger.debug(\"Unsubscribed from '\".concat(hash, \"'\"));\n                topicsOpenCount--;\n                logger.debug(\"Topics open:\", topicsOpenCount);\n\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function unsubscribe(_x4) {\n        return _unsubscribe.apply(this, arguments);\n      }\n\n      return unsubscribe;\n    }()\n  }, {\n    key: \"publish\",\n    value: function publish(topic, message) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (this._subscriptions[topic] && this._ipfs.pubsub) {\n        this._ipfs.pubsub.publish(topic, Buffer.from(JSON.stringify(message)), options);\n      }\n    }\n  }, {\n    key: \"disconnect\",\n    value: function () {\n      var _disconnect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var _this2 = this;\n\n        var topics;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                topics = Object.keys(this._subscriptions);\n                _context3.next = 3;\n                return pSeries(topics.map(function (t) {\n                  return _this2.unsubscribe.bind(_this2, t);\n                }));\n\n              case 3:\n                this._subscriptions = {};\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function disconnect() {\n        return _disconnect.apply(this, arguments);\n      }\n\n      return disconnect;\n    }()\n  }, {\n    key: \"_handleMessage\",\n    value: function () {\n      var _handleMessage2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(message) {\n        var content, subscription, topicId;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!(message.from === this._id)) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\");\n\n              case 2:\n                try {\n                  // Get the topic\n                  topicId = message.topicIDs[0];\n                  content = JSON.parse(message.data);\n                  subscription = this._subscriptions[topicId];\n                } catch (e) {\n                  logger.error(e);\n                  logger.error('Couldn\\'t parse pubsub message:', message);\n                }\n\n                if (!(subscription && subscription.onMessage && content)) {\n                  _context4.next = 6;\n                  break;\n                }\n\n                _context4.next = 6;\n                return subscription.onMessage(topicId, content, message.from);\n\n              case 6:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function _handleMessage(_x5) {\n        return _handleMessage2.apply(this, arguments);\n      }\n\n      return _handleMessage;\n    }()\n  }]);\n\n  return IPFSPubsub;\n}();\n\nmodule.exports = IPFSPubsub;","map":null,"metadata":{},"sourceType":"script"}