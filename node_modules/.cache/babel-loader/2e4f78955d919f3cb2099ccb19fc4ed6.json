{"ast":null,"code":"/* @flow */\n'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _createForOfIteratorHelper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _awaitAsyncGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _wrapAsyncGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar _asyncIterator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar _require = require('interface-datastore'),\n    Adapter = _require.Adapter,\n    Key = _require.Key,\n    Errors = _require.Errors,\n    _require$utils = _require.utils,\n    filter = _require$utils.filter,\n    take = _require$utils.take,\n    sortAll = _require$utils.sortAll,\n    replaceStartWith = _require$utils.replaceStartWith;\n\nvar Keytransform = require('./keytransform');\n/**\n * A datastore that can combine multiple stores inside various\n * key prefixs.\n */\n\n\nvar MountDatastore = /*#__PURE__*/function (_Adapter) {\n  _inherits(MountDatastore, _Adapter);\n\n  var _super = _createSuper(MountDatastore);\n\n  function MountDatastore(mounts) {\n    var _this;\n\n    _classCallCheck(this, MountDatastore);\n\n    _this = _super.call(this);\n    _this.mounts = mounts.slice();\n    return _this;\n  }\n\n  _createClass(MountDatastore, [{\n    key: \"open\",\n    value: function open() {\n      return Promise.all(this.mounts.map(function (m) {\n        return m.datastore.open();\n      }));\n    }\n    /**\n     * Lookup the matching datastore for the given key.\n     *\n     * @private\n     * @param {Key} key\n     * @returns {{Datastore, Key, Key}}\n     */\n\n  }, {\n    key: \"_lookup\",\n    value: function _lookup(key) {\n      var _iterator2 = _createForOfIteratorHelper(this.mounts),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var mount = _step2.value;\n\n          if (mount.prefix.toString() === key.toString() || mount.prefix.isAncestorOf(key)) {\n            var s = replaceStartWith(key.toString(), mount.prefix.toString());\n            return {\n              datastore: mount.datastore,\n              mountpoint: mount.prefix,\n              rest: new Key(s)\n            };\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }, {\n    key: \"put\",\n    value: function put(key, value, options) {\n      var match = this._lookup(key);\n\n      if (match == null) {\n        throw Errors.dbWriteFailedError(new Error('No datastore mounted for this key'));\n      }\n\n      return match.datastore.put(match.rest, value, options);\n    }\n  }, {\n    key: \"get\",\n    value: function get(key, options) {\n      var match = this._lookup(key);\n\n      if (match == null) {\n        throw Errors.notFoundError(new Error('No datastore mounted for this key'));\n      }\n\n      return match.datastore.get(match.rest, options);\n    }\n  }, {\n    key: \"has\",\n    value: function has(key, options) {\n      var match = this._lookup(key);\n\n      if (match == null) {\n        return false;\n      }\n\n      return match.datastore.has(match.rest, options);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key, options) {\n      var match = this._lookup(key);\n\n      if (match == null) {\n        throw Errors.dbDeleteFailedError(new Error('No datastore mounted for this key'));\n      }\n\n      return match.datastore.delete(match.rest, options);\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      return Promise.all(this.mounts.map(function (m) {\n        return m.datastore.close();\n      }));\n    }\n  }, {\n    key: \"batch\",\n    value: function batch() {\n      var _this2 = this;\n\n      var batchMounts = {};\n\n      var lookup = function lookup(key) {\n        var match = _this2._lookup(key);\n\n        if (match == null) {\n          throw new Error('No datastore mounted for this key');\n        }\n\n        var m = match.mountpoint.toString();\n\n        if (batchMounts[m] == null) {\n          batchMounts[m] = match.datastore.batch();\n        }\n\n        return {\n          batch: batchMounts[m],\n          rest: match.rest\n        };\n      };\n\n      return {\n        put: function put(key, value) {\n          var match = lookup(key);\n          match.batch.put(match.rest, value);\n        },\n        delete: function _delete(key) {\n          var match = lookup(key);\n          match.batch.delete(match.rest);\n        },\n        commit: function commit(options) {\n          return Promise.all(Object.keys(batchMounts).map(function (p) {\n            return batchMounts[p].commit(options);\n          }));\n        }\n      };\n    }\n  }, {\n    key: \"query\",\n    value: function query(q, options) {\n      var qs = this.mounts.map(function (m) {\n        var ks = new Keytransform(m.datastore, {\n          convert: function convert(key) {\n            throw new Error('should never be called');\n          },\n          invert: function invert(key) {\n            return m.prefix.child(key);\n          }\n        });\n        var prefix;\n\n        if (q.prefix != null) {\n          prefix = replaceStartWith(q.prefix, m.prefix.toString());\n        }\n\n        return ks.query({\n          prefix: prefix,\n          filters: q.filters,\n          keysOnly: q.keysOnly\n        }, options);\n      });\n\n      var it = _many(qs);\n\n      if (q.filters) q.filters.forEach(function (f) {\n        it = filter(it, f);\n      });\n      if (q.orders) q.orders.forEach(function (o) {\n        it = sortAll(it, o);\n      });\n\n      if (q.offset != null) {\n        var i = 0;\n        it = filter(it, function () {\n          return i++ >= q.offset;\n        });\n      }\n\n      if (q.limit != null) it = take(it, q.limit);\n      return it;\n    }\n  }]);\n\n  return MountDatastore;\n}(Adapter);\n\nfunction _many(iterable) {\n  return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var i, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, v;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            i = 0;\n\n          case 1:\n            if (!(i < iterable.length)) {\n              _context.next = 39;\n              break;\n            }\n\n            _iteratorNormalCompletion = true;\n            _didIteratorError = false;\n            _context.prev = 4;\n            _iterator = _asyncIterator(iterable[i]);\n\n          case 6:\n            _context.next = 8;\n            return _awaitAsyncGenerator(_iterator.next());\n\n          case 8:\n            _step = _context.sent;\n            _iteratorNormalCompletion = _step.done;\n            _context.next = 12;\n            return _awaitAsyncGenerator(_step.value);\n\n          case 12:\n            _value = _context.sent;\n\n            if (_iteratorNormalCompletion) {\n              _context.next = 20;\n              break;\n            }\n\n            v = _value;\n            _context.next = 17;\n            return v;\n\n          case 17:\n            _iteratorNormalCompletion = true;\n            _context.next = 6;\n            break;\n\n          case 20:\n            _context.next = 26;\n            break;\n\n          case 22:\n            _context.prev = 22;\n            _context.t0 = _context[\"catch\"](4);\n            _didIteratorError = true;\n            _iteratorError = _context.t0;\n\n          case 26:\n            _context.prev = 26;\n            _context.prev = 27;\n\n            if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n              _context.next = 31;\n              break;\n            }\n\n            _context.next = 31;\n            return _awaitAsyncGenerator(_iterator.return());\n\n          case 31:\n            _context.prev = 31;\n\n            if (!_didIteratorError) {\n              _context.next = 34;\n              break;\n            }\n\n            throw _iteratorError;\n\n          case 34:\n            return _context.finish(31);\n\n          case 35:\n            return _context.finish(26);\n\n          case 36:\n            i++;\n            _context.next = 1;\n            break;\n\n          case 39:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[4, 22, 26, 36], [27,, 31, 35]]);\n  }))();\n}\n\nmodule.exports = MountDatastore;","map":null,"metadata":{},"sourceType":"script"}