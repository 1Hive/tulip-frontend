{"ast":null,"code":"'use strict';\n\nconst errcode = require('err-code');\n\nconst debug = require('debug');\n\nconst log = debug('libp2p:peer-store');\nlog.error = debug('libp2p:peer-store:error');\n\nconst {\n  EventEmitter\n} = require('events');\n\nconst PeerId = require('peer-id');\n\nconst PeerInfo = require('peer-info');\n\nconst {\n  ERR_INVALID_PARAMETERS\n} = require('../errors');\n/**\n * Responsible for managing known peers, as well as their addresses and metadata\n * @fires PeerStore#peer Emitted when a peer is connected to this node\n * @fires PeerStore#change:protocols\n * @fires PeerStore#change:multiaddrs\n */\n\n\nclass PeerStore extends EventEmitter {\n  constructor() {\n    super();\n    /**\n     * Map of peers\n     *\n     * @type {Map<string, PeerInfo>}\n     */\n\n    this.peers = new Map(); // TODO: Track ourselves. We should split `peerInfo` up into its pieces so we get better\n    // control and observability. This will be the initial step for removing PeerInfo\n    // https://github.com/libp2p/go-libp2p-core/blob/master/peerstore/peerstore.go\n    // this.addressBook = new Map()\n    // this.protoBook = new Map()\n  }\n  /**\n   * Stores the peerInfo of a new peer.\n   * If already exist, its info is updated. If `silent` is set to\n   * true, no 'peer' event will be emitted. This can be useful if you\n   * are already in the process of dialing the peer. The peer is technically\n   * known, but may not have been added to the PeerStore yet.\n   * @param {PeerInfo} peerInfo\n   * @param {object} [options]\n   * @param {boolean} [options.silent] (Default=false)\n   * @return {PeerInfo}\n   */\n\n\n  put(peerInfo, options = {\n    silent: false\n  }) {\n    if (!PeerInfo.isPeerInfo(peerInfo)) {\n      throw errcode(new Error('peerInfo must be an instance of peer-info'), ERR_INVALID_PARAMETERS);\n    }\n\n    let peer; // Already know the peer?\n\n    if (this.has(peerInfo.id)) {\n      peer = this.update(peerInfo);\n    } else {\n      peer = this.add(peerInfo); // Emit the peer if silent = false\n\n      !options.silent && this.emit('peer', peerInfo);\n    }\n\n    return peer;\n  }\n  /**\n   * Add a new peer to the store.\n   * @param {PeerInfo} peerInfo\n   * @return {PeerInfo}\n   */\n\n\n  add(peerInfo) {\n    if (!PeerInfo.isPeerInfo(peerInfo)) {\n      throw errcode(new Error('peerInfo must be an instance of peer-info'), ERR_INVALID_PARAMETERS);\n    } // Create new instance and add values to it\n\n\n    const newPeerInfo = new PeerInfo(peerInfo.id);\n    peerInfo.multiaddrs.forEach(ma => newPeerInfo.multiaddrs.add(ma));\n    peerInfo.protocols.forEach(p => newPeerInfo.protocols.add(p));\n    const connectedMa = peerInfo.isConnected();\n    connectedMa && newPeerInfo.connect(connectedMa);\n    const peerProxy = new Proxy(newPeerInfo, {\n      set: (obj, prop, value) => {\n        if (prop === 'multiaddrs') {\n          this.emit('change:multiaddrs', {\n            peerInfo: obj,\n            multiaddrs: value.toArray()\n          });\n        } else if (prop === 'protocols') {\n          this.emit('change:protocols', {\n            peerInfo: obj,\n            protocols: Array.from(value)\n          });\n        }\n\n        return Reflect.set(...arguments);\n      }\n    });\n    this.peers.set(peerInfo.id.toB58String(), peerProxy);\n    return peerProxy;\n  }\n  /**\n   * Updates an already known peer.\n   * @param {PeerInfo} peerInfo\n   * @return {PeerInfo}\n   */\n\n\n  update(peerInfo) {\n    if (!PeerInfo.isPeerInfo(peerInfo)) {\n      throw errcode(new Error('peerInfo must be an instance of peer-info'), ERR_INVALID_PARAMETERS);\n    }\n\n    const id = peerInfo.id.toB58String();\n    const recorded = this.peers.get(id); // pass active connection state\n\n    const ma = peerInfo.isConnected();\n\n    if (ma) {\n      recorded.connect(ma);\n    } // Verify new multiaddrs\n    // TODO: better track added and removed multiaddrs\n\n\n    const multiaddrsIntersection = [...recorded.multiaddrs.toArray()].filter(m => peerInfo.multiaddrs.has(m));\n\n    if (multiaddrsIntersection.length !== peerInfo.multiaddrs.size || multiaddrsIntersection.length !== recorded.multiaddrs.size) {\n      for (const ma of peerInfo.multiaddrs.toArray()) {\n        recorded.multiaddrs.add(ma);\n      }\n\n      this.emit('change:multiaddrs', {\n        peerInfo: recorded,\n        multiaddrs: recorded.multiaddrs.toArray()\n      });\n    } // Update protocols\n    // TODO: better track added and removed protocols\n\n\n    const protocolsIntersection = new Set([...recorded.protocols].filter(p => peerInfo.protocols.has(p)));\n\n    if (protocolsIntersection.size !== peerInfo.protocols.size || protocolsIntersection.size !== recorded.protocols.size) {\n      for (const protocol of peerInfo.protocols) {\n        recorded.protocols.add(protocol);\n      }\n\n      this.emit('change:protocols', {\n        peerInfo: recorded,\n        protocols: Array.from(recorded.protocols)\n      });\n    } // Add the public key if missing\n\n\n    if (!recorded.id.pubKey && peerInfo.id.pubKey) {\n      recorded.id.pubKey = peerInfo.id.pubKey;\n    }\n\n    return recorded;\n  }\n  /**\n   * Get the info to the given id.\n   * @param {PeerId|string} peerId b58str id\n   * @returns {PeerInfo}\n   */\n\n\n  get(peerId) {\n    // TODO: deprecate this and just accept `PeerId` instances\n    if (PeerId.isPeerId(peerId)) {\n      peerId = peerId.toB58String();\n    }\n\n    return this.peers.get(peerId);\n  }\n  /**\n   * Has the info to the given id.\n   * @param {PeerId|string} peerId b58str id\n   * @returns {boolean}\n   */\n\n\n  has(peerId) {\n    // TODO: deprecate this and just accept `PeerId` instances\n    if (PeerId.isPeerId(peerId)) {\n      peerId = peerId.toB58String();\n    }\n\n    return this.peers.has(peerId);\n  }\n  /**\n   * Removes the Peer with the matching `peerId` from the PeerStore\n   * @param {PeerId|string} peerId b58str id\n   * @returns {boolean} true if found and removed\n   */\n\n\n  remove(peerId) {\n    // TODO: deprecate this and just accept `PeerId` instances\n    if (PeerId.isPeerId(peerId)) {\n      peerId = peerId.toB58String();\n    }\n\n    return this.peers.delete(peerId);\n  }\n  /**\n   * Completely replaces the existing peers metadata with the given `peerInfo`\n   * @param {PeerInfo} peerInfo\n   * @returns {void}\n   */\n\n\n  replace(peerInfo) {\n    if (!PeerInfo.isPeerInfo(peerInfo)) {\n      throw errcode(new Error('peerInfo must be an instance of peer-info'), ERR_INVALID_PARAMETERS);\n    }\n\n    this.remove(peerInfo.id.toB58String());\n    this.add(peerInfo); // This should be cleaned up in PeerStore v2\n\n    this.emit('change:multiaddrs', {\n      peerInfo,\n      multiaddrs: peerInfo.multiaddrs.toArray()\n    });\n    this.emit('change:protocols', {\n      peerInfo,\n      protocols: Array.from(peerInfo.protocols)\n    });\n  }\n  /**\n   * Returns the known multiaddrs for a given `PeerInfo`. All returned multiaddrs\n   * will include the encapsulated `PeerId` of the peer.\n   * @param {PeerInfo} peer\n   * @returns {Array<Multiaddr>}\n   */\n\n\n  multiaddrsForPeer(peer) {\n    return this.put(peer, true).multiaddrs.toArray().map(addr => {\n      const idString = addr.getPeerId();\n      if (idString && idString === peer.id.toB58String()) return addr;\n      return addr.encapsulate(`/p2p/${peer.id.toB58String()}`);\n    });\n  }\n\n}\n\nmodule.exports = PeerStore;","map":null,"metadata":{},"sourceType":"script"}