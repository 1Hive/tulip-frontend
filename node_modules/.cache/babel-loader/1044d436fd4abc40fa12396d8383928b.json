{"ast":null,"code":"/*!\n * poly1305.js - poly1305 for bcrypto\n * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Parts of this software are based on floodyberry/poly1305-donna:\n *   Placed into the public domain by Andrew Moon.\n *   https://github.com/floodyberry/poly1305-donna\n *\n * Resources:\n *   https://en.wikipedia.org/wiki/Poly1305\n *   https://cr.yp.to/mac.html\n *   https://tools.ietf.org/html/rfc7539#section-2.5\n *   https://github.com/floodyberry/poly1305-donna/blob/master/poly1305-donna-16.h\n */\n'use strict';\n\nconst assert = require('../internal/assert');\n/**\n * Poly1305\n */\n\n\nclass Poly1305 {\n  /**\n   * Create a Poly1305 context.\n   * @constructor\n   */\n  constructor() {\n    this.r = new Uint16Array(10);\n    this.h = new Uint16Array(10);\n    this.pad = new Uint16Array(8);\n    this.buffer = Buffer.alloc(16);\n    this.fin = -1;\n    this.leftover = 0;\n  }\n  /**\n   * Initialize poly1305 with a key.\n   * @param {Buffer} key\n   */\n\n\n  init(key) {\n    assert(Buffer.isBuffer(key) && key.length >= 32); // r &= 0xffffffc0ffffffc0ffffffc0fffffff\n\n    const t0 = readU16(key, 0);\n    const t1 = readU16(key, 2);\n    const t2 = readU16(key, 4);\n    const t3 = readU16(key, 6);\n    const t4 = readU16(key, 8);\n    const t5 = readU16(key, 10);\n    const t6 = readU16(key, 12);\n    const t7 = readU16(key, 14);\n    this.r[0] = t0 & 0x1fff;\n    this.r[1] = (t0 >>> 13 | t1 << 3) & 0x1fff;\n    this.r[2] = (t1 >>> 10 | t2 << 6) & 0x1f03;\n    this.r[3] = (t2 >>> 7 | t3 << 9) & 0x1fff;\n    this.r[4] = (t3 >>> 4 | t4 << 12) & 0x00ff;\n    this.r[5] = t4 >>> 1 & 0x1ffe;\n    this.r[6] = (t4 >>> 14 | t5 << 2) & 0x1fff;\n    this.r[7] = (t5 >>> 11 | t6 << 5) & 0x1f81;\n    this.r[8] = (t6 >>> 8 | t7 << 8) & 0x1fff;\n    this.r[9] = t7 >>> 5 & 0x007f; // h = 0\n\n    for (let i = 0; i < 10; i++) this.h[i] = 0; // Save pad for later.\n\n\n    for (let i = 0; i < 8; i++) this.pad[i] = readU16(key, 16 + 2 * i);\n\n    this.fin = 0;\n    this.leftover = 0;\n    return this;\n  }\n  /**\n   * Process 16 byte blocks.\n   * @private\n   * @param {Buffer} data - Blocks.\n   * @param {Number} bytes - Size.\n   * @param {Number} m - Offset pointer.\n   */\n\n\n  _blocks(data, bytes, m) {\n    const hibit = this.fin ? 0 : 1 << 11; // 1 << 128\n\n    const d = new Uint32Array(10);\n\n    while (bytes >= 16) {\n      // h += m[i]\n      const t0 = readU16(data, m + 0);\n      const t1 = readU16(data, m + 2);\n      const t2 = readU16(data, m + 4);\n      const t3 = readU16(data, m + 6);\n      const t4 = readU16(data, m + 8);\n      const t5 = readU16(data, m + 10);\n      const t6 = readU16(data, m + 12);\n      const t7 = readU16(data, m + 14);\n      this.h[0] += t0 & 0x1fff;\n      this.h[1] += (t0 >>> 13 | t1 << 3) & 0x1fff;\n      this.h[2] += (t1 >>> 10 | t2 << 6) & 0x1fff;\n      this.h[3] += (t2 >>> 7 | t3 << 9) & 0x1fff;\n      this.h[4] += (t3 >>> 4 | t4 << 12) & 0x1fff;\n      this.h[5] += t4 >>> 1 & 0x1fff;\n      this.h[6] += (t4 >>> 14 | t5 << 2) & 0x1fff;\n      this.h[7] += (t5 >>> 11 | t6 << 5) & 0x1fff;\n      this.h[8] += (t6 >>> 8 | t7 << 8) & 0x1fff;\n      this.h[9] += t7 >>> 5 | hibit; // h *= r, (partial) h %= p\n\n      let c = 0;\n\n      for (let i = 0; i < 10; i++) {\n        d[i] = c;\n\n        for (let j = 0; j < 10; j++) {\n          let a = this.h[j];\n          if (j <= i) a *= this.r[i - j];else a *= 5 * this.r[i + 10 - j];\n          d[i] += a; // Sum(h[i] * r[i] * 5) will overflow\n          // slightly above 6 products with an\n          // unclamped r, so carry at 5.\n\n          if (j === 4) {\n            c = d[i] >>> 13;\n            d[i] &= 0x1fff;\n          }\n        }\n\n        c += d[i] >>> 13;\n        d[i] &= 0x1fff;\n      }\n\n      c = (c << 2) + c; // c *= 5\n\n      c += d[0];\n      d[0] = c & 0x1fff;\n      c = c >>> 13;\n      d[1] += c;\n\n      for (let i = 0; i < 10; i++) this.h[i] = d[i];\n\n      m += 16;\n      bytes -= 16;\n    }\n  }\n  /**\n   * Update the MAC with data (will be\n   * processed as 16 byte blocks).\n   * @param {Buffer} data\n   */\n\n\n  update(data) {\n    assert(Buffer.isBuffer(data));\n    if (this.fin === -1) throw new Error('Context is not initialized.');\n    let bytes = data.length;\n    let m = 0; // Handle leftover.\n\n    if (this.leftover) {\n      let want = 16 - this.leftover;\n      if (want > bytes) want = bytes;\n\n      for (let i = 0; i < want; i++) this.buffer[this.leftover + i] = data[m + i];\n\n      bytes -= want;\n      m += want;\n      this.leftover += want;\n      if (this.leftover < 16) return this;\n\n      this._blocks(this.buffer, 16, 0);\n\n      this.leftover = 0;\n    } // Process full blocks.\n\n\n    if (bytes >= 16) {\n      const want = bytes & ~(16 - 1);\n\n      this._blocks(data, want, m);\n\n      m += want;\n      bytes -= want;\n    } // Store leftover.\n\n\n    if (bytes) {\n      for (let i = 0; i < bytes; i++) this.buffer[this.leftover + i] = data[m + i];\n\n      this.leftover += bytes;\n    }\n\n    return this;\n  }\n  /**\n   * Finalize and return a 16-byte MAC.\n   * @returns {Buffer}\n   */\n\n\n  final() {\n    if (this.fin === -1) throw new Error('Context is not initialized.');\n    const mac = Buffer.alloc(16);\n    const g = new Uint16Array(10); // Process the remaining block.\n\n    if (this.leftover) {\n      let i = this.leftover;\n      this.buffer[i++] = 1;\n\n      for (; i < 16; i++) this.buffer[i] = 0;\n\n      this.fin = 1;\n\n      this._blocks(this.buffer, 16, 0);\n    } // Fully carry h.\n\n\n    let c = this.h[1] >>> 13;\n    this.h[1] &= 0x1fff;\n\n    for (let i = 2; i < 10; i++) {\n      this.h[i] += c;\n      c = this.h[i] >>> 13;\n      this.h[i] &= 0x1fff;\n    }\n\n    this.h[0] += c * 5;\n    c = this.h[0] >>> 13;\n    this.h[0] &= 0x1fff;\n    this.h[1] += c;\n    c = this.h[1] >>> 13;\n    this.h[1] &= 0x1fff;\n    this.h[2] += c; // Compute h + -p.\n\n    g[0] = this.h[0] + 5;\n    c = g[0] >>> 13;\n    g[0] &= 0x1fff;\n\n    for (let i = 1; i < 10; i++) {\n      g[i] = this.h[i] + c;\n      c = g[i] >>> 13;\n      g[i] &= 0x1fff;\n    } // Select h if h < p, or h + -p if h >= p.\n\n\n    let mask = (c ^ 1) - 1;\n\n    for (let i = 0; i < 10; i++) g[i] &= mask;\n\n    mask = ~mask;\n\n    for (let i = 0; i < 10; i++) this.h[i] = this.h[i] & mask | g[i]; // h = h % (2^128)\n\n\n    this.h[0] = (this.h[0] | this.h[1] << 13) & 0xffff;\n    this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 0xffff;\n    this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 0xffff;\n    this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 0xffff;\n    this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 0xffff;\n    this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 0xffff;\n    this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 0xffff;\n    this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 0xffff; // mac = (h + pad) % (2^128)\n\n    let f = this.h[0] + this.pad[0];\n    this.h[0] = f;\n\n    for (let i = 1; i < 8; i++) {\n      f = this.h[i] + this.pad[i] + (f >>> 16);\n      this.h[i] = f;\n    }\n\n    for (let i = 0; i < 8; i++) writeU16(mac, this.h[i], i * 2); // Zero out the state.\n\n\n    this.destroy();\n    return mac;\n  }\n  /**\n   * Destroy the context.\n   */\n\n\n  destroy() {\n    for (let i = 0; i < 10; i++) {\n      this.r[i] = 0;\n      this.h[i] = 0;\n    }\n\n    for (let i = 0; i < 8; i++) this.pad[i] = 0;\n\n    for (let i = 0; i < 16; i++) this.buffer[i] = 0;\n\n    this.fin = -1;\n    this.leftover = 0;\n  }\n  /**\n   * Finalize and verify MAC against tag.\n   * @param {Buffer} tag\n   * @returns {Boolean}\n   */\n\n\n  verify(tag) {\n    assert(Buffer.isBuffer(tag));\n    assert(tag.length === 16);\n    const mac = this.final();\n    let z = 0;\n\n    for (let i = 0; i < 16; i++) z |= mac[i] ^ tag[i];\n\n    return z - 1 >>> 31 !== 0;\n  }\n\n}\n/*\n * Static\n */\n\n\nPoly1305.native = 0;\n/*\n * Helpers\n */\n\nfunction readU16(data, off) {\n  return data[off++] + data[off] * 0x100;\n}\n\nfunction writeU16(dst, num, off) {\n  dst[off++] = num;\n  dst[off++] = num >>> 8;\n  return off;\n}\n/*\n * Expose\n */\n\n\nmodule.exports = Poly1305;","map":null,"metadata":{},"sourceType":"script"}