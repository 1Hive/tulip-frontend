{"ast":null,"code":"'use strict';\n\nconst Channel = require('ipfs-pubsub-1on1');\n\nconst Logger = require('logplease');\n\nconst logger = Logger.create('exchange-heads', {\n  color: Logger.Colors.Yellow\n});\nLogger.setLogLevel('ERROR');\n\nconst getHeadsForDatabase = async store => {\n  if (!(store && store._cache)) return [];\n  const localHeads = (await store._cache.get(store.localHeadsPath)) || [];\n  const remoteHeads = (await store._cache.get(store.remoteHeadsPath)) || [];\n  return [...localHeads, ...remoteHeads];\n};\n\nconst exchangeHeads = async (ipfs, address, peer, getStore, getDirectConnection, onMessage, onChannelCreated) => {\n  const _handleMessage = message => {\n    const msg = JSON.parse(message.data);\n    const {\n      address,\n      heads\n    } = msg;\n    onMessage(address, heads);\n  };\n\n  let channel = getDirectConnection(peer);\n\n  if (!channel) {\n    try {\n      logger.debug(`Create a channel to ${peer}`);\n      channel = await Channel.open(ipfs, peer);\n      channel.on('message', _handleMessage);\n      logger.debug(`Channel created to ${peer}`);\n      onChannelCreated(channel);\n    } catch (e) {\n      logger.error(e);\n    }\n  } // Wait for the direct channel to be fully connected\n\n\n  await channel.connect();\n  logger.debug(`Connected to ${peer}`); // Send the heads if we have any\n\n  const heads = await getHeadsForDatabase(getStore(address));\n  logger.debug(`Send latest heads of '${address}':\\n`, JSON.stringify(heads.map(e => e.hash), null, 2));\n\n  if (heads) {\n    await channel.send(JSON.stringify({\n      address: address,\n      heads: heads\n    }));\n  }\n\n  return channel;\n};\n\nmodule.exports = exchangeHeads;","map":null,"metadata":{},"sourceType":"script"}