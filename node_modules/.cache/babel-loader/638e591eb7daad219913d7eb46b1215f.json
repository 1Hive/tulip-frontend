{"ast":null,"code":"const {\n  getWeek,\n  subWeeks,\n  subYears,\n  startOfMinute,\n  getUnixTime\n} = require(\"date-fns\");\n\nconst {\n  TWENTY_FOUR_HOURS\n} = require('./../constants');\n\nconst {\n  dayData,\n  tokenHourData,\n  tokenDayData,\n  pairHourData,\n  pairDayData,\n  ethPriceHourly\n} = require('./exchange');\n\nmodule.exports = {\n  async factory() {\n    let data = await dayData();\n    let weeklyData = [];\n    let startIndexWeekly = -1;\n    let currentWeek = -1;\n    data.forEach((entry, i) => {\n      const week = getWeek(data[i].date);\n\n      if (week !== currentWeek) {\n        currentWeek = week;\n        startIndexWeekly++;\n      }\n\n      weeklyData[startIndexWeekly] = weeklyData[startIndexWeekly] || {};\n      weeklyData[startIndexWeekly].date = data[i].date;\n      weeklyData[startIndexWeekly].weeklyVolumeUSD = (weeklyData[startIndexWeekly].weeklyVolumeUSD ? weeklyData[startIndexWeekly].weeklyVolumeUSD : 0) + data[i].volumeUSD;\n    });\n    return [data, weeklyData];\n  },\n\n  async tokenHourly({\n    token_address = undefined,\n    startTime = undefined\n  }) {\n    if (!token_address) {\n      throw new Error(\"sushi-data: Token address undefined\");\n    }\n\n    let [tokenData, ethPrices] = await Promise.all([tokenHourData({\n      minTimestamp: startTime,\n      token_address\n    }), ethPriceHourly({\n      minTimestamp: startTime\n    })]);\n    tokenData = tokenData.map(tokenEntry => {\n      const ethPriceUSD = ethPrices.find(ethEntry => ethEntry.timestamp === tokenEntry.timestamp).priceUSD;\n      return { ...tokenEntry,\n        priceUSD: tokenEntry.derivedETH * ethPriceUSD\n      };\n    });\n    tokenData = tokenData.map((tokenEntry, i) => ({ ...tokenEntry,\n      volume: tokenData[i - 1] ? tokenEntry.volume - tokenData[i - 1].volume : undefined,\n      volumeUSD: tokenData[i - 1] ? tokenEntry.volumeUSD - tokenData[i - 1].volumeUSD : undefined,\n      untrackedVolumeUSD: tokenData[i - 1] ? tokenEntry.untrackedVolumeUSD - tokenData[i - 1].untrackedVolumeUSD : undefined,\n      txCount: tokenData[i - 1] ? tokenEntry.txCount - tokenData[i - 1].txCount : undefined,\n      open: tokenEntry.priceUSD,\n      close: tokenData[i + 1] ? tokenData[i + 1].priceUSD : undefined\n    }));\n    return tokenData;\n  },\n\n  async tokenDaily({\n    token_address = undefined\n  } = {}) {\n    if (!token_address) {\n      throw new Error(\"sushi-data: Token address undefined\");\n    }\n\n    let data = await tokenDayData({\n      token_address\n    });\n    const endTime = getUnixTime(new Date());\n    const startTime = getUnixTime(startOfMinute(subYears(new Date(), 1)));\n    let dayIndexSet = new Set();\n    let dayIndexArray = [];\n    data.forEach((dayData, i) => {\n      // add the day index to the set of days\n      dayIndexSet.add((data[i].timestamp / TWENTY_FOUR_HOURS).toFixed(0));\n      dayIndexArray.push(data[i]);\n    }); // fill in empty days\n\n    let timestamp = data[0] && data[0].timestamp ? data[0].timestamp : startTime;\n    let latestLiquidity = data[0] && data[0].liquidity;\n    let latestLiquidityUSD = data[0] && data[0].liquidityUSD;\n    let latestLiquidityETH = data[0] && data[0].liquidityETH;\n    let latestPriceUSD = data[0] && data[0].priceUSD;\n    let index = 1;\n\n    while (timestamp < endTime - TWENTY_FOUR_HOURS) {\n      const nextDay = timestamp + TWENTY_FOUR_HOURS;\n      let currentDayIndex = (nextDay / TWENTY_FOUR_HOURS).toFixed(0);\n\n      if (!dayIndexSet.has(currentDayIndex)) {\n        data.push({\n          id: `${data[0].id.split(\"-\")[0]}-${nextDay / TWENTY_FOUR_HOURS}`,\n          date: new Date(nextDay * 1000),\n          timestamp: nextDay,\n          volume: 0,\n          volumeETH: 0,\n          volumeUSD: 0,\n          liquidity: latestLiquidity,\n          liquidityETH: latestLiquidityETH,\n          liquidityUSD: latestLiquidityUSD,\n          priceUSD: latestPriceUSD,\n          txCount: 0\n        });\n      } else {\n        latestLiquidity = dayIndexArray[index].liquidity;\n        latestLiquidityETH = dayIndexArray[index].liquidityETH;\n        latestLiquidityUSD = dayIndexArray[index].liquidityUSD;\n        latestPriceUSD = dayIndexArray[index].priceUSD;\n        index = index + 1;\n      }\n\n      timestamp = nextDay;\n    }\n\n    data = data.sort((a, b) => parseInt(a.timestamp) > parseInt(b.timestamp) ? 1 : -1);\n    return data;\n  },\n\n  async pairHourly({\n    pair_address = undefined,\n    startTime = undefined\n  }) {\n    if (!pair_address) {\n      throw new Error(\"sushi-data: Pair address undefined\");\n    }\n\n    let pairData = await pairHourData({\n      minTimestamp: startTime,\n      pair_address\n    });\n    pairData = pairData.map((pairEntry, i) => ({ ...pairEntry,\n      volumeToken0: pairData[i - 1] ? pairEntry.volumeToken0 - pairData[i - 1].volumeToken0 : undefined,\n      volumeToken1: pairData[i - 1] ? pairEntry.volumeToken1 - pairData[i - 1].volumeToken1 : undefined,\n      rate0: {\n        open: pairEntry.token0Price,\n        close: pairData[i + 1] ? pairData[i + 1].token0Price : undefined\n      },\n      rate1: {\n        open: pairEntry.token1Price,\n        close: pairData[i + 1] ? pairData[i + 1].token1Price : undefined\n      },\n      txCount: pairData[i - 1] ? pairEntry.txCount - pairData[i - 1].txCount : undefined\n    }));\n    return pairData;\n  },\n\n  async pairDaily({\n    pair_address = undefined\n  } = {}) {\n    if (!pair_address) {\n      throw new Error(\"sushi-data: Pair address undefined\");\n    }\n\n    let data = await pairDayData({\n      pair_address\n    });\n    const endTime = getUnixTime(new Date());\n    const startTime = getUnixTime(startOfMinute(subYears(new Date(), 1)));\n    let dayIndexSet = new Set();\n    let dayIndexArray = [];\n    data.forEach((dayData, i) => {\n      // add the day index to the set of days\n      dayIndexSet.add((data[i].timestamp / TWENTY_FOUR_HOURS).toFixed(0));\n      dayIndexArray.push(data[i]);\n    });\n    let timestamp = data[0].timestamp ? data[0].timestamp : startTime;\n    let latestLiquidityUSD = data[0].liquidityUSD;\n    let index = 1;\n\n    while (timestamp < endTime - TWENTY_FOUR_HOURS) {\n      const nextDay = timestamp + TWENTY_FOUR_HOURS;\n      let currentDayIndex = (nextDay / TWENTY_FOUR_HOURS).toFixed(0);\n\n      if (!dayIndexSet.has(currentDayIndex)) {\n        data.push({\n          id: `${data[0].id.split(\"-\")[0]}-${nextDay / TWENTY_FOUR_HOURS}`,\n          date: new Date(nextDay * 1000),\n          timestamp: nextDay,\n          volumeUSD: 0,\n          volumeToken0: 0,\n          volumeToken1: 0,\n          liquidityUSD: latestLiquidityUSD,\n          txCount: 0\n        });\n      } else {\n        latestLiquidityUSD = dayIndexArray[index].liquidityUSD;\n        index = index + 1;\n      }\n\n      timestamp = nextDay;\n    }\n\n    data = data.sort((a, b) => parseInt(a.timestamp) > parseInt(b.timestamp) ? 1 : -1);\n    return data;\n  }\n\n};","map":null,"metadata":{},"sourceType":"script"}