{"ast":null,"code":"/* eslint-env browser */\n'use strict';\n\nconst TLRU = require('../../utils/tlru');\n\nconst {\n  default: PQueue\n} = require('p-queue');\n\nconst HTTP = require('ipfs-utils/src/http'); // Avoid sending multiple queries for the same hostname by caching results\n\n\nconst cache = new TLRU(1000); // TODO: /api/v0/dns does not return TTL yet: https://github.com/ipfs/go-ipfs/issues/5884\n// However we know browsers themselves cache DNS records for at least 1 minute,\n// which acts a provisional default ttl: https://stackoverflow.com/a/36917902/11518426\n\nconst ttl = 60 * 1000; // browsers limit concurrent connections per host,\n// we don't want preload calls to exhaust the limit (~6)\n\nconst httpQueue = new PQueue({\n  concurrency: 4\n});\n\nconst ipfsPath = response => {\n  if (response.Path) return response.Path;\n  throw new Error(response.Message);\n};\n\nmodule.exports = async (fqdn, opts) => {\n  // eslint-disable-line require-await\n  const resolveDnslink = async (fqdn, opts) => {\n    opts = opts || {};\n    const searchParams = new URLSearchParams(opts);\n    searchParams.set('arg', fqdn); // try cache first\n\n    const query = searchParams.toString();\n\n    if (!opts.nocache && cache.has(query)) {\n      const response = cache.get(query);\n      return ipfsPath(response);\n    } // fallback to delegated DNS resolver\n\n\n    const response = await httpQueue.add(async () => {\n      // Delegated HTTP resolver sending DNSLink queries to ipfs.io\n      // TODO: replace hardcoded host with configurable DNS over HTTPS: https://github.com/ipfs/js-ipfs/issues/2212\n      const res = await HTTP.get('https://ipfs.io/api/v0/dns', {\n        searchParams\n      });\n      const query = new URL(res.url).search.slice(1);\n      const json = await res.json();\n      cache.set(query, json, ttl);\n      return json;\n    });\n    return ipfsPath(response);\n  };\n\n  return resolveDnslink(fqdn, opts);\n};","map":null,"metadata":{},"sourceType":"script"}