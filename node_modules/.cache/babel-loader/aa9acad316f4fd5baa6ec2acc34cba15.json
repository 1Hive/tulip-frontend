{"ast":null,"code":"'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst {\n  openDB,\n  deleteDB\n} = require('idb');\n\nconst {\n  Key,\n  Errors,\n  utils,\n  Adapter\n} = require('interface-datastore');\n\nconst {\n  filter,\n  sortAll\n} = utils;\n\nconst isStrictTypedArray = arr => {\n  return arr instanceof Int8Array || arr instanceof Int16Array || arr instanceof Int32Array || arr instanceof Uint8Array || arr instanceof Uint8ClampedArray || arr instanceof Uint16Array || arr instanceof Uint32Array || arr instanceof Float32Array || arr instanceof Float64Array;\n};\n\nconst typedarrayToBuffer = arr => {\n  if (isStrictTypedArray(arr)) {\n    // To avoid a copy, use the typed array's underlying ArrayBuffer to back new Buffer\n    let buf = Buffer.from(arr.buffer);\n\n    if (arr.byteLength !== arr.buffer.byteLength) {\n      // Respect the \"view\", i.e. byteOffset and byteLength, without doing a copy\n      buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength);\n    }\n\n    return buf;\n  } else {\n    // Pass through all other types to `Buffer.from`\n    return Buffer.from(arr);\n  }\n};\n\nconst str2ab = str => {\n  const buf = new ArrayBuffer(str.length);\n  const bufView = new Uint8Array(buf);\n\n  for (let i = 0, strLen = str.length; i < strLen; i++) {\n    bufView[i] = str.charCodeAt(i);\n  }\n\n  return buf;\n};\n\nconst queryIt = async function* (q, store, location) {\n  const range = q.prefix ? self.IDBKeyRange.bound(str2ab(q.prefix), str2ab(q.prefix + '\\xFF'), false, true) : undefined;\n  let cursor = await store.transaction(location).store.openCursor(range);\n  let limit = 0;\n\n  if (cursor && q.offset && q.offset > 0) {\n    cursor = await cursor.advance(q.offset);\n  }\n\n  while (cursor) {\n    // limit\n    if (q.limit !== undefined && q.limit === limit) {\n      return;\n    }\n\n    limit++;\n    const key = new Key(Buffer.from(cursor.key));\n\n    if (q.keysOnly) {\n      yield {\n        key\n      };\n    } else {\n      const value = Buffer.from(cursor.value);\n      yield {\n        key,\n        value\n      };\n    }\n\n    cursor = await cursor.continue();\n  }\n};\n\nclass IdbDatastore extends Adapter {\n  constructor(location, options = {}) {\n    super();\n    this.store = null;\n    this.options = options;\n    this.location = options.prefix + location;\n    this.version = options.version || 1;\n  }\n\n  async open() {\n    if (this.store !== null) {\n      return;\n    }\n\n    const location = this.location;\n\n    try {\n      this.store = await openDB(this.location, this.version, {\n        upgrade(db) {\n          db.createObjectStore(location);\n        }\n\n      });\n    } catch (err) {\n      throw Errors.dbOpenFailedError(err);\n    }\n  }\n\n  async put(key, val) {\n    if (this.store === null) {\n      throw new Error('Datastore needs to be opened.');\n    }\n\n    try {\n      await this.store.put(this.location, val, key.toBuffer());\n    } catch (err) {\n      throw Errors.dbWriteFailedError(err);\n    }\n  }\n\n  async get(key) {\n    if (this.store === null) {\n      throw new Error('Datastore needs to be opened.');\n    }\n\n    let value;\n\n    try {\n      value = await this.store.get(this.location, key.toBuffer());\n    } catch (err) {\n      throw Errors.dbWriteFailedError(err);\n    }\n\n    if (!value) {\n      throw Errors.notFoundError();\n    }\n\n    return typedarrayToBuffer(value);\n  }\n\n  async has(key) {\n    if (this.store === null) {\n      throw new Error('Datastore needs to be opened.');\n    }\n\n    try {\n      await this.get(key);\n    } catch (err) {\n      if (err.code === 'ERR_NOT_FOUND') return false;\n      throw err;\n    }\n\n    return true;\n  }\n\n  async delete(key) {\n    if (this.store === null) {\n      throw new Error('Datastore needs to be opened.');\n    }\n\n    try {\n      await this.store.delete(this.location, key.toBuffer());\n    } catch (err) {\n      throw Errors.dbDeleteFailedError(err);\n    }\n  }\n\n  batch() {\n    const puts = [];\n    const dels = [];\n    return {\n      put(key, value) {\n        puts.push([key.toBuffer(), value]);\n      },\n\n      delete(key) {\n        dels.push(key.toBuffer());\n      },\n\n      commit: async () => {\n        if (this.store === null) {\n          throw new Error('Datastore needs to be opened.');\n        }\n\n        const tx = this.store.transaction(this.location, 'readwrite');\n        const store = tx.store;\n        await Promise.all(puts.map(p => store.put(p[1], p[0])));\n        await Promise.all(dels.map(p => store.delete(p)));\n        await tx.done;\n      }\n    };\n  }\n\n  query(q) {\n    if (this.store === null) {\n      throw new Error('Datastore needs to be opened.');\n    }\n\n    let it = queryIt(q, this.store, this.location);\n\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it);\n    }\n\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sortAll(it, f), it);\n    }\n\n    return it;\n  }\n\n  close() {\n    if (this.store === null) {\n      throw new Error('Datastore needs to be opened.');\n    }\n\n    this.store.close();\n    this.store = null;\n  }\n\n  destroy() {\n    return deleteDB(this.location);\n  }\n\n}\n\nmodule.exports = IdbDatastore;","map":null,"metadata":{},"sourceType":"script"}