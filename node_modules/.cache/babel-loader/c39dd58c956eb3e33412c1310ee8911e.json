{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _createForOfIteratorHelper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar mergeOptions = require('merge-options');\n\nvar pipe = require('it-pipe');\n\nvar _require = require('streaming-iterables'),\n    tap = _require.tap;\n\nvar oldPeerLRU = require('./old-peers');\n\nvar _require2 = require('../constants'),\n    defaultOptions = _require2.METRICS;\n\nvar Stats = require('./stats');\n\nvar initialCounters = ['dataReceived', 'dataSent'];\nvar directionToEvent = {\n  in: 'dataReceived',\n  out: 'dataSent'\n};\n\nvar Metrics = /*#__PURE__*/function () {\n  /**\n   *\n   * @param {object} options\n   * @param {number} options.computeThrottleMaxQueueSize\n   * @param {number} options.computeThrottleTimeout\n   * @param {Array<number>} options.movingAverageIntervals\n   * @param {number} options.maxOldPeersRetention\n   */\n  function Metrics(options) {\n    _classCallCheck(this, Metrics);\n\n    this._options = mergeOptions(defaultOptions, options);\n    this._globalStats = new Stats(initialCounters, this._options);\n    this._peerStats = new Map();\n    this._protocolStats = new Map();\n    this._oldPeers = oldPeerLRU(this._options.maxOldPeersRetention);\n    this._running = false;\n    this._onMessage = this._onMessage.bind(this);\n  }\n  /**\n   * Must be called for stats to saved. Any data pushed for tracking\n   * will be ignored.\n   */\n\n\n  _createClass(Metrics, [{\n    key: \"start\",\n    value: function start() {\n      this._running = true;\n    }\n    /**\n     * Stops all averages timers and prevents new data from being tracked.\n     * Once `stop` is called, `start` must be called to resume stats tracking.\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this._running = false;\n\n      this._globalStats.stop();\n\n      var _iterator = _createForOfIteratorHelper(this._peerStats.values()),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var stats = _step.value;\n          stats.stop();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var _iterator2 = _createForOfIteratorHelper(this._protocolStats.values()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _stats = _step2.value;\n\n          _stats.stop();\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n    /**\n     * Gets the global `Stats` object\n     * @returns {Stats}\n     */\n\n  }, {\n    key: \"global\",\n    get: function get() {\n      return this._globalStats;\n    }\n    /**\n     * Returns a list of `PeerId` strings currently being tracked\n     * @returns {Array<string>}\n     */\n\n  }, {\n    key: \"peers\",\n    get: function get() {\n      return Array.from(this._peerStats.keys());\n    }\n    /**\n     * Returns the `Stats` object for the given `PeerId` whether it\n     * is a live peer, or in the disconnected peer LRU cache.\n     * @param {PeerId} peerId\n     * @returns {Stats}\n     */\n\n  }, {\n    key: \"forPeer\",\n    value: function forPeer(peerId) {\n      var idString = peerId.toB58String();\n      return this._peerStats.get(idString) || this._oldPeers.get(idString);\n    }\n    /**\n     * Returns a list of all protocol strings currently being tracked.\n     * @returns {Array<string>}\n     */\n\n  }, {\n    key: \"protocols\",\n    get: function get() {\n      return Array.from(this._protocolStats.keys());\n    }\n    /**\n     * Returns the `Stats` object for the given `protocol`.\n     * @param {string} protocol\n     * @returns {Stats}\n     */\n\n  }, {\n    key: \"forProtocol\",\n    value: function forProtocol(protocol) {\n      return this._protocolStats.get(protocol);\n    }\n    /**\n     * Should be called when all connections to a given peer\n     * have closed. The `Stats` collection for the peer will\n     * be stopped and moved to an LRU for temporary retention.\n     * @param {PeerId} peerId\n     */\n\n  }, {\n    key: \"onPeerDisconnected\",\n    value: function onPeerDisconnected(peerId) {\n      var idString = peerId.toB58String();\n\n      var peerStats = this._peerStats.get(idString);\n\n      if (peerStats) {\n        peerStats.stop();\n\n        this._peerStats.delete(idString);\n\n        this._oldPeers.set(idString, peerStats);\n      }\n    }\n    /**\n     * Takes the metadata for a message and tracks it in the\n     * appropriate categories. If the protocol is present, protocol\n     * stats will also be tracked.\n     *\n     * @private\n     * @param {object} params\n     * @param {PeerId} params.remotePeer Remote peer\n     * @param {string} [params.protocol] Protocol string the stream is running\n     * @param {string} params.direction One of ['in','out']\n     * @param {number} params.dataLength Size of the message\n     * @returns {void}\n     */\n\n  }, {\n    key: \"_onMessage\",\n    value: function _onMessage(_ref) {\n      var remotePeer = _ref.remotePeer,\n          protocol = _ref.protocol,\n          direction = _ref.direction,\n          dataLength = _ref.dataLength;\n      if (!this._running) return;\n      var key = directionToEvent[direction];\n      var peerStats = this.forPeer(remotePeer);\n\n      if (!peerStats) {\n        peerStats = new Stats(initialCounters, this._options);\n\n        this._peerStats.set(remotePeer.toB58String(), peerStats);\n      } // Peer and global stats\n\n\n      peerStats.push(key, dataLength);\n\n      this._globalStats.push(key, dataLength); // Protocol specific stats\n\n\n      if (protocol) {\n        var protocolStats = this.forProtocol(protocol);\n\n        if (!protocolStats) {\n          protocolStats = new Stats(initialCounters, this._options);\n\n          this._protocolStats.set(protocol, protocolStats);\n        }\n\n        protocolStats.push(key, dataLength);\n      }\n    }\n    /**\n     * Replaces the `PeerId` string with the given `peerId`.\n     * If stats are already being tracked for the given `peerId`, the\n     * placeholder stats will be merged with the existing stats.\n     * @param {PeerId} placeholder A peerId string\n     * @param {PeerId} peerId\n     */\n\n  }, {\n    key: \"updatePlaceholder\",\n    value: function updatePlaceholder(placeholder, peerId) {\n      if (!this._running) return;\n      var placeholderStats = this.forPeer(placeholder);\n      var peerIdString = peerId.toB58String();\n      var existingStats = this.forPeer(peerId);\n      var mergedStats = placeholderStats; // If we already have stats, merge the two\n\n      if (existingStats) {\n        // If existing, merge\n        mergedStats = Metrics.mergeStats(existingStats, mergedStats); // Attempt to delete from the old peers list just in case it was tracked there\n\n        this._oldPeers.delete(peerIdString);\n      }\n\n      this._peerStats.delete(placeholder.toB58String());\n\n      this._peerStats.set(peerIdString, mergedStats);\n\n      mergedStats.start();\n    }\n    /**\n     * Tracks data running through a given Duplex Iterable `stream`. If\n     * the `peerId` is not provided, a placeholder string will be created and\n     * returned. This allows lazy tracking of a peer when the peer is not yet known.\n     * When the `PeerId` is known, `Metrics.updatePlaceholder` should be called\n     * with the placeholder string returned from here, and the known `PeerId`.\n     *\n     * @param {Object} options\n     * @param {{ sink: function(*), source: function() }} options.stream A duplex iterable stream\n     * @param {PeerId} [options.peerId] The id of the remote peer that's connected\n     * @param {string} [options.protocol] The protocol the stream is running\n     * @returns {string} The peerId string or placeholder string\n     */\n\n  }, {\n    key: \"trackStream\",\n    value: function trackStream(_ref2) {\n      var stream = _ref2.stream,\n          remotePeer = _ref2.remotePeer,\n          protocol = _ref2.protocol;\n      var metrics = this;\n      var _source = stream.source;\n      stream.source = tap(function (chunk) {\n        return metrics._onMessage({\n          remotePeer: remotePeer,\n          protocol: protocol,\n          direction: 'in',\n          dataLength: chunk.length\n        });\n      })(_source);\n      var _sink = stream.sink;\n\n      stream.sink = function (source) {\n        return pipe(source, tap(function (chunk) {\n          return metrics._onMessage({\n            remotePeer: remotePeer,\n            protocol: protocol,\n            direction: 'out',\n            dataLength: chunk.length\n          });\n        }), _sink);\n      };\n\n      return stream;\n    }\n    /**\n     * Merges `other` into `target`. `target` will be modified\n     * and returned.\n     * @param {Stats} target\n     * @param {Stats} other\n     * @returns {Stats}\n     */\n\n  }], [{\n    key: \"mergeStats\",\n    value: function mergeStats(target, other) {\n      target.stop();\n      other.stop(); // Merge queues\n\n      target._queue = [].concat(_toConsumableArray(target._queue), _toConsumableArray(other._queue)); // TODO: how to merge moving averages?\n\n      return target;\n    }\n  }]);\n\n  return Metrics;\n}();\n\nmodule.exports = Metrics;","map":null,"metadata":{},"sourceType":"script"}