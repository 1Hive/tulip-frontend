{"ast":null,"code":"'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst crypto = require('libp2p-crypto');\n\nconst multibase = require('multibase');\n\nexports = module.exports;\n/**\n * Generatea random sequence number.\n *\n * @returns {Buffer}\n * @private\n */\n\nexports.randomSeqno = () => {\n  return crypto.randomBytes(8);\n};\n/**\n * Generate a message id, based on the `from` and `seqno`.\n *\n * @param {string} from\n * @param {Buffer} seqno\n * @returns {string}\n * @private\n */\n\n\nexports.msgId = (from, seqno) => {\n  return from + seqno.toString('hex');\n};\n/**\n * Check if any member of the first set is also a member\n * of the second set.\n *\n * @param {Set|Array} a\n * @param {Set|Array} b\n * @returns {boolean}\n * @private\n */\n\n\nexports.anyMatch = (a, b) => {\n  let bHas;\n\n  if (Array.isArray(b)) {\n    bHas = val => b.indexOf(val) > -1;\n  } else {\n    bHas = val => b.has(val);\n  }\n\n  for (const val of a) {\n    if (bHas(val)) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Make everything an array.\n *\n * @param {any} maybeArray\n * @returns {Array}\n * @private\n */\n\n\nexports.ensureArray = maybeArray => {\n  if (!Array.isArray(maybeArray)) {\n    return [maybeArray];\n  }\n\n  return maybeArray;\n};\n/**\n * Ensures `message.from` is base58 encoded\n * @param {Object} message\n * @param {Buffer|String} message.from\n * @return {Object}\n */\n\n\nexports.normalizeInRpcMessage = message => {\n  const m = Object.assign({}, message);\n\n  if (Buffer.isBuffer(message.from)) {\n    m.from = multibase.encode('base58btc', message.from).toString().slice(1);\n  }\n\n  return m;\n};\n/**\n * The same as `normalizeInRpcMessage`, but performed on an array of messages\n * @param {Object[]} messages\n * @return {Object[]}\n */\n\n\nexports.normalizeInRpcMessages = messages => {\n  if (!messages) {\n    return messages;\n  }\n\n  return messages.map(exports.normalizeInRpcMessage);\n};\n\nexports.normalizeOutRpcMessage = message => {\n  const m = Object.assign({}, message);\n\n  if (typeof message.from === 'string' || message.from instanceof String) {\n    m.from = multibase.decode('z' + message.from);\n  }\n\n  return m;\n};\n\nexports.normalizeOutRpcMessages = messages => {\n  if (!messages) {\n    return messages;\n  }\n\n  return messages.map(exports.normalizeOutRpcMessage);\n};","map":null,"metadata":{},"sourceType":"script"}