{"ast":null,"code":"/* eslint-env browser */\n'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar TLRU = require('../../utils/tlru');\n\nvar _require = require('p-queue'),\n    PQueue = _require.default;\n\nvar HTTP = require('ipfs-utils/src/http'); // Avoid sending multiple queries for the same hostname by caching results\n\n\nvar cache = new TLRU(1000); // TODO: /api/v0/dns does not return TTL yet: https://github.com/ipfs/go-ipfs/issues/5884\n// However we know browsers themselves cache DNS records for at least 1 minute,\n// which acts a provisional default ttl: https://stackoverflow.com/a/36917902/11518426\n\nvar ttl = 60 * 1000; // browsers limit concurrent connections per host,\n// we don't want preload calls to exhaust the limit (~6)\n\nvar httpQueue = new PQueue({\n  concurrency: 4\n});\n\nvar ipfsPath = function ipfsPath(response) {\n  if (response.Path) return response.Path;\n  throw new Error(response.Message);\n};\n\nmodule.exports = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(fqdn, opts) {\n    var resolveDnslink;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            // eslint-disable-line require-await\n            resolveDnslink = /*#__PURE__*/function () {\n              var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(fqdn, opts) {\n                var searchParams, query, _response, response;\n\n                return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n                  while (1) {\n                    switch (_context2.prev = _context2.next) {\n                      case 0:\n                        opts = opts || {};\n                        searchParams = new URLSearchParams(opts);\n                        searchParams.set('arg', fqdn); // try cache first\n\n                        query = searchParams.toString();\n\n                        if (!(!opts.nocache && cache.has(query))) {\n                          _context2.next = 7;\n                          break;\n                        }\n\n                        _response = cache.get(query);\n                        return _context2.abrupt(\"return\", ipfsPath(_response));\n\n                      case 7:\n                        _context2.next = 9;\n                        return httpQueue.add( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n                          var res, query, json;\n                          return _regeneratorRuntime.wrap(function _callee$(_context) {\n                            while (1) {\n                              switch (_context.prev = _context.next) {\n                                case 0:\n                                  _context.next = 2;\n                                  return HTTP.get('https://ipfs.io/api/v0/dns', {\n                                    searchParams: searchParams\n                                  });\n\n                                case 2:\n                                  res = _context.sent;\n                                  query = new URL(res.url).search.slice(1);\n                                  _context.next = 6;\n                                  return res.json();\n\n                                case 6:\n                                  json = _context.sent;\n                                  cache.set(query, json, ttl);\n                                  return _context.abrupt(\"return\", json);\n\n                                case 9:\n                                case \"end\":\n                                  return _context.stop();\n                              }\n                            }\n                          }, _callee);\n                        })));\n\n                      case 9:\n                        response = _context2.sent;\n                        return _context2.abrupt(\"return\", ipfsPath(response));\n\n                      case 11:\n                      case \"end\":\n                        return _context2.stop();\n                    }\n                  }\n                }, _callee2);\n              }));\n\n              return function resolveDnslink(_x3, _x4) {\n                return _ref2.apply(this, arguments);\n              };\n            }();\n\n            return _context3.abrupt(\"return\", resolveDnslink(fqdn, opts));\n\n          case 2:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function (_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":null,"metadata":{},"sourceType":"script"}