{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _objectSpread = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _get = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _require = require('events'),\n    EventEmitter = _require.EventEmitter;\n\nvar debug = require('debug');\n\nvar globalThis = require('ipfs-utils/src/globalthis');\n\nvar log = debug('libp2p');\nlog.error = debug('libp2p:error');\n\nvar PeerInfo = require('peer-info');\n\nvar peerRouting = require('./peer-routing');\n\nvar contentRouting = require('./content-routing');\n\nvar pubsub = require('./pubsub');\n\nvar _require2 = require('./get-peer-info'),\n    getPeerInfo = _require2.getPeerInfo;\n\nvar _require3 = require('./config'),\n    validateConfig = _require3.validate;\n\nvar _require4 = require('./errors'),\n    codes = _require4.codes;\n\nvar ConnectionManager = require('./connection-manager');\n\nvar Circuit = require('./circuit');\n\nvar Dialer = require('./dialer');\n\nvar Metrics = require('./metrics');\n\nvar TransportManager = require('./transport-manager');\n\nvar Upgrader = require('./upgrader');\n\nvar PeerStore = require('./peer-store');\n\nvar Registrar = require('./registrar');\n\nvar _ping = require('./ping');\n\nvar _require5 = require('./identify'),\n    IdentifyService = _require5.IdentifyService,\n    IDENTIFY_PROTOCOLS = _require5.multicodecs;\n/**\n * @fires Libp2p#error Emitted when an error occurs\n * @fires Libp2p#peer:connect Emitted when a peer is connected to this node\n * @fires Libp2p#peer:disconnect Emitted when a peer disconnects from this node\n * @fires Libp2p#peer:discovery Emitted when a peer is discovered\n */\n\n\nvar Libp2p = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(Libp2p, _EventEmitter);\n\n  var _super = _createSuper(Libp2p);\n\n  function Libp2p(_options) {\n    var _this;\n\n    _classCallCheck(this, Libp2p);\n\n    _this = _super.call(this); // validateConfig will ensure the config is correct,\n    // and add default values where appropriate\n\n    _this._options = validateConfig(_options);\n    _this.datastore = _this._options.datastore;\n    _this.peerInfo = _this._options.peerInfo;\n    _this.peerStore = new PeerStore();\n    _this._modules = _this._options.modules;\n    _this._config = _this._options.config;\n    _this._transport = []; // Transport instances/references\n\n    _this._discovery = new Map(); // Discovery service instances/references\n\n    if (_this._options.metrics.enabled) {\n      _this.metrics = new Metrics(_this._options.metrics);\n    } // Setup the Upgrader\n\n\n    _this.upgrader = new Upgrader({\n      localPeer: _this.peerInfo.id,\n      metrics: _this.metrics,\n      onConnection: function onConnection(connection) {\n        var peerInfo = _this.peerStore.put(new PeerInfo(connection.remotePeer), {\n          silent: true\n        });\n\n        _this.registrar.onConnect(peerInfo, connection);\n\n        _this.connectionManager.onConnect(connection);\n\n        _this.emit('peer:connect', peerInfo); // Run identify for every connection\n\n\n        if (_this.identifyService) {\n          _this.identifyService.identify(connection, connection.remotePeer).catch(log.error);\n        }\n      },\n      onConnectionEnd: function onConnectionEnd(connection) {\n        var peerInfo = Dialer.getDialable(connection.remotePeer);\n\n        _this.registrar.onDisconnect(peerInfo, connection);\n\n        _this.connectionManager.onDisconnect(connection); // If there are no connections to the peer, disconnect\n\n\n        if (!_this.registrar.getConnection(peerInfo)) {\n          _this.emit('peer:disconnect', peerInfo);\n\n          _this.metrics && _this.metrics.onPeerDisconnected(peerInfo.id);\n        }\n      }\n    }); // Create the Registrar\n\n    _this.registrar = new Registrar({\n      peerStore: _this.peerStore\n    });\n    _this.handle = _this.handle.bind(_assertThisInitialized(_this));\n    _this.registrar.handle = _this.handle; // Create the Connection Manager\n\n    _this.connectionManager = new ConnectionManager(_assertThisInitialized(_this), _this._options.connectionManager); // Setup the transport manager\n\n    _this.transportManager = new TransportManager({\n      libp2p: _assertThisInitialized(_this),\n      upgrader: _this.upgrader\n    }); // Attach crypto channels\n\n    if (_this._modules.connEncryption) {\n      var cryptos = _this._modules.connEncryption;\n      cryptos.forEach(function (crypto) {\n        _this.upgrader.cryptos.set(crypto.protocol, crypto);\n      });\n    }\n\n    _this.dialer = new Dialer({\n      transportManager: _this.transportManager,\n      peerStore: _this.peerStore,\n      concurrency: _this._options.dialer.maxParallelDials,\n      perPeerLimit: _this._options.dialer.maxDialsPerPeer,\n      timeout: _this._options.dialer.dialTimeout\n    });\n\n    _this._modules.transport.forEach(function (Transport) {\n      var key = Transport.prototype[Symbol.toStringTag];\n      var transportOptions = _this._config.transport[key];\n\n      _this.transportManager.add(key, Transport, transportOptions);\n    });\n\n    if (_this._config.relay.enabled) {\n      _this.transportManager.add(Circuit.prototype[Symbol.toStringTag], Circuit);\n    } // Attach stream multiplexers\n\n\n    if (_this._modules.streamMuxer) {\n      var muxers = _this._modules.streamMuxer;\n      muxers.forEach(function (muxer) {\n        _this.upgrader.muxers.set(muxer.multicodec, muxer);\n      }); // Add the identify service since we can multiplex\n\n      _this.identifyService = new IdentifyService({\n        registrar: _this.registrar,\n        peerInfo: _this.peerInfo,\n        protocols: _this.upgrader.protocols\n      });\n\n      _this.handle(Object.values(IDENTIFY_PROTOCOLS), _this.identifyService.handleMessage);\n    } // Attach private network protector\n\n\n    if (_this._modules.connProtector) {\n      _this.upgrader.protector = _this._modules.connProtector;\n    } else if (globalThis.process !== undefined && globalThis.process.env && globalThis.process.env.LIBP2P_FORCE_PNET) {\n      throw new Error('Private network is enforced, but no protector was provided');\n    } // dht provided components (peerRouting, contentRouting, dht)\n\n\n    if (_this._modules.dht) {\n      var DHT = _this._modules.dht;\n      _this._dht = new DHT(_objectSpread({\n        dialer: _this.dialer,\n        peerInfo: _this.peerInfo,\n        peerStore: _this.peerStore,\n        registrar: _this.registrar,\n        datastore: _this.datastore\n      }, _this._config.dht));\n    } // start pubsub\n\n\n    if (_this._modules.pubsub) {\n      _this.pubsub = pubsub(_assertThisInitialized(_this), _this._modules.pubsub, _this._config.pubsub);\n    } // Attach remaining APIs\n    // peer and content routing will automatically get modules from _modules and _dht\n\n\n    _this.peerRouting = peerRouting(_assertThisInitialized(_this));\n    _this.contentRouting = contentRouting(_assertThisInitialized(_this)); // Mount default protocols\n\n    _ping.mount(_assertThisInitialized(_this));\n\n    _this._onDiscoveryPeer = _this._onDiscoveryPeer.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n  /**\n   * Overrides EventEmitter.emit to conditionally emit errors\n   * if there is a handler. If not, errors will be logged.\n   * @param {string} eventName\n   * @param  {...any} args\n   * @returns {void}\n   */\n\n\n  _createClass(Libp2p, [{\n    key: \"emit\",\n    value: function emit(eventName) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      if (eventName === 'error' && !this._events.error) {\n        log.error.apply(log, args);\n      } else {\n        var _get2;\n\n        (_get2 = _get(_getPrototypeOf(Libp2p.prototype), \"emit\", this)).call.apply(_get2, [this, eventName].concat(args));\n      }\n    }\n    /**\n     * Starts the libp2p node and all its subsystems\n     *\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"start\",\n    value: function () {\n      var _start = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                log('libp2p is starting');\n                _context.prev = 1;\n                _context.next = 4;\n                return this._onStarting();\n\n              case 4:\n                _context.next = 6;\n                return this._onDidStart();\n\n              case 6:\n                log('libp2p has started');\n                _context.next = 16;\n                break;\n\n              case 9:\n                _context.prev = 9;\n                _context.t0 = _context[\"catch\"](1);\n                this.emit('error', _context.t0);\n                log.error('An error occurred starting libp2p', _context.t0);\n                _context.next = 15;\n                return this.stop();\n\n              case 15:\n                throw _context.t0;\n\n              case 16:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[1, 9]]);\n      }));\n\n      function start() {\n        return _start.apply(this, arguments);\n      }\n\n      return start;\n    }()\n    /**\n     * Stop the libp2p node by closing its listeners and open connections\n     * @async\n     * @returns {void}\n     */\n\n  }, {\n    key: \"stop\",\n    value: function () {\n      var _stop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var _iterator, _step, service;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                log('libp2p is stopping');\n                _context2.prev = 1;\n                _iterator = _createForOfIteratorHelper(this._discovery.values());\n\n                try {\n                  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                    service = _step.value;\n                    service.removeListener('peer', this._onDiscoveryPeer);\n                  }\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n\n                _context2.next = 6;\n                return Promise.all(Array.from(this._discovery.values(), function (s) {\n                  return s.stop();\n                }));\n\n              case 6:\n                this._discovery = new Map();\n                this.connectionManager.stop();\n                _context2.next = 10;\n                return Promise.all([this.pubsub && this.pubsub.stop(), this._dht && this._dht.stop(), this.metrics && this.metrics.stop()]);\n\n              case 10:\n                _context2.next = 12;\n                return this.transportManager.close();\n\n              case 12:\n                _context2.next = 14;\n                return this.registrar.close();\n\n              case 14:\n                _ping.unmount(this);\n\n                this.dialer.destroy();\n                _context2.next = 21;\n                break;\n\n              case 18:\n                _context2.prev = 18;\n                _context2.t0 = _context2[\"catch\"](1);\n\n                if (_context2.t0) {\n                  log.error(_context2.t0);\n                  this.emit('error', _context2.t0);\n                }\n\n              case 21:\n                this._isStarted = false;\n                log('libp2p has stopped');\n\n              case 23:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[1, 18]]);\n      }));\n\n      function stop() {\n        return _stop.apply(this, arguments);\n      }\n\n      return stop;\n    }()\n  }, {\n    key: \"isStarted\",\n    value: function isStarted() {\n      return this._isStarted;\n    }\n    /**\n     * Gets a Map of the current connections. The keys are the stringified\n     * `PeerId` of the peer. The value is an array of Connections to that peer.\n     * @returns {Map<string, Connection[]>}\n     */\n\n  }, {\n    key: \"connections\",\n    get: function get() {\n      return this.registrar.connections;\n    }\n    /**\n     * Dials to the provided peer. If successful, the `PeerInfo` of the\n     * peer will be added to the nodes `peerStore`\n     *\n     * @param {PeerInfo|PeerId|Multiaddr|string} peer The peer to dial\n     * @param {object} options\n     * @param {AbortSignal} [options.signal]\n     * @returns {Promise<Connection>}\n     */\n\n  }, {\n    key: \"dial\",\n    value: function dial(peer, options) {\n      return this.dialProtocol(peer, null, options);\n    }\n    /**\n     * Dials to the provided peer and handshakes with the given protocol.\n     * If successful, the `PeerInfo` of the peer will be added to the nodes `peerStore`,\n     * and the `Connection` will be sent in the callback\n     *\n     * @async\n     * @param {PeerInfo|PeerId|Multiaddr|string} peer The peer to dial\n     * @param {string[]|string} protocols\n     * @param {object} options\n     * @param {AbortSignal} [options.signal]\n     * @returns {Promise<Connection|*>}\n     */\n\n  }, {\n    key: \"dialProtocol\",\n    value: function () {\n      var _dialProtocol = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(peer, protocols, options) {\n        var dialable, connection;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                dialable = Dialer.getDialable(peer);\n\n                if (PeerInfo.isPeerInfo(dialable)) {\n                  this.peerStore.put(dialable, {\n                    silent: true\n                  });\n                  connection = this.registrar.getConnection(dialable);\n                }\n\n                if (connection) {\n                  _context3.next = 6;\n                  break;\n                }\n\n                _context3.next = 5;\n                return this.dialer.connectToPeer(dialable, options);\n\n              case 5:\n                connection = _context3.sent;\n\n              case 6:\n                if (!protocols) {\n                  _context3.next = 8;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", connection.newStream(protocols));\n\n              case 8:\n                return _context3.abrupt(\"return\", connection);\n\n              case 9:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function dialProtocol(_x, _x2, _x3) {\n        return _dialProtocol.apply(this, arguments);\n      }\n\n      return dialProtocol;\n    }()\n    /**\n     * Disconnects all connections to the given `peer`\n     *\n     * @param {PeerInfo|PeerId|multiaddr|string} peer the peer to close connections to\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"hangUp\",\n    value: function () {\n      var _hangUp = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(peer) {\n        var peerInfo, connections;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                peerInfo = getPeerInfo(peer, this.peerStore);\n                connections = this.registrar.connections.get(peerInfo.id.toB58String());\n\n                if (connections) {\n                  _context4.next = 4;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\");\n\n              case 4:\n                _context4.next = 6;\n                return Promise.all(connections.map(function (connection) {\n                  return connection.close();\n                }));\n\n              case 6:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function hangUp(_x4) {\n        return _hangUp.apply(this, arguments);\n      }\n\n      return hangUp;\n    }()\n    /**\n     * Pings the given peer\n     * @param {PeerInfo|PeerId|Multiaddr|string} peer The peer to ping\n     * @returns {Promise<number>}\n     */\n\n  }, {\n    key: \"ping\",\n    value: function () {\n      var _ping2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(peer) {\n        var peerInfo;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return getPeerInfo(peer, this.peerStore);\n\n              case 2:\n                peerInfo = _context5.sent;\n                return _context5.abrupt(\"return\", _ping(this, peerInfo));\n\n              case 4:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function ping(_x5) {\n        return _ping2.apply(this, arguments);\n      }\n\n      return ping;\n    }()\n    /**\n     * Registers the `handler` for each protocol\n     * @param {string[]|string} protocols\n     * @param {function({ connection:*, stream:*, protocol:string })} handler\n     */\n\n  }, {\n    key: \"handle\",\n    value: function handle(protocols, handler) {\n      var _this2 = this;\n\n      protocols = Array.isArray(protocols) ? protocols : [protocols];\n      protocols.forEach(function (protocol) {\n        _this2.upgrader.protocols.set(protocol, handler);\n      }); // Only push if libp2p is running\n\n      if (this.isStarted() && this.identifyService) {\n        this.identifyService.pushToPeerStore(this.peerStore);\n      }\n    }\n    /**\n     * Removes the handler for each protocol. The protocol\n     * will no longer be supported on streams.\n     * @param {string[]|string} protocols\n     */\n\n  }, {\n    key: \"unhandle\",\n    value: function unhandle(protocols) {\n      var _this3 = this;\n\n      protocols = Array.isArray(protocols) ? protocols : [protocols];\n      protocols.forEach(function (protocol) {\n        _this3.upgrader.protocols.delete(protocol);\n      }); // Only push if libp2p is running\n\n      if (this.isStarted() && this.identifyService) {\n        this.identifyService.pushToPeerStore(this.peerStore);\n      }\n    }\n  }, {\n    key: \"_onStarting\",\n    value: function () {\n      var _onStarting2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        var multiaddrs, _iterator2, _step2, ma;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                // Listen on the addresses supplied in the peerInfo\n                multiaddrs = this.peerInfo.multiaddrs.toArray();\n                _context6.next = 3;\n                return this.transportManager.listen(multiaddrs);\n\n              case 3:\n                // The addresses may change once the listener starts\n                // eg /ip4/0.0.0.0/tcp/0 => /ip4/192.168.1.0/tcp/58751\n                this.peerInfo.multiaddrs.clear();\n                _iterator2 = _createForOfIteratorHelper(this.transportManager.getAddrs());\n\n                try {\n                  for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                    ma = _step2.value;\n                    this.peerInfo.multiaddrs.add(ma);\n                  }\n                } catch (err) {\n                  _iterator2.e(err);\n                } finally {\n                  _iterator2.f();\n                }\n\n                if (this._config.pubsub.enabled) {\n                  this.pubsub && this.pubsub.start();\n                } // DHT subsystem\n\n\n                if (this._config.dht.enabled) {\n                  this._dht && this._dht.start(); // TODO: this should be modified once random-walk is used as\n                  // the other discovery modules\n\n                  this._dht.on('peer', this._onDiscoveryPeer);\n                } // Start metrics if present\n\n\n                this.metrics && this.metrics.start();\n\n              case 9:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function _onStarting() {\n        return _onStarting2.apply(this, arguments);\n      }\n\n      return _onStarting;\n    }()\n    /**\n     * Called when libp2p has started and before it returns\n     * @private\n     */\n\n  }, {\n    key: \"_onDidStart\",\n    value: function () {\n      var _onDidStart2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n        var _this4 = this;\n\n        var _iterator3, _step3, peerInfo;\n\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                this._isStarted = true;\n                this.connectionManager.start();\n                this.peerStore.on('peer', function (peerInfo) {\n                  _this4.emit('peer:discovery', peerInfo);\n\n                  _this4._maybeConnect(peerInfo);\n                }); // Peer discovery\n\n                _context7.next = 5;\n                return this._setupPeerDiscovery();\n\n              case 5:\n                // Once we start, emit and dial any peers we may have already discovered\n                _iterator3 = _createForOfIteratorHelper(this.peerStore.peers.values());\n\n                try {\n                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n                    peerInfo = _step3.value;\n                    this.emit('peer:discovery', peerInfo);\n\n                    this._maybeConnect(peerInfo);\n                  }\n                } catch (err) {\n                  _iterator3.e(err);\n                } finally {\n                  _iterator3.f();\n                }\n\n              case 7:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function _onDidStart() {\n        return _onDidStart2.apply(this, arguments);\n      }\n\n      return _onDidStart;\n    }()\n    /**\n     * Called whenever peer discovery services emit `peer` events.\n     * Known peers may be emitted.\n     * @private\n     * @param {PeerInfo} peerInfo\n     */\n\n  }, {\n    key: \"_onDiscoveryPeer\",\n    value: function _onDiscoveryPeer(peerInfo) {\n      if (peerInfo.id.toB58String() === this.peerInfo.id.toB58String()) {\n        log.error(new Error(codes.ERR_DISCOVERED_SELF));\n        return;\n      }\n\n      this.peerStore.put(peerInfo);\n    }\n    /**\n     * Will dial to the given `peerInfo` if the current number of\n     * connected peers is less than the configured `ConnectionManager`\n     * minPeers.\n     * @private\n     * @param {PeerInfo} peerInfo\n     */\n\n  }, {\n    key: \"_maybeConnect\",\n    value: function () {\n      var _maybeConnect2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(peerInfo) {\n        var minPeers;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                if (!(this._config.peerDiscovery.autoDial === true && !this.registrar.getConnection(peerInfo))) {\n                  _context8.next = 12;\n                  break;\n                }\n\n                minPeers = this._options.connectionManager.minPeers || 0;\n\n                if (!(minPeers > this.connectionManager._connections.size)) {\n                  _context8.next = 12;\n                  break;\n                }\n\n                log('connecting to discovered peer %s', peerInfo.id.toB58String());\n                _context8.prev = 4;\n                _context8.next = 7;\n                return this.dialer.connectToPeer(peerInfo);\n\n              case 7:\n                _context8.next = 12;\n                break;\n\n              case 9:\n                _context8.prev = 9;\n                _context8.t0 = _context8[\"catch\"](4);\n                log.error('could not connect to discovered peer', _context8.t0);\n\n              case 12:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this, [[4, 9]]);\n      }));\n\n      function _maybeConnect(_x6) {\n        return _maybeConnect2.apply(this, arguments);\n      }\n\n      return _maybeConnect;\n    }()\n    /**\n     * Initializes and starts peer discovery services\n     *\n     * @async\n     * @private\n     */\n\n  }, {\n    key: \"_setupPeerDiscovery\",\n    value: function () {\n      var _setupPeerDiscovery2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n        var _this5 = this;\n\n        var setupService, _iterator4, _step4, DiscoveryService, _iterator5, _step5, Transport;\n\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                setupService = function setupService(DiscoveryService) {\n                  var config = {\n                    enabled: true // on by default\n\n                  };\n\n                  if (DiscoveryService.tag && _this5._config.peerDiscovery && _this5._config.peerDiscovery[DiscoveryService.tag]) {\n                    config = _objectSpread(_objectSpread({}, config), _this5._config.peerDiscovery[DiscoveryService.tag]);\n                  }\n\n                  if (config.enabled && !_this5._discovery.has(DiscoveryService.tag)) {\n                    // not already added\n                    var discoveryService;\n\n                    if (typeof DiscoveryService === 'function') {\n                      discoveryService = new DiscoveryService(Object.assign({}, config, {\n                        peerInfo: _this5.peerInfo,\n                        libp2p: _this5\n                      }));\n                    } else {\n                      discoveryService = DiscoveryService;\n                    }\n\n                    discoveryService.on('peer', _this5._onDiscoveryPeer);\n\n                    _this5._discovery.set(DiscoveryService.tag, discoveryService);\n                  }\n                }; // Discovery modules\n\n\n                _iterator4 = _createForOfIteratorHelper(this._modules.peerDiscovery || []);\n\n                try {\n                  for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                    DiscoveryService = _step4.value;\n                    setupService(DiscoveryService);\n                  } // Transport modules with discovery\n\n                } catch (err) {\n                  _iterator4.e(err);\n                } finally {\n                  _iterator4.f();\n                }\n\n                _iterator5 = _createForOfIteratorHelper(this.transportManager.getTransports());\n\n                try {\n                  for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                    Transport = _step5.value;\n\n                    if (Transport.discovery) {\n                      setupService(Transport.discovery);\n                    }\n                  }\n                } catch (err) {\n                  _iterator5.e(err);\n                } finally {\n                  _iterator5.f();\n                }\n\n                _context9.next = 7;\n                return Promise.all(Array.from(this._discovery.values(), function (d) {\n                  return d.start();\n                }));\n\n              case 7:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function _setupPeerDiscovery() {\n        return _setupPeerDiscovery2.apply(this, arguments);\n      }\n\n      return _setupPeerDiscovery;\n    }()\n  }]);\n\n  return Libp2p;\n}(EventEmitter);\n/**\n * Like `new Libp2p(options)` except it will create a `PeerInfo`\n * instance if one is not provided in options.\n * @param {object} options Libp2p configuration options\n * @returns {Libp2p}\n */\n\n\nLibp2p.create = /*#__PURE__*/function () {\n  var _create = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {\n    var options,\n        peerInfo,\n        _args10 = arguments;\n    return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n      while (1) {\n        switch (_context10.prev = _context10.next) {\n          case 0:\n            options = _args10.length > 0 && _args10[0] !== undefined ? _args10[0] : {};\n\n            if (!options.peerInfo) {\n              _context10.next = 3;\n              break;\n            }\n\n            return _context10.abrupt(\"return\", new Libp2p(options));\n\n          case 3:\n            _context10.next = 5;\n            return PeerInfo.create();\n\n          case 5:\n            peerInfo = _context10.sent;\n            options.peerInfo = peerInfo;\n            return _context10.abrupt(\"return\", new Libp2p(options));\n\n          case 8:\n          case \"end\":\n            return _context10.stop();\n        }\n      }\n    }, _callee10);\n  }));\n\n  function create() {\n    return _create.apply(this, arguments);\n  }\n\n  return create;\n}();\n\nmodule.exports = Libp2p;","map":null,"metadata":{},"sourceType":"script"}