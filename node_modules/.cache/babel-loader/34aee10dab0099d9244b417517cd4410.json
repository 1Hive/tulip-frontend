{"ast":null,"code":"'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst PeerId = require('peer-id');\n\nconst crypto = require('libp2p-crypto');\n\nconst debug = require('debug');\n\nconst log = debug('libp2p:secio');\nlog.error = debug('libp2p:secio:error');\n\nconst pbm = require('./secio.proto');\n\nconst support = require('../support');\n\nconst {\n  UnexpectedPeerError\n} = require('libp2p-interfaces/src/crypto/errors'); // nonceSize is the size of our nonces (in bytes)\n\n\nconst nonceSize = 16;\n\nexports.createProposal = state => {\n  state.proposal.out = {\n    rand: crypto.randomBytes(nonceSize),\n    pubkey: state.key.local.public.bytes,\n    exchanges: support.exchanges.join(','),\n    ciphers: support.ciphers.join(','),\n    hashes: support.hashes.join(',')\n  };\n  state.proposalEncoded.out = pbm.Propose.encode(state.proposal.out);\n  return state.proposalEncoded.out;\n};\n\nexports.createExchange = async state => {\n  const res = await crypto.keys.generateEphemeralKeyPair(state.protocols.local.curveT);\n  state.ephemeralKey.local = res.key;\n  state.shared.generate = res.genSharedKey; // Gather corpus to sign.\n\n  const selectionOut = Buffer.concat([state.proposalEncoded.out, state.proposalEncoded.in, state.ephemeralKey.local]);\n  const sig = await state.key.local.sign(selectionOut);\n  state.exchange.out = {\n    epubkey: state.ephemeralKey.local,\n    signature: sig\n  };\n  return pbm.Exchange.encode(state.exchange.out);\n};\n\nexports.identify = async (state, msg) => {\n  log('1.1 identify');\n  state.proposalEncoded.in = msg;\n  state.proposal.in = pbm.Propose.decode(msg);\n  const pubkey = state.proposal.in.pubkey;\n  state.key.remote = crypto.keys.unmarshalPublicKey(pubkey);\n  const remoteId = await PeerId.createFromPubKey(pubkey.toString('base64')); // If we know who we are dialing to, double check\n\n  if (state.id.remote) {\n    if (state.id.remote.toString() !== remoteId.toString()) {\n      throw new UnexpectedPeerError('Dialed to the wrong peer: IDs do not match!');\n    }\n\n    state.id.remote.pubKey = state.key.remote;\n  } else {\n    state.id.remote = remoteId;\n  }\n\n  log('1.1 identify - %s - identified remote peer as %s', state.id.local.toB58String(), state.id.remote.toB58String());\n};\n\nexports.selectProtocols = async state => {\n  log('1.2 selection');\n  const local = {\n    pubKeyBytes: state.key.local.public.bytes,\n    exchanges: support.exchanges,\n    hashes: support.hashes,\n    ciphers: support.ciphers,\n    nonce: state.proposal.out.rand\n  };\n  const remote = {\n    pubKeyBytes: state.proposal.in.pubkey,\n    exchanges: state.proposal.in.exchanges.split(','),\n    hashes: state.proposal.in.hashes.split(','),\n    ciphers: state.proposal.in.ciphers.split(','),\n    nonce: state.proposal.in.rand\n  };\n  const selected = await support.selectBest(local, remote); // we use the same params for both directions (must choose same curve)\n  // WARNING: if they dont SelectBest the same way, this won't work...\n\n  state.protocols.remote = {\n    order: selected.order,\n    curveT: selected.curveT,\n    cipherT: selected.cipherT,\n    hashT: selected.hashT\n  };\n  state.protocols.local = {\n    order: selected.order,\n    curveT: selected.curveT,\n    cipherT: selected.cipherT,\n    hashT: selected.hashT\n  };\n};\n\nexports.verify = async (state, msg) => {\n  log('2.1. verify');\n  state.exchange.in = pbm.Exchange.decode(msg);\n  state.ephemeralKey.remote = state.exchange.in.epubkey;\n  const selectionIn = Buffer.concat([state.proposalEncoded.in, state.proposalEncoded.out, state.ephemeralKey.remote]);\n  const sigOk = await state.key.remote.verify(selectionIn, state.exchange.in.signature);\n\n  if (!sigOk) {\n    throw new Error('Bad signature');\n  }\n\n  log('2.1. verify - signature verified');\n};\n\nexports.generateKeys = async state => {\n  log('2.2. keys');\n  const secret = await state.shared.generate(state.exchange.in.epubkey);\n  state.shared.secret = secret;\n  const keys = await crypto.keys.keyStretcher(state.protocols.local.cipherT, state.protocols.local.hashT, state.shared.secret); // use random nonces to decide order.\n\n  if (state.protocols.local.order > 0) {\n    state.protocols.local.keys = keys.k1;\n    state.protocols.remote.keys = keys.k2;\n  } else if (state.protocols.local.order < 0) {\n    // swap\n    state.protocols.local.keys = keys.k2;\n    state.protocols.remote.keys = keys.k1;\n  } else {\n    // we should've bailed before state. but if not, bail here.\n    throw new Error('you are trying to talk to yourself');\n  }\n\n  log('2.3. mac + cipher');\n  await Promise.all([state.protocols.local, state.protocols.remote].map(data => support.makeMacAndCipher(data)));\n};\n\nexports.verifyNonce = (state, n2) => {\n  const n1 = state.proposal.out.rand;\n  if (n1.equals(n2)) return;\n  throw new Error(`Failed to read our encrypted nonce: ${n1.toString('hex')} != ${n2.toString('hex')}`);\n};","map":null,"metadata":{},"sourceType":"script"}