{"ast":null,"code":"'use strict';\n\nconst EventEmitter = require('events');\n\nconst pipe = require('it-pipe');\n\nconst PROTOCOL = require('./protocol');\n\nconst encoding = require('./encoding');\n\nmodule.exports = class Connection extends EventEmitter {\n  constructor(remoteId, libp2p, room) {\n    super();\n    this._remoteId = remoteId;\n    this._libp2p = libp2p;\n    this._room = room;\n    this._connection = null;\n    this._connecting = false;\n  }\n\n  push(message) {\n    if (this._connection) {\n      this._connection.push(encoding(message));\n\n      return;\n    }\n\n    this.once('connect', () => {\n      this.push(message);\n    });\n\n    if (!this._connecting) {\n      this._connect();\n    }\n  }\n\n  stop() {\n    if (this._connection) {\n      this._connection.end();\n    }\n  }\n\n  async _connect() {\n    this._connecting = true;\n\n    if (!this._isConnectedToRemote()) {\n      this.emit('disconnect');\n      this._connecting = false;\n      return; // early\n    }\n\n    const peerInfo = this._libp2p.peerStore.get(this._remoteId);\n\n    const {\n      stream\n    } = await this._libp2p.dialProtocol(peerInfo, PROTOCOL);\n    this._connection = new FiFoMessageQueue();\n    pipe(this._connection, stream, async source => {\n      this._connecting = false;\n      this.emit('connect', this._connection);\n\n      for await (const message of source) {\n        this.emit('message', message);\n      }\n    }).then(() => {\n      this.emit('disconnect');\n    }, err => {\n      this.emit('error', err);\n    });\n  }\n\n  _isConnectedToRemote() {\n    for (const peerId of this._libp2p.connections.keys()) {\n      if (peerId === this._remoteId) {\n        return true;\n      }\n    }\n  }\n\n};\n\nclass FiFoMessageQueue {\n  constructor() {\n    this._queue = [];\n  }\n\n  [Symbol.asyncIterator]() {\n    return this;\n  }\n\n  push(message) {\n    if (this._ended) {\n      throw new Error('Message queue ended');\n    }\n\n    if (this._resolve) {\n      return this._resolve({\n        done: false,\n        value: message\n      });\n    }\n\n    this._queue.push(message);\n  }\n\n  end() {\n    this._ended = true;\n\n    if (this._resolve) {\n      this._resolve({\n        done: true\n      });\n    }\n  }\n\n  next() {\n    if (this._ended) {\n      return {\n        done: true\n      };\n    }\n\n    if (this._queue.length) {\n      return {\n        done: false,\n        value: this._queue.shift()\n      };\n    }\n\n    return new Promise(resolve => {\n      this._resolve = resolve;\n    });\n  }\n\n}","map":null,"metadata":{},"sourceType":"script"}