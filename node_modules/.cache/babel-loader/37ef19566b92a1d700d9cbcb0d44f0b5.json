{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst EventEmitter = require(\"eventemitter3\");\n\nconst p_timeout_1 = require(\"p-timeout\");\n\nconst priority_queue_1 = require(\"./priority-queue\"); // eslint-disable-next-line @typescript-eslint/no-empty-function\n\n\nconst empty = () => {};\n\nconst timeoutError = new p_timeout_1.TimeoutError();\n/**\nPromise queue with concurrency control.\n*/\n\nclass PQueue extends EventEmitter {\n  constructor(options) {\n    var _a, _b, _c, _d;\n\n    super();\n    this._intervalCount = 0;\n    this._intervalEnd = 0;\n    this._pendingCount = 0;\n    this._resolveEmpty = empty;\n    this._resolveIdle = empty; // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n\n    options = Object.assign({\n      carryoverConcurrencyCount: false,\n      intervalCap: Infinity,\n      interval: 0,\n      concurrency: Infinity,\n      autoStart: true,\n      queueClass: priority_queue_1.default\n    }, options);\n\n    if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {\n      throw new TypeError(`Expected \\`intervalCap\\` to be a number from 1 and up, got \\`${(_b = (_a = options.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : ''}\\` (${typeof options.intervalCap})`);\n    }\n\n    if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {\n      throw new TypeError(`Expected \\`interval\\` to be a finite number >= 0, got \\`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ''}\\` (${typeof options.interval})`);\n    }\n\n    this._carryoverConcurrencyCount = options.carryoverConcurrencyCount;\n    this._isIntervalIgnored = options.intervalCap === Infinity || options.interval === 0;\n    this._intervalCap = options.intervalCap;\n    this._interval = options.interval;\n    this._queue = new options.queueClass();\n    this._queueClass = options.queueClass;\n    this.concurrency = options.concurrency;\n    this._timeout = options.timeout;\n    this._throwOnTimeout = options.throwOnTimeout === true;\n    this._isPaused = options.autoStart === false;\n  }\n\n  get _doesIntervalAllowAnother() {\n    return this._isIntervalIgnored || this._intervalCount < this._intervalCap;\n  }\n\n  get _doesConcurrentAllowAnother() {\n    return this._pendingCount < this._concurrency;\n  }\n\n  _next() {\n    this._pendingCount--;\n\n    this._tryToStartAnother();\n\n    this.emit('next');\n  }\n\n  _resolvePromises() {\n    this._resolveEmpty();\n\n    this._resolveEmpty = empty;\n\n    if (this._pendingCount === 0) {\n      this._resolveIdle();\n\n      this._resolveIdle = empty;\n      this.emit('idle');\n    }\n  }\n\n  _onResumeInterval() {\n    this._onInterval();\n\n    this._initializeIntervalIfNeeded();\n\n    this._timeoutId = undefined;\n  }\n\n  _isIntervalPaused() {\n    const now = Date.now();\n\n    if (this._intervalId === undefined) {\n      const delay = this._intervalEnd - now;\n\n      if (delay < 0) {\n        // Act as the interval was done\n        // We don't need to resume it here because it will be resumed on line 160\n        this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;\n      } else {\n        // Act as the interval is pending\n        if (this._timeoutId === undefined) {\n          this._timeoutId = setTimeout(() => {\n            this._onResumeInterval();\n          }, delay);\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  _tryToStartAnother() {\n    if (this._queue.size === 0) {\n      // We can clear the interval (\"pause\")\n      // Because we can redo it later (\"resume\")\n      if (this._intervalId) {\n        clearInterval(this._intervalId);\n      }\n\n      this._intervalId = undefined;\n\n      this._resolvePromises();\n\n      return false;\n    }\n\n    if (!this._isPaused) {\n      const canInitializeInterval = !this._isIntervalPaused();\n\n      if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {\n        const job = this._queue.dequeue();\n\n        if (!job) {\n          return false;\n        }\n\n        this.emit('active');\n        job();\n\n        if (canInitializeInterval) {\n          this._initializeIntervalIfNeeded();\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  _initializeIntervalIfNeeded() {\n    if (this._isIntervalIgnored || this._intervalId !== undefined) {\n      return;\n    }\n\n    this._intervalId = setInterval(() => {\n      this._onInterval();\n    }, this._interval);\n    this._intervalEnd = Date.now() + this._interval;\n  }\n\n  _onInterval() {\n    if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) {\n      clearInterval(this._intervalId);\n      this._intervalId = undefined;\n    }\n\n    this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;\n\n    this._processQueue();\n  }\n  /**\n  Executes all queued functions until it reaches the limit.\n  */\n\n\n  _processQueue() {\n    // eslint-disable-next-line no-empty\n    while (this._tryToStartAnother()) {}\n  }\n\n  get concurrency() {\n    return this._concurrency;\n  }\n\n  set concurrency(newConcurrency) {\n    if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {\n      throw new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${newConcurrency}\\` (${typeof newConcurrency})`);\n    }\n\n    this._concurrency = newConcurrency;\n\n    this._processQueue();\n  }\n  /**\n  Adds a sync or async task to the queue. Always returns a promise.\n  */\n\n\n  async add(fn, options = {}) {\n    return new Promise((resolve, reject) => {\n      const run = async () => {\n        this._pendingCount++;\n        this._intervalCount++;\n\n        try {\n          const operation = this._timeout === undefined && options.timeout === undefined ? fn() : p_timeout_1.default(Promise.resolve(fn()), options.timeout === undefined ? this._timeout : options.timeout, () => {\n            if (options.throwOnTimeout === undefined ? this._throwOnTimeout : options.throwOnTimeout) {\n              reject(timeoutError);\n            }\n\n            return undefined;\n          });\n          resolve(await operation);\n        } catch (error) {\n          reject(error);\n        }\n\n        this._next();\n      };\n\n      this._queue.enqueue(run, options);\n\n      this._tryToStartAnother();\n\n      this.emit('add');\n    });\n  }\n  /**\n  Same as `.add()`, but accepts an array of sync or async functions.\n   @returns A promise that resolves when all functions are resolved.\n  */\n\n\n  async addAll(functions, options) {\n    return Promise.all(functions.map(async function_ => this.add(function_, options)));\n  }\n  /**\n  Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)\n  */\n\n\n  start() {\n    if (!this._isPaused) {\n      return this;\n    }\n\n    this._isPaused = false;\n\n    this._processQueue();\n\n    return this;\n  }\n  /**\n  Put queue execution on hold.\n  */\n\n\n  pause() {\n    this._isPaused = true;\n  }\n  /**\n  Clear the queue.\n  */\n\n\n  clear() {\n    this._queue = new this._queueClass();\n  }\n  /**\n  Can be called multiple times. Useful if you for example add additional items at a later time.\n   @returns A promise that settles when the queue becomes empty.\n  */\n\n\n  async onEmpty() {\n    // Instantly resolve if the queue is empty\n    if (this._queue.size === 0) {\n      return;\n    }\n\n    return new Promise(resolve => {\n      const existingResolve = this._resolveEmpty;\n\n      this._resolveEmpty = () => {\n        existingResolve();\n        resolve();\n      };\n    });\n  }\n  /**\n  The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.\n   @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.\n  */\n\n\n  async onIdle() {\n    // Instantly resolve if none pending and if nothing else is queued\n    if (this._pendingCount === 0 && this._queue.size === 0) {\n      return;\n    }\n\n    return new Promise(resolve => {\n      const existingResolve = this._resolveIdle;\n\n      this._resolveIdle = () => {\n        existingResolve();\n        resolve();\n      };\n    });\n  }\n  /**\n  Size of the queue.\n  */\n\n\n  get size() {\n    return this._queue.size;\n  }\n  /**\n  Size of the queue, filtered by the given options.\n   For example, this can be used to find the number of items remaining in the queue with a specific priority level.\n  */\n\n\n  sizeBy(options) {\n    // eslint-disable-next-line unicorn/no-fn-reference-in-iterator\n    return this._queue.filter(options).length;\n  }\n  /**\n  Number of pending promises.\n  */\n\n\n  get pending() {\n    return this._pendingCount;\n  }\n  /**\n  Whether the queue is currently paused.\n  */\n\n\n  get isPaused() {\n    return this._isPaused;\n  }\n\n  get timeout() {\n    return this._timeout;\n  }\n  /**\n  Set the timeout for future operations.\n  */\n\n\n  set timeout(milliseconds) {\n    this._timeout = milliseconds;\n  }\n\n}\n\nexports.default = PQueue;","map":null,"metadata":{},"sourceType":"script"}