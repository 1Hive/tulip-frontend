{"ast":null,"code":"'use strict';\n\nconst mafmt = require('mafmt');\n\nconst multiaddr = require('multiaddr');\n\nconst PeerId = require('peer-id');\n\nconst PeerInfo = require('peer-info');\n\nconst withIs = require('class-is');\n\nconst {\n  CircuitRelay: CircuitPB\n} = require('./protocol');\n\nconst debug = require('debug');\n\nconst log = debug('libp2p:circuit');\nlog.error = debug('libp2p:circuit:error');\n\nconst toConnection = require('libp2p-utils/src/stream-to-ma-conn');\n\nconst {\n  relay: multicodec\n} = require('./multicodec');\n\nconst createListener = require('./listener');\n\nconst {\n  handleCanHop,\n  handleHop,\n  hop\n} = require('./circuit/hop');\n\nconst {\n  handleStop\n} = require('./circuit/stop');\n\nconst StreamHandler = require('./circuit/stream-handler');\n\nclass Circuit {\n  /**\n   * Creates an instance of Circuit.\n   *\n   * @constructor\n   * @param {object} options\n   * @param {Libp2p} options.libp2p\n   * @param {Upgrader} options.upgrader\n   */\n  constructor({\n    libp2p,\n    upgrader\n  }) {\n    this._dialer = libp2p.dialer;\n    this._registrar = libp2p.registrar;\n    this._upgrader = upgrader;\n    this._options = libp2p._config.relay;\n    this.peerInfo = libp2p.peerInfo;\n\n    this._registrar.handle(multicodec, this._onProtocol.bind(this));\n  }\n\n  async _onProtocol({\n    connection,\n    stream,\n    protocol\n  }) {\n    const streamHandler = new StreamHandler({\n      stream\n    });\n    const request = await streamHandler.read();\n    const circuit = this;\n    let virtualConnection;\n\n    switch (request.type) {\n      case CircuitPB.Type.CAN_HOP:\n        {\n          log('received CAN_HOP request from %s', connection.remotePeer.toB58String());\n          await handleCanHop({\n            circuit,\n            connection,\n            streamHandler\n          });\n          break;\n        }\n\n      case CircuitPB.Type.HOP:\n        {\n          log('received HOP request from %s', connection.remotePeer.toB58String());\n          virtualConnection = await handleHop({\n            connection,\n            request,\n            streamHandler,\n            circuit\n          });\n          break;\n        }\n\n      case CircuitPB.Type.STOP:\n        {\n          log('received STOP request from %s', connection.remotePeer.toB58String());\n          virtualConnection = await handleStop({\n            connection,\n            request,\n            streamHandler,\n            circuit\n          });\n          break;\n        }\n\n      default:\n        {\n          log('Request of type %s not supported', request.type);\n        }\n    }\n\n    if (virtualConnection) {\n      const remoteAddr = multiaddr(request.dstPeer.addrs[0]);\n      const localAddr = multiaddr(request.srcPeer.addrs[0]);\n      const maConn = toConnection({\n        stream: virtualConnection,\n        remoteAddr,\n        localAddr\n      });\n      const type = CircuitPB.Type === CircuitPB.Type.HOP ? 'relay' : 'inbound';\n      log('new %s connection %s', type, maConn.remoteAddr);\n      const conn = await this._upgrader.upgradeInbound(maConn);\n      log('%s connection %s upgraded', type, maConn.remoteAddr);\n      this.handler && this.handler(conn);\n    }\n  }\n  /**\n   * Dial a peer over a relay\n   *\n   * @param {multiaddr} ma - the multiaddr of the peer to dial\n   * @param {Object} options - dial options\n   * @param {AbortSignal} [options.signal] - An optional abort signal\n   * @returns {Connection} - the connection\n   */\n\n\n  async dial(ma, options) {\n    // Check the multiaddr to see if it contains a relay and a destination peer\n    const addrs = ma.toString().split('/p2p-circuit');\n    const relayAddr = multiaddr(addrs[0]);\n    const destinationAddr = multiaddr(addrs[addrs.length - 1]);\n    const relayPeer = PeerId.createFromCID(relayAddr.getPeerId());\n    const destinationPeer = PeerId.createFromCID(destinationAddr.getPeerId());\n    let disconnectOnFailure = false;\n\n    let relayConnection = this._registrar.getConnection(new PeerInfo(relayPeer));\n\n    if (!relayConnection) {\n      relayConnection = await this._dialer.connectToPeer(relayAddr, options);\n      disconnectOnFailure = true;\n    }\n\n    try {\n      const virtualConnection = await hop({\n        connection: relayConnection,\n        circuit: this,\n        request: {\n          type: CircuitPB.Type.HOP,\n          srcPeer: {\n            id: this.peerInfo.id.toBytes(),\n            addrs: this.peerInfo.multiaddrs.toArray().map(addr => addr.buffer)\n          },\n          dstPeer: {\n            id: destinationPeer.toBytes(),\n            addrs: [multiaddr(destinationAddr).buffer]\n          }\n        }\n      });\n      const localAddr = relayAddr.encapsulate(`/p2p-circuit/p2p/${this.peerInfo.id.toB58String()}`);\n      const maConn = toConnection({\n        stream: virtualConnection,\n        remoteAddr: ma,\n        localAddr\n      });\n      log('new outbound connection %s', maConn.remoteAddr);\n      return this._upgrader.upgradeOutbound(maConn);\n    } catch (err) {\n      log.error('Circuit relay dial failed', err);\n      disconnectOnFailure && (await relayConnection.close());\n      throw err;\n    }\n  }\n  /**\n   * Create a listener\n   *\n   * @param {any} options\n   * @param {Function} handler\n   * @return {listener}\n   */\n\n\n  createListener(options, handler) {\n    if (typeof options === 'function') {\n      handler = options;\n      options = {};\n    } // Called on successful HOP and STOP requests\n\n\n    this.handler = handler;\n    return createListener(this, options);\n  }\n  /**\n   * Filter check for all Multiaddrs that this transport can dial on\n   *\n   * @param {Array<Multiaddr>} multiaddrs\n   * @returns {Array<Multiaddr>}\n   */\n\n\n  filter(multiaddrs) {\n    multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];\n    return multiaddrs.filter(ma => {\n      return mafmt.Circuit.matches(ma);\n    });\n  }\n\n}\n/**\n * @type {Circuit}\n */\n\n\nmodule.exports = withIs(Circuit, {\n  className: 'Circuit',\n  symbolName: '@libp2p/js-libp2p-circuit/circuit'\n});","map":null,"metadata":{},"sourceType":"script"}