{"ast":null,"code":"/*!\n * hkdf.js - hkdf for bcrypto\n * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Resources:\n *   https://en.wikipedia.org/wiki/HKDF\n *   https://tools.ietf.org/html/rfc5869\n */\n'use strict';\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar assert = require('./internal/assert');\n/**\n * HKDF\n */\n\n\nvar HKDF = /*#__PURE__*/function () {\n  function HKDF(hash, ikm, salt, info) {\n    _classCallCheck(this, HKDF);\n\n    assert(hash && typeof hash.id === 'string');\n    this.hash = hash;\n    this.size = hash.size;\n    this.prk = null;\n    this.state = null;\n    this.slab = null;\n    this.save = 0;\n    if (ikm || salt || info) this.init(ikm, salt, info);\n  }\n\n  _createClass(HKDF, [{\n    key: \"init\",\n    value: function init(ikm, salt, info) {\n      if (ikm == null) ikm = Buffer.alloc(0);\n      if (salt == null) salt = Buffer.alloc(this.size, 0x00);\n      this.prk = this.hash.mac(ikm, salt);\n      this.reset(info);\n      return this;\n    }\n  }, {\n    key: \"set\",\n    value: function set(prk, info) {\n      assert(Buffer.isBuffer(prk));\n      assert(prk.length === this.size);\n      this.prk = prk;\n      this.reset(info);\n      return this;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset(info) {\n      if (info == null) info = Buffer.alloc(0);\n      assert(Buffer.isBuffer(info)); // state = prev || info || counter\n\n      var state = Buffer.alloc(this.size + info.length + 1);\n      state.fill(0x00, 0, this.size);\n      info.copy(state, this.size);\n      state[state.length - 1] = 0;\n      this.state = state;\n      this.slab = Buffer.alloc(this.size);\n      this.save = 0;\n      return this;\n    }\n  }, {\n    key: \"generate\",\n    value: function generate(len) {\n      assert(len >>> 0 === len);\n      if (!this.prk || !this.state || !this.slab) throw new Error('HKDF is not initialized.');\n      var left = (255 - this.state[this.state.length - 1]) * this.size;\n      if (len > this.save + left) throw new Error('Too many bytes requested.');\n      var blocks = Math.ceil(Math.max(0, len - this.save) / this.size);\n      var okm = Buffer.alloc(this.save + blocks * this.size);\n      this.slab.copy(okm, 0, 0, this.save);\n\n      for (var i = 0; i < blocks; i++) {\n        var state = this.state;\n        if (state[state.length - 1] === 0) state = state.slice(this.size);\n        assert(state[state.length - 1] !== 255);\n        state[state.length - 1] += 1;\n        var mac = this.hash.mac(state, this.prk);\n        mac.copy(this.state, 0);\n        mac.copy(okm, this.save + i * this.size);\n      }\n\n      this.save = okm.copy(this.slab, 0, len);\n      return okm.slice(0, len);\n    }\n  }, {\n    key: \"randomBytes\",\n    value: function randomBytes(size) {\n      return this.generate(size);\n    }\n  }], [{\n    key: \"extract\",\n    value: function extract(hash, ikm, salt) {\n      assert(hash && typeof hash.id === 'string');\n      if (ikm == null) ikm = Buffer.alloc(0);\n      if (salt == null) salt = Buffer.alloc(hash.size, 0x00);\n      return hash.mac(ikm, salt);\n    }\n  }, {\n    key: \"expand\",\n    value: function expand(hash, prk, info, len) {\n      var hkdf = new HKDF(hash);\n      return hkdf.set(prk, info).generate(len);\n    }\n  }, {\n    key: \"derive\",\n    value: function derive(hash, ikm, salt, info, len) {\n      var hkdf = new HKDF(hash);\n      return hkdf.init(ikm, salt, info).generate(len);\n    }\n  }]);\n\n  return HKDF;\n}();\n/*\n * Static\n */\n\n\nHKDF.native = 0;\n/*\n * Expose\n */\n\nmodule.exports = HKDF;","map":null,"metadata":{},"sourceType":"script"}