{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = (0, _getPrototypeOf2[\"default\"])(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = (0, _getPrototypeOf2[\"default\"])(this).constructor;\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return (0, _possibleConstructorReturn2[\"default\"])(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nvar IPFS = require('ipfs');\n\nvar multiaddr = require('multiaddr');\n\nvar _require = require('3id-blockchain-utils'),\n    createLink = _require.createLink,\n    validateLink = _require.validateLink;\n\nvar ThreeId = require('./3id');\n\nvar Replicator = require('./replicator');\n\nvar PublicStore = require('./publicStore');\n\nvar PrivateStore = require('./privateStore');\n\nvar Verified = require('./verified');\n\nvar Space = require('./space');\n\nvar utils = require('./utils/index');\n\nvar idUtils = require('./utils/id');\n\nvar config = require('./config');\n\nvar BoxApi = require('./api');\n\nvar IPFSRepo = require('ipfs-repo');\n\nvar LevelStore = require('datastore-level');\n\nvar didJWT = require('did-jwt');\n\nvar _require2 = require('3id-connect'),\n    ThreeIdConnect = _require2.ThreeIdConnect;\n\nvar _require3 = require('3box-shared-cache'),\n    IframeCache = _require3.IframeCache;\n\nvar PINNING_NODE = config.pinning_node;\nvar ADDRESS_SERVER_URL = config.address_server_url;\nvar IPFS_OPTIONS = config.ipfs_options;\nvar RENDEZVOUS_ADDRESS = config.rendezvous_address;\nvar THREEID_CONNECT_URL = config.threeid_connect_url;\nvar IFRAME_CACHE_URL = config.iframe_cache_url;\nvar supportAlert = 'This site uses local data storage to give you control of your data. Please enable web APIs like localstorage, indexxeddb, etc in your browser settings.';\nvar globalIPFS, globalIPFSPromise, threeIdConnect, iframeCacheService, cacheSupportedPromise;\nvar browserHuh = typeof window !== 'undefined' && typeof document !== 'undefined';\n\nif (browserHuh) {\n  require('./modernizr.js');\n\n  threeIdConnect = new ThreeIdConnect(THREEID_CONNECT_URL);\n  iframeCacheService = new IframeCache(IFRAME_CACHE_URL);\n  cacheSupportedPromise = iframeCacheService.connect();\n}\n/**\n * @extends BoxApi\n */\n\n\nvar Box = /*#__PURE__*/function (_BoxApi) {\n  (0, _inherits2[\"default\"])(Box, _BoxApi);\n\n  var _super = _createSuper(Box);\n  /**\n   * Please use the **openBox** method to instantiate a 3Box\n   * @constructor\n   */\n\n\n  function Box(provider, ipfs) {\n    var _this;\n\n    var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    (0, _classCallCheck2[\"default\"])(this, Box);\n    _this = _super.call(this);\n    _this._provider = provider;\n    _this._ipfs = ipfs;\n    _this._opts = opts;\n    _this._serverUrl = opts.addressServer || ADDRESS_SERVER_URL;\n    /**\n     * @property {KeyValueStore} public         access the profile store of the users 3Box\n     */\n\n    _this[\"public\"] = null;\n    /**\n     * @property {KeyValueStore} private        access the private store of the users 3Box\n     */\n\n    _this[\"private\"] = null;\n    /**\n     * @property {Verified} verified        check and create verifications\n     */\n\n    _this.verified = new Verified((0, _assertThisInitialized2[\"default\"])(_this));\n    /**\n     * @property {Object} spaces            an object containing all open spaces indexed by their name.\n     */\n\n    _this.spaces = {};\n    /**\n     * @property {Promise} syncDone         A promise that is resolved when the box is synced\n     */\n\n    _this.syncDone = null;\n    _this.hasPublishedLink = {};\n    return _this;\n  }\n\n  (0, _createClass2[\"default\"])(Box, [{\n    key: \"_init\",\n    value: function () {\n      var _init2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee2(opts) {\n        var replicatorOpts, cacheSupported, self, peerId;\n        return _regenerator[\"default\"].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                replicatorOpts = _objectSpread({}, opts);\n\n                if (!(opts.iframeCache && iframeCacheService)) {\n                  _context2.next = 6;\n                  break;\n                }\n\n                _context2.next = 4;\n                return cacheSupportedPromise;\n\n              case 4:\n                cacheSupported = _context2.sent;\n\n                if (cacheSupported) {\n                  replicatorOpts.cacheProxy = iframeCacheService.getOrbitStorageProxyFactory();\n                }\n\n              case 6:\n                _context2.next = 8;\n                return Replicator.create(this._ipfs, replicatorOpts);\n\n              case 8:\n                this.replicator = _context2.sent;\n\n                if (opts.ghostPinbot) {\n                  this._ghostPinbot = opts.ghostPinbot;\n                  self = this;\n                  peerId = utils.getPeerIdFromMultiaddr(opts.ghostPinbot); // ping Ghost Pinbot to keep connection alive\n\n                  this.ghostPinbotKeepAliveHandle = setInterval( /*#__PURE__*/(0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee() {\n                    return _regenerator[\"default\"].wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            _context.next = 2;\n                            return self._ipfs.ping(peerId);\n\n                          case 2:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee);\n                  })), 10000);\n                }\n\n              case 10:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _init(_x) {\n        return _init2.apply(this, arguments);\n      }\n\n      return _init;\n    }()\n  }, {\n    key: \"_load\",\n    value: function () {\n      var _load2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee3() {\n        var _this2 = this;\n\n        var opts,\n            address,\n            _ref2,\n            rootStoreAddress,\n            did,\n            authData,\n            rootstoreName,\n            key,\n            _args3 = arguments;\n\n        return _regenerator[\"default\"].wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                opts = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : {};\n                _context3.t0 = opts.address;\n\n                if (_context3.t0) {\n                  _context3.next = 6;\n                  break;\n                }\n\n                _context3.next = 5;\n                return this._3id.getAddress();\n\n              case 5:\n                _context3.t0 = _context3.sent;\n\n              case 6:\n                address = _context3.t0;\n\n                if (!address) {\n                  _context3.next = 13;\n                  break;\n                }\n\n                _context3.next = 10;\n                return this._getLinkedData(address);\n\n              case 10:\n                _context3.t1 = _context3.sent;\n                _context3.next = 14;\n                break;\n\n              case 13:\n                _context3.t1 = {};\n\n              case 14:\n                _ref2 = _context3.t1;\n                rootStoreAddress = _ref2.rootStoreAddress;\n                did = _ref2.did;\n\n                if (!rootStoreAddress) {\n                  _context3.next = 29;\n                  break;\n                }\n\n                _context3.next = 20;\n                return this.replicator.start(rootStoreAddress, did, {\n                  profile: true\n                });\n\n              case 20:\n                _context3.next = 22;\n                return this.replicator.rootstoreSyncDone;\n\n              case 22:\n                _context3.next = 24;\n                return this.replicator.getAuthData();\n\n              case 24:\n                authData = _context3.sent;\n                _context3.next = 27;\n                return this._3id.authenticate(opts.spaces, {\n                  authData: authData,\n                  address: address\n                });\n\n              case 27:\n                _context3.next = 38;\n                break;\n\n              case 29:\n                _context3.next = 31;\n                return this._3id.authenticate(opts.spaces, {\n                  address: address\n                });\n\n              case 31:\n                rootstoreName = this._3id.muportFingerprint + '.root';\n                _context3.next = 34;\n                return this._3id.getPublicKeys(null, true);\n\n              case 34:\n                key = _context3.sent.signingKey;\n                _context3.next = 37;\n                return this.replicator[\"new\"](rootstoreName, key, this._3id.DID);\n\n              case 37:\n                this._publishRootStore(this.replicator.rootstore.address.toString());\n\n              case 38:\n                _context3.t2 = this.replicator.rootstore;\n                _context3.next = 41;\n                return this._3id.getOdbId();\n\n              case 41:\n                _context3.t3 = _context3.sent;\n\n                _context3.t2.setIdentity.call(_context3.t2, _context3.t3);\n\n                this.syncDone = this.replicator.syncDone;\n\n                this._3id.events.on('new-auth-method', function (authData) {\n                  _this2._writeRootstoreEntry(Replicator.entryTypes.AUTH_DATA, authData);\n                });\n\n                this._3id.events.on('new-link-proof', function (proof) {\n                  _this2._writeAddressLink(proof);\n                });\n\n                this._3id.startUpdatePolling();\n\n                this[\"public\"] = new PublicStore(this._3id.muportFingerprint + '.public', this.replicator, this._3id);\n                this[\"private\"] = new PrivateStore(this._3id.muportFingerprint + '.private', this.replicator, this._3id);\n                _context3.next = 51;\n                return this[\"public\"]._load();\n\n              case 51:\n                _context3.next = 53;\n                return this[\"private\"]._load();\n\n              case 53:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function _load() {\n        return _load2.apply(this, arguments);\n      }\n\n      return _load;\n    }()\n    /**\n     * Creates an instance of 3Box\n     *\n     * @param     {provider}          provider                A 3ID provider, or ethereum provider\n     * @param     {Object}            opts                    Optional parameters\n     * @param     {String}            opts.pinningNode        A string with an ipfs multi-address to a 3box pinning node\n     * @param     {Object}            opts.ipfs               A js-ipfs ipfs object\n     * @param     {String}            opts.addressServer      URL of the Address Server\n     * @param     {String}            opts.ghostPinbot        MultiAddress of a Ghost Pinbot node\n     * @param     {String}            opts.supportCheck       Gives browser alert if 3boxjs/ipfs not supported in browser env, defaults to true. You can also set to false to implement your own alert and call Box.support to check if supported.\n     * @param     {Boolean}           opts.iframeCache        Enable iframe cache for ipfs/orbit, defaults to true\n     * @return    {Box}                                       the 3Box session instance\n     */\n\n  }, {\n    key: \"_setProvider\",\n    value: function () {\n      var _setProvider2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee4(provider) {\n        return _regenerator[\"default\"].wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (provider) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\");\n\n              case 2:\n                if (!(!provider.is3idProvider && threeIdConnect)) {\n                  _context4.next = 10;\n                  break;\n                }\n\n                _context4.next = 5;\n                return threeIdConnect.connect(provider, ThreeId, this._ipfs);\n\n              case 5:\n                _context4.next = 7;\n                return threeIdConnect.get3idProvider();\n\n              case 7:\n                this._provider = _context4.sent;\n                _context4.next = 11;\n                break;\n\n              case 10:\n                this._provider = provider;\n\n              case 11:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function _setProvider(_x2) {\n        return _setProvider2.apply(this, arguments);\n      }\n\n      return _setProvider;\n    }()\n    /**\n     * Authenticate the user\n     *\n     * @param     {Array<String>}     spaces                  A list of spaces to authenticate (optional)\n     * @param     {Object}            opts                    Optional parameters\n     * @param     {String}            opts.address            An ethereum address\n     * @param     {String}            opts.provider           A 3ID provider, or ethereum provider\n     * @param     {Function}          opts.consentCallback    A function that will be called when the user has consented to opening the box\n     */\n\n  }, {\n    key: \"auth\",\n    value: function () {\n      var _auth = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee6() {\n        var _this3 = this;\n\n        var spaces,\n            opts,\n            _args6 = arguments;\n        return _regenerator[\"default\"].wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                spaces = _args6.length > 0 && _args6[0] !== undefined ? _args6[0] : [];\n                opts = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : {};\n\n                if (!opts.provider) {\n                  _context6.next = 5;\n                  break;\n                }\n\n                _context6.next = 5;\n                return this._setProvider(opts.provider);\n\n              case 5:\n                if (this._provider) {\n                  _context6.next = 7;\n                  break;\n                }\n\n                throw new Error('auth: provider was not passed to auth or create, provider required');\n\n              case 7:\n                opts.address = opts.address ? opts.address.toLowerCase() : opts.address;\n                this._3idEthAddress = opts.address;\n\n                if (this._3id) {\n                  _context6.next = 19;\n                  break;\n                }\n\n                if (!(!this._provider.is3idProvider && !opts.address)) {\n                  _context6.next = 12;\n                  break;\n                }\n\n                throw new Error('auth: address needed when 3ID provider is not used');\n\n              case 12:\n                _context6.next = 14;\n                return ThreeId.getIdFromEthAddress(opts.address, this._provider, this._ipfs, this.replicator._orbitdb.keystore, opts);\n\n              case 14:\n                this._3id = _context6.sent;\n                _context6.next = 17;\n                return this._load(Object.assign(opts, {\n                  spaces: spaces\n                }));\n\n              case 17:\n                _context6.next = 23;\n                break;\n\n              case 19:\n                if (!(this._provider.threeIdConnect && this._provider.migration && !opts.address)) {\n                  _context6.next = 21;\n                  break;\n                }\n\n                throw new Error('auth: address needed when 3ID provider not given');\n\n              case 21:\n                _context6.next = 23;\n                return this._3id.authenticate(spaces, {\n                  address: opts.address\n                });\n\n              case 23:\n                _context6.next = 25;\n                return this.linkAddress();\n\n              case 25:\n                _context6.next = 27;\n                return Promise.all(spaces.map( /*#__PURE__*/function () {\n                  var _ref3 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee5(space) {\n                    return _regenerator[\"default\"].wrap(function _callee5$(_context5) {\n                      while (1) {\n                        switch (_context5.prev = _context5.next) {\n                          case 0:\n                            _context5.next = 2;\n                            return _this3.openSpace(space);\n\n                          case 2:\n                          case \"end\":\n                            return _context5.stop();\n                        }\n                      }\n                    }, _callee5);\n                  }));\n\n                  return function (_x3) {\n                    return _ref3.apply(this, arguments);\n                  };\n                }()));\n\n              case 27:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function auth() {\n        return _auth.apply(this, arguments);\n      }\n\n      return auth;\n    }()\n    /**\n     * Opens the 3Box associated with the given address\n     *\n     * @param     {String}            address                 An ethereum address\n     * @param     {provider}          provider                An ethereum or 3ID provider\n     * @param     {Object}            opts                    Optional parameters\n     * @param     {Function}          opts.consentCallback    A function that will be called when the user has consented to opening the box\n     * @param     {String}            opts.pinningNode        A string with an ipfs multi-address to a 3box pinning node\n     * @param     {Object}            opts.ipfs               A js-ipfs ipfs object\n     * @param     {String}            opts.addressServer      URL of the Address Server\n     * @param     {String}            opts.contentSignature   A signature, provided by a client of 3box using the private keys associated with the given address, of the 3box consent message\n     * @return    {Box}                                       the 3Box instance for the given address\n     */\n\n  }, {\n    key: \"openSpace\",\n\n    /**\n     * Opens the space with the given name in the users 3Box\n     *\n     * @param     {String}            name                    The name of the space\n     * @param     {Object}            opts                    Optional parameters\n     * @param     {Function}          opts.consentCallback    A function that will be called when the user has consented to opening the box\n     * @param     {Function}          opts.onSyncDone         A function that will be called when the space has finished syncing with the pinning node\n     * @return    {Space}                                     the Space instance for the given space name\n     */\n    value: function () {\n      var _openSpace = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee7(name) {\n        var opts,\n            _args7 = arguments;\n        return _regenerator[\"default\"].wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                opts = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : {};\n                opts = Object.assign(opts, {\n                  address: this._3idEthAddress\n                });\n\n                if (!name.includes('.')) {\n                  _context7.next = 4;\n                  break;\n                }\n\n                throw new Error('Invalid name: character \".\" not allowed');\n\n              case 4:\n                if (this._3id) {\n                  _context7.next = 6;\n                  break;\n                }\n\n                throw new Error('openSpace: auth required');\n\n              case 6:\n                if (!this.spaces[name]) {\n                  this.spaces[name] = new Space(name, this.replicator);\n                }\n\n                if (this.spaces[name].isOpen) {\n                  _context7.next = 23;\n                  break;\n                }\n\n                _context7.prev = 8;\n                _context7.next = 11;\n                return this.spaces[name].open(this._3id, opts);\n\n              case 11:\n                _context7.next = 21;\n                break;\n\n              case 13:\n                _context7.prev = 13;\n                _context7.t0 = _context7[\"catch\"](8);\n                delete this.spaces[name];\n\n                if (!_context7.t0.message.includes('User denied message signature.')) {\n                  _context7.next = 20;\n                  break;\n                }\n\n                throw new Error('User denied space consent.');\n\n              case 20:\n                throw new Error('An error occurred while opening space: ', _context7.t0);\n\n              case 21:\n                _context7.next = 24;\n                break;\n\n              case 23:\n                if (opts.onSyncDone) {\n                  // since the space is already open we can call onSyncDone directly\n                  opts.onSyncDone();\n                }\n\n              case 24:\n                return _context7.abrupt(\"return\", this.spaces[name]);\n\n              case 25:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[8, 13]]);\n      }));\n\n      function openSpace(_x4) {\n        return _openSpace.apply(this, arguments);\n      }\n\n      return openSpace;\n    }()\n    /**\n     * Open a thread. Use this to start receiving updates\n     *\n     * @param     {String}    space                   The name of the space for this thread\n     * @param     {String}    name                    The name of the thread\n     * @param     {Object}    opts                    Optional parameters\n     * @param     {String}    opts.firstModerator     DID of first moderator of a thread, by default, user is first moderator\n     * @param     {Boolean}   opts.members            join a members only thread, which only members can post in, defaults to open thread\n     * @param     {Boolean}   opts.noAutoSub          Disable auto subscription to the thread when posting to it (default false)\n     * @param     {Boolean}   opts.ghost              Enable ephemeral messaging via Ghost Thread\n     * @param     {Number}    opts.ghostBacklogLimit  The number of posts to maintain in the ghost backlog\n     * @param     {Array<Function>} opts.ghostFilters Array of functions for filtering messages\n     *\n     * @return    {Thread}                  An instance of the thread class for the joined thread\n     */\n\n  }, {\n    key: \"openThread\",\n    value: function () {\n      var _openThread = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee8(space, name, opts) {\n        var options;\n        return _regenerator[\"default\"].wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                if (!this.spaces[space]) {\n                  this.spaces[space] = new Space(space, this.replicator);\n                }\n\n                if (this._ghostPinbot) {\n                  options = opts || {};\n                  options.ghostPinbot = this._ghostPinbot;\n                }\n\n                return _context8.abrupt(\"return\", this.spaces[space].joinThread(name, opts));\n\n              case 3:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function openThread(_x5, _x6, _x7) {\n        return _openThread.apply(this, arguments);\n      }\n\n      return openThread;\n    }()\n    /**\n     * Sets the callback function that will be called once when the box is fully synced.\n     *\n     * @param     {Function}      syncDone        The function that will be called\n     * @return    {Promise}                       A promise that is fulfilled when the box is syned\n     */\n\n  }, {\n    key: \"onSyncDone\",\n    value: function () {\n      var _onSyncDone = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee9(syncDone) {\n        return _regenerator[\"default\"].wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.next = 2;\n                return this.syncDone;\n\n              case 2:\n                syncDone();\n\n              case 3:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function onSyncDone(_x8) {\n        return _onSyncDone.apply(this, arguments);\n      }\n\n      return onSyncDone;\n    }()\n  }, {\n    key: \"_publishRootStore\",\n    value: function () {\n      var _publishRootStore2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee11(rootStoreAddress) {\n        var _this4 = this;\n\n        var addressToken, publish;\n        return _regenerator[\"default\"].wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                _context11.next = 2;\n                return this._3id.signJWT({\n                  rootStoreAddress: rootStoreAddress\n                });\n\n              case 2:\n                addressToken = _context11.sent; // Store odbAddress on 3box-address-server\n\n                publish = /*#__PURE__*/function () {\n                  var _ref4 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee10(token) {\n                    return _regenerator[\"default\"].wrap(function _callee10$(_context10) {\n                      while (1) {\n                        switch (_context10.prev = _context10.next) {\n                          case 0:\n                            _context10.prev = 0;\n                            _context10.next = 3;\n                            return utils.fetchJson(_this4._serverUrl + '/odbAddress', {\n                              address_token: token\n                            });\n\n                          case 3:\n                            _context10.next = 14;\n                            break;\n\n                          case 5:\n                            _context10.prev = 5;\n                            _context10.t0 = _context10[\"catch\"](0);\n\n                            if (!(_context10.t0.message === 'Invalid JWT')) {\n                              _context10.next = 12;\n                              break;\n                            }\n\n                            _context10.next = 10;\n                            return new Promise(function (resolve) {\n                              return setTimeout(resolve, 300);\n                            });\n\n                          case 10:\n                            _context10.next = 12;\n                            return publish(token);\n\n                          case 12:\n                            if (_context10.t0.statusCode) {\n                              _context10.next = 14;\n                              break;\n                            }\n\n                            throw new Error(_context10.t0);\n\n                          case 14:\n                          case \"end\":\n                            return _context10.stop();\n                        }\n                      }\n                    }, _callee10, null, [[0, 5]]);\n                  }));\n\n                  return function publish(_x10) {\n                    return _ref4.apply(this, arguments);\n                  };\n                }();\n\n                _context11.next = 6;\n                return publish(addressToken);\n\n              case 6:\n                return _context11.abrupt(\"return\", true);\n\n              case 7:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function _publishRootStore(_x9) {\n        return _publishRootStore2.apply(this, arguments);\n      }\n\n      return _publishRootStore;\n    }()\n  }, {\n    key: \"_getLinkedData\",\n    value: function () {\n      var _getLinkedData2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee12(ethereumAddress) {\n        var _yield$utils$fetchJso, rootStoreAddress, did;\n\n        return _regenerator[\"default\"].wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                _context12.prev = 0;\n                _context12.next = 3;\n                return utils.fetchJson(\"\".concat(this._serverUrl, \"/odbAddress/\").concat(ethereumAddress));\n\n              case 3:\n                _yield$utils$fetchJso = _context12.sent.data;\n                rootStoreAddress = _yield$utils$fetchJso.rootStoreAddress;\n                did = _yield$utils$fetchJso.did;\n                return _context12.abrupt(\"return\", {\n                  rootStoreAddress: rootStoreAddress,\n                  did: did\n                });\n\n              case 9:\n                _context12.prev = 9;\n                _context12.t0 = _context12[\"catch\"](0);\n\n                if (!(_context12.t0.statusCode === 404)) {\n                  _context12.next = 13;\n                  break;\n                }\n\n                return _context12.abrupt(\"return\", {});\n\n              case 13:\n                throw new Error('Error while getting rootstore', _context12.t0);\n\n              case 14:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this, [[0, 9]]);\n      }));\n\n      function _getLinkedData(_x11) {\n        return _getLinkedData2.apply(this, arguments);\n      }\n\n      return _getLinkedData;\n    }()\n    /**\n     * @property {String} DID        the DID of the user\n     */\n\n  }, {\n    key: \"linkAddress\",\n\n    /**\n     * Creates a proof that links an ethereum address to the 3Box account of the user. If given proof, it will simply be added to the root store.\n     *\n     * @param     {Object}    [link]                         Optional link object with type or proof\n     * @param     {Object}    [link.proof]                   Proof object, should follow [spec](https://github.com/3box/3box/blob/master/3IPs/3ip-5.md)\n     */\n    value: function () {\n      var _linkAddress = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee13() {\n        var link,\n            _args13 = arguments;\n        return _regenerator[\"default\"].wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                link = _args13.length > 0 && _args13[0] !== undefined ? _args13[0] : {};\n\n                if (this._3id) {\n                  _context13.next = 3;\n                  break;\n                }\n\n                throw new Error('linkAddress: auth required');\n\n              case 3:\n                if (!link.proof) {\n                  _context13.next = 8;\n                  break;\n                }\n\n                _context13.next = 6;\n                return this._writeAddressLink(link.proof);\n\n              case 6:\n                _context13.next = 10;\n                break;\n\n              case 8:\n                _context13.next = 10;\n                return this._linkProfile();\n\n              case 10:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function linkAddress() {\n        return _linkAddress.apply(this, arguments);\n      }\n\n      return linkAddress;\n    }()\n    /**\n     * Remove given address link, returns true if successful\n     *\n     * @param     {String}   address      address that is linked\n     */\n\n  }, {\n    key: \"removeAddressLink\",\n    value: function () {\n      var _removeAddressLink = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee14(address) {\n        var linkExist, payload, oneHour, deleteToken;\n        return _regenerator[\"default\"].wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                if (this._3id) {\n                  _context14.next = 2;\n                  break;\n                }\n\n                throw new Error('removeAddressLink: auth required');\n\n              case 2:\n                address = address.toLowerCase();\n                _context14.next = 5;\n                return this.isAddressLinked({\n                  address: address\n                });\n\n              case 5:\n                linkExist = _context14.sent;\n\n                if (linkExist) {\n                  _context14.next = 8;\n                  break;\n                }\n\n                throw new Error('removeAddressLink: link for given address does not exist');\n\n              case 8:\n                payload = {\n                  address: address,\n                  type: 'delete-address-link'\n                };\n                oneHour = 60 * 60;\n                _context14.next = 12;\n                return this._3id.signJWT(payload, {\n                  expiresIn: oneHour\n                });\n\n              case 12:\n                deleteToken = _context14.sent;\n                _context14.prev = 13;\n                _context14.next = 16;\n                return utils.fetchJson(this._serverUrl + '/linkdelete', {\n                  delete_token: deleteToken\n                });\n\n              case 16:\n                _context14.next = 22;\n                break;\n\n              case 18:\n                _context14.prev = 18;\n                _context14.t0 = _context14[\"catch\"](13);\n\n                if (_context14.t0.statusCode) {\n                  _context14.next = 22;\n                  break;\n                }\n\n                throw new Error(_context14.t0);\n\n              case 22:\n                _context14.next = 24;\n                return this._deleteAddressLink(address);\n\n              case 24:\n                return _context14.abrupt(\"return\", true);\n\n              case 25:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this, [[13, 18]]);\n      }));\n\n      function removeAddressLink(_x12) {\n        return _removeAddressLink.apply(this, arguments);\n      }\n\n      return removeAddressLink;\n    }()\n    /**\n     * Checks if there is a proof that links an external account to the 3Box account of the user. If not params given and any link exists, returns true\n     *\n     * @param     {Object}    [query]            Optional object with address and/or type.\n     * @param     {String}    [query.type]       Does the given type of link exist\n     * @param     {String}    [query.address]    Is the given adressed linked\n     */\n\n  }, {\n    key: \"isAddressLinked\",\n    value: function () {\n      var _isAddressLinked = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee15() {\n        var query,\n            links,\n            linksQuery,\n            _args15 = arguments;\n        return _regenerator[\"default\"].wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                query = _args15.length > 0 && _args15[0] !== undefined ? _args15[0] : {};\n\n                if (this._3id) {\n                  _context15.next = 3;\n                  break;\n                }\n\n                throw new Error('isAddressLinked: auth required');\n\n              case 3:\n                if (query.address) query.address = query.address.toLowerCase();\n                _context15.next = 6;\n                return this._readAddressLinks();\n\n              case 6:\n                links = _context15.sent;\n                linksQuery = links.find(function (link) {\n                  var res = query.address ? link.address.toLowerCase() === query.address : true;\n                  return query.type ? res && link.type === query.type : res;\n                });\n                return _context15.abrupt(\"return\", Boolean(linksQuery));\n\n              case 9:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15, this);\n      }));\n\n      function isAddressLinked() {\n        return _isAddressLinked.apply(this, arguments);\n      }\n\n      return isAddressLinked;\n    }()\n    /**\n     * Lists address links associated with this 3Box\n     *\n     * @return    {Array}                        An array of link objects\n     */\n\n  }, {\n    key: \"listAddressLinks\",\n    value: function () {\n      var _listAddressLinks = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee16() {\n        var entries;\n        return _regenerator[\"default\"].wrap(function _callee16$(_context16) {\n          while (1) {\n            switch (_context16.prev = _context16.next) {\n              case 0:\n                if (this._3id) {\n                  _context16.next = 2;\n                  break;\n                }\n\n                throw new Error('listAddressLinks: auth required');\n\n              case 2:\n                _context16.next = 4;\n                return this._readAddressLinks();\n\n              case 4:\n                entries = _context16.sent;\n                return _context16.abrupt(\"return\", entries.reduce(function (list, entry) {\n                  var item = Object.assign({}, entry);\n                  item.linkId = item.entry.hash;\n                  delete item.entry;\n                  list.push(item);\n                  return list;\n                }, []));\n\n              case 6:\n              case \"end\":\n                return _context16.stop();\n            }\n          }\n        }, _callee16, this);\n      }));\n\n      function listAddressLinks() {\n        return _listAddressLinks.apply(this, arguments);\n      }\n\n      return listAddressLinks;\n    }()\n  }, {\n    key: \"_writeAddressLink\",\n    value: function () {\n      var _writeAddressLink2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee17(proof) {\n        var validProof;\n        return _regenerator[\"default\"].wrap(function _callee17$(_context17) {\n          while (1) {\n            switch (_context17.prev = _context17.next) {\n              case 0:\n                _context17.next = 2;\n                return validateLink(proof);\n\n              case 2:\n                validProof = _context17.sent;\n\n                if (validProof) {\n                  _context17.next = 5;\n                  break;\n                }\n\n                throw new Error('tried to write invalid link proof', proof);\n\n              case 5:\n                _context17.next = 7;\n                return this.isAddressLinked({\n                  address: validProof.address\n                });\n\n              case 7:\n                if (!_context17.sent) {\n                  _context17.next = 9;\n                  break;\n                }\n\n                return _context17.abrupt(\"return\", true);\n\n              case 9:\n                _context17.next = 11;\n                return this._writeRootstoreEntry(Replicator.entryTypes.ADDRESS_LINK, proof);\n\n              case 11:\n                _context17.next = 13;\n                return utils.fetchJson(this._serverUrl + '/link', proof);\n\n              case 13:\n              case \"end\":\n                return _context17.stop();\n            }\n          }\n        }, _callee17, this);\n      }));\n\n      function _writeAddressLink(_x13) {\n        return _writeAddressLink2.apply(this, arguments);\n      }\n\n      return _writeAddressLink;\n    }()\n  }, {\n    key: \"_linkProfile\",\n    value: function () {\n      var _linkProfile2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee18() {\n        var address, proof, proofdid, issuer, jwt;\n        return _regenerator[\"default\"].wrap(function _callee18$(_context18) {\n          while (1) {\n            switch (_context18.prev = _context18.next) {\n              case 0:\n                _context18.next = 2;\n                return this._3id.getAddress();\n\n              case 2:\n                address = _context18.sent;\n                _context18.next = 5;\n                return this._readAddressLink(address);\n\n              case 5:\n                proof = _context18.sent;\n\n                if (proof) {\n                  _context18.next = 27;\n                  break;\n                }\n\n                if (this._provider.is3idProvider) {\n                  _context18.next = 25;\n                  break;\n                }\n\n                _context18.prev = 8;\n                _context18.next = 11;\n                return createLink(this._3id.DID, address, this._provider);\n\n              case 11:\n                proof = _context18.sent;\n                _context18.next = 17;\n                break;\n\n              case 14:\n                _context18.prev = 14;\n                _context18.t0 = _context18[\"catch\"](8);\n                throw new Error('Link consent message must be signed before adding data, to link address to store', _context18.t0);\n\n              case 17:\n                _context18.prev = 17;\n                _context18.next = 20;\n                return this._writeAddressLink(proof);\n\n              case 20:\n                _context18.next = 25;\n                break;\n\n              case 22:\n                _context18.prev = 22;\n                _context18.t1 = _context18[\"catch\"](17);\n                throw new Error('An error occured while publishing link:', _context18.t1);\n\n              case 25:\n                _context18.next = 37;\n                break;\n\n              case 27:\n                if (this.hasPublishedLink[proof.signature]) {\n                  _context18.next = 37;\n                  break;\n                } // Don't want to publish on every call to _linkProfile\n\n\n                this.hasPublishedLink[proof.signature] = true;\n                _context18.prev = 29;\n                _context18.next = 32;\n                return utils.fetchJson(this._serverUrl + '/link', proof);\n\n              case 32:\n                _context18.next = 37;\n                break;\n\n              case 34:\n                _context18.prev = 34;\n                _context18.t2 = _context18[\"catch\"](29);\n                throw new Error('An error occured while publishing link:', _context18.t2);\n\n              case 37:\n                _context18.next = 39;\n                return this[\"public\"].get('proof_did');\n\n              case 39:\n                proofdid = _context18.sent;\n\n                if (!proofdid) {\n                  _context18.next = 52;\n                  break;\n                } // if prior muport, re publish with 3id including muport\n\n\n                issuer = didJWT.decodeJWT(proofdid).payload.iss;\n\n                if (!issuer.includes('muport')) {\n                  _context18.next = 50;\n                  break;\n                }\n\n                jwt = {\n                  muport: proofdid\n                };\n                _context18.t3 = this[\"public\"];\n                _context18.next = 47;\n                return this._3id.signJWT(jwt);\n\n              case 47:\n                _context18.t4 = _context18.sent;\n                _context18.next = 50;\n                return _context18.t3.set.call(_context18.t3, 'proof_did', _context18.t4);\n\n              case 50:\n                _context18.next = 58;\n                break;\n\n              case 52:\n                _context18.t5 = this[\"public\"];\n                _context18.next = 55;\n                return this._3id.signJWT();\n\n              case 55:\n                _context18.t6 = _context18.sent;\n                _context18.next = 58;\n                return _context18.t5.set.call(_context18.t5, 'proof_did', _context18.t6);\n\n              case 58:\n              case \"end\":\n                return _context18.stop();\n            }\n          }\n        }, _callee18, this, [[8, 14], [17, 22], [29, 34]]);\n      }));\n\n      function _linkProfile() {\n        return _linkProfile2.apply(this, arguments);\n      }\n\n      return _linkProfile;\n    }()\n  }, {\n    key: \"_writeRootstoreEntry\",\n    value: function () {\n      var _writeRootstoreEntry2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee20(type, payload) {\n        var _this5 = this;\n\n        var cid, entryExist, entry, prev;\n        return _regenerator[\"default\"].wrap(function _callee20$(_context20) {\n          while (1) {\n            switch (_context20.prev = _context20.next) {\n              case 0:\n                _context20.next = 2;\n                return this._ipfs.dag.put(payload);\n\n              case 2:\n                cid = _context20.sent.toBaseEncodedString();\n                _context20.next = 5;\n                return this._ipfs.pin.add(cid);\n\n              case 5:\n                _context20.next = 7;\n                return this._typeCIDExists(type, cid);\n\n              case 7:\n                entryExist = _context20.sent;\n\n                if (!entryExist) {\n                  _context20.next = 10;\n                  break;\n                }\n\n                return _context20.abrupt(\"return\");\n\n              case 10:\n                entry = {\n                  type: type,\n                  data: cid\n                }; // the below code prevents multiple simultaneous writes,\n                // which orbitdb doesn't support\n\n                prev = this._rootstoreQueue;\n                this._rootstoreQueue = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee19() {\n                  return _regenerator[\"default\"].wrap(function _callee19$(_context19) {\n                    while (1) {\n                      switch (_context19.prev = _context19.next) {\n                        case 0:\n                          if (!prev) {\n                            _context19.next = 3;\n                            break;\n                          }\n\n                          _context19.next = 3;\n                          return prev;\n\n                        case 3:\n                          _context19.next = 5;\n                          return _this5.replicator.rootstore.add(entry);\n\n                        case 5:\n                        case \"end\":\n                          return _context19.stop();\n                      }\n                    }\n                  }, _callee19);\n                }))();\n\n              case 13:\n              case \"end\":\n                return _context20.stop();\n            }\n          }\n        }, _callee20, this);\n      }));\n\n      function _writeRootstoreEntry(_x14, _x15) {\n        return _writeRootstoreEntry2.apply(this, arguments);\n      }\n\n      return _writeRootstoreEntry;\n    }()\n  }, {\n    key: \"_typeCIDExists\",\n    value: function () {\n      var _typeCIDExists2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee21(type, cid) {\n        var entries, typeEntries;\n        return _regenerator[\"default\"].wrap(function _callee21$(_context21) {\n          while (1) {\n            switch (_context21.prev = _context21.next) {\n              case 0:\n                _context21.next = 2;\n                return this.replicator.rootstore.iterator({\n                  limit: -1\n                }).collect();\n\n              case 2:\n                entries = _context21.sent;\n                typeEntries = entries.filter(function (e) {\n                  return e.payload.value.type === type;\n                });\n                return _context21.abrupt(\"return\", Boolean(typeEntries.find(function (entry) {\n                  return entry.data === cid;\n                })));\n\n              case 5:\n              case \"end\":\n                return _context21.stop();\n            }\n          }\n        }, _callee21, this);\n      }));\n\n      function _typeCIDExists(_x16, _x17) {\n        return _typeCIDExists2.apply(this, arguments);\n      }\n\n      return _typeCIDExists;\n    }()\n  }, {\n    key: \"_deleteAddressLink\",\n    value: function () {\n      var _deleteAddressLink2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee22(address) {\n        var link;\n        return _regenerator[\"default\"].wrap(function _callee22$(_context22) {\n          while (1) {\n            switch (_context22.prev = _context22.next) {\n              case 0:\n                address = address.toLowerCase();\n                _context22.next = 3;\n                return this._readAddressLink(address);\n\n              case 3:\n                link = _context22.sent;\n\n                if (link) {\n                  _context22.next = 6;\n                  break;\n                }\n\n                throw new Error('_deleteAddressLink: link for given address does not exist');\n\n              case 6:\n                return _context22.abrupt(\"return\", this.replicator.rootstore.remove(link.entry.hash));\n\n              case 7:\n              case \"end\":\n                return _context22.stop();\n            }\n          }\n        }, _callee22, this);\n      }));\n\n      function _deleteAddressLink(_x18) {\n        return _deleteAddressLink2.apply(this, arguments);\n      }\n\n      return _deleteAddressLink;\n    }()\n  }, {\n    key: \"_readAddressLinks\",\n    value: function () {\n      var _readAddressLinks2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee23() {\n        var links, allLinks;\n        return _regenerator[\"default\"].wrap(function _callee23$(_context23) {\n          while (1) {\n            switch (_context23.prev = _context23.next) {\n              case 0:\n                _context23.next = 2;\n                return this.replicator.getAddressLinks();\n\n              case 2:\n                links = _context23.sent;\n                _context23.next = 5;\n                return Promise.all(links.map(validateLink));\n\n              case 5:\n                allLinks = _context23.sent;\n                return _context23.abrupt(\"return\", allLinks.filter(Boolean));\n\n              case 7:\n              case \"end\":\n                return _context23.stop();\n            }\n          }\n        }, _callee23, this);\n      }));\n\n      function _readAddressLinks() {\n        return _readAddressLinks2.apply(this, arguments);\n      }\n\n      return _readAddressLinks;\n    }()\n  }, {\n    key: \"_readAddressLink\",\n    value: function () {\n      var _readAddressLink2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee24(address) {\n        var links;\n        return _regenerator[\"default\"].wrap(function _callee24$(_context24) {\n          while (1) {\n            switch (_context24.prev = _context24.next) {\n              case 0:\n                address = address.toLowerCase();\n                _context24.next = 3;\n                return this._readAddressLinks();\n\n              case 3:\n                links = _context24.sent;\n                return _context24.abrupt(\"return\", links.find(function (link) {\n                  return link.address.toLowerCase() === address;\n                }));\n\n              case 5:\n              case \"end\":\n                return _context24.stop();\n            }\n          }\n        }, _callee24, this);\n      }));\n\n      function _readAddressLink(_x19) {\n        return _readAddressLink2.apply(this, arguments);\n      }\n\n      return _readAddressLink;\n    }()\n  }, {\n    key: \"close\",\n    value: function () {\n      var _close = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee25() {\n        return _regenerator[\"default\"].wrap(function _callee25$(_context25) {\n          while (1) {\n            switch (_context25.prev = _context25.next) {\n              case 0:\n                if (this._3id) {\n                  _context25.next = 2;\n                  break;\n                }\n\n                throw new Error('close: auth required');\n\n              case 2:\n                _context25.next = 4;\n                return this._3id.stopUpdatePolling();\n\n              case 4:\n                if (this.ghostPinbotKeepAliveHandle) {\n                  clearInterval(this.ghostPinbotKeepAliveHandle);\n                }\n\n                _context25.next = 7;\n                return this.replicator.stop();\n\n              case 7:\n              case \"end\":\n                return _context25.stop();\n            }\n          }\n        }, _callee25, this);\n      }));\n\n      function close() {\n        return _close.apply(this, arguments);\n      }\n\n      return close;\n    }()\n    /**\n     * Closes the 3box instance and clears local cache. If you call this,\n     * users will need to sign a consent message to log in the next time\n     * you call openBox.\n     */\n\n  }, {\n    key: \"logout\",\n    value: function () {\n      var _logout = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee26() {\n        return _regenerator[\"default\"].wrap(function _callee26$(_context26) {\n          while (1) {\n            switch (_context26.prev = _context26.next) {\n              case 0:\n                if (this._3id) {\n                  _context26.next = 2;\n                  break;\n                }\n\n                throw new Error('logout: auth required');\n\n              case 2:\n                _context26.next = 4;\n                return this.close();\n\n              case 4:\n                this._3id.logout();\n\n                delete this._3idEthAddress;\n                delete this.replicator;\n                delete this._3id;\n                this[\"public\"] = null;\n                this[\"private\"] = null;\n                this.spaces = {};\n                this.syncDone = null;\n                this.hasPublishedLink = {};\n                _context26.next = 15;\n                return this._init(this._opts);\n\n              case 15:\n              case \"end\":\n                return _context26.stop();\n            }\n          }\n        }, _callee26, this);\n      }));\n\n      function logout() {\n        return _logout.apply(this, arguments);\n      }\n\n      return logout;\n    }()\n    /**\n     * Check if the given address is logged in\n     *\n     * @param     {String}    address                 An ethereum address\n     * @return    {Boolean}                           true if the user is logged in\n     */\n\n  }, {\n    key: \"DID\",\n    get: function get() {\n      if (!this._3id) throw new Error('DID: auth required');\n      return this._3id.DID;\n    }\n  }], [{\n    key: \"create\",\n    value: function () {\n      var _create = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee27(provider) {\n        var opts,\n            ipfs,\n            box,\n            _args27 = arguments;\n        return _regenerator[\"default\"].wrap(function _callee27$(_context27) {\n          while (1) {\n            switch (_context27.prev = _context27.next) {\n              case 0:\n                opts = _args27.length > 1 && _args27[1] !== undefined ? _args27[1] : {};\n\n                if (!(opts.supportCheck !== false && browserHuh)) {\n                  _context27.next = 4;\n                  break;\n                }\n\n                _context27.next = 4;\n                return this._supportAlert();\n\n              case 4:\n                opts.iframeCache = typeof opts.iframeCache === 'boolean' ? opts.iframeCache : true;\n                _context27.next = 7;\n                return Box.getIPFS(opts);\n\n              case 7:\n                ipfs = _context27.sent;\n                box = new Box(provider, ipfs, opts);\n                _context27.next = 11;\n                return box._setProvider(provider);\n\n              case 11:\n                _context27.next = 13;\n                return box._init(opts);\n\n              case 13:\n                return _context27.abrupt(\"return\", box);\n\n              case 14:\n              case \"end\":\n                return _context27.stop();\n            }\n          }\n        }, _callee27, this);\n      }));\n\n      function create(_x20) {\n        return _create.apply(this, arguments);\n      }\n\n      return create;\n    }()\n  }, {\n    key: \"_supportAlert\",\n    value: function () {\n      var _supportAlert2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee28() {\n        var supported;\n        return _regenerator[\"default\"].wrap(function _callee28$(_context28) {\n          while (1) {\n            switch (_context28.prev = _context28.next) {\n              case 0:\n                _context28.next = 2;\n                return this.supported();\n\n              case 2:\n                supported = _context28.sent;\n                if (!supported) window.alert(supportAlert);\n\n              case 4:\n              case \"end\":\n                return _context28.stop();\n            }\n          }\n        }, _callee28, this);\n      }));\n\n      function _supportAlert() {\n        return _supportAlert2.apply(this, arguments);\n      }\n\n      return _supportAlert;\n    }()\n    /**\n     * Determines if this browser environment supports 3boxjs and ipfs.\n     *\n     * @return    {Boolean}\n     */\n\n  }, {\n    key: \"supported\",\n    value: function () {\n      var _supported = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee29() {\n        return _regenerator[\"default\"].wrap(function _callee29$(_context29) {\n          while (1) {\n            switch (_context29.prev = _context29.next) {\n              case 0:\n                return _context29.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  if (!browserHuh) throw new Error('Supported only detects browser feature support');\n                  window.Modernizr.on('indexeddb', resolve);\n                }));\n\n              case 1:\n              case \"end\":\n                return _context29.stop();\n            }\n          }\n        }, _callee29);\n      }));\n\n      function supported() {\n        return _supported.apply(this, arguments);\n      }\n\n      return supported;\n    }()\n  }, {\n    key: \"get3idConnectProvider\",\n    value: function get3idConnectProvider() {\n      throw new Error('3idConnectProvider function is no longer supported, initialize 3box as you did before 3idConnectProvider by passing a provider to Box.create or box.auth, and 3box will create a 3idConnectProvider in the background using your given provider - https://medium.com/3box/introducing-3id-connect-531af4f84d3f');\n    }\n  }, {\n    key: \"openBox\",\n    value: function () {\n      var _openBox = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee30(address, provider) {\n        var opts,\n            box,\n            _args30 = arguments;\n        return _regenerator[\"default\"].wrap(function _callee30$(_context30) {\n          while (1) {\n            switch (_context30.prev = _context30.next) {\n              case 0:\n                opts = _args30.length > 2 && _args30[2] !== undefined ? _args30[2] : {};\n                opts = Object.assign(opts, {\n                  address: address\n                });\n                _context30.next = 4;\n                return Box.create(provider, opts);\n\n              case 4:\n                box = _context30.sent;\n                _context30.next = 7;\n                return box.auth([], opts);\n\n              case 7:\n                return _context30.abrupt(\"return\", box);\n\n              case 8:\n              case \"end\":\n                return _context30.stop();\n            }\n          }\n        }, _callee30);\n      }));\n\n      function openBox(_x21, _x22) {\n        return _openBox.apply(this, arguments);\n      }\n\n      return openBox;\n    }()\n  }, {\n    key: \"isLoggedIn\",\n    value: function isLoggedIn(address) {\n      console.warn('Box.isLoggedIn: function no longer supported, simply call auth and it will not prompt user again if they have already authenticated');\n      return ThreeId.isLoggedIn(address);\n    }\n    /**\n     * Instanciate ipfs used by 3Box without calling openBox.\n     *\n     * @return    {IPFS}                           the ipfs instance\n     */\n\n  }, {\n    key: \"getIPFS\",\n    value: function () {\n      var _getIPFS = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee31() {\n        var opts,\n            ipfs,\n            pinningNode,\n            _args31 = arguments;\n        return _regenerator[\"default\"].wrap(function _callee31$(_context31) {\n          while (1) {\n            switch (_context31.prev = _context31.next) {\n              case 0:\n                opts = _args31.length > 0 && _args31[0] !== undefined ? _args31[0] : {};\n\n                if (browserHuh) {\n                  globalIPFS = window.globalIPFS;\n                  globalIPFSPromise = window.globalIPFSPromise;\n                }\n\n                if (!globalIPFS && !globalIPFSPromise) {\n                  globalIPFSPromise = initIPFS(opts.ipfs, opts.iframeStore, opts.ipfsOptions, opts.iframeCache);\n                }\n\n                if (browserHuh) window.globalIPFSPromise = globalIPFSPromise;\n\n                if (globalIPFS) {\n                  _context31.next = 8;\n                  break;\n                }\n\n                _context31.next = 7;\n                return globalIPFSPromise;\n\n              case 7:\n                globalIPFS = _context31.sent;\n\n              case 8:\n                if (browserHuh) window.globalIPFS = globalIPFS;\n                ipfs = globalIPFS;\n                pinningNode = opts.pinningNode || PINNING_NODE;\n                ipfs.swarm.connect(pinningNode);\n\n                if (opts.ghostPinbot) {\n                  ipfs.swarm.connect(opts.ghostPinbot);\n                }\n\n                if (browserHuh && ipfs.libp2p && !opts.disableRendezvous) {\n                  ipfs.libp2p.transportManager.listen(multiaddr(RENDEZVOUS_ADDRESS))[\"catch\"](console.warn);\n                }\n\n                return _context31.abrupt(\"return\", ipfs);\n\n              case 15:\n              case \"end\":\n                return _context31.stop();\n            }\n          }\n        }, _callee31);\n      }));\n\n      function getIPFS() {\n        return _getIPFS.apply(this, arguments);\n      }\n\n      return getIPFS;\n    }()\n  }]);\n  return Box;\n}(BoxApi);\n\nfunction initIPFSRepo(_x23) {\n  return _initIPFSRepo.apply(this, arguments);\n}\n\nfunction _initIPFSRepo() {\n  _initIPFSRepo = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee32(iframeCache) {\n    var repoOpts, ipfsRootPath, sessionID, levelInstance, ipfsDatastorePath, levelDatastore, cacheSupported, repo;\n    return _regenerator[\"default\"].wrap(function _callee32$(_context32) {\n      while (1) {\n        switch (_context32.prev = _context32.next) {\n          case 0:\n            repoOpts = {};\n\n            if (!(typeof window !== 'undefined' && window.indexedDB)) {\n              _context32.next = 13;\n              break;\n            }\n\n            sessionID = utils.randInt(10000);\n            ipfsRootPath = 'ipfs/root/' + sessionID;\n            levelInstance = new LevelStore(ipfsRootPath);\n            ipfsDatastorePath = 'ipfs/datastore'; // path name level-js-ipfs/datastore\n\n            levelDatastore = new LevelStore(ipfsDatastorePath);\n            repoOpts = {\n              storageBackends: {\n                root: function root() {\n                  return levelInstance;\n                },\n                datastore: function datastore() {\n                  return levelDatastore;\n                }\n              }\n            };\n\n            if (!(iframeCache && iframeCacheService)) {\n              _context32.next = 13;\n              break;\n            }\n\n            _context32.next = 11;\n            return cacheSupportedPromise;\n\n          case 11:\n            cacheSupported = _context32.sent;\n\n            if (cacheSupported) {\n              repoOpts.storageBackends.blocks = iframeCacheService.getIpfsStorageProxy();\n            }\n\n          case 13:\n            repo = new IPFSRepo('ipfs', repoOpts);\n            return _context32.abrupt(\"return\", {\n              repo: repo,\n              rootPath: ipfsRootPath\n            });\n\n          case 15:\n          case \"end\":\n            return _context32.stop();\n        }\n      }\n    }, _callee32);\n  }));\n  return _initIPFSRepo.apply(this, arguments);\n}\n\nfunction initIPFS(_x24, _x25, _x26, _x27) {\n  return _initIPFS.apply(this, arguments);\n}\n\nfunction _initIPFS() {\n  _initIPFS = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee33(ipfs, iframeStore, ipfsOptions, iframeCache) {\n    var ipfsRepo;\n    return _regenerator[\"default\"].wrap(function _callee33$(_context33) {\n      while (1) {\n        switch (_context33.prev = _context33.next) {\n          case 0:\n            if (!!ipfs && iframeCache) console.warn('Warning: Caching in iframe is true, but the given ipfs object that is being used may not be using the iframe cache');\n\n            if (!ipfs) {\n              _context33.next = 5;\n              break;\n            }\n\n            return _context33.abrupt(\"return\", ipfs);\n\n          case 5:\n            if (ipfsOptions) {\n              _context33.next = 11;\n              break;\n            }\n\n            if (ipfsOptions && iframeCache) console.warn('Warning: Caching in iframe is true, but received ipfs options which may not include the proper repo configuration for using the iframe cache');\n            _context33.next = 9;\n            return initIPFSRepo(iframeCache);\n\n          case 9:\n            ipfsRepo = _context33.sent;\n            ipfsOptions = Object.assign(IPFS_OPTIONS, {\n              repo: ipfsRepo.repo\n            });\n\n          case 11:\n            _context33.next = 13;\n            return IPFS.create(ipfsOptions);\n\n          case 13:\n            ipfs = _context33.sent;\n\n            if (ipfsRepo && typeof window !== 'undefined' && window.indexedDB) {\n              // deletes once db is closed again\n              window.indexedDB.deleteDatabase(ipfsRepo.rootPath);\n            }\n\n            return _context33.abrupt(\"return\", ipfs);\n\n          case 16:\n          case \"end\":\n            return _context33.stop();\n        }\n      }\n    }, _callee33);\n  }));\n  return _initIPFS.apply(this, arguments);\n}\n\nBox.idUtils = idUtils;\nmodule.exports = Box;","map":null,"metadata":{},"sourceType":"script"}