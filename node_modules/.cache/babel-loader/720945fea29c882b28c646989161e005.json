{"ast":null,"code":"const pageResults = require('graph-results-pager');\n\nconst ws = require('isomorphic-ws');\n\nconst {\n  SubscriptionClient\n} = require('subscriptions-transport-ws');\n\nconst {\n  request,\n  gql\n} = require('graphql-request');\n\nconst {\n  subWeeks,\n  getUnixTime,\n  fromUnixTime\n} = require(\"date-fns\");\n\nconst {\n  graphAPIEndpoints,\n  graphWSEndpoints,\n  TWENTY_FOUR_HOURS\n} = require('./../../constants');\n\nconst {\n  timestampToBlock,\n  timestampsToBlocks,\n  blockToTimestamp\n} = require('./../../utils');\n\nconst {\n  ethPrice\n} = require('./../exchange/eth');\n\nmodule.exports = {\n  async token({\n    block = undefined,\n    timestamp = undefined,\n    token_address = undefined\n  } = {}) {\n    if (!token_address) {\n      throw new Error(\"sushi-data: Token address undefined\");\n    }\n\n    block = block ? block : timestamp ? await timestampToBlock(timestamp) : undefined;\n    block = block ? `block: { number: ${block} }` : \"\";\n    const result = await request(graphAPIEndpoints.exchange, gql`{\n                    token(id: \"${token_address.toLowerCase()}\", ${block}) {\n                        ${tokens.properties.toString()}\n                    }\n                }`);\n    return tokens.callback([result.token])[0];\n  },\n\n  async token24h({\n    block = undefined,\n    timestamp = undefined,\n    token_address = undefined\n  } = {}) {\n    if (!token_address) {\n      throw new Error(\"sushi-data: Token address undefined\");\n    }\n\n    let timestampNow = timestamp ? timestamp : block ? await blockToTimestamp(block) : Math.floor(Date.now() / 1000);\n    timestamp24ago = timestampNow - TWENTY_FOUR_HOURS;\n    timestamp48ago = timestamp24ago - TWENTY_FOUR_HOURS;\n    block = timestamp ? await timestampToBlock(timestamp) : block;\n    block24ago = await timestampToBlock(timestamp24ago);\n    block48ago = await timestampToBlock(timestamp48ago);\n    const result = await module.exports.token({\n      block: block,\n      token_address\n    });\n    const result24ago = await module.exports.token({\n      block: block24ago,\n      token_address\n    });\n    const result48ago = await module.exports.token({\n      block: block48ago,\n      token_address\n    });\n    const ethPriceUSD = await ethPrice({\n      block: block\n    });\n    const ethPriceUSD24ago = await ethPrice({\n      block: block24ago\n    });\n    return tokens.callback24h([result], [result24ago], [result48ago], ethPriceUSD, ethPriceUSD24ago)[0];\n  },\n\n  async tokenHourData({\n    minTimestamp = undefined,\n    maxTimestamp = undefined,\n    minBlock = undefined,\n    maxBlock = undefined,\n    token_address = undefined\n  } = {}) {\n    if (!token_address) {\n      throw new Error(\"sushi-data: Token address undefined\");\n    }\n\n    minTimestamp = minBlock ? blockToTimestamp(minBlock) : minTimestamp;\n    maxTimestamp = maxBlock ? blockToTimestamp(maxBlock) : maxTimestamp;\n    const endTime = maxTimestamp ? fromUnixTime(maxTimestamp) : new Date();\n    let time = minTimestamp ? minTimestamp : getUnixTime(subWeeks(endTime, 1)); // create an array of hour start times until we reach current hour\n\n    const timestamps = [];\n\n    while (time <= getUnixTime(endTime) - 3600) {\n      timestamps.push(time);\n      time += 3600;\n    }\n\n    let blocks = await timestampsToBlocks(timestamps);\n    const query = gql`{\n                ${blocks.map((block, i) => gql`\n                    timestamp${timestamps[i]}: token(id: \"${token_address.toLowerCase()}\", block: {number: ${block}}) {\n                        ${tokens.properties.toString()}\n                }`)}\n            }`;\n    let result = await request(graphAPIEndpoints.exchange, query);\n    result = Object.keys(result).map(key => ({ ...result[key],\n      timestamp: Number(key.split(\"timestamp\")[1])\n    })).sort((a, b) => a.timestamp - b.timestamp);\n    return tokens.callbackHourData(result);\n  },\n\n  async tokenDayData({\n    minTimestamp = undefined,\n    maxTimestamp = undefined,\n    minBlock = undefined,\n    maxBlock = undefined,\n    token_address = undefined\n  } = {}) {\n    if (!token_address) {\n      throw new Error(\"sushi-data: Token address undefined\");\n    }\n\n    return pageResults({\n      api: graphAPIEndpoints.exchange,\n      query: {\n        entity: 'tokenDayDatas',\n        selection: {\n          orderDirection: 'desc',\n          where: {\n            token: `\\\\\"${token_address.toLowerCase()}\\\\\"`,\n            date_gte: minTimestamp || (minBlock ? await blockToTimestamp(minBlock) : undefined),\n            date_lte: maxTimestamp || (maxBlock ? await blockToTimestamp(maxBlock) : undefined)\n          }\n        },\n        properties: tokens.propertiesDayData\n      }\n    }).then(results => tokens.callbackDayData(results)).catch(err => console.log(err));\n  },\n\n  observeToken({\n    token_address = undefined\n  }) {\n    if (!token_address) {\n      throw new Error(\"sushi-data: Token address undefined\");\n    }\n\n    const query = gql`\n            subscription {\n                token(id: \"${token_address.toLowerCase()}\") {\n                    ${tokens.properties.toString()}\n                }\n        }`;\n    const client = new SubscriptionClient(graphWSEndpoints.exchange, {\n      reconnect: true\n    }, ws);\n    const observable = client.request({\n      query\n    });\n    return {\n      subscribe({\n        next,\n        error,\n        complete\n      }) {\n        return observable.subscribe({\n          next(results) {\n            next(tokens.callback([results.data.token])[0]);\n          },\n\n          error,\n          complete\n        });\n      }\n\n    };\n  },\n\n  async tokens({\n    block = undefined,\n    timestamp = undefined,\n    max = undefined\n  } = {}) {\n    return pageResults({\n      api: graphAPIEndpoints.exchange,\n      query: {\n        entity: 'tokens',\n        selection: {\n          block: block ? {\n            number: block\n          } : timestamp ? {\n            number: await timestampToBlock(timestamp)\n          } : undefined\n        },\n        properties: tokens.properties\n      },\n      max\n    }).then(results => tokens.callback(results)).catch(err => console.log(err));\n  },\n\n  async tokens24h({\n    block = undefined,\n    timestamp = undefined,\n    max = undefined\n  } = {}) {\n    let timestampNow = timestamp ? timestamp : block ? await blockToTimestamp(block) : Math.floor(Date.now() / 1000);\n    timestamp24ago = timestampNow - TWENTY_FOUR_HOURS;\n    timestamp48ago = timestamp24ago - TWENTY_FOUR_HOURS;\n    block = timestamp ? await timestampToBlock(timestamp) : block;\n    block24ago = await timestampToBlock(timestamp24ago);\n    block48ago = await timestampToBlock(timestamp48ago);\n    const results = await module.exports.tokens({\n      block: block,\n      max\n    });\n    const results24ago = await module.exports.tokens({\n      block: block24ago,\n      max\n    });\n    const results48ago = await module.exports.tokens({\n      block: block48ago,\n      max\n    });\n    const ethPriceUSD = await ethPrice({\n      block: block\n    });\n    const ethPriceUSD24ago = await ethPrice({\n      block: block24ago\n    });\n    return tokens.callback24h(results, results24ago, results48ago, ethPriceUSD, ethPriceUSD24ago);\n  },\n\n  observeTokens() {\n    const query = gql`\n            subscription {\n                tokens(first: 1000, orderBy: volumeUSD, orderDirection: desc) {\n                    ${tokens.properties.toString()}\n                }\n        }`;\n    const client = new SubscriptionClient(graphWSEndpoints.exchange, {\n      reconnect: true\n    }, ws);\n    const observable = client.request({\n      query\n    });\n    return {\n      subscribe({\n        next,\n        error,\n        complete\n      }) {\n        return observable.subscribe({\n          next(results) {\n            next(tokens.callback(results.data.tokens));\n          },\n\n          error,\n          complete\n        });\n      }\n\n    };\n  }\n\n};\nconst tokens = {\n  properties: ['id', 'symbol', 'name', 'decimals', 'totalSupply', 'volume', 'volumeUSD', 'untrackedVolumeUSD', 'txCount', 'liquidity', 'derivedETH'],\n\n  callback(results) {\n    return results.map(({\n      id,\n      symbol,\n      name,\n      decimals,\n      totalSupply,\n      volume,\n      volumeUSD,\n      untrackedVolumeUSD,\n      txCount,\n      liquidity,\n      derivedETH\n    }) => ({\n      id: id,\n      symbol: symbol,\n      name: name,\n      decimals: Number(decimals),\n      totalSupply: Number(totalSupply),\n      volume: Number(volume),\n      volumeUSD: Number(volumeUSD),\n      untrackedVolumeUSD: Number(untrackedVolumeUSD),\n      txCount: Number(txCount),\n      liquidity: Number(liquidity),\n      derivedETH: Number(derivedETH)\n    })).sort((a, b) => b.volumeUSD - a.volumeUSD);\n  },\n\n  callback24h(results, results24h, results48h, ethPriceUSD, ethPriceUSD24ago) {\n    return results.map(result => {\n      const result24h = results24h.find(e => e.id === result.id) || result;\n      const result48h = results48h.find(e => e.id === result.id) || result;\n      return { ...result,\n        priceUSD: result.derivedETH * ethPriceUSD,\n        priceUSDChange: result.derivedETH * ethPriceUSD / (result24h.derivedETH * ethPriceUSD24ago) * 100 - 100,\n        priceUSDChangeCount: result.derivedETH * ethPriceUSD - result24h.derivedETH * ethPriceUSD24ago,\n        liquidityUSD: result.liquidity * result.derivedETH * ethPriceUSD,\n        liquidityUSDChange: result.liquidity * result.derivedETH * ethPriceUSD / (result24h.liquidity * result24h.derivedETH * ethPriceUSD24ago) * 100 - 100,\n        liquidityUSDChangeCount: result.liquidity * result.derivedETH * ethPriceUSD - result24h.liquidity * result24h.derivedETH * ethPriceUSD24ago,\n        liquidityETH: result.liquidity * result.derivedETH,\n        liquidityETHChange: result.liquidity * result.derivedETH / (result24h.liquidity * result24h.derivedETH) * 100 - 100,\n        liquidityETHChangeCount: result.liquidity * result.derivedETH - result24h.liquidity * result24h.derivedETH,\n        volumeUSDOneDay: result.volumeUSD - result24h.volumeUSD,\n        volumeUSDChange: (result.volumeUSD - result24h.volumeUSD) / (result24h.volumeUSD - result48h.volumeUSD) * 100 - 100,\n        volumeUSDChangeCount: result.volumeUSD - result24h.volumeUSD - (result24h.volumeUSD - result48h.volumeUSD),\n        untrackedVolumeUSDOneDay: result.untrackedVolumeUSD - result24h.untrackedVolumeUSD,\n        untrackedVolumeUSDChange: (result.untrackedVolumeUSD - result24h.untrackedVolumeUSD) / (result24h.untrackedVolumeUSD - result48h.untrackedVolumeUSD) * 100 - 100,\n        untrackedVolumeUSDChangeCount: result.untrackedVolumeUSD - result24h.untrackedVolumeUSD - (result24h.untrackedVolumeUSD - result48h.untrackedVolumeUSD),\n        txCountOneDay: result.txCount - result24h.txCount,\n        txCountChange: (result.txCount - result24h.txCount) / (result24h.txCount - result48h.txCount) * 100 - 100,\n        txCountChangeCount: result.txCount - result24h.txCount - (result24h.txCount - result48h.txCount)\n      };\n    });\n  },\n\n  callbackHourData(results) {\n    return results.map(result => ({\n      id: result.id,\n      symbol: result.symbol,\n      name: result.name,\n      decimals: Number(result.decimals),\n      totalSupply: Number(result.totalSupply),\n      volume: Number(result.volume),\n      volumeUSD: Number(result.volumeUSD),\n      untrackedVolumeUSD: Number(result.untrackedVolumeUSD),\n      txCount: Number(result.txCount),\n      liquidity: Number(result.liquidity),\n      derivedETH: Number(result.derivedETH),\n      timestamp: result.timestamp\n    }));\n  },\n\n  propertiesDayData: ['id', 'date', 'volume', 'volumeETH', 'volumeUSD', 'liquidity', 'liquidityETH', 'liquidityUSD', 'priceUSD', 'txCount'],\n\n  callbackDayData(results) {\n    return results.map(result => ({\n      id: result.id,\n      date: new Date(result.date * 1000),\n      timestamp: Number(result.date),\n      volume: Number(result.volume),\n      volumeETH: Number(result.volumeETH),\n      volumeUSD: Number(result.volumeUSD),\n      liquidity: Number(result.liquidity),\n      liquidityETH: Number(result.liquidityETH),\n      liquidityUSD: Number(result.liquidityUSD),\n      priceUSD: Number(result.priceUSD),\n      txCount: Number(result.txCount)\n    }));\n  }\n\n};","map":null,"metadata":{},"sourceType":"script"}