{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _slicedToArray = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _createForOfIteratorHelper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar mh = require('multihashing-async');\n\nvar crypto = require('libp2p-crypto');\n\nvar _require2 = require('libp2p-interfaces/src/crypto/errors'),\n    InvalidCryptoExchangeError = _require2.InvalidCryptoExchangeError;\n\nexports.exchanges = ['P-256', 'P-384', 'P-521'];\nexports.ciphers = ['AES-256', 'AES-128'];\nexports.hashes = ['SHA256', 'SHA512']; // Determines which algorithm to use.  Note:  f(a, b) = f(b, a)\n\nexports.theBest = function (order, p1, p2) {\n  var first;\n  var second;\n\n  if (order < 0) {\n    first = p2;\n    second = p1;\n  } else if (order > 0) {\n    first = p1;\n    second = p2;\n  } else {\n    return p1[0];\n  }\n\n  var _iterator = _createForOfIteratorHelper(first),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var firstCandidate = _step.value;\n\n      var _iterator2 = _createForOfIteratorHelper(second),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var secondCandidate = _step2.value;\n\n          if (firstCandidate === secondCandidate) {\n            return firstCandidate;\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  throw new InvalidCryptoExchangeError('No algorithms in common!');\n};\n\nexports.makeMacAndCipher = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(target) {\n    var _yield$Promise$all, _yield$Promise$all2;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return Promise.all([makeMac(target.hashT, target.keys.macKey), makeCipher(target.cipherT, target.keys.iv, target.keys.cipherKey)]);\n\n          case 2:\n            _yield$Promise$all = _context.sent;\n            _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n            target.mac = _yield$Promise$all2[0];\n            target.cipher = _yield$Promise$all2[1];\n\n          case 6:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function (_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nfunction makeMac(hash, key) {\n  return crypto.hmac.create(hash, key);\n}\n\nfunction makeCipher(cipherType, iv, key) {\n  if (cipherType === 'AES-128' || cipherType === 'AES-256') {\n    return crypto.aes.create(key, iv);\n  } // TODO: figure out if Blowfish is needed and if so find a library for it.\n\n\n  throw new InvalidCryptoExchangeError(\"unrecognized cipher type: \".concat(cipherType));\n}\n\nexports.selectBest = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(local, remote) {\n    var oh1, oh2, order;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return exports.digest(Buffer.concat([remote.pubKeyBytes, local.nonce]));\n\n          case 2:\n            oh1 = _context2.sent;\n            _context2.next = 5;\n            return exports.digest(Buffer.concat([local.pubKeyBytes, remote.nonce]));\n\n          case 5:\n            oh2 = _context2.sent;\n            order = Buffer.compare(oh1, oh2);\n\n            if (!(order === 0)) {\n              _context2.next = 9;\n              break;\n            }\n\n            throw new InvalidCryptoExchangeError('you are trying to talk to yourself');\n\n          case 9:\n            return _context2.abrupt(\"return\", {\n              curveT: exports.theBest(order, local.exchanges, remote.exchanges),\n              cipherT: exports.theBest(order, local.ciphers, remote.ciphers),\n              hashT: exports.theBest(order, local.hashes, remote.hashes),\n              order: order\n            });\n\n          case 10:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function (_x2, _x3) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nexports.digest = function (buf) {\n  return mh.digest(buf, 'sha2-256', buf.length);\n};","map":null,"metadata":{},"sourceType":"script"}