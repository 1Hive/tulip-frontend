{"ast":null,"code":"'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst BufferList = require('bl/BufferList');\n\nconst lp = require('it-length-prefixed');\n\nconst pipe = require('it-pipe');\n\nconst errCode = require('err-code');\n\nconst NewLine = Buffer.from('\\n');\n\nasync function oneChunk(source) {\n  for await (const chunk of source) return chunk; // We only need one!\n\n}\n\nexports.encode = buffer => lp.encode.single(new BufferList([buffer, NewLine])); // `write` encodes and writes a single buffer\n\n\nexports.write = (writer, buffer) => writer.push(exports.encode(buffer)); // `writeAll` behaves like `write`, except it encodes an array of items as a single write\n\n\nexports.writeAll = (writer, buffers) => {\n  writer.push(buffers.reduce((bl, buffer) => bl.append(exports.encode(buffer)), new BufferList()));\n};\n\nexports.read = async reader => {\n  let byteLength = 1; // Read single byte chunks until the length is known\n\n  const varByteSource = {\n    // No return impl - we want the reader to remain readable\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n\n    next: () => reader.next(byteLength)\n  }; // Once the length has been parsed, read chunk for that length\n\n  const onLength = l => {\n    byteLength = l;\n  };\n\n  const buf = await pipe(varByteSource, lp.decode({\n    onLength\n  }), oneChunk);\n\n  if (buf.get(buf.length - 1) !== NewLine[0]) {\n    throw errCode(new Error('missing newline'), 'ERR_INVALID_MULTISTREAM_SELECT_MESSAGE');\n  }\n\n  return buf.shallowSlice(0, -1); // Remove newline\n};","map":null,"metadata":{},"sourceType":"script"}