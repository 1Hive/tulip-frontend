{"ast":null,"code":"'use strict';\n\nconst pipe = require('it-pipe');\n\nconst pushable = require('it-pushable');\n\nconst log = require('debug')('libp2p:mplex');\n\nconst abortable = require('abortable-iterator');\n\nconst Coder = require('./coder');\n\nconst restrictSize = require('./restrict-size');\n\nconst {\n  MessageTypes,\n  MessageTypeNames\n} = require('./message-types');\n\nconst createStream = require('./stream');\n\nclass Mplex {\n  /**\n   * @constructor\n   * @param {object} options\n   * @param {function(*)} options.onStream Called whenever an inbound stream is created\n   * @param {function(*)} options.onStreamEnd Called whenever a stream ends\n   * @param {AbortSignal} options.signal An AbortController signal\n   */\n  constructor(options) {\n    options = options || {};\n    options = typeof options === 'function' ? {\n      onStream: options\n    } : options;\n    this._streamId = 0;\n    this._streams = {\n      /**\n       * @type {Map<number, *>} Stream to ids map\n       */\n      initiators: new Map(),\n\n      /**\n       * @type {Map<number, *>} Stream to ids map\n       */\n      receivers: new Map()\n    };\n    this._options = options;\n    /**\n     * An iterable sink\n     */\n\n    this.sink = this._createSink();\n    /**\n     * An iterable source\n     */\n\n    this.source = this._createSource();\n    /**\n     * @property {function} onStream\n     */\n\n    this.onStream = options.onStream;\n    /**\n     * @property {function} onStreamEnd\n     */\n\n    this.onStreamEnd = options.onStreamEnd;\n  }\n  /**\n   * Returns a Map of streams and their ids\n   * @returns {Map<number,*>}\n   */\n\n\n  get streams() {\n    // Inbound and Outbound streams may have the same ids, so we need to make those unique\n    const streams = [];\n\n    this._streams.initiators.forEach(stream => {\n      streams.push(stream);\n    });\n\n    this._streams.receivers.forEach(stream => {\n      streams.push(stream);\n    });\n\n    return streams;\n  }\n  /**\n   * Initiate a new stream with the given name. If no name is\n   * provided, the id of th stream will be used.\n   * @param {string} [name] If name is not a string it will be cast to one\n   * @returns {Stream}\n   */\n\n\n  newStream(name) {\n    const id = this._streamId++;\n    name = name == null ? id.toString() : String(name);\n    const registry = this._streams.initiators;\n    return this._newStream({\n      id,\n      name,\n      type: 'initiator',\n      registry\n    });\n  }\n  /**\n   * Called whenever an inbound stream is created\n   * @private\n   * @param {*} options\n   * @param {number} options.id\n   * @param {string} options.name\n   * @returns {*} A muxed stream\n   */\n\n\n  _newReceiverStream({\n    id,\n    name\n  }) {\n    const registry = this._streams.receivers;\n    return this._newStream({\n      id,\n      name,\n      type: 'receiver',\n      registry\n    });\n  }\n  /**\n   * Creates a new stream\n   * @private\n   * @param {object} options\n   * @param {number} options.id\n   * @param {string} options.name\n   * @param {string} options.type\n   * @param {Map<number, *>} options.registry A map of streams to their ids\n   * @returns {*} A muxed stream\n   */\n\n\n  _newStream({\n    id,\n    name,\n    type,\n    registry\n  }) {\n    if (registry.has(id)) {\n      throw new Error(`${type} stream ${id} already exists!`);\n    }\n\n    log('new %s stream %s %s', type, id, name);\n\n    const send = msg => {\n      if (log.enabled) {\n        log('%s stream %s %s send', type, id, name, { ...msg,\n          type: MessageTypeNames[msg.type],\n          data: msg.data && msg.data.slice()\n        });\n      }\n\n      return this.source.push(msg);\n    };\n\n    const onEnd = () => {\n      log('%s stream %s %s ended', type, id, name);\n      registry.delete(id);\n      this.onStreamEnd && this.onStreamEnd(stream);\n    };\n\n    const stream = createStream({\n      id,\n      name,\n      send,\n      type,\n      onEnd,\n      maxMsgSize: this._options.maxMsgSize\n    });\n    registry.set(id, stream);\n    return stream;\n  }\n  /**\n   * Creates a sink with an abortable source. Incoming messages will\n   * also have their size restricted. All messages will be varint decoded.\n   * @private\n   * @returns {*} Returns an iterable sink\n   */\n\n\n  _createSink() {\n    return async source => {\n      if (this._options.signal) {\n        source = abortable(source, this._options.signal);\n      }\n\n      try {\n        await pipe(source, Coder.decode, restrictSize(this._options.maxMsgSize), async source => {\n          for await (const msgs of source) {\n            for (const msg of msgs) {\n              this._handleIncoming(msg);\n            }\n          }\n        });\n      } catch (err) {\n        log('error in sink', err);\n        return this.source.end(err); // End the source with an error\n      }\n\n      this.source.end();\n    };\n  }\n  /**\n   * Creates a source that restricts outgoing message sizes\n   * and varint encodes them.\n   * @private\n   * @returns {*} An iterable source\n   */\n\n\n  _createSource() {\n    const onEnd = err => {\n      const {\n        initiators,\n        receivers\n      } = this._streams; // Abort all the things!\n\n      for (const s of initiators.values()) s.abort(err);\n\n      for (const s of receivers.values()) s.abort(err);\n    };\n\n    const source = pushable({\n      onEnd,\n      writev: true\n    });\n    return Object.assign(Coder.encode(source), {\n      push: source.push,\n      end: source.end,\n      return: source.return\n    });\n  }\n  /**\n   * @private\n   * @param {object} options\n   * @param {number} options.id\n   * @param {string} options.type\n   * @param {Buffer|BufferList} options.data\n   * @returns {void}\n   */\n\n\n  _handleIncoming({\n    id,\n    type,\n    data\n  }) {\n    if (log.enabled) {\n      log('incoming message', {\n        id,\n        type: MessageTypeNames[type],\n        data: data.slice()\n      });\n    } // Create a new stream?\n\n\n    if (type === MessageTypes.NEW_STREAM && this.onStream) {\n      const stream = this._newReceiverStream({\n        id,\n        name: data.toString()\n      });\n\n      return this.onStream(stream);\n    }\n\n    const list = type & 1 ? this._streams.initiators : this._streams.receivers;\n    const stream = list.get(id);\n    if (!stream) return log('missing stream %s', id);\n\n    switch (type) {\n      case MessageTypes.MESSAGE_INITIATOR:\n      case MessageTypes.MESSAGE_RECEIVER:\n        stream.source.push(data);\n        break;\n\n      case MessageTypes.CLOSE_INITIATOR:\n      case MessageTypes.CLOSE_RECEIVER:\n        stream.close();\n        break;\n\n      case MessageTypes.RESET_INITIATOR:\n      case MessageTypes.RESET_RECEIVER:\n        stream.reset();\n        break;\n\n      default:\n        log('unknown message type %s', type);\n    }\n  }\n\n}\n\nMplex.multicodec = '/mplex/6.7.0';\nmodule.exports = Mplex;","map":null,"metadata":{},"sourceType":"script"}