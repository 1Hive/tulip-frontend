{"ast":null,"code":"var _jsxFileName = \"/Users/fabianmolina/Documents/1hive/tulip-frontend/src/providers/ActivityProvider.js\";\nimport React, { useCallback, useContext, useEffect, useMemo, useRef, useState } from 'react';\nimport PropTypes from 'prop-types';\nimport StoredList from '../StoredList';\nimport { getNetworkType } from '../lib/web3-utils';\nimport { MINUTE } from '../utils/date-utils';\nimport { useWallet } from './Wallet';\nimport { ACTIVITY_STATUS_CONFIRMED, ACTIVITY_STATUS_FAILED, ACTIVITY_STATUS_PENDING, ACTIVITY_STATUS_TIMED_OUT } from '../components/Activity/activity-statuses';\nimport actions from '../actions/court-action-types';\nconst ActivityContext = /*#__PURE__*/React.createContext(); // Only used to serialize / deserialize the symbols\n\nconst StatusSymbolsByName = new Map(Object.entries({\n  ACTIVITY_STATUS_CONFIRMED,\n  ACTIVITY_STATUS_FAILED,\n  ACTIVITY_STATUS_PENDING,\n  ACTIVITY_STATUS_TIMED_OUT\n}));\nconst TypeSymbolsByName = new Map(Object.entries(actions));\nconst TIMEOUT_DURATION = 10 * MINUTE;\n\nfunction getStoredList(account) {\n  return new StoredList(`activity:${getNetworkType()}:${account}`, {\n    preStringify: activity => ({ ...activity,\n      status: activity.status.description.replace('ACTIVITY_STATUS_', ''),\n      type: activity.type.description\n    }),\n    postParse: activity => ({ ...activity,\n      status: StatusSymbolsByName.get(`ACTIVITY_STATUS_${activity.status}`),\n      type: TypeSymbolsByName.get(activity.type)\n    })\n  });\n}\n\nasync function getActivityFinalStatus(ethers, {\n  createdAt,\n  transactionHash,\n  status\n}) {\n  if (status !== ACTIVITY_STATUS_PENDING) {\n    return status;\n  }\n\n  const now = Date.now();\n  return Promise.race([// Get the transaction status once mined\n  ethers.getTransaction(String(transactionHash)).then(tx => {\n    // tx is null if no tx was found\n    if (!tx) {\n      throw new Error('No transaction found');\n    }\n\n    return tx.wait().then(receipt => {\n      return receipt.blockNumber ? ACTIVITY_STATUS_CONFIRMED : ACTIVITY_STATUS_FAILED;\n    });\n  }).catch(() => {\n    return ACTIVITY_STATUS_FAILED;\n  }), // Timeout after 10 minutes\n  new Promise(resolve => {\n    if (now - createdAt > TIMEOUT_DURATION) {\n      return ACTIVITY_STATUS_TIMED_OUT;\n    }\n\n    setTimeout(() => {\n      resolve(ACTIVITY_STATUS_TIMED_OUT);\n    }, TIMEOUT_DURATION - (now - createdAt));\n  })]);\n}\n\nfunction ActivityProvider({\n  children\n}) {\n  const [activities, setActivities] = useState([]);\n  const storedList = useRef(null);\n  const wallet = useWallet();\n  const {\n    account,\n    ethers\n  } = wallet; // Update the activities, ensuring the activities\n  // are updated in the stored list and in the state.\n\n  const updateActivities = useCallback(cb => {\n    const newActivities = cb(activities);\n    setActivities(newActivities);\n\n    if (storedList.current) {\n      storedList.current.update(newActivities);\n    }\n  }, [activities]); // Add a single activity.\n\n  const addActivity = useCallback(async (tx, // see types defined in ../actions/court-action-types.js\n  type, description = '') => {\n    // tx might be a promise resolving into a tx\n    tx = await tx;\n    updateActivities(activities => [...activities, {\n      createdAt: Date.now(),\n      description,\n      from: tx.from,\n      nonce: tx.nonce,\n      read: false,\n      status: ACTIVITY_STATUS_PENDING,\n      type,\n      to: tx.to,\n      transactionHash: tx.hash\n    }]);\n    return tx;\n  }, [updateActivities]); // Clear a single activity\n\n  const removeActivity = useCallback(transactionHash => {\n    updateActivities(activities => activities.filter(activity => activity.transactionHash !== transactionHash));\n  }, [updateActivities]); // Clear all non pending activities − we don’t clear\n  // pending because we’re awaiting state change.\n\n  const clearActivities = useCallback(() => {\n    updateActivities(activities => activities.filter(activity => activity.status === ACTIVITY_STATUS_PENDING));\n  }, [updateActivities]); // Update the status of a single activity,\n  // using its transaction hash.\n\n  const updateActivityStatus = useCallback((hash, status) => {\n    updateActivities(activities => activities.map(activity => {\n      if (activity.transactionHash !== hash) {\n        return activity;\n      }\n\n      return { ...activity,\n        read: false,\n        status\n      };\n    }));\n  }, [updateActivities]); // Mark the current user’s activities as read\n\n  const markActivitiesRead = useCallback(() => {\n    updateActivities(activities => activities.map(activity => ({ ...activity,\n      read: true\n    })));\n  }, [updateActivities]); // Total number of unread activities\n\n  const unreadCount = useMemo(() => {\n    return activities.reduce((count, {\n      read\n    }) => count + Number(!read), 0);\n  }, [activities]);\n  const updateActivitiesFromStorage = useCallback(() => {\n    if (!storedList.current) {\n      return;\n    }\n\n    const activitiesFromStorage = storedList.current.getItems(); // We will diff activities from storage and activites from state to prevent loops in the useEffect below\n\n    const activitiesChanged = activities.length !== activitiesFromStorage.length || activitiesFromStorage.filter(({\n      transactionHash\n    }) => activities.findIndex(activity => activity.transactionHash === transactionHash) === -1) > 0;\n\n    if (activitiesChanged) {\n      setActivities(activitiesFromStorage);\n    }\n  }, [activities]); // Triggered every time the account changes\n\n  useEffect(() => {\n    if (!account) {\n      return;\n    }\n\n    let cancelled = false;\n    storedList.current = getStoredList(account);\n    updateActivitiesFromStorage();\n    activities.forEach(async activity => {\n      const status = await getActivityFinalStatus(ethers, activity);\n\n      if (!cancelled && status !== activity.status) {\n        updateActivityStatus(activity.transactionHash, status);\n      }\n    });\n    return () => {\n      cancelled = true;\n    };\n  }, [account, activities, ethers, updateActivitiesFromStorage, updateActivityStatus]);\n  return /*#__PURE__*/React.createElement(ActivityContext.Provider, {\n    value: {\n      activities,\n      addActivity,\n      clearActivities,\n      markActivitiesRead,\n      removeActivity,\n      unreadCount,\n      updateActivities\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 244,\n      columnNumber: 5\n    }\n  }, children);\n}\n\nActivityProvider.propTypes = {\n  children: PropTypes.node\n};\n\nfunction useActivity() {\n  return useContext(ActivityContext);\n}\n\nexport { ActivityProvider, useActivity };","map":{"version":3,"sources":["/Users/fabianmolina/Documents/1hive/tulip-frontend/src/providers/ActivityProvider.js"],"names":["React","useCallback","useContext","useEffect","useMemo","useRef","useState","PropTypes","StoredList","getNetworkType","MINUTE","useWallet","ACTIVITY_STATUS_CONFIRMED","ACTIVITY_STATUS_FAILED","ACTIVITY_STATUS_PENDING","ACTIVITY_STATUS_TIMED_OUT","actions","ActivityContext","createContext","StatusSymbolsByName","Map","Object","entries","TypeSymbolsByName","TIMEOUT_DURATION","getStoredList","account","preStringify","activity","status","description","replace","type","postParse","get","getActivityFinalStatus","ethers","createdAt","transactionHash","now","Date","Promise","race","getTransaction","String","then","tx","Error","wait","receipt","blockNumber","catch","resolve","setTimeout","ActivityProvider","children","activities","setActivities","storedList","wallet","updateActivities","cb","newActivities","current","update","addActivity","from","nonce","read","to","hash","removeActivity","filter","clearActivities","updateActivityStatus","map","markActivitiesRead","unreadCount","reduce","count","Number","updateActivitiesFromStorage","activitiesFromStorage","getItems","activitiesChanged","length","findIndex","cancelled","forEach","propTypes","node","useActivity"],"mappings":"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","sourcesContent":["import React, {\r\n  useCallback,\r\n  useContext,\r\n  useEffect,\r\n  useMemo,\r\n  useRef,\r\n  useState,\r\n} from 'react'\r\nimport PropTypes from 'prop-types'\r\nimport StoredList from '../StoredList'\r\nimport { getNetworkType } from '../lib/web3-utils'\r\nimport { MINUTE } from '../utils/date-utils'\r\nimport { useWallet } from './Wallet'\r\nimport {\r\n  ACTIVITY_STATUS_CONFIRMED,\r\n  ACTIVITY_STATUS_FAILED,\r\n  ACTIVITY_STATUS_PENDING,\r\n  ACTIVITY_STATUS_TIMED_OUT,\r\n} from '../components/Activity/activity-statuses'\r\nimport actions from '../actions/court-action-types'\r\n\r\nconst ActivityContext = React.createContext()\r\n\r\n// Only used to serialize / deserialize the symbols\r\nconst StatusSymbolsByName = new Map(\r\n  Object.entries({\r\n    ACTIVITY_STATUS_CONFIRMED,\r\n    ACTIVITY_STATUS_FAILED,\r\n    ACTIVITY_STATUS_PENDING,\r\n    ACTIVITY_STATUS_TIMED_OUT,\r\n  })\r\n)\r\n\r\nconst TypeSymbolsByName = new Map(Object.entries(actions))\r\n\r\nconst TIMEOUT_DURATION = 10 * MINUTE\r\n\r\nfunction getStoredList(account) {\r\n  return new StoredList(`activity:${getNetworkType()}:${account}`, {\r\n    preStringify: activity => ({\r\n      ...activity,\r\n      status: activity.status.description.replace('ACTIVITY_STATUS_', ''),\r\n      type: activity.type.description,\r\n    }),\r\n    postParse: activity => ({\r\n      ...activity,\r\n      status: StatusSymbolsByName.get(`ACTIVITY_STATUS_${activity.status}`),\r\n      type: TypeSymbolsByName.get(activity.type),\r\n    }),\r\n  })\r\n}\r\n\r\nasync function getActivityFinalStatus(\r\n  ethers,\r\n  { createdAt, transactionHash, status }\r\n) {\r\n  if (status !== ACTIVITY_STATUS_PENDING) {\r\n    return status\r\n  }\r\n\r\n  const now = Date.now()\r\n\r\n  return Promise.race([\r\n    // Get the transaction status once mined\r\n    ethers\r\n      .getTransaction(String(transactionHash))\r\n      .then(tx => {\r\n        // tx is null if no tx was found\r\n        if (!tx) {\r\n          throw new Error('No transaction found')\r\n        }\r\n        return tx.wait().then(receipt => {\r\n          return receipt.blockNumber\r\n            ? ACTIVITY_STATUS_CONFIRMED\r\n            : ACTIVITY_STATUS_FAILED\r\n        })\r\n      })\r\n      .catch(() => {\r\n        return ACTIVITY_STATUS_FAILED\r\n      }),\r\n\r\n    // Timeout after 10 minutes\r\n    new Promise(resolve => {\r\n      if (now - createdAt > TIMEOUT_DURATION) {\r\n        return ACTIVITY_STATUS_TIMED_OUT\r\n      }\r\n      setTimeout(() => {\r\n        resolve(ACTIVITY_STATUS_TIMED_OUT)\r\n      }, TIMEOUT_DURATION - (now - createdAt))\r\n    }),\r\n  ])\r\n}\r\n\r\nfunction ActivityProvider({ children }) {\r\n  const [activities, setActivities] = useState([])\r\n  const storedList = useRef(null)\r\n  const wallet = useWallet()\r\n  const { account, ethers } = wallet\r\n\r\n  // Update the activities, ensuring the activities\r\n  // are updated in the stored list and in the state.\r\n  const updateActivities = useCallback(\r\n    cb => {\r\n      const newActivities = cb(activities)\r\n      setActivities(newActivities)\r\n      if (storedList.current) {\r\n        storedList.current.update(newActivities)\r\n      }\r\n    },\r\n    [activities]\r\n  )\r\n\r\n  // Add a single activity.\r\n  const addActivity = useCallback(\r\n    async (\r\n      tx,\r\n\r\n      // see types defined in ../actions/court-action-types.js\r\n      type,\r\n      description = ''\r\n    ) => {\r\n      // tx might be a promise resolving into a tx\r\n      tx = await tx\r\n\r\n      updateActivities(activities => [\r\n        ...activities,\r\n        {\r\n          createdAt: Date.now(),\r\n          description,\r\n          from: tx.from,\r\n          nonce: tx.nonce,\r\n          read: false,\r\n          status: ACTIVITY_STATUS_PENDING,\r\n          type,\r\n          to: tx.to,\r\n          transactionHash: tx.hash,\r\n        },\r\n      ])\r\n\r\n      return tx\r\n    },\r\n    [updateActivities]\r\n  )\r\n\r\n  // Clear a single activity\r\n  const removeActivity = useCallback(\r\n    transactionHash => {\r\n      updateActivities(activities =>\r\n        activities.filter(\r\n          activity => activity.transactionHash !== transactionHash\r\n        )\r\n      )\r\n    },\r\n    [updateActivities]\r\n  )\r\n\r\n  // Clear all non pending activities − we don’t clear\r\n  // pending because we’re awaiting state change.\r\n  const clearActivities = useCallback(() => {\r\n    updateActivities(activities =>\r\n      activities.filter(activity => activity.status === ACTIVITY_STATUS_PENDING)\r\n    )\r\n  }, [updateActivities])\r\n\r\n  // Update the status of a single activity,\r\n  // using its transaction hash.\r\n  const updateActivityStatus = useCallback(\r\n    (hash, status) => {\r\n      updateActivities(activities =>\r\n        activities.map(activity => {\r\n          if (activity.transactionHash !== hash) {\r\n            return activity\r\n          }\r\n          return { ...activity, read: false, status }\r\n        })\r\n      )\r\n    },\r\n    [updateActivities]\r\n  )\r\n\r\n  // Mark the current user’s activities as read\r\n  const markActivitiesRead = useCallback(() => {\r\n    updateActivities(activities =>\r\n      activities.map(activity => ({ ...activity, read: true }))\r\n    )\r\n  }, [updateActivities])\r\n\r\n  // Total number of unread activities\r\n  const unreadCount = useMemo(() => {\r\n    return activities.reduce((count, { read }) => count + Number(!read), 0)\r\n  }, [activities])\r\n\r\n  const updateActivitiesFromStorage = useCallback(() => {\r\n    if (!storedList.current) {\r\n      return\r\n    }\r\n\r\n    const activitiesFromStorage = storedList.current.getItems()\r\n\r\n    // We will diff activities from storage and activites from state to prevent loops in the useEffect below\r\n    const activitiesChanged =\r\n      activities.length !== activitiesFromStorage.length ||\r\n      activitiesFromStorage.filter(\r\n        ({ transactionHash }) =>\r\n          activities.findIndex(\r\n            activity => activity.transactionHash === transactionHash\r\n          ) === -1\r\n      ) > 0\r\n\r\n    if (activitiesChanged) {\r\n      setActivities(activitiesFromStorage)\r\n    }\r\n  }, [activities])\r\n\r\n  // Triggered every time the account changes\r\n  useEffect(() => {\r\n    if (!account) {\r\n      return\r\n    }\r\n\r\n    let cancelled = false\r\n    storedList.current = getStoredList(account)\r\n    updateActivitiesFromStorage()\r\n\r\n    activities.forEach(async activity => {\r\n      const status = await getActivityFinalStatus(ethers, activity)\r\n      if (!cancelled && status !== activity.status) {\r\n        updateActivityStatus(activity.transactionHash, status)\r\n      }\r\n    })\r\n\r\n    return () => {\r\n      cancelled = true\r\n    }\r\n  }, [\r\n    account,\r\n    activities,\r\n    ethers,\r\n    updateActivitiesFromStorage,\r\n    updateActivityStatus,\r\n  ])\r\n\r\n  return (\r\n    <ActivityContext.Provider\r\n      value={{\r\n        activities,\r\n        addActivity,\r\n        clearActivities,\r\n        markActivitiesRead,\r\n        removeActivity,\r\n        unreadCount,\r\n        updateActivities,\r\n      }}\r\n    >\r\n      {children}\r\n    </ActivityContext.Provider>\r\n  )\r\n}\r\n\r\nActivityProvider.propTypes = {\r\n  children: PropTypes.node,\r\n}\r\n\r\nfunction useActivity() {\r\n  return useContext(ActivityContext)\r\n}\r\n\r\nexport { ActivityProvider, useActivity }\r\n"]},"metadata":{},"sourceType":"module"}