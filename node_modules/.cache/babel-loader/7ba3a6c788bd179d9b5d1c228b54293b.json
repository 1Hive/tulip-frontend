{"ast":null,"code":"'use strict';\n\nvar _defineProperty = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncIterator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar BufferList = require('bl/BufferList');\n\nvar lp = require('it-length-prefixed');\n\nvar pipe = require('it-pipe');\n\nvar errCode = require('err-code');\n\nvar NewLine = Buffer.from('\\n');\n\nfunction oneChunk(source) {\n  var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, chunk;\n\n  return _regeneratorRuntime.async(function oneChunk$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _iteratorNormalCompletion = true;\n          _didIteratorError = false;\n          _context.prev = 2;\n          _iterator = _asyncIterator(source);\n\n        case 4:\n          _context.next = 6;\n          return _regeneratorRuntime.awrap(_iterator.next());\n\n        case 6:\n          _step = _context.sent;\n          _iteratorNormalCompletion = _step.done;\n          _context.next = 10;\n          return _regeneratorRuntime.awrap(_step.value);\n\n        case 10:\n          _value = _context.sent;\n\n          if (_iteratorNormalCompletion) {\n            _context.next = 17;\n            break;\n          }\n\n          chunk = _value;\n          return _context.abrupt(\"return\", chunk);\n\n        case 14:\n          _iteratorNormalCompletion = true;\n          _context.next = 4;\n          break;\n\n        case 17:\n          _context.next = 23;\n          break;\n\n        case 19:\n          _context.prev = 19;\n          _context.t0 = _context[\"catch\"](2);\n          _didIteratorError = true;\n          _iteratorError = _context.t0;\n\n        case 23:\n          _context.prev = 23;\n          _context.prev = 24;\n\n          if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n            _context.next = 28;\n            break;\n          }\n\n          _context.next = 28;\n          return _regeneratorRuntime.awrap(_iterator.return());\n\n        case 28:\n          _context.prev = 28;\n\n          if (!_didIteratorError) {\n            _context.next = 31;\n            break;\n          }\n\n          throw _iteratorError;\n\n        case 31:\n          return _context.finish(28);\n\n        case 32:\n          return _context.finish(23);\n\n        case 33:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, [[2, 19, 23, 33], [24,, 28, 32]], Promise);\n}\n\nexports.encode = function (buffer) {\n  return lp.encode.single(new BufferList([buffer, NewLine]));\n}; // `write` encodes and writes a single buffer\n\n\nexports.write = function (writer, buffer) {\n  return writer.push(exports.encode(buffer));\n}; // `writeAll` behaves like `write`, except it encodes an array of items as a single write\n\n\nexports.writeAll = function (writer, buffers) {\n  writer.push(buffers.reduce(function (bl, buffer) {\n    return bl.append(exports.encode(buffer));\n  }, new BufferList()));\n};\n\nexports.read = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(reader) {\n    var _varByteSource;\n\n    var byteLength, varByteSource, onLength, buf;\n    return _regeneratorRuntime.wrap(function _callee$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            byteLength = 1; // Read single byte chunks until the length is known\n\n            varByteSource = (_varByteSource = {}, _defineProperty(_varByteSource, Symbol.asyncIterator, function () {\n              return this;\n            }), _defineProperty(_varByteSource, \"next\", function next() {\n              return reader.next(byteLength);\n            }), _varByteSource); // Once the length has been parsed, read chunk for that length\n\n            onLength = function onLength(l) {\n              byteLength = l;\n            };\n\n            _context2.next = 5;\n            return pipe(varByteSource, lp.decode({\n              onLength: onLength\n            }), oneChunk);\n\n          case 5:\n            buf = _context2.sent;\n\n            if (!(buf.get(buf.length - 1) !== NewLine[0])) {\n              _context2.next = 8;\n              break;\n            }\n\n            throw errCode(new Error('missing newline'), 'ERR_INVALID_MULTISTREAM_SELECT_MESSAGE');\n\n          case 8:\n            return _context2.abrupt(\"return\", buf.shallowSlice(0, -1));\n\n          case 9:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function (_x) {\n    return _ref.apply(this, arguments);\n  };\n}();","map":null,"metadata":{},"sourceType":"script"}