{"ast":null,"code":"'use strict';\n\nvar _inherits = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncIterator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar batch = require('it-batch');\n\nmodule.exports = /*#__PURE__*/_regeneratorRuntime.mark(function trickleReduceToRoot(source, reduce, options) {\n  return _regeneratorRuntime.wrap(function trickleReduceToRoot$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          _context2.next = 2;\n          return trickleStream(source, reduce, options);\n\n        case 2:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, trickleReduceToRoot);\n});\n\nfunction trickleStream(source, reduce, options) {\n  var root, iteration, maxDepth, subTree, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, layer;\n\n  return _regeneratorRuntime.async(function trickleStream$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          iteration = 0;\n          maxDepth = 1;\n          subTree = root = new Root(options.layerRepeat);\n          _iteratorNormalCompletion = true;\n          _didIteratorError = false;\n          _context.prev = 5;\n          _iterator = _asyncIterator(batch(source, options.maxChildrenPerNode));\n\n        case 7:\n          _context.next = 9;\n          return _regeneratorRuntime.awrap(_iterator.next());\n\n        case 9:\n          _step = _context.sent;\n          _iteratorNormalCompletion = _step.done;\n          _context.next = 13;\n          return _regeneratorRuntime.awrap(_step.value);\n\n        case 13:\n          _value = _context.sent;\n\n          if (_iteratorNormalCompletion) {\n            _context.next = 30;\n            break;\n          }\n\n          layer = _value;\n\n          if (!subTree.isFull()) {\n            _context.next = 26;\n            break;\n          }\n\n          if (!(subTree !== root)) {\n            _context.next = 23;\n            break;\n          }\n\n          _context.t0 = root;\n          _context.next = 21;\n          return _regeneratorRuntime.awrap(subTree.reduce(reduce));\n\n        case 21:\n          _context.t1 = _context.sent;\n\n          _context.t0.addChild.call(_context.t0, _context.t1);\n\n        case 23:\n          if (iteration && iteration % options.layerRepeat === 0) {\n            maxDepth++;\n          }\n\n          subTree = new SubTree(maxDepth, options.layerRepeat, iteration);\n          iteration++;\n\n        case 26:\n          subTree.append(layer);\n\n        case 27:\n          _iteratorNormalCompletion = true;\n          _context.next = 7;\n          break;\n\n        case 30:\n          _context.next = 36;\n          break;\n\n        case 32:\n          _context.prev = 32;\n          _context.t2 = _context[\"catch\"](5);\n          _didIteratorError = true;\n          _iteratorError = _context.t2;\n\n        case 36:\n          _context.prev = 36;\n          _context.prev = 37;\n\n          if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n            _context.next = 41;\n            break;\n          }\n\n          _context.next = 41;\n          return _regeneratorRuntime.awrap(_iterator.return());\n\n        case 41:\n          _context.prev = 41;\n\n          if (!_didIteratorError) {\n            _context.next = 44;\n            break;\n          }\n\n          throw _iteratorError;\n\n        case 44:\n          return _context.finish(41);\n\n        case 45:\n          return _context.finish(36);\n\n        case 46:\n          if (!(subTree && subTree !== root)) {\n            _context.next = 52;\n            break;\n          }\n\n          _context.t3 = root;\n          _context.next = 50;\n          return _regeneratorRuntime.awrap(subTree.reduce(reduce));\n\n        case 50:\n          _context.t4 = _context.sent;\n\n          _context.t3.addChild.call(_context.t3, _context.t4);\n\n        case 52:\n          return _context.abrupt(\"return\", root.reduce(reduce));\n\n        case 53:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, [[5, 32, 36, 46], [37,, 41, 45]], Promise);\n}\n\nvar SubTree = /*#__PURE__*/function () {\n  function SubTree(maxDepth, layerRepeat, iteration) {\n    _classCallCheck(this, SubTree);\n\n    this.maxDepth = maxDepth;\n    this.layerRepeat = layerRepeat;\n    this.currentDepth = 1;\n    this.iteration = iteration;\n    this.root = this.node = this.parent = {\n      children: [],\n      depth: this.currentDepth,\n      maxDepth: maxDepth,\n      maxChildren: (this.maxDepth - this.currentDepth) * this.layerRepeat\n    };\n  }\n\n  _createClass(SubTree, [{\n    key: \"isFull\",\n    value: function isFull() {\n      if (!this.root.data) {\n        return false;\n      }\n\n      if (this.currentDepth < this.maxDepth && this.node.maxChildren) {\n        // can descend\n        this._addNextNodeToParent(this.node);\n\n        return false;\n      } // try to find new node from node.parent\n\n\n      var distantRelative = this._findParent(this.node, this.currentDepth);\n\n      if (distantRelative) {\n        this._addNextNodeToParent(distantRelative);\n\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_addNextNodeToParent\",\n    value: function _addNextNodeToParent(parent) {\n      this.parent = parent; // find site for new node\n\n      var nextNode = {\n        children: [],\n        depth: parent.depth + 1,\n        parent: parent,\n        maxDepth: this.maxDepth,\n        maxChildren: Math.floor(parent.children.length / this.layerRepeat) * this.layerRepeat\n      };\n      parent.children.push(nextNode);\n      this.currentDepth = nextNode.depth;\n      this.node = nextNode;\n    }\n  }, {\n    key: \"append\",\n    value: function append(layer) {\n      this.node.data = layer;\n    }\n  }, {\n    key: \"reduce\",\n    value: function reduce(_reduce) {\n      return this._reduce(this.root, _reduce);\n    }\n  }, {\n    key: \"_reduce\",\n    value: function () {\n      var _reduce2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(node, reduce) {\n        var _this = this;\n\n        var children;\n        return _regeneratorRuntime.wrap(function _callee$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                children = [];\n\n                if (!node.children.length) {\n                  _context3.next = 5;\n                  break;\n                }\n\n                _context3.next = 4;\n                return Promise.all(node.children.filter(function (child) {\n                  return child.data;\n                }).map(function (child) {\n                  return _this._reduce(child, reduce);\n                }));\n\n              case 4:\n                children = _context3.sent;\n\n              case 5:\n                return _context3.abrupt(\"return\", reduce(node.data.concat(children)));\n\n              case 6:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function _reduce(_x, _x2) {\n        return _reduce2.apply(this, arguments);\n      }\n\n      return _reduce;\n    }()\n  }, {\n    key: \"_findParent\",\n    value: function _findParent(node, depth) {\n      var parent = node.parent;\n\n      if (!parent || parent.depth === 0) {\n        return;\n      }\n\n      if (parent.children.length === parent.maxChildren || !parent.maxChildren) {\n        // this layer is full, may be able to traverse to a different branch\n        return this._findParent(parent, depth);\n      }\n\n      return parent;\n    }\n  }]);\n\n  return SubTree;\n}();\n\nvar Root = /*#__PURE__*/function (_SubTree) {\n  _inherits(Root, _SubTree);\n\n  var _super = _createSuper(Root);\n\n  function Root(layerRepeat) {\n    var _this2;\n\n    _classCallCheck(this, Root);\n\n    _this2 = _super.call(this, 0, layerRepeat);\n    _this2.root.depth = 0;\n    _this2.currentDepth = 1;\n    return _this2;\n  }\n\n  _createClass(Root, [{\n    key: \"addChild\",\n    value: function addChild(child) {\n      this.root.children.push(child);\n    }\n  }, {\n    key: \"reduce\",\n    value: function reduce(_reduce3) {\n      return _reduce3(this.root.data.concat(this.root.children));\n    }\n  }]);\n\n  return Root;\n}(SubTree);","map":null,"metadata":{},"sourceType":"script"}