{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar debug = require('debug');\n\nvar PeerInfo = require('peer-info');\n\nvar PeerId = require('peer-id');\n\nvar _require = require('./utils'),\n    validateAddrs = _require.validateAddrs;\n\nvar StreamHandler = require('./stream-handler');\n\nvar _require2 = require('../protocol'),\n    CircuitPB = _require2.CircuitRelay;\n\nvar pipe = require('it-pipe');\n\nvar errCode = require('err-code');\n\nvar _require3 = require('../../errors'),\n    Errors = _require3.codes;\n\nvar _require4 = require('./stop'),\n    stop = _require4.stop;\n\nvar multicodec = require('./../multicodec');\n\nvar log = debug('libp2p:circuit:hop');\nlog.error = debug('libp2p:circuit:hop:error');\n\nmodule.exports.handleHop = /*#__PURE__*/function () {\n  var _handleHop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref) {\n    var connection, request, streamHandler, circuit, destinationPeer, destinationConnection, stopRequest, destinationStream, sourceStream;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            connection = _ref.connection, request = _ref.request, streamHandler = _ref.streamHandler, circuit = _ref.circuit;\n\n            if (circuit._options.hop.enabled) {\n              _context.next = 4;\n              break;\n            }\n\n            log('HOP request received but we are not acting as a relay');\n            return _context.abrupt(\"return\", streamHandler.end({\n              type: CircuitPB.Type.STATUS,\n              code: CircuitPB.Status.HOP_CANT_SPEAK_RELAY\n            }));\n\n          case 4:\n            _context.prev = 4;\n            validateAddrs(request, streamHandler);\n            _context.next = 11;\n            break;\n\n          case 8:\n            _context.prev = 8;\n            _context.t0 = _context[\"catch\"](4);\n            return _context.abrupt(\"return\", log.error('invalid hop request via peer %s', connection.remotePeer.toB58String(), _context.t0));\n\n          case 11:\n            // Get the connection to the destination (stop) peer\n            destinationPeer = new PeerId(request.dstPeer.id);\n            destinationConnection = circuit._registrar.getConnection(new PeerInfo(destinationPeer));\n\n            if (!(!destinationConnection && !circuit._options.hop.active)) {\n              _context.next = 16;\n              break;\n            }\n\n            log('HOP request received but we are not connected to the destination peer');\n            return _context.abrupt(\"return\", streamHandler.end({\n              type: CircuitPB.Type.STATUS,\n              code: CircuitPB.Status.HOP_NO_CONN_TO_DST\n            }));\n\n          case 16:\n            // TODO: Handle being an active relay\n            // Handle the incoming HOP request by performing a STOP request\n            stopRequest = {\n              type: CircuitPB.Type.STOP,\n              dstPeer: request.dstPeer,\n              srcPeer: request.srcPeer\n            };\n            _context.prev = 17;\n            _context.next = 20;\n            return stop({\n              connection: destinationConnection,\n              request: stopRequest,\n              circuit: circuit\n            });\n\n          case 20:\n            destinationStream = _context.sent;\n            _context.next = 26;\n            break;\n\n          case 23:\n            _context.prev = 23;\n            _context.t1 = _context[\"catch\"](17);\n            return _context.abrupt(\"return\", log.error(_context.t1));\n\n          case 26:\n            log('hop request from %s is valid', connection.remotePeer.toB58String());\n            streamHandler.write({\n              type: CircuitPB.Type.STATUS,\n              code: CircuitPB.Status.SUCCESS\n            });\n            sourceStream = streamHandler.rest(); // Short circuit the two streams to create the relayed connection\n\n            return _context.abrupt(\"return\", pipe(sourceStream, destinationStream, sourceStream));\n\n          case 30:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[4, 8], [17, 23]]);\n  }));\n\n  function handleHop(_x) {\n    return _handleHop.apply(this, arguments);\n  }\n\n  return handleHop;\n}();\n/**\n * Performs a HOP request to a relay peer, to request a connection to another\n * peer. A new, virtual, connection will be created between the two via the relay.\n *\n * @param {object} options\n * @param {Connection} options.connection Connection to the relay\n * @param {*} options.request\n * @param {Circuit} options.circuit\n * @returns {Promise<Connection>}\n */\n\n\nmodule.exports.hop = /*#__PURE__*/function () {\n  var _hop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref2) {\n    var connection, request, _yield$connection$new, stream, streamHandler, response;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            connection = _ref2.connection, request = _ref2.request;\n            _context2.next = 3;\n            return connection.newStream([multicodec.relay]);\n\n          case 3:\n            _yield$connection$new = _context2.sent;\n            stream = _yield$connection$new.stream;\n            // Send the HOP request\n            streamHandler = new StreamHandler({\n              stream: stream\n            });\n            streamHandler.write(request);\n            _context2.next = 9;\n            return streamHandler.read();\n\n          case 9:\n            response = _context2.sent;\n\n            if (!(response.code === CircuitPB.Status.SUCCESS)) {\n              _context2.next = 13;\n              break;\n            }\n\n            log('hop request was successful');\n            return _context2.abrupt(\"return\", streamHandler.rest());\n\n          case 13:\n            log('hop request failed with code %d, closing stream', response.code);\n            streamHandler.close();\n            throw errCode(new Error(\"HOP request failed with code \".concat(response.code)), Errors.ERR_HOP_REQUEST_FAILED);\n\n          case 16:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  function hop(_x2) {\n    return _hop.apply(this, arguments);\n  }\n\n  return hop;\n}();\n/**\n * Creates an unencoded CAN_HOP response based on the Circuits configuration\n * @private\n */\n\n\nmodule.exports.handleCanHop = function handleCanHop(_ref3) {\n  var connection = _ref3.connection,\n      streamHandler = _ref3.streamHandler,\n      circuit = _ref3.circuit;\n  var canHop = circuit._options.hop.enabled;\n  log('can hop (%s) request from %s', canHop, connection.remotePeer.toB58String());\n  streamHandler.end({\n    type: CircuitPB.Type.STATUS,\n    code: canHop ? CircuitPB.Status.SUCCESS : CircuitPB.Status.HOP_CANT_SPEAK_RELAY\n  });\n};","map":null,"metadata":{},"sourceType":"script"}