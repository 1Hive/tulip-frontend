{"ast":null,"code":"var _jsxFileName = \"/Users/fabianmolina/Documents/1hive/tulip-frontend/src/providers/ActivityProvider.js\";\nimport React, { useCallback, useContext, useEffect, useMemo, useRef, useState } from 'react';\nimport PropTypes from 'prop-types';\nimport StoredList from '../StoredList';\nimport { getNetworkType } from '../lib/web3-utils';\nimport { MINUTE } from '../utils/date-utils';\nimport { useWallet } from './Wallet';\nimport { ACTIVITY_STATUS_CONFIRMED, ACTIVITY_STATUS_FAILED, ACTIVITY_STATUS_PENDING, ACTIVITY_STATUS_TIMED_OUT } from '../components/Activity/activity-statuses';\nimport actions from '../actions/court-action-types';\nconst ActivityContext = /*#__PURE__*/React.createContext(); // Only used to serialize / deserialize the symbols\n\nconst StatusSymbolsByName = new Map(Object.entries({\n  ACTIVITY_STATUS_CONFIRMED,\n  ACTIVITY_STATUS_FAILED,\n  ACTIVITY_STATUS_PENDING,\n  ACTIVITY_STATUS_TIMED_OUT\n}));\nconst TypeSymbolsByName = new Map(Object.entries(actions));\nconst TIMEOUT_DURATION = 10 * MINUTE;\n\nfunction getStoredList(account) {\n  return new StoredList(`activity:${getNetworkType()}:${account}`, {\n    preStringify: activity => ({ ...activity,\n      status: activity.status.description.replace('ACTIVITY_STATUS_', ''),\n      type: activity.type.description\n    }),\n    postParse: activity => ({ ...activity,\n      status: StatusSymbolsByName.get(`ACTIVITY_STATUS_${activity.status}`),\n      type: TypeSymbolsByName.get(activity.type)\n    })\n  });\n}\n\nasync function getActivityFinalStatus(ethers, {\n  createdAt,\n  transactionHash,\n  status\n}) {\n  if (status !== ACTIVITY_STATUS_PENDING) {\n    return status;\n  }\n\n  const now = Date.now();\n  return Promise.race([// Get the transaction status once mined\n  ethers.getTransaction(String(transactionHash)).then(tx => {\n    // tx is null if no tx was found\n    if (!tx) {\n      throw new Error('No transaction found');\n    }\n\n    return tx.wait().then(receipt => {\n      return receipt.blockNumber ? ACTIVITY_STATUS_CONFIRMED : ACTIVITY_STATUS_FAILED;\n    });\n  }).catch(() => {\n    return ACTIVITY_STATUS_FAILED;\n  }), // Timeout after 10 minutes\n  new Promise(resolve => {\n    if (now - createdAt > TIMEOUT_DURATION) {\n      return ACTIVITY_STATUS_TIMED_OUT;\n    }\n\n    setTimeout(() => {\n      resolve(ACTIVITY_STATUS_TIMED_OUT);\n    }, TIMEOUT_DURATION - (now - createdAt));\n  })]);\n}\n\nfunction ActivityProvider({\n  children\n}) {\n  const [activities, setActivities] = useState([]);\n  const storedList = useRef(null);\n  const wallet = useWallet();\n  const {\n    account,\n    ethers\n  } = wallet; // Update the activities, ensuring the activities\n  // are updated in the stored list and in the state.\n\n  const updateActivities = useCallback(cb => {\n    const newActivities = cb(activities);\n    setActivities(newActivities);\n\n    if (storedList.current) {\n      storedList.current.update(newActivities);\n    }\n  }, [activities]); // Add a single activity.\n\n  const addActivity = useCallback(async (tx, // see types defined in ../actions/court-action-types.js\n  type, description = '') => {\n    // tx might be a promise resolving into a tx\n    tx = await tx;\n    updateActivities(activities => [...activities, {\n      createdAt: Date.now(),\n      description,\n      from: tx.from,\n      nonce: tx.nonce,\n      read: false,\n      status: ACTIVITY_STATUS_PENDING,\n      type,\n      to: tx.to,\n      transactionHash: tx.hash\n    }]);\n    return tx;\n  }, [updateActivities]); // Clear a single activity\n\n  const removeActivity = useCallback(transactionHash => {\n    updateActivities(activities => activities.filter(activity => activity.transactionHash !== transactionHash));\n  }, [updateActivities]); // Clear all non pending activities − we don’t clear\n  // pending because we’re awaiting state change.\n\n  const clearActivities = useCallback(() => {\n    updateActivities(activities => activities.filter(activity => activity.status === ACTIVITY_STATUS_PENDING));\n  }, [updateActivities]); // Update the status of a single activity,\n  // using its transaction hash.\n\n  const updateActivityStatus = useCallback((hash, status) => {\n    updateActivities(activities => activities.map(activity => {\n      if (activity.transactionHash !== hash) {\n        return activity;\n      }\n\n      return { ...activity,\n        read: false,\n        status\n      };\n    }));\n  }, [updateActivities]); // Mark the current user’s activities as read\n\n  const markActivitiesRead = useCallback(() => {\n    updateActivities(activities => activities.map(activity => ({ ...activity,\n      read: true\n    })));\n  }, [updateActivities]); // Total number of unread activities\n\n  const unreadCount = useMemo(() => {\n    return activities.reduce((count, {\n      read\n    }) => count + Number(!read), 0);\n  }, [activities]);\n  const updateActivitiesFromStorage = useCallback(() => {\n    if (!storedList.current) {\n      return;\n    }\n\n    const activitiesFromStorage = storedList.current.getItems(); // We will diff activities from storage and activites from state to prevent loops in the useEffect below\n\n    const activitiesChanged = activities.length !== activitiesFromStorage.length || activitiesFromStorage.filter(({\n      transactionHash\n    }) => activities.findIndex(activity => activity.transactionHash === transactionHash) === -1) > 0;\n\n    if (activitiesChanged) {\n      setActivities(activitiesFromStorage);\n    }\n  }, [activities]); // Triggered every time the account changes\n\n  useEffect(() => {\n    if (!account) {\n      return;\n    }\n\n    let cancelled = false;\n    storedList.current = getStoredList(account);\n    updateActivitiesFromStorage();\n    activities.forEach(async activity => {\n      const status = await getActivityFinalStatus(ethers, activity);\n\n      if (!cancelled && status !== activity.status) {\n        updateActivityStatus(activity.transactionHash, status);\n      }\n    });\n    return () => {\n      cancelled = true;\n    };\n  }, [account, activities, ethers, updateActivitiesFromStorage, updateActivityStatus]);\n  return /*#__PURE__*/React.createElement(ActivityContext.Provider, {\n    value: {\n      activities,\n      addActivity,\n      clearActivities,\n      markActivitiesRead,\n      removeActivity,\n      unreadCount,\n      updateActivities\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 244,\n      columnNumber: 5\n    }\n  }, children);\n}\n\nActivityProvider.propTypes = {\n  children: PropTypes.node\n};\n\nfunction useActivity() {\n  return useContext(ActivityContext);\n}\n\nexport { ActivityProvider, useActivity };","map":{"version":3,"sources":["/Users/fabianmolina/Documents/1hive/tulip-frontend/src/providers/ActivityProvider.js"],"names":["React","useCallback","useContext","useEffect","useMemo","useRef","useState","PropTypes","StoredList","getNetworkType","MINUTE","useWallet","ACTIVITY_STATUS_CONFIRMED","ACTIVITY_STATUS_FAILED","ACTIVITY_STATUS_PENDING","ACTIVITY_STATUS_TIMED_OUT","actions","ActivityContext","createContext","StatusSymbolsByName","Map","Object","entries","TypeSymbolsByName","TIMEOUT_DURATION","getStoredList","account","preStringify","activity","status","description","replace","type","postParse","get","getActivityFinalStatus","ethers","createdAt","transactionHash","now","Date","Promise","race","getTransaction","String","then","tx","Error","wait","receipt","blockNumber","catch","resolve","setTimeout","ActivityProvider","children","activities","setActivities","storedList","wallet","updateActivities","cb","newActivities","current","update","addActivity","from","nonce","read","to","hash","removeActivity","filter","clearActivities","updateActivityStatus","map","markActivitiesRead","unreadCount","reduce","count","Number","updateActivitiesFromStorage","activitiesFromStorage","getItems","activitiesChanged","length","findIndex","cancelled","forEach","propTypes","node","useActivity"],"mappings":"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","sourcesContent":["import React, {\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from 'react'\nimport PropTypes from 'prop-types'\nimport StoredList from '../StoredList'\nimport { getNetworkType } from '../lib/web3-utils'\nimport { MINUTE } from '../utils/date-utils'\nimport { useWallet } from './Wallet'\nimport {\n  ACTIVITY_STATUS_CONFIRMED,\n  ACTIVITY_STATUS_FAILED,\n  ACTIVITY_STATUS_PENDING,\n  ACTIVITY_STATUS_TIMED_OUT,\n} from '../components/Activity/activity-statuses'\nimport actions from '../actions/court-action-types'\n\nconst ActivityContext = React.createContext()\n\n// Only used to serialize / deserialize the symbols\nconst StatusSymbolsByName = new Map(\n  Object.entries({\n    ACTIVITY_STATUS_CONFIRMED,\n    ACTIVITY_STATUS_FAILED,\n    ACTIVITY_STATUS_PENDING,\n    ACTIVITY_STATUS_TIMED_OUT,\n  })\n)\n\nconst TypeSymbolsByName = new Map(Object.entries(actions))\n\nconst TIMEOUT_DURATION = 10 * MINUTE\n\nfunction getStoredList(account) {\n  return new StoredList(`activity:${getNetworkType()}:${account}`, {\n    preStringify: activity => ({\n      ...activity,\n      status: activity.status.description.replace('ACTIVITY_STATUS_', ''),\n      type: activity.type.description,\n    }),\n    postParse: activity => ({\n      ...activity,\n      status: StatusSymbolsByName.get(`ACTIVITY_STATUS_${activity.status}`),\n      type: TypeSymbolsByName.get(activity.type),\n    }),\n  })\n}\n\nasync function getActivityFinalStatus(\n  ethers,\n  { createdAt, transactionHash, status }\n) {\n  if (status !== ACTIVITY_STATUS_PENDING) {\n    return status\n  }\n\n  const now = Date.now()\n\n  return Promise.race([\n    // Get the transaction status once mined\n    ethers\n      .getTransaction(String(transactionHash))\n      .then(tx => {\n        // tx is null if no tx was found\n        if (!tx) {\n          throw new Error('No transaction found')\n        }\n        return tx.wait().then(receipt => {\n          return receipt.blockNumber\n            ? ACTIVITY_STATUS_CONFIRMED\n            : ACTIVITY_STATUS_FAILED\n        })\n      })\n      .catch(() => {\n        return ACTIVITY_STATUS_FAILED\n      }),\n\n    // Timeout after 10 minutes\n    new Promise(resolve => {\n      if (now - createdAt > TIMEOUT_DURATION) {\n        return ACTIVITY_STATUS_TIMED_OUT\n      }\n      setTimeout(() => {\n        resolve(ACTIVITY_STATUS_TIMED_OUT)\n      }, TIMEOUT_DURATION - (now - createdAt))\n    }),\n  ])\n}\n\nfunction ActivityProvider({ children }) {\n  const [activities, setActivities] = useState([])\n  const storedList = useRef(null)\n  const wallet = useWallet()\n  const { account, ethers } = wallet\n\n  // Update the activities, ensuring the activities\n  // are updated in the stored list and in the state.\n  const updateActivities = useCallback(\n    cb => {\n      const newActivities = cb(activities)\n      setActivities(newActivities)\n      if (storedList.current) {\n        storedList.current.update(newActivities)\n      }\n    },\n    [activities]\n  )\n\n  // Add a single activity.\n  const addActivity = useCallback(\n    async (\n      tx,\n\n      // see types defined in ../actions/court-action-types.js\n      type,\n      description = ''\n    ) => {\n      // tx might be a promise resolving into a tx\n      tx = await tx\n\n      updateActivities(activities => [\n        ...activities,\n        {\n          createdAt: Date.now(),\n          description,\n          from: tx.from,\n          nonce: tx.nonce,\n          read: false,\n          status: ACTIVITY_STATUS_PENDING,\n          type,\n          to: tx.to,\n          transactionHash: tx.hash,\n        },\n      ])\n\n      return tx\n    },\n    [updateActivities]\n  )\n\n  // Clear a single activity\n  const removeActivity = useCallback(\n    transactionHash => {\n      updateActivities(activities =>\n        activities.filter(\n          activity => activity.transactionHash !== transactionHash\n        )\n      )\n    },\n    [updateActivities]\n  )\n\n  // Clear all non pending activities − we don’t clear\n  // pending because we’re awaiting state change.\n  const clearActivities = useCallback(() => {\n    updateActivities(activities =>\n      activities.filter(activity => activity.status === ACTIVITY_STATUS_PENDING)\n    )\n  }, [updateActivities])\n\n  // Update the status of a single activity,\n  // using its transaction hash.\n  const updateActivityStatus = useCallback(\n    (hash, status) => {\n      updateActivities(activities =>\n        activities.map(activity => {\n          if (activity.transactionHash !== hash) {\n            return activity\n          }\n          return { ...activity, read: false, status }\n        })\n      )\n    },\n    [updateActivities]\n  )\n\n  // Mark the current user’s activities as read\n  const markActivitiesRead = useCallback(() => {\n    updateActivities(activities =>\n      activities.map(activity => ({ ...activity, read: true }))\n    )\n  }, [updateActivities])\n\n  // Total number of unread activities\n  const unreadCount = useMemo(() => {\n    return activities.reduce((count, { read }) => count + Number(!read), 0)\n  }, [activities])\n\n  const updateActivitiesFromStorage = useCallback(() => {\n    if (!storedList.current) {\n      return\n    }\n\n    const activitiesFromStorage = storedList.current.getItems()\n\n    // We will diff activities from storage and activites from state to prevent loops in the useEffect below\n    const activitiesChanged =\n      activities.length !== activitiesFromStorage.length ||\n      activitiesFromStorage.filter(\n        ({ transactionHash }) =>\n          activities.findIndex(\n            activity => activity.transactionHash === transactionHash\n          ) === -1\n      ) > 0\n\n    if (activitiesChanged) {\n      setActivities(activitiesFromStorage)\n    }\n  }, [activities])\n\n  // Triggered every time the account changes\n  useEffect(() => {\n    if (!account) {\n      return\n    }\n\n    let cancelled = false\n    storedList.current = getStoredList(account)\n    updateActivitiesFromStorage()\n\n    activities.forEach(async activity => {\n      const status = await getActivityFinalStatus(ethers, activity)\n      if (!cancelled && status !== activity.status) {\n        updateActivityStatus(activity.transactionHash, status)\n      }\n    })\n\n    return () => {\n      cancelled = true\n    }\n  }, [\n    account,\n    activities,\n    ethers,\n    updateActivitiesFromStorage,\n    updateActivityStatus,\n  ])\n\n  return (\n    <ActivityContext.Provider\n      value={{\n        activities,\n        addActivity,\n        clearActivities,\n        markActivitiesRead,\n        removeActivity,\n        unreadCount,\n        updateActivities,\n      }}\n    >\n      {children}\n    </ActivityContext.Provider>\n  )\n}\n\nActivityProvider.propTypes = {\n  children: PropTypes.node,\n}\n\nfunction useActivity() {\n  return useContext(ActivityContext)\n}\n\nexport { ActivityProvider, useActivity }\n"]},"metadata":{},"sourceType":"module"}