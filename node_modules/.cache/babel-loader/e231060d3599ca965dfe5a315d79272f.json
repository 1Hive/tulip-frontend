{"ast":null,"code":"'use strict';\n\nconst errcode = require('err-code');\n\nconst pTimeout = require('p-timeout');\n\nconst PeerId = require('peer-id');\n\nconst PeerInfo = require('peer-info');\n\nconst crypto = require('libp2p-crypto');\n\nconst c = require('../constants');\n\nconst Message = require('../message');\n\nconst Query = require('../query');\n\nconst utils = require('../utils');\n\nmodule.exports = dht => {\n  /**\n   * Look if we are connected to a peer with the given id.\n   * Returns the `PeerInfo` for it, if found, otherwise `undefined`.\n   * @param {PeerId} peer\n   * @returns {Promise<PeerInfo>}\n   */\n  const findPeerLocal = async peer => {\n    dht._log('findPeerLocal %s', peer.toB58String());\n\n    const p = await dht.routingTable.find(peer);\n\n    if (!p || !dht.peerStore.has(p)) {\n      return;\n    }\n\n    return dht.peerStore.get(p);\n  };\n  /**\n   * Get a value via rpc call for the given parameters.\n   * @param {PeerId} peer\n   * @param {Buffer} key\n   * @returns {Promise<Message>}\n   * @private\n   */\n\n\n  const getValueSingle = async (peer, key) => {\n    // eslint-disable-line require-await\n    const msg = new Message(Message.TYPES.GET_VALUE, key, 0);\n    return dht.network.sendRequest(peer, msg);\n  };\n  /**\n   * Find close peers for a given peer\n   * @param {Buffer} key\n   * @param {PeerId} peer\n   * @returns {Promise<Array<PeerInfo>>}\n   * @private\n   */\n\n\n  const closerPeersSingle = async (key, peer) => {\n    dht._log('closerPeersSingle %b from %s', key, peer.toB58String());\n\n    const msg = await dht.peerRouting._findPeerSingle(peer, new PeerId(key));\n    return msg.closerPeers.filter(pInfo => !dht._isSelf(pInfo.id)).map(pInfo => dht.peerStore.put(pInfo));\n  };\n  /**\n   * Get the public key directly from a node.\n   * @param {PeerId} peer\n   * @returns {Promise<PublicKey>}\n   * @private\n   */\n\n\n  const getPublicKeyFromNode = async peer => {\n    const pkKey = utils.keyForPublicKey(peer);\n    const msg = await getValueSingle(peer, pkKey);\n\n    if (!msg.record || !msg.record.value) {\n      throw errcode(`Node not responding with its public key: ${peer.toB58String()}`, 'ERR_INVALID_RECORD');\n    }\n\n    const recPeer = PeerId.createFromPubKey(msg.record.value); // compare hashes of the pub key\n\n    if (!recPeer.isEqual(peer)) {\n      throw errcode('public key does not match id', 'ERR_PUBLIC_KEY_DOES_NOT_MATCH_ID');\n    }\n\n    return recPeer.pubKey;\n  };\n\n  return {\n    /**\n     * Ask peer `peer` if they know where the peer with id `target` is.\n     * @param {PeerId} peer\n     * @param {PeerId} target\n     * @returns {Promise<Message>}\n     * @private\n     */\n    async _findPeerSingle(peer, target) {\n      // eslint-disable-line require-await\n      dht._log('findPeerSingle %s', peer.toB58String());\n\n      const msg = new Message(Message.TYPES.FIND_NODE, target.id, 0);\n      return dht.network.sendRequest(peer, msg);\n    },\n\n    /**\n     * Search for a peer with the given ID.\n     * @param {PeerId} id\n     * @param {Object} options - findPeer options\n     * @param {number} options.timeout - how long the query should maximally run, in milliseconds (default: 60000)\n     * @returns {Promise<PeerInfo>}\n     */\n    async findPeer(id, options = {}) {\n      options.timeout = options.timeout || c.minute;\n\n      dht._log('findPeer %s', id.toB58String()); // Try to find locally\n\n\n      const pi = await findPeerLocal(id); // already got it\n\n      if (pi != null) {\n        dht._log('found local');\n\n        return pi;\n      }\n\n      const key = await utils.convertPeerId(id);\n      const peers = dht.routingTable.closestPeers(key, dht.kBucketSize);\n\n      if (peers.length === 0) {\n        throw errcode(new Error('Peer lookup failed'), 'ERR_LOOKUP_FAILED');\n      } // sanity check\n\n\n      const match = peers.find(p => p.isEqual(id));\n\n      if (match && dht.peerStore.has(id)) {\n        dht._log('found in peerStore');\n\n        return dht.peerStore.get(id);\n      } // query the network\n\n\n      const query = new Query(dht, id.id, () => {\n        // There is no distinction between the disjoint paths,\n        // so there are no per-path variables in dht scope.\n        // Just return the actual query function.\n        return async peer => {\n          const msg = await this._findPeerSingle(peer, id);\n          const match = msg.closerPeers.find(p => p.id.isEqual(id)); // found it\n\n          if (match) {\n            return {\n              peer: match,\n              queryComplete: true\n            };\n          }\n\n          return {\n            closerPeers: msg.closerPeers\n          };\n        };\n      });\n      let error, result;\n\n      try {\n        result = await pTimeout(query.run(peers), options.timeout);\n      } catch (err) {\n        error = err;\n      }\n\n      query.stop();\n      if (error) throw error;\n      let success = false;\n      result.paths.forEach(result => {\n        if (result.success) {\n          success = true;\n          dht.peerStore.put(result.peer);\n        }\n      });\n\n      dht._log('findPeer %s: %s', id.toB58String(), success);\n\n      if (!success) {\n        throw errcode(new Error('No peer found'), 'ERR_NOT_FOUND');\n      }\n\n      return dht.peerStore.get(id);\n    },\n\n    /**\n     * Kademlia 'node lookup' operation.\n     * @param {Buffer} key\n     * @param {Object} [options]\n     * @param {boolean} [options.shallow] shallow query (default: false)\n     * @returns {AsyncIterable<PeerId>}\n     */\n    async *getClosestPeers(key, options = {\n      shallow: false\n    }) {\n      dht._log('getClosestPeers to %b', key);\n\n      const id = await utils.convertBuffer(key);\n      const tablePeers = dht.routingTable.closestPeers(id, dht.kBucketSize);\n      const q = new Query(dht, key, () => {\n        // There is no distinction between the disjoint paths,\n        // so there are no per-path variables in dht scope.\n        // Just return the actual query function.\n        return async peer => {\n          const closer = await closerPeersSingle(key, peer);\n          return {\n            closerPeers: closer,\n            pathComplete: options.shallow ? true : undefined\n          };\n        };\n      });\n      const res = await q.run(tablePeers);\n\n      if (!res || !res.finalSet) {\n        return [];\n      }\n\n      const sorted = await utils.sortClosestPeers(Array.from(res.finalSet), id);\n\n      for (const pId of sorted.slice(0, dht.kBucketSize)) {\n        yield pId;\n      }\n    },\n\n    /**\n     * Get the public key for the given peer id.\n     * @param {PeerId} peer\n     * @returns {Promise<PubKey>}\n     */\n    async getPublicKey(peer) {\n      dht._log('getPublicKey %s', peer.toB58String()); // local check\n\n\n      let info;\n\n      if (dht.peerStore.has(peer)) {\n        info = dht.peerStore.get(peer);\n\n        if (info && info.id.pubKey) {\n          dht._log('getPublicKey: found local copy');\n\n          return info.id.pubKey;\n        }\n      } else {\n        info = dht.peerStore.put(new PeerInfo(peer));\n      } // try the node directly\n\n\n      let pk;\n\n      try {\n        pk = await getPublicKeyFromNode(peer);\n      } catch (err) {\n        // try dht directly\n        const pkKey = utils.keyForPublicKey(peer);\n        const value = await dht.get(pkKey);\n        pk = crypto.keys.unmarshalPublicKey(value);\n      }\n\n      info.id = new PeerId(peer.id, null, pk);\n      dht.peerStore.put(info);\n      return pk;\n    }\n\n  };\n};","map":null,"metadata":{},"sourceType":"script"}