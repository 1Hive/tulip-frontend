{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar START_MASKS = [255, 254, 252, 248, 240, 224, 192, 128];\nvar STOP_MASKS = [1, 3, 7, 15, 31, 63, 127, 255];\n\nmodule.exports = /*#__PURE__*/function () {\n  function ConsumableBuffer(value) {\n    _classCallCheck(this, ConsumableBuffer);\n\n    this._value = value;\n    this._currentBytePos = value.length - 1;\n    this._currentBitPos = 7;\n  }\n\n  _createClass(ConsumableBuffer, [{\n    key: \"availableBits\",\n    value: function availableBits() {\n      return this._currentBitPos + 1 + this._currentBytePos * 8;\n    }\n  }, {\n    key: \"totalBits\",\n    value: function totalBits() {\n      return this._value.length * 8;\n    }\n  }, {\n    key: \"take\",\n    value: function take(bits) {\n      var pendingBits = bits;\n      var result = 0;\n\n      while (pendingBits && this._haveBits()) {\n        var byte = this._value[this._currentBytePos];\n        var availableBits = this._currentBitPos + 1;\n        var taking = Math.min(availableBits, pendingBits);\n        var value = byteBitsToInt(byte, availableBits - taking, taking);\n        result = (result << taking) + value;\n        pendingBits -= taking;\n        this._currentBitPos -= taking;\n\n        if (this._currentBitPos < 0) {\n          this._currentBitPos = 7;\n          this._currentBytePos--;\n        }\n      }\n\n      return result;\n    }\n  }, {\n    key: \"untake\",\n    value: function untake(bits) {\n      this._currentBitPos += bits;\n\n      while (this._currentBitPos > 7) {\n        this._currentBitPos -= 8;\n        this._currentBytePos += 1;\n      }\n    }\n  }, {\n    key: \"_haveBits\",\n    value: function _haveBits() {\n      return this._currentBytePos >= 0;\n    }\n  }]);\n\n  return ConsumableBuffer;\n}();\n\nfunction byteBitsToInt(byte, start, length) {\n  var mask = maskFor(start, length);\n  return (byte & mask) >>> start;\n}\n\nfunction maskFor(start, length) {\n  return START_MASKS[start] & STOP_MASKS[Math.min(length + start - 1, 7)];\n}","map":null,"metadata":{},"sourceType":"script"}