{"ast":null,"code":"'use strict';\n\nconst errCode = require('err-code');\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst globalThis = require('ipfs-utils/src/globalthis');\n/*\n * Transform one of:\n *\n * ```\n * Bytes (Buffer|ArrayBuffer|TypedArray) [single file]\n * Bloby (Blob|File) [single file]\n * String [single file]\n * { path, content: Bytes } [single file]\n * { path, content: Bloby } [single file]\n * { path, content: String } [single file]\n * { path, content: Iterable<Number> } [single file]\n * { path, content: Iterable<Bytes> } [single file]\n * { path, content: AsyncIterable<Bytes> } [single file]\n * Iterable<Number> [single file]\n * Iterable<Bytes> [single file]\n * Iterable<Bloby> [multiple files]\n * Iterable<String> [multiple files]\n * Iterable<{ path, content: Bytes }> [multiple files]\n * Iterable<{ path, content: Bloby }> [multiple files]\n * Iterable<{ path, content: String }> [multiple files]\n * Iterable<{ path, content: Iterable<Number> }> [multiple files]\n * Iterable<{ path, content: Iterable<Bytes> }> [multiple files]\n * Iterable<{ path, content: AsyncIterable<Bytes> }> [multiple files]\n * AsyncIterable<Bytes> [single file]\n * AsyncIterable<Bloby> [multiple files]\n * AsyncIterable<String> [multiple files]\n * AsyncIterable<{ path, content: Bytes }> [multiple files]\n * AsyncIterable<{ path, content: Bloby }> [multiple files]\n * AsyncIterable<{ path, content: String }> [multiple files]\n * AsyncIterable<{ path, content: Iterable<Number> }> [multiple files]\n * AsyncIterable<{ path, content: Iterable<Bytes> }> [multiple files]\n * AsyncIterable<{ path, content: AsyncIterable<Bytes> }> [multiple files]\n * ```\n * Into:\n *\n * ```\n * AsyncIterable<{ path, content: AsyncIterable<Buffer> }>\n * ```\n *\n * @param input Object\n * @return AsyncInterable<{ path, content: AsyncIterable<Buffer> }>\n */\n\n\nmodule.exports = function normaliseInput(input) {\n  // must give us something\n  if (input === null || input === undefined) {\n    throw errCode(new Error(`Unexpected input: ${input}`, 'ERR_UNEXPECTED_INPUT'));\n  } // String\n\n\n  if (typeof input === 'string' || input instanceof String) {\n    return async function* () {\n      // eslint-disable-line require-await\n      yield toFileObject(input);\n    }();\n  } // Buffer|ArrayBuffer|TypedArray\n  // Blob|File\n\n\n  if (isBytes(input) || isBloby(input)) {\n    return async function* () {\n      // eslint-disable-line require-await\n      yield toFileObject(input);\n    }();\n  } // Iterable<?>\n\n\n  if (input[Symbol.iterator]) {\n    return async function* () {\n      // eslint-disable-line require-await\n      const iterator = input[Symbol.iterator]();\n      const first = iterator.next();\n      if (first.done) return iterator; // Iterable<Number>\n      // Iterable<Bytes>\n\n      if (Number.isInteger(first.value) || isBytes(first.value)) {\n        yield toFileObject(function* () {\n          yield first.value;\n          yield* iterator;\n        }());\n        return;\n      } // Iterable<Bloby>\n      // Iterable<String>\n      // Iterable<{ path, content }>\n\n\n      if (isFileObject(first.value) || isBloby(first.value) || typeof first.value === 'string') {\n        yield toFileObject(first.value);\n\n        for (const obj of iterator) {\n          yield toFileObject(obj);\n        }\n\n        return;\n      }\n\n      throw errCode(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT');\n    }();\n  } // window.ReadableStream\n\n\n  if (typeof input.getReader === 'function') {\n    return async function* () {\n      for await (const obj of browserStreamToIt(input)) {\n        yield toFileObject(obj);\n      }\n    }();\n  } // AsyncIterable<?>\n\n\n  if (input[Symbol.asyncIterator]) {\n    return async function* () {\n      const iterator = input[Symbol.asyncIterator]();\n      const first = await iterator.next();\n      if (first.done) return iterator; // AsyncIterable<Bytes>\n\n      if (isBytes(first.value)) {\n        yield toFileObject(async function* () {\n          // eslint-disable-line require-await\n          yield first.value;\n          yield* iterator;\n        }());\n        return;\n      } // AsyncIterable<Bloby>\n      // AsyncIterable<String>\n      // AsyncIterable<{ path, content }>\n\n\n      if (isFileObject(first.value) || isBloby(first.value) || typeof first.value === 'string') {\n        yield toFileObject(first.value);\n\n        for await (const obj of iterator) {\n          yield toFileObject(obj);\n        }\n\n        return;\n      }\n\n      throw errCode(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT');\n    }();\n  } // { path, content: ? }\n  // Note: Detected _after_ AsyncIterable<?> because Node.js streams have a\n  // `path` property that passes this check.\n\n\n  if (isFileObject(input)) {\n    return async function* () {\n      // eslint-disable-line require-await\n      yield toFileObject(input);\n    }();\n  }\n\n  throw errCode(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT');\n};\n\nfunction toFileObject(input) {\n  const obj = {\n    path: input.path || '',\n    mode: input.mode,\n    mtime: input.mtime\n  };\n\n  if (input.content) {\n    obj.content = toAsyncIterable(input.content);\n  } else if (!input.path) {\n    // Not already a file object with path or content prop\n    obj.content = toAsyncIterable(input);\n  }\n\n  return obj;\n}\n\nfunction toAsyncIterable(input) {\n  // Bytes | String\n  if (isBytes(input) || typeof input === 'string') {\n    return async function* () {\n      // eslint-disable-line require-await\n      yield toBuffer(input);\n    }();\n  } // Bloby\n\n\n  if (isBloby(input)) {\n    return blobToAsyncGenerator(input);\n  } // Browser stream\n\n\n  if (typeof input.getReader === 'function') {\n    return browserStreamToIt(input);\n  } // Iterator<?>\n\n\n  if (input[Symbol.iterator]) {\n    return async function* () {\n      // eslint-disable-line require-await\n      const iterator = input[Symbol.iterator]();\n      const first = iterator.next();\n      if (first.done) return iterator; // Iterable<Number>\n\n      if (Number.isInteger(first.value)) {\n        yield toBuffer(Array.from(function* () {\n          yield first.value;\n          yield* iterator;\n        }()));\n        return;\n      } // Iterable<Bytes>\n\n\n      if (isBytes(first.value)) {\n        yield toBuffer(first.value);\n\n        for (const chunk of iterator) {\n          yield toBuffer(chunk);\n        }\n\n        return;\n      }\n\n      throw errCode(new Error('Unexpected input: ' + typeof input), 'ERR_UNEXPECTED_INPUT');\n    }();\n  } // AsyncIterable<Bytes>\n\n\n  if (input[Symbol.asyncIterator]) {\n    return async function* () {\n      for await (const chunk of input) {\n        yield toBuffer(chunk);\n      }\n    }();\n  }\n\n  throw errCode(new Error(`Unexpected input: ${input}`), 'ERR_UNEXPECTED_INPUT');\n}\n\nfunction toBuffer(chunk) {\n  return isBytes(chunk) ? chunk : Buffer.from(chunk);\n}\n\nfunction isBytes(obj) {\n  return Buffer.isBuffer(obj) || ArrayBuffer.isView(obj) || obj instanceof ArrayBuffer;\n}\n\nfunction isBloby(obj) {\n  return typeof globalThis.Blob !== 'undefined' && obj instanceof globalThis.Blob;\n} // An object with a path or content property\n\n\nfunction isFileObject(obj) {\n  return typeof obj === 'object' && (obj.path || obj.content);\n}\n\nfunction blobToAsyncGenerator(blob) {\n  if (typeof blob.stream === 'function') {\n    // firefox < 69 does not support blob.stream()\n    return browserStreamToIt(blob.stream());\n  }\n\n  return readBlob(blob);\n}\n\nasync function* browserStreamToIt(stream) {\n  const reader = stream.getReader();\n\n  while (true) {\n    const result = await reader.read();\n\n    if (result.done) {\n      return;\n    }\n\n    yield result.value;\n  }\n}\n\nasync function* readBlob(blob, options) {\n  options = options || {};\n  const reader = new globalThis.FileReader();\n  const chunkSize = options.chunkSize || 1024 * 1024;\n  let offset = options.offset || 0;\n\n  const getNextChunk = () => new Promise((resolve, reject) => {\n    reader.onloadend = e => {\n      const data = e.target.result;\n      resolve(data.byteLength === 0 ? null : data);\n    };\n\n    reader.onerror = reject;\n    const end = offset + chunkSize;\n    const slice = blob.slice(offset, end);\n    reader.readAsArrayBuffer(slice);\n    offset = end;\n  });\n\n  while (true) {\n    const data = await getNextChunk();\n\n    if (data == null) {\n      return;\n    }\n\n    yield Buffer.from(data);\n  }\n}","map":null,"metadata":{},"sourceType":"script"}