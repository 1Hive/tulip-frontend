{"ast":null,"code":"/*!\n * hkdf.js - hkdf for bcrypto\n * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Resources:\n *   https://en.wikipedia.org/wiki/HKDF\n *   https://tools.ietf.org/html/rfc5869\n */\n'use strict';\n\nconst assert = require('./internal/assert');\n/**\n * HKDF\n */\n\n\nclass HKDF {\n  constructor(hash, ikm, salt, info) {\n    assert(hash && typeof hash.id === 'string');\n    this.hash = hash;\n    this.size = hash.size;\n    this.prk = null;\n    this.state = null;\n    this.slab = null;\n    this.save = 0;\n    if (ikm || salt || info) this.init(ikm, salt, info);\n  }\n\n  init(ikm, salt, info) {\n    if (ikm == null) ikm = Buffer.alloc(0);\n    if (salt == null) salt = Buffer.alloc(this.size, 0x00);\n    this.prk = this.hash.mac(ikm, salt);\n    this.reset(info);\n    return this;\n  }\n\n  set(prk, info) {\n    assert(Buffer.isBuffer(prk));\n    assert(prk.length === this.size);\n    this.prk = prk;\n    this.reset(info);\n    return this;\n  }\n\n  reset(info) {\n    if (info == null) info = Buffer.alloc(0);\n    assert(Buffer.isBuffer(info)); // state = prev || info || counter\n\n    const state = Buffer.alloc(this.size + info.length + 1);\n    state.fill(0x00, 0, this.size);\n    info.copy(state, this.size);\n    state[state.length - 1] = 0;\n    this.state = state;\n    this.slab = Buffer.alloc(this.size);\n    this.save = 0;\n    return this;\n  }\n\n  generate(len) {\n    assert(len >>> 0 === len);\n    if (!this.prk || !this.state || !this.slab) throw new Error('HKDF is not initialized.');\n    const left = (255 - this.state[this.state.length - 1]) * this.size;\n    if (len > this.save + left) throw new Error('Too many bytes requested.');\n    const blocks = Math.ceil(Math.max(0, len - this.save) / this.size);\n    const okm = Buffer.alloc(this.save + blocks * this.size);\n    this.slab.copy(okm, 0, 0, this.save);\n\n    for (let i = 0; i < blocks; i++) {\n      let state = this.state;\n      if (state[state.length - 1] === 0) state = state.slice(this.size);\n      assert(state[state.length - 1] !== 255);\n      state[state.length - 1] += 1;\n      const mac = this.hash.mac(state, this.prk);\n      mac.copy(this.state, 0);\n      mac.copy(okm, this.save + i * this.size);\n    }\n\n    this.save = okm.copy(this.slab, 0, len);\n    return okm.slice(0, len);\n  }\n\n  randomBytes(size) {\n    return this.generate(size);\n  }\n\n  static extract(hash, ikm, salt) {\n    assert(hash && typeof hash.id === 'string');\n    if (ikm == null) ikm = Buffer.alloc(0);\n    if (salt == null) salt = Buffer.alloc(hash.size, 0x00);\n    return hash.mac(ikm, salt);\n  }\n\n  static expand(hash, prk, info, len) {\n    const hkdf = new HKDF(hash);\n    return hkdf.set(prk, info).generate(len);\n  }\n\n  static derive(hash, ikm, salt, info, len) {\n    const hkdf = new HKDF(hash);\n    return hkdf.init(ikm, salt, info).generate(len);\n  }\n\n}\n/*\n * Static\n */\n\n\nHKDF.native = 0;\n/*\n * Expose\n */\n\nmodule.exports = HKDF;","map":null,"metadata":{},"sourceType":"script"}