{"ast":null,"code":"/*!\n * aead.js - aead for bcrypto\n * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).\n * https://github.com/bcoin-org/bcrypto\n *\n * Resources:\n *   https://tools.ietf.org/html/rfc7539#section-2.8\n *   https://github.com/openssh/openssh-portable\n */\n'use strict';\n\nconst assert = require('../internal/assert');\n\nconst ChaCha20 = require('./chacha20');\n\nconst Poly1305 = require('./poly1305');\n/**\n * AEAD\n */\n\n\nclass AEAD {\n  /**\n   * Create an AEAD context.\n   * @constructor\n   */\n  constructor() {\n    this.chacha = new ChaCha20();\n    this.poly = new Poly1305();\n    this.key = Buffer.alloc(64);\n    this.mode = -1;\n    this.aadLen = 0;\n    this.cipherLen = 0;\n  }\n  /**\n   * Initialize the AEAD with a key and iv.\n   * @param {Buffer} key\n   * @param {Buffer} iv - IV / packet sequence number.\n   */\n\n\n  init(key, iv) {\n    assert(Buffer.isBuffer(key));\n    assert(Buffer.isBuffer(iv));\n    this.key.fill(0x00);\n    this.chacha.init(key, iv, 0);\n    this.chacha.encrypt(this.key);\n    this.poly.init(this.key);\n    this.mode = 0;\n    this.aadLen = 0;\n    this.cipherLen = 0;\n    return this;\n  }\n  /**\n   * Update the aad (will be finalized\n   * on an encrypt/decrypt call).\n   * @param {Buffer} aad\n   */\n\n\n  aad(data) {\n    if (this.mode === -1) throw new Error('Context is not initialized.');\n    if (this.mode !== 0) throw new Error('Invalid state for aad.');\n    this.poly.update(data);\n    this.aadLen += data.length;\n    return this;\n  }\n  /**\n   * Encrypt a piece of data.\n   * @param {Buffer} data\n   */\n\n\n  encrypt(data) {\n    if (this.mode === -1) throw new Error('Context is not initialized.');\n    if (this.mode !== 0 && this.mode !== 1) throw new Error('Invalid state for encrypt.');\n\n    if (this.mode === 0) {\n      this._pad16(this.aadLen);\n\n      this.mode = 1;\n    }\n\n    this.chacha.encrypt(data);\n    this.poly.update(data);\n    this.cipherLen += data.length;\n    return data;\n  }\n  /**\n   * Decrypt a piece of data.\n   * @param {Buffer} data\n   */\n\n\n  decrypt(data) {\n    assert(Buffer.isBuffer(data));\n    if (this.mode === -1) throw new Error('Context is not initialized.');\n    if (this.mode !== 0 && this.mode !== 2) throw new Error('Invalid state for decrypt.');\n\n    if (this.mode === 0) {\n      this._pad16(this.aadLen);\n\n      this.mode = 2;\n    }\n\n    this.cipherLen += data.length;\n    this.poly.update(data);\n    this.chacha.encrypt(data);\n    return data;\n  }\n  /**\n   * Authenticate data without decrypting.\n   * @param {Buffer} data\n   */\n\n\n  auth(data) {\n    assert(Buffer.isBuffer(data));\n    if (this.mode === -1) throw new Error('Context is not initialized.');\n    if (this.mode !== 0 && this.mode !== 3) throw new Error('Invalid state for auth.');\n\n    if (this.mode === 0) {\n      this._pad16(this.aadLen);\n\n      this.mode = 3;\n    }\n\n    this.cipherLen += data.length;\n    this.poly.update(data);\n    return data;\n  }\n  /**\n   * Finalize the aead and generate a MAC.\n   * @returns {Buffer} MAC\n   */\n\n\n  final() {\n    if (this.mode === -1) throw new Error('Context is not initialized.');\n    const len = Buffer.allocUnsafe(16);\n    writeU64(len, this.aadLen, 0);\n    writeU64(len, this.cipherLen, 8);\n    if (this.mode === 0) this._pad16(this.aadLen);\n\n    this._pad16(this.cipherLen);\n\n    this.poly.update(len);\n    const mac = this.poly.final();\n    this.destroy();\n    return mac;\n  }\n  /**\n   * Destroy the context.\n   */\n\n\n  destroy() {\n    this.chacha.destroy();\n    this.poly.destroy();\n\n    for (let i = 0; i < 64; i++) this.key[i] = 0;\n\n    this.mode = -1;\n    this.aadLen = 0;\n    this.cipherLen = 0;\n    return this;\n  }\n  /**\n   * Finalize and verify MAC against tag.\n   * @param {Buffer} tag\n   * @returns {Boolean}\n   */\n\n\n  verify(tag) {\n    assert(Buffer.isBuffer(tag));\n    assert(tag.length === 16);\n    const mac = this.final();\n    let z = 0;\n\n    for (let i = 0; i < 16; i++) z |= mac[i] ^ tag[i];\n\n    return z - 1 >>> 31 !== 0;\n  }\n  /**\n   * Pad a chunk before updating mac.\n   * @private\n   * @param {Number} size\n   */\n\n\n  _pad16(size) {\n    const pos = size & 15;\n    if (pos === 0) return;\n    const pad = Buffer.allocUnsafe(16 - pos);\n    pad.fill(0x00);\n    this.poly.update(pad);\n  }\n  /**\n   * Encrypt a piece of data.\n   * @param {Buffer} key\n   * @param {Buffer} iv\n   * @param {Buffer} msg\n   * @param {Buffer?} aad\n   * @returns {Buffer} tag\n   */\n\n\n  static encrypt(key, iv, msg, aad) {\n    const aead = new AEAD();\n    aead.init(key, iv);\n    if (aad) aead.aad(aad);\n    aead.encrypt(msg);\n    return aead.final();\n  }\n  /**\n   * Decrypt a piece of data.\n   * @param {Buffer} key\n   * @param {Buffer} iv\n   * @param {Buffer} msg\n   * @param {Buffer} tag\n   * @param {Buffer?} aad\n   * @returns {Boolean}\n   */\n\n\n  static decrypt(key, iv, msg, tag, aad) {\n    const aead = new AEAD();\n    aead.init(key, iv);\n    if (aad) aead.aad(aad);\n    aead.decrypt(msg);\n    return aead.verify(tag);\n  }\n  /**\n   * Authenticate data without decrypting.\n   * @param {Buffer} key\n   * @param {Buffer} iv\n   * @param {Buffer} msg\n   * @param {Buffer} tag\n   * @param {Buffer?} aad\n   * @returns {Boolean}\n   */\n\n\n  static auth(key, iv, msg, tag, aad) {\n    const aead = new AEAD();\n    aead.init(key, iv);\n    if (aad) aead.aad(aad);\n    aead.auth(msg);\n    return aead.verify(tag);\n  }\n\n}\n/*\n * Static\n */\n\n\nAEAD.native = ChaCha20.native;\n/*\n * Helpers\n */\n\nfunction writeU32(dst, num, off) {\n  dst[off++] = num;\n  num >>>= 8;\n  dst[off++] = num;\n  num >>>= 8;\n  dst[off++] = num;\n  num >>>= 8;\n  dst[off++] = num;\n  return off;\n}\n\nfunction writeU64(dst, num, off) {\n  const hi = num * (1 / 0x100000000) >>> 0;\n  const lo = num >>> 0;\n  writeU32(dst, lo, off + 0);\n  writeU32(dst, hi, off + 4);\n  return off + 8;\n}\n/*\n * Expose\n */\n\n\nmodule.exports = AEAD;","map":null,"metadata":{},"sourceType":"script"}