{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _awaitAsyncGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _wrapAsyncGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar _asyncIterator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar PeerId = require('peer-id');\n\nvar CID = require('cids');\n\nvar errCode = require('err-code');\n\nvar _require = require('../utils'),\n    withTimeoutOption = _require.withTimeoutOption;\n\nvar _require2 = require('buffer'),\n    Buffer = _require2.Buffer;\n\nmodule.exports = function (_ref3) {\n  var libp2p = _ref3.libp2p,\n      repo = _ref3.repo;\n  return {\n    /**\n     * Given a key, query the DHT for its best value.\n     *\n     * @param {Buffer} key\n     * @param {Object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout\n     * @returns {Promise<Buffer>}\n     */\n    get: withTimeoutOption( /*#__PURE__*/function () {\n      var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(key, options) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                // eslint-disable-line require-await\n                options = options || {};\n\n                if (Buffer.isBuffer(key)) {\n                  _context.next = 9;\n                  break;\n                }\n\n                _context.prev = 2;\n                key = new CID(key).buffer;\n                _context.next = 9;\n                break;\n\n              case 6:\n                _context.prev = 6;\n                _context.t0 = _context[\"catch\"](2);\n                throw errCode(_context.t0, 'ERR_INVALID_CID');\n\n              case 9:\n                return _context.abrupt(\"return\", libp2p._dht.get(key, options));\n\n              case 10:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[2, 6]]);\n      }));\n\n      return function (_x4, _x5) {\n        return _ref4.apply(this, arguments);\n      };\n    }()),\n\n    /**\n     * Write a key/value pair to the DHT.\n     *\n     * Given a key of the form /foo/bar and a value of any\n     * form, this will write that value to the DHT with\n     * that key.\n     *\n     * @param {Buffer} key\n     * @param {Buffer} value\n     * @returns {Promise}\n     */\n    put: withTimeoutOption( /*#__PURE__*/function () {\n      var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(key, value) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (Buffer.isBuffer(key)) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                _context2.prev = 1;\n                key = new CID(key).buffer;\n                _context2.next = 8;\n                break;\n\n              case 5:\n                _context2.prev = 5;\n                _context2.t0 = _context2[\"catch\"](1);\n                throw errCode(_context2.t0, 'ERR_INVALID_CID');\n\n              case 8:\n                return _context2.abrupt(\"return\", libp2p._dht.put(key, value));\n\n              case 9:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, null, [[1, 5]]);\n      }));\n\n      return function (_x6, _x7) {\n        return _ref5.apply(this, arguments);\n      };\n    }()),\n\n    /**\n     * Find peers in the DHT that can provide a specific value, given a key.\n     *\n     * @param {CID} key - They key to find providers for.\n     * @param {Object} [options] - findProviders options\n     * @param {number} [options.timeout] - how long the query should maximally run, in milliseconds (default: 60000)\n     * @param {number} [options.numProviders] - maximum number of providers to find\n     * @returns {AsyncIterable<{ id: CID, addrs: Multiaddr[] }>}\n     */\n    findProvs: withTimeoutOption( /*#__PURE__*/function () {\n      var _ref = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(key, options) {\n        var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, peerInfo;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                // eslint-disable-line require-await\n                options = options || {};\n\n                if (!(typeof key === 'string')) {\n                  _context3.next = 9;\n                  break;\n                }\n\n                _context3.prev = 2;\n                key = new CID(key);\n                _context3.next = 9;\n                break;\n\n              case 6:\n                _context3.prev = 6;\n                _context3.t0 = _context3[\"catch\"](2);\n                throw errCode(_context3.t0, 'ERR_INVALID_CID');\n\n              case 9:\n                if (options.numProviders) {\n                  options.maxNumProviders = options.numProviders;\n                }\n\n                _iteratorNormalCompletion = true;\n                _didIteratorError = false;\n                _context3.prev = 12;\n                _iterator = _asyncIterator(libp2p._dht.findProviders(key, options));\n\n              case 14:\n                _context3.next = 16;\n                return _awaitAsyncGenerator(_iterator.next());\n\n              case 16:\n                _step = _context3.sent;\n                _iteratorNormalCompletion = _step.done;\n                _context3.next = 20;\n                return _awaitAsyncGenerator(_step.value);\n\n              case 20:\n                _value = _context3.sent;\n\n                if (_iteratorNormalCompletion) {\n                  _context3.next = 28;\n                  break;\n                }\n\n                peerInfo = _value;\n                _context3.next = 25;\n                return {\n                  id: peerInfo.id.toB58String(),\n                  addrs: peerInfo.multiaddrs.toArray()\n                };\n\n              case 25:\n                _iteratorNormalCompletion = true;\n                _context3.next = 14;\n                break;\n\n              case 28:\n                _context3.next = 34;\n                break;\n\n              case 30:\n                _context3.prev = 30;\n                _context3.t1 = _context3[\"catch\"](12);\n                _didIteratorError = true;\n                _iteratorError = _context3.t1;\n\n              case 34:\n                _context3.prev = 34;\n                _context3.prev = 35;\n\n                if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                  _context3.next = 39;\n                  break;\n                }\n\n                _context3.next = 39;\n                return _awaitAsyncGenerator(_iterator.return());\n\n              case 39:\n                _context3.prev = 39;\n\n                if (!_didIteratorError) {\n                  _context3.next = 42;\n                  break;\n                }\n\n                throw _iteratorError;\n\n              case 42:\n                return _context3.finish(39);\n\n              case 43:\n                return _context3.finish(34);\n\n              case 44:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, null, [[2, 6], [12, 30, 34, 44], [35,, 39, 43]]);\n      }));\n\n      return function (_x, _x2) {\n        return _ref.apply(this, arguments);\n      };\n    }()),\n\n    /**\n     * Query the DHT for all multiaddresses associated with a `PeerId`.\n     *\n     * @param {PeerId} peerId - The id of the peer to search for.\n     * @returns {Promise<{ id: CID, addrs: Multiaddr[] }>}\n     */\n    findPeer: withTimeoutOption( /*#__PURE__*/function () {\n      var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(peerId) {\n        var peerInfo;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                // eslint-disable-line require-await\n                if (typeof peerId === 'string') {\n                  peerId = PeerId.createFromCID(peerId);\n                }\n\n                _context4.next = 3;\n                return libp2p._dht.findPeer(peerId);\n\n              case 3:\n                peerInfo = _context4.sent;\n                return _context4.abrupt(\"return\", {\n                  id: peerInfo.id.toB58String(),\n                  addrs: peerInfo.multiaddrs.toArray()\n                });\n\n              case 5:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      return function (_x8) {\n        return _ref6.apply(this, arguments);\n      };\n    }()),\n\n    /**\n     * Announce to the network that we are providing given values.\n     *\n     * @param {CID|CID[]} keys - The keys that should be announced.\n     * @param {Object} [options] - provide options\n     * @param {bool} [options.recursive=false] - Provide not only the given object but also all objects linked from it.\n     * @returns {Promise}\n     */\n    provide: withTimeoutOption( /*#__PURE__*/function () {\n      var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(keys, options) {\n        var i, hasKeys, hasAll;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                keys = Array.isArray(keys) ? keys : [keys];\n                options = options || {};\n                _context5.t0 = _regeneratorRuntime.keys(keys);\n\n              case 3:\n                if ((_context5.t1 = _context5.t0()).done) {\n                  _context5.next = 15;\n                  break;\n                }\n\n                i = _context5.t1.value;\n\n                if (!(typeof keys[i] === 'string')) {\n                  _context5.next = 13;\n                  break;\n                }\n\n                _context5.prev = 6;\n                keys[i] = new CID(keys[i]);\n                _context5.next = 13;\n                break;\n\n              case 10:\n                _context5.prev = 10;\n                _context5.t2 = _context5[\"catch\"](6);\n                throw errCode(_context5.t2, 'ERR_INVALID_CID');\n\n              case 13:\n                _context5.next = 3;\n                break;\n\n              case 15:\n                _context5.next = 17;\n                return Promise.all(keys.map(function (k) {\n                  return repo.blocks.has(k);\n                }));\n\n              case 17:\n                hasKeys = _context5.sent;\n                hasAll = hasKeys.every(function (has) {\n                  return has;\n                });\n\n                if (hasAll) {\n                  _context5.next = 21;\n                  break;\n                }\n\n                throw errCode('block(s) not found locally, cannot provide', 'ERR_BLOCK_NOT_FOUND');\n\n              case 21:\n                if (!options.recursive) {\n                  _context5.next = 25;\n                  break;\n                }\n\n                throw errCode('not implemented yet', 'ERR_NOT_IMPLEMENTED_YET');\n\n              case 25:\n                _context5.next = 27;\n                return Promise.all(keys.map(function (k) {\n                  return libp2p._dht.provide(k);\n                }));\n\n              case 27:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, null, [[6, 10]]);\n      }));\n\n      return function (_x9, _x10) {\n        return _ref7.apply(this, arguments);\n      };\n    }()),\n\n    /**\n     * Find the closest peers to a given `PeerId`, by querying the DHT.\n     *\n     * @param {string|PeerId} peerId - The `PeerId` to run the query against.\n     * @returns {AsyncIterable<{ id: CID, addrs: Multiaddr[] }>}\n     */\n    query: withTimeoutOption( /*#__PURE__*/function () {\n      var _ref2 = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(peerId) {\n        var _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _value2, closerPeerId;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (typeof peerId === 'string') {\n                  peerId = PeerId.createFromCID(peerId);\n                }\n\n                _iteratorNormalCompletion2 = true;\n                _didIteratorError2 = false;\n                _context6.prev = 3;\n                _iterator2 = _asyncIterator(libp2p._dht.getClosestPeers(peerId.toBytes()));\n\n              case 5:\n                _context6.next = 7;\n                return _awaitAsyncGenerator(_iterator2.next());\n\n              case 7:\n                _step2 = _context6.sent;\n                _iteratorNormalCompletion2 = _step2.done;\n                _context6.next = 11;\n                return _awaitAsyncGenerator(_step2.value);\n\n              case 11:\n                _value2 = _context6.sent;\n\n                if (_iteratorNormalCompletion2) {\n                  _context6.next = 19;\n                  break;\n                }\n\n                closerPeerId = _value2;\n                _context6.next = 16;\n                return {\n                  id: closerPeerId.toB58String(),\n                  addrs: [] // TODO: get addrs?\n\n                };\n\n              case 16:\n                _iteratorNormalCompletion2 = true;\n                _context6.next = 5;\n                break;\n\n              case 19:\n                _context6.next = 25;\n                break;\n\n              case 21:\n                _context6.prev = 21;\n                _context6.t0 = _context6[\"catch\"](3);\n                _didIteratorError2 = true;\n                _iteratorError2 = _context6.t0;\n\n              case 25:\n                _context6.prev = 25;\n                _context6.prev = 26;\n\n                if (!(!_iteratorNormalCompletion2 && _iterator2.return != null)) {\n                  _context6.next = 30;\n                  break;\n                }\n\n                _context6.next = 30;\n                return _awaitAsyncGenerator(_iterator2.return());\n\n              case 30:\n                _context6.prev = 30;\n\n                if (!_didIteratorError2) {\n                  _context6.next = 33;\n                  break;\n                }\n\n                throw _iteratorError2;\n\n              case 33:\n                return _context6.finish(30);\n\n              case 34:\n                return _context6.finish(25);\n\n              case 35:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, null, [[3, 21, 25, 35], [26,, 30, 34]]);\n      }));\n\n      return function (_x3) {\n        return _ref2.apply(this, arguments);\n      };\n    }())\n  };\n};","map":null,"metadata":{},"sourceType":"script"}