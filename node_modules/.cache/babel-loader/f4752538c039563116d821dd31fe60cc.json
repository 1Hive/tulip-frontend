{"ast":null,"code":"'use strict';\n\nconst log = require('debug')('ipfs:components:init');\n\nconst PeerId = require('peer-id');\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst PeerInfo = require('peer-info');\n\nconst mergeOptions = require('merge-options');\n\nconst getDefaultConfig = require('../runtime/config-nodejs.js');\n\nconst createRepo = require('../runtime/repo-nodejs');\n\nconst Keychain = require('libp2p-keychain');\n\nconst NoKeychain = require('./no-keychain');\n\nconst mortice = require('mortice');\n\nconst {\n  DAGNode\n} = require('ipld-dag-pb');\n\nconst UnixFs = require('ipfs-unixfs');\n\nconst multicodec = require('multicodec');\n\nconst {\n  AlreadyInitializingError,\n  AlreadyInitializedError,\n  NotStartedError,\n  NotEnabledError\n} = require('../errors');\n\nconst BlockService = require('ipfs-block-service');\n\nconst Ipld = require('ipld');\n\nconst getDefaultIpldOptions = require('../runtime/ipld-nodejs');\n\nconst createPreloader = require('../preload');\n\nconst {\n  ERR_REPO_NOT_INITIALIZED\n} = require('ipfs-repo').errors;\n\nconst IPNS = require('../ipns');\n\nconst OfflineDatastore = require('../ipns/routing/offline-datastore');\n\nconst initAssets = require('../runtime/init-assets-nodejs');\n\nconst PinManager = require('./pin/pin-manager');\n\nconst Components = require('./');\n\nmodule.exports = ({\n  apiManager,\n  print,\n  options: constructorOptions\n}) => async function init(options) {\n  const {\n    cancel\n  } = apiManager.update({\n    init: () => {\n      throw new AlreadyInitializingError();\n    }\n  });\n\n  try {\n    options = options || {};\n\n    if (typeof constructorOptions.init === 'object') {\n      options = mergeOptions(constructorOptions.init, options);\n    }\n\n    options.pass = options.pass || constructorOptions.pass;\n\n    if (constructorOptions.config) {\n      options.config = mergeOptions(options.config, constructorOptions.config);\n    }\n\n    options.repo = options.repo || constructorOptions.repo;\n    options.repoAutoMigrate = options.repoAutoMigrate || constructorOptions.repoAutoMigrate;\n    const repo = typeof options.repo === 'string' || options.repo == null ? createRepo({\n      path: options.repo,\n      autoMigrate: options.repoAutoMigrate\n    }) : options.repo;\n    let isInitialized = true;\n\n    if (repo.closed) {\n      try {\n        await repo.open();\n      } catch (err) {\n        if (err.code === ERR_REPO_NOT_INITIALIZED) {\n          isInitialized = false;\n        } else {\n          throw err;\n        }\n      }\n    }\n\n    if (!isInitialized && options.allowNew === false) {\n      throw new NotEnabledError('new repo initialization is not enabled');\n    }\n\n    const {\n      peerId,\n      keychain\n    } = isInitialized ? await initExistingRepo(repo, options) : await initNewRepo(repo, { ...options,\n      print\n    });\n    log('peer created');\n    const peerInfo = new PeerInfo(peerId);\n    const blockService = new BlockService(repo);\n    const ipld = new Ipld(getDefaultIpldOptions(blockService, constructorOptions.ipld, log));\n    const preload = createPreloader(constructorOptions.preload);\n    await preload.start(); // Make sure GC lock is specific to repo, for tests where there are\n    // multiple instances of IPFS\n\n    const gcLock = mortice(repo.path, {\n      singleProcess: constructorOptions.repoOwner !== false\n    });\n    const dag = {\n      get: Components.dag.get({\n        ipld,\n        preload\n      }),\n      resolve: Components.dag.resolve({\n        ipld,\n        preload\n      }),\n      tree: Components.dag.tree({\n        ipld,\n        preload\n      })\n    };\n    const object = {\n      data: Components.object.data({\n        ipld,\n        preload\n      }),\n      get: Components.object.get({\n        ipld,\n        preload\n      }),\n      links: Components.object.links({\n        dag\n      }),\n      new: Components.object.new({\n        ipld,\n        preload\n      }),\n      patch: {\n        addLink: Components.object.patch.addLink({\n          ipld,\n          gcLock,\n          preload\n        }),\n        appendData: Components.object.patch.appendData({\n          ipld,\n          gcLock,\n          preload\n        }),\n        rmLink: Components.object.patch.rmLink({\n          ipld,\n          gcLock,\n          preload\n        }),\n        setData: Components.object.patch.setData({\n          ipld,\n          gcLock,\n          preload\n        })\n      },\n      put: Components.object.put({\n        ipld,\n        gcLock,\n        preload\n      }),\n      stat: Components.object.stat({\n        ipld,\n        preload\n      })\n    };\n    const pinManager = new PinManager(repo, dag);\n    await pinManager.load();\n    const pin = {\n      add: Components.pin.add({\n        pinManager,\n        gcLock,\n        dag\n      }),\n      ls: Components.pin.ls({\n        pinManager,\n        dag\n      }),\n      rm: Components.pin.rm({\n        pinManager,\n        gcLock,\n        dag\n      })\n    }; // FIXME: resolve this circular dependency\n\n    dag.put = Components.dag.put({\n      ipld,\n      pin,\n      gcLock,\n      preload\n    });\n    const block = {\n      get: Components.block.get({\n        blockService,\n        preload\n      }),\n      put: Components.block.put({\n        blockService,\n        pin,\n        gcLock,\n        preload\n      }),\n      rm: Components.block.rm({\n        blockService,\n        gcLock,\n        pinManager\n      }),\n      stat: Components.block.stat({\n        blockService,\n        preload\n      })\n    };\n    const add = Components.add({\n      block,\n      preload,\n      pin,\n      gcLock,\n      options: constructorOptions\n    });\n\n    if (!isInitialized && !options.emptyRepo) {\n      // add empty unixfs dir object (go-ipfs assumes this exists)\n      const emptyDirCid = await addEmptyDir({\n        dag\n      });\n      log('adding default assets');\n      await initAssets({\n        add,\n        print\n      });\n      log('initializing IPNS keyspace'); // Setup the offline routing for IPNS.\n      // This is primarily used for offline ipns modifications, such as the initializeKeyspace feature.\n\n      const offlineDatastore = new OfflineDatastore(repo);\n      const ipns = new IPNS(offlineDatastore, repo.datastore, peerInfo, keychain, {\n        pass: options.pass\n      });\n      await ipns.initializeKeyspace(peerId.privKey, emptyDirCid.toString());\n    }\n\n    const api = createApi({\n      add,\n      apiManager,\n      constructorOptions,\n      block,\n      blockService,\n      dag,\n      gcLock,\n      initOptions: options,\n      ipld,\n      keychain,\n      object,\n      peerInfo,\n      pin,\n      pinManager,\n      preload,\n      print,\n      repo\n    });\n    apiManager.update(api, () => {\n      throw new NotStartedError();\n    });\n  } catch (err) {\n    cancel();\n    throw err;\n  }\n\n  return apiManager.api;\n};\n\nasync function initNewRepo(repo, {\n  privateKey,\n  emptyRepo,\n  bits,\n  profiles,\n  config,\n  pass,\n  print\n}) {\n  emptyRepo = emptyRepo || false;\n  bits = bits == null ? 2048 : Number(bits);\n  config = mergeOptions(applyProfiles(profiles, getDefaultConfig()), config); // Verify repo does not exist yet\n\n  const exists = await repo.exists();\n  log('repo exists?', exists);\n\n  if (exists === true) {\n    throw new Error('repo already exists');\n  }\n\n  const peerId = await createPeerId({\n    privateKey,\n    bits,\n    print\n  });\n  let keychain = new NoKeychain();\n  log('identity generated');\n  config.Identity = {\n    PeerID: peerId.toB58String(),\n    PrivKey: peerId.privKey.bytes.toString('base64')\n  };\n  privateKey = peerId.privKey;\n  config.Keychain = Keychain.generateOptions();\n  log('peer identity: %s', config.Identity.PeerID);\n  await repo.init(config);\n  await repo.open();\n  log('repo opened');\n\n  if (pass) {\n    log('creating keychain');\n    const keychainOptions = {\n      passPhrase: pass,\n      ...config.Keychain\n    };\n    keychain = new Keychain(repo.keys, keychainOptions);\n    await keychain.importPeer('self', {\n      privKey: privateKey\n    });\n  }\n\n  return {\n    peerId,\n    keychain\n  };\n}\n\nasync function initExistingRepo(repo, {\n  config: newConfig,\n  profiles,\n  pass\n}) {\n  let config = await repo.config.get();\n\n  if (newConfig || profiles) {\n    if (profiles) {\n      config = applyProfiles(profiles, config);\n    }\n\n    if (newConfig) {\n      config = mergeOptions(config, newConfig);\n    }\n\n    await repo.config.set(config);\n  }\n\n  let keychain = new NoKeychain();\n\n  if (pass) {\n    const keychainOptions = {\n      passPhrase: pass,\n      ...config.Keychain\n    };\n    keychain = new Keychain(repo.keys, keychainOptions);\n    log('keychain constructed');\n  }\n\n  const peerId = await PeerId.createFromPrivKey(config.Identity.PrivKey); // Import the private key as 'self', if needed.\n\n  if (pass) {\n    try {\n      await keychain.findKeyByName('self');\n    } catch (err) {\n      log('Creating \"self\" key');\n      await keychain.importPeer('self', peerId);\n    }\n  }\n\n  return {\n    peerId,\n    keychain\n  };\n}\n\nfunction createPeerId({\n  privateKey,\n  bits,\n  print\n}) {\n  if (privateKey) {\n    log('using user-supplied private-key');\n    return typeof privateKey === 'object' ? privateKey : PeerId.createFromPrivKey(Buffer.from(privateKey, 'base64'));\n  } else {\n    // Generate peer identity keypair + transform to desired format + add to config.\n    print('generating %s-bit RSA keypair...', bits);\n    return PeerId.create({\n      bits\n    });\n  }\n}\n\nfunction addEmptyDir({\n  dag\n}) {\n  const node = new DAGNode(new UnixFs('directory').marshal());\n  return dag.put(node, {\n    version: 0,\n    format: multicodec.DAG_PB,\n    hashAlg: multicodec.SHA2_256,\n    preload: false\n  });\n} // Apply profiles (e.g. ['server', 'lowpower']) to config\n\n\nfunction applyProfiles(profiles, config) {\n  return (profiles || []).reduce((config, name) => {\n    const profile = require('./config').profiles[name];\n\n    if (!profile) {\n      throw new Error(`Could not find profile with name '${name}'`);\n    }\n\n    log('applying profile %s', name);\n    return profile.transform(config);\n  }, config);\n}\n\nfunction createApi({\n  add,\n  apiManager,\n  constructorOptions,\n  block,\n  blockService,\n  dag,\n  gcLock,\n  initOptions,\n  ipld,\n  keychain,\n  object,\n  peerInfo,\n  pin,\n  pinManager,\n  preload,\n  print,\n  repo\n}) {\n  const notStarted = async () => {\n    // eslint-disable-line require-await\n    throw new NotStartedError();\n  };\n\n  const resolve = Components.resolve({\n    ipld\n  });\n  const refs = Components.refs({\n    ipld,\n    resolve,\n    preload\n  });\n  refs.local = Components.refs.local({\n    repo\n  });\n  const api = {\n    add,\n    bitswap: {\n      stat: notStarted,\n      unwant: notStarted,\n      wantlist: notStarted\n    },\n    bootstrap: {\n      add: Components.bootstrap.add({\n        repo\n      }),\n      list: Components.bootstrap.list({\n        repo\n      }),\n      rm: Components.bootstrap.rm({\n        repo\n      })\n    },\n    block,\n    cat: Components.cat({\n      ipld,\n      preload\n    }),\n    config: Components.config({\n      repo\n    }),\n    dag,\n    dns: Components.dns(),\n    files: Components.files({\n      ipld,\n      block,\n      blockService,\n      repo,\n      preload,\n      options: constructorOptions\n    }),\n    get: Components.get({\n      ipld,\n      preload\n    }),\n    id: Components.id({\n      peerInfo\n    }),\n    init: async () => {\n      throw new AlreadyInitializedError();\n    },\n    // eslint-disable-line require-await\n    isOnline: Components.isOnline({}),\n    key: {\n      export: Components.key.export({\n        keychain\n      }),\n      gen: Components.key.gen({\n        keychain\n      }),\n      import: Components.key.import({\n        keychain\n      }),\n      info: Components.key.info({\n        keychain\n      }),\n      list: Components.key.list({\n        keychain\n      }),\n      rename: Components.key.rename({\n        keychain\n      }),\n      rm: Components.key.rm({\n        keychain\n      })\n    },\n    ls: Components.ls({\n      ipld,\n      preload\n    }),\n    object,\n    pin,\n    refs,\n    repo: {\n      gc: Components.repo.gc({\n        gcLock,\n        pin,\n        pinManager,\n        refs,\n        repo\n      }),\n      stat: Components.repo.stat({\n        repo\n      }),\n      version: Components.repo.version({\n        repo\n      })\n    },\n    resolve,\n    start: Components.start({\n      apiManager,\n      options: constructorOptions,\n      blockService,\n      gcLock,\n      initOptions,\n      ipld,\n      keychain,\n      peerInfo,\n      pinManager,\n      preload,\n      print,\n      repo\n    }),\n    stats: {\n      bitswap: notStarted,\n      bw: notStarted,\n      repo: Components.repo.stat({\n        repo\n      })\n    },\n    stop: () => {},\n    swarm: {\n      addrs: notStarted,\n      connect: notStarted,\n      disconnect: notStarted,\n      localAddrs: Components.swarm.localAddrs({\n        peerInfo\n      }),\n      peers: notStarted\n    },\n    version: Components.version({\n      repo\n    })\n  };\n  return api;\n}","map":null,"metadata":{},"sourceType":"script"}