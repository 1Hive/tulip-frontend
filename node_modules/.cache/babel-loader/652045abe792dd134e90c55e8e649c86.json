{"ast":null,"code":"'use strict';\n\nconst {\n  difference\n} = require('./utils');\n\nconst EventEmitter = require('events');\n\nconst DEFAULT_OPTIONS = {\n  start: true,\n  pollInterval: 1000\n};\n\nclass IpfsPubsubPeerMonitor extends EventEmitter {\n  constructor(ipfsPubsub, topic, options) {\n    super();\n    this._pubsub = ipfsPubsub;\n    this._topic = topic;\n    this._options = Object.assign({}, DEFAULT_OPTIONS, options);\n    this._peers = [];\n    this._interval = null;\n    if (this._options.start) this.start();\n  }\n\n  get started() {\n    return this._interval !== null;\n  }\n\n  set started(val) {\n    throw new Error(\"'started' is read-only\");\n  }\n\n  start() {\n    if (this._interval) this.stop();\n    this._interval = setInterval(this._pollPeers.bind(this), this._options.pollInterval);\n\n    this._pollPeers();\n  }\n\n  stop() {\n    clearInterval(this._interval);\n    this._interval = null;\n    this.removeAllListeners('error');\n    this.removeAllListeners('join');\n    this.removeAllListeners('leave');\n  }\n\n  async getPeers() {\n    this._peers = await this._pubsub.peers(this._topic);\n    return this._peers.slice();\n  }\n\n  hasPeer(peer) {\n    return this._peers.includes(peer);\n  }\n\n  async _pollPeers() {\n    try {\n      const peers = await this._pubsub.peers(this._topic);\n\n      IpfsPubsubPeerMonitor._emitJoinsAndLeaves(new Set(this._peers), new Set(peers), this);\n\n      this._peers = peers;\n    } catch (err) {\n      clearInterval(this._interval);\n      this.emit('error', err);\n    }\n  }\n\n  static _emitJoinsAndLeaves(oldValues, newValues, events) {\n    const emitJoin = addedPeer => events.emit('join', addedPeer);\n\n    const emitLeave = removedPeer => events.emit('leave', removedPeer);\n\n    difference(newValues, oldValues).forEach(emitJoin);\n    difference(oldValues, newValues).forEach(emitLeave);\n  }\n\n}\n\nmodule.exports = IpfsPubsubPeerMonitor;","map":null,"metadata":{},"sourceType":"script"}