{"ast":null,"code":"'use strict';\n\nconst {\n  DAGLink,\n  DAGNode\n} = require('ipld-dag-pb');\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst UnixFS = require('ipfs-unixfs');\n\nconst multihashing = require('multihashing-async');\n\nconst Dir = require('./dir');\n\nconst persist = require('./utils/persist');\n\nconst Bucket = require('hamt-sharding');\n\nconst mergeOptions = require('merge-options').bind({\n  ignoreUndefined: true\n});\n\nconst hashFn = async function (value) {\n  const hash = await multihashing(Buffer.from(value, 'utf8'), 'murmur3-128'); // Multihashing inserts preamble of 2 bytes. Remove it.\n  // Also, murmur3 outputs 128 bit but, accidently, IPFS Go's\n  // implementation only uses the first 64, so we must do the same\n  // for parity..\n\n  const justHash = hash.slice(2, 10);\n  const length = justHash.length;\n  const result = Buffer.alloc(length); // TODO: invert buffer because that's how Go impl does it\n\n  for (let i = 0; i < length; i++) {\n    result[length - i - 1] = justHash[i];\n  }\n\n  return result;\n};\n\nhashFn.code = 0x22; // TODO: get this from multihashing-async?\n\nconst defaultOptions = {\n  hamtHashFn: hashFn,\n  hamtBucketBits: 8\n};\n\nclass DirSharded extends Dir {\n  constructor(props, options) {\n    options = mergeOptions(defaultOptions, options);\n    super(props, options);\n    this._bucket = Bucket({\n      hashFn: options.hamtHashFn,\n      bits: options.hamtBucketBits\n    });\n  }\n\n  async put(name, value) {\n    await this._bucket.put(name, value);\n  }\n\n  get(name) {\n    return this._bucket.get(name);\n  }\n\n  childCount() {\n    return this._bucket.leafCount();\n  }\n\n  directChildrenCount() {\n    return this._bucket.childrenCount();\n  }\n\n  onlyChild() {\n    return this._bucket.onlyChild();\n  }\n\n  async *eachChildSeries() {\n    for await (const {\n      key,\n      value\n    } of this._bucket.eachLeafSeries()) {\n      yield {\n        key,\n        child: value\n      };\n    }\n  }\n\n  async *flush(path, block) {\n    for await (const entry of flush(path, this._bucket, block, this, this.options)) {\n      yield entry;\n    }\n  }\n\n}\n\nmodule.exports = DirSharded;\nmodule.exports.hashFn = hashFn;\n\nasync function* flush(path, bucket, block, shardRoot, options) {\n  const children = bucket._children;\n  const links = [];\n  let childrenSize = 0;\n\n  for (let i = 0; i < children.length; i++) {\n    const child = children.get(i);\n\n    if (!child) {\n      continue;\n    }\n\n    const labelPrefix = i.toString(16).toUpperCase().padStart(2, '0');\n\n    if (Bucket.isBucket(child)) {\n      let shard;\n\n      for await (const subShard of await flush('', child, block, null, options)) {\n        shard = subShard;\n      }\n\n      links.push(new DAGLink(labelPrefix, shard.size, shard.cid));\n      childrenSize += shard.size;\n    } else if (typeof child.value.flush === 'function') {\n      const dir = child.value;\n      let flushedDir;\n\n      for await (const entry of dir.flush(dir.path, block)) {\n        flushedDir = entry;\n        yield flushedDir;\n      }\n\n      const label = labelPrefix + child.key;\n      links.push(new DAGLink(label, flushedDir.size, flushedDir.cid));\n      childrenSize += flushedDir.size;\n    } else {\n      const value = child.value;\n\n      if (!value.cid) {\n        continue;\n      }\n\n      const label = labelPrefix + child.key;\n      const size = value.size;\n      links.push(new DAGLink(label, size, value.cid));\n      childrenSize += size;\n    }\n  } // go-ipfs uses little endian, that's why we have to\n  // reverse the bit field before storing it\n\n\n  const data = Buffer.from(children.bitField().reverse());\n  const dir = new UnixFS({\n    type: 'hamt-sharded-directory',\n    data,\n    fanout: bucket.tableSize(),\n    hashType: options.hamtHashFn.code,\n    mtime: shardRoot && shardRoot.mtime,\n    mode: shardRoot && shardRoot.mode\n  });\n  const node = new DAGNode(dir.marshal(), links);\n  const buffer = node.serialize();\n  const cid = await persist(buffer, block, options);\n  const size = buffer.length + childrenSize;\n  yield {\n    cid,\n    unixfs: dir,\n    path,\n    size\n  };\n}","map":null,"metadata":{},"sourceType":"script"}