{"ast":null,"code":"'use strict';\n\nconst PeerId = require('peer-id');\n\nconst CID = require('cids');\n\nconst errCode = require('err-code');\n\nconst {\n  withTimeoutOption\n} = require('../utils');\n\nconst {\n  Buffer\n} = require('buffer');\n\nmodule.exports = ({\n  libp2p,\n  repo\n}) => {\n  return {\n    /**\n     * Given a key, query the DHT for its best value.\n     *\n     * @param {Buffer} key\n     * @param {Object} [options] - get options\n     * @param {number} [options.timeout] - optional timeout\n     * @returns {Promise<Buffer>}\n     */\n    get: withTimeoutOption(async (key, options) => {\n      // eslint-disable-line require-await\n      options = options || {};\n\n      if (!Buffer.isBuffer(key)) {\n        try {\n          key = new CID(key).buffer;\n        } catch (err) {\n          throw errCode(err, 'ERR_INVALID_CID');\n        }\n      }\n\n      return libp2p._dht.get(key, options);\n    }),\n\n    /**\n     * Write a key/value pair to the DHT.\n     *\n     * Given a key of the form /foo/bar and a value of any\n     * form, this will write that value to the DHT with\n     * that key.\n     *\n     * @param {Buffer} key\n     * @param {Buffer} value\n     * @returns {Promise}\n     */\n    put: withTimeoutOption(async (key, value) => {\n      // eslint-disable-line require-await\n      if (!Buffer.isBuffer(key)) {\n        try {\n          key = new CID(key).buffer;\n        } catch (err) {\n          throw errCode(err, 'ERR_INVALID_CID');\n        }\n      }\n\n      return libp2p._dht.put(key, value);\n    }),\n\n    /**\n     * Find peers in the DHT that can provide a specific value, given a key.\n     *\n     * @param {CID} key - They key to find providers for.\n     * @param {Object} [options] - findProviders options\n     * @param {number} [options.timeout] - how long the query should maximally run, in milliseconds (default: 60000)\n     * @param {number} [options.numProviders] - maximum number of providers to find\n     * @returns {AsyncIterable<{ id: CID, addrs: Multiaddr[] }>}\n     */\n    findProvs: withTimeoutOption(async function* (key, options) {\n      // eslint-disable-line require-await\n      options = options || {};\n\n      if (typeof key === 'string') {\n        try {\n          key = new CID(key);\n        } catch (err) {\n          throw errCode(err, 'ERR_INVALID_CID');\n        }\n      }\n\n      if (options.numProviders) {\n        options.maxNumProviders = options.numProviders;\n      }\n\n      for await (const peerInfo of libp2p._dht.findProviders(key, options)) {\n        yield {\n          id: peerInfo.id.toB58String(),\n          addrs: peerInfo.multiaddrs.toArray()\n        };\n      }\n    }),\n\n    /**\n     * Query the DHT for all multiaddresses associated with a `PeerId`.\n     *\n     * @param {PeerId} peerId - The id of the peer to search for.\n     * @returns {Promise<{ id: CID, addrs: Multiaddr[] }>}\n     */\n    findPeer: withTimeoutOption(async peerId => {\n      // eslint-disable-line require-await\n      if (typeof peerId === 'string') {\n        peerId = PeerId.createFromCID(peerId);\n      }\n\n      const peerInfo = await libp2p._dht.findPeer(peerId);\n      return {\n        id: peerInfo.id.toB58String(),\n        addrs: peerInfo.multiaddrs.toArray()\n      };\n    }),\n\n    /**\n     * Announce to the network that we are providing given values.\n     *\n     * @param {CID|CID[]} keys - The keys that should be announced.\n     * @param {Object} [options] - provide options\n     * @param {bool} [options.recursive=false] - Provide not only the given object but also all objects linked from it.\n     * @returns {Promise}\n     */\n    provide: withTimeoutOption(async (keys, options) => {\n      keys = Array.isArray(keys) ? keys : [keys];\n      options = options || {};\n\n      for (var i in keys) {\n        if (typeof keys[i] === 'string') {\n          try {\n            keys[i] = new CID(keys[i]);\n          } catch (err) {\n            throw errCode(err, 'ERR_INVALID_CID');\n          }\n        }\n      } // ensure blocks are actually local\n\n\n      const hasKeys = await Promise.all(keys.map(k => repo.blocks.has(k)));\n      const hasAll = hasKeys.every(has => has);\n\n      if (!hasAll) {\n        throw errCode('block(s) not found locally, cannot provide', 'ERR_BLOCK_NOT_FOUND');\n      }\n\n      if (options.recursive) {\n        // TODO: Implement recursive providing\n        throw errCode('not implemented yet', 'ERR_NOT_IMPLEMENTED_YET');\n      } else {\n        await Promise.all(keys.map(k => libp2p._dht.provide(k)));\n      }\n    }),\n\n    /**\n     * Find the closest peers to a given `PeerId`, by querying the DHT.\n     *\n     * @param {string|PeerId} peerId - The `PeerId` to run the query against.\n     * @returns {AsyncIterable<{ id: CID, addrs: Multiaddr[] }>}\n     */\n    query: withTimeoutOption(async function* (peerId) {\n      if (typeof peerId === 'string') {\n        peerId = PeerId.createFromCID(peerId);\n      }\n\n      for await (const closerPeerId of libp2p._dht.getClosestPeers(peerId.toBytes())) {\n        yield {\n          id: closerPeerId.toB58String(),\n          addrs: [] // TODO: get addrs?\n\n        };\n      }\n    })\n  };\n};","map":null,"metadata":{},"sourceType":"script"}