{"ast":null,"code":"import HKDF from 'bcrypto/lib/hkdf';\nimport x25519 from 'bcrypto/lib/js/x25519';\nimport SHA256 from 'bcrypto/lib/js/sha256';\nimport { Buffer } from \"buffer\";\nimport PeerId from \"peer-id\";\nimport { keys } from 'libp2p-crypto';\nimport { pb } from \"./proto/payload\";\nconst NoiseHandshakePayloadProto = pb.NoiseHandshakePayload;\nexport function generateKeypair() {\n  const privateKey = x25519.privateKeyGenerate();\n  const publicKey = x25519.publicKeyCreate(privateKey);\n  return {\n    publicKey,\n    privateKey\n  };\n}\nexport async function getPayload(localPeer, staticPublicKey, earlyData) {\n  const signedPayload = await signPayload(localPeer, getHandshakePayload(staticPublicKey));\n  const earlyDataPayload = earlyData || Buffer.alloc(0);\n  return await createHandshakePayload(localPeer.marshalPubKey(), signedPayload, earlyDataPayload);\n}\nexport async function createHandshakePayload(libp2pPublicKey, signedPayload, earlyData) {\n  const payloadInit = NoiseHandshakePayloadProto.create({\n    identityKey: libp2pPublicKey,\n    identitySig: signedPayload,\n    data: earlyData || null\n  });\n  return Buffer.from(NoiseHandshakePayloadProto.encode(payloadInit).finish());\n}\nexport async function signPayload(peerId, payload) {\n  return peerId.privKey.sign(payload);\n}\nexport async function getPeerIdFromPayload(payload) {\n  return await PeerId.createFromPubKey(Buffer.from(payload.identityKey));\n}\nexport async function decodePayload(payload) {\n  return NoiseHandshakePayloadProto.toObject(NoiseHandshakePayloadProto.decode(Buffer.from(payload)));\n}\nexport function getHandshakePayload(publicKey) {\n  return Buffer.concat([Buffer.from(\"noise-libp2p-static-key:\"), publicKey]);\n}\n\nasync function isValidPeerId(peerId, publicKeyProtobuf) {\n  const generatedPeerId = await PeerId.createFromPubKey(publicKeyProtobuf);\n  return generatedPeerId.id.equals(peerId);\n}\n/**\n * Verifies signed payload, throws on any irregularities.\n * @param {bytes} noiseStaticKey - owner's noise static key\n * @param {bytes} payload - decoded payload\n * @param {PeerId} remotePeer - owner's libp2p peer ID\n * @returns {Promise<PeerId>} - peer ID of payload owner\n */\n\n\nexport async function verifySignedPayload(noiseStaticKey, payload, remotePeer) {\n  const identityKey = Buffer.from(payload.identityKey);\n\n  if (!(await isValidPeerId(remotePeer.id, identityKey))) {\n    throw new Error(\"Peer ID doesn't match libp2p public key.\");\n  }\n\n  const generatedPayload = getHandshakePayload(noiseStaticKey); // Unmarshaling from PublicKey protobuf\n\n  const publicKey = keys.unmarshalPublicKey(identityKey);\n\n  if (!payload.identitySig || !publicKey.verify(generatedPayload, Buffer.from(payload.identitySig))) {\n    throw new Error(\"Static key doesn't match to peer that signed payload!\");\n  }\n\n  return PeerId.createFromPubKey(identityKey);\n}\nexport function getHkdf(ck, ikm) {\n  const info = Buffer.alloc(0);\n  const prk = HKDF.extract(SHA256, ikm, ck);\n  const okm = HKDF.expand(SHA256, prk, info, 96);\n  const k1 = okm.slice(0, 32);\n  const k2 = okm.slice(32, 64);\n  const k3 = okm.slice(64, 96);\n  return [k1, k2, k3];\n}\nexport function isValidPublicKey(pk) {\n  return x25519.publicKeyVerify(pk.slice(0, 32));\n}","map":null,"metadata":{},"sourceType":"module"}