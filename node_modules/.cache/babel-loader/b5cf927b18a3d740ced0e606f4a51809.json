{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _awaitAsyncGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _wrapAsyncGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar _asyncIterator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar errcode = require('err-code');\n\nvar pTimeout = require('p-timeout');\n\nvar PeerInfo = require('peer-info');\n\nvar c = require('../constants');\n\nvar LimitedPeerList = require('../peer-list/limited-peer-list');\n\nvar Message = require('../message');\n\nvar Query = require('../query');\n\nvar utils = require('../utils');\n\nmodule.exports = function (dht) {\n  /**\n   * Check for providers from a single node.\n   *\n   * @param {PeerId} peer\n   * @param {CID} key\n   * @returns {Promise<Message>}\n   *\n   * @private\n   */\n  var findProvidersSingle = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(peer, key) {\n      var msg;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              // eslint-disable-line require-await\n              msg = new Message(Message.TYPES.GET_PROVIDERS, key.buffer, 0);\n              return _context.abrupt(\"return\", dht.network.sendRequest(peer, msg));\n\n            case 2:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function findProvidersSingle(_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n\n  return {\n    /**\n     * Announce to the network that we can provide given key's value.\n     * @param {CID} key\n     * @returns {Promise<void>}\n     */\n    provide: function provide(key) {\n      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var errors, msg, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, peer;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                dht._log('provide: %s', key.toBaseEncodedString());\n\n                errors = []; // Add peer as provider\n\n                _context2.next = 4;\n                return dht.providers.addProvider(key, dht.peerInfo.id);\n\n              case 4:\n                msg = new Message(Message.TYPES.ADD_PROVIDER, key.buffer, 0);\n                msg.providerPeers = [dht.peerInfo]; // Notify closest peers\n\n                _iteratorNormalCompletion = true;\n                _didIteratorError = false;\n                _context2.prev = 8;\n                _iterator = _asyncIterator(dht.getClosestPeers(key.buffer));\n\n              case 10:\n                _context2.next = 12;\n                return _iterator.next();\n\n              case 12:\n                _step = _context2.sent;\n                _iteratorNormalCompletion = _step.done;\n                _context2.next = 16;\n                return _step.value;\n\n              case 16:\n                _value = _context2.sent;\n\n                if (_iteratorNormalCompletion) {\n                  _context2.next = 31;\n                  break;\n                }\n\n                peer = _value;\n\n                dht._log('putProvider %s to %s', key.toBaseEncodedString(), peer.toB58String());\n\n                _context2.prev = 20;\n                _context2.next = 23;\n                return dht.network.sendMessage(peer, msg);\n\n              case 23:\n                _context2.next = 28;\n                break;\n\n              case 25:\n                _context2.prev = 25;\n                _context2.t0 = _context2[\"catch\"](20);\n                errors.push(_context2.t0);\n\n              case 28:\n                _iteratorNormalCompletion = true;\n                _context2.next = 10;\n                break;\n\n              case 31:\n                _context2.next = 37;\n                break;\n\n              case 33:\n                _context2.prev = 33;\n                _context2.t1 = _context2[\"catch\"](8);\n                _didIteratorError = true;\n                _iteratorError = _context2.t1;\n\n              case 37:\n                _context2.prev = 37;\n                _context2.prev = 38;\n\n                if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                  _context2.next = 42;\n                  break;\n                }\n\n                _context2.next = 42;\n                return _iterator.return();\n\n              case 42:\n                _context2.prev = 42;\n\n                if (!_didIteratorError) {\n                  _context2.next = 45;\n                  break;\n                }\n\n                throw _iteratorError;\n\n              case 45:\n                return _context2.finish(42);\n\n              case 46:\n                return _context2.finish(37);\n\n              case 47:\n                if (!errors.length) {\n                  _context2.next = 49;\n                  break;\n                }\n\n                throw errcode(\"Failed to provide to \".concat(errors.length, \" of \").concat(dht.kBucketSize, \" peers\"), 'ERR_SOME_PROVIDES_FAILED', {\n                  errors: errors\n                });\n\n              case 49:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, null, [[8, 33, 37, 47], [20, 25], [38,, 42, 46]]);\n      }))();\n    },\n\n    /**\n     * Search the dht for up to `K` providers of the given CID.\n     * @param {CID} key\n     * @param {Object} options - findProviders options\n     * @param {number} options.timeout - how long the query should maximally run, in milliseconds (default: 60000)\n     * @param {number} options.maxNumProviders - maximum number of providers to find\n     * @returns {AsyncIterable<PeerInfo>}\n     */\n    findProviders: function findProviders(key) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var providerTimeout, n, out, provs, _iterator2, _step2, pInfo, paths, query, peers, _iterator3, _step3, _pInfo;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                providerTimeout = options.timeout || c.minute;\n                n = options.maxNumProviders || c.K;\n\n                dht._log('findProviders %s', key.toBaseEncodedString());\n\n                out = new LimitedPeerList(n);\n                _context4.next = 6;\n                return _awaitAsyncGenerator(dht.providers.getProviders(key));\n\n              case 6:\n                provs = _context4.sent;\n                provs.forEach(function (id) {\n                  var info;\n\n                  if (dht.peerStore.has(id)) {\n                    info = dht.peerStore.get(id);\n                  } else {\n                    info = dht.peerStore.put(new PeerInfo(id));\n                  }\n\n                  out.push(info);\n                }); // All done\n\n                if (!(out.length >= n)) {\n                  _context4.next = 27;\n                  break;\n                }\n\n                // yield values\n                _iterator2 = _createForOfIteratorHelper(out.toArray());\n                _context4.prev = 10;\n\n                _iterator2.s();\n\n              case 12:\n                if ((_step2 = _iterator2.n()).done) {\n                  _context4.next = 18;\n                  break;\n                }\n\n                pInfo = _step2.value;\n                _context4.next = 16;\n                return pInfo;\n\n              case 16:\n                _context4.next = 12;\n                break;\n\n              case 18:\n                _context4.next = 23;\n                break;\n\n              case 20:\n                _context4.prev = 20;\n                _context4.t0 = _context4[\"catch\"](10);\n\n                _iterator2.e(_context4.t0);\n\n              case 23:\n                _context4.prev = 23;\n\n                _iterator2.f();\n\n                return _context4.finish(23);\n\n              case 26:\n                return _context4.abrupt(\"return\");\n\n              case 27:\n                // need more, query the network\n                paths = [];\n                query = new Query(dht, key.buffer, function (pathIndex, numPaths) {\n                  // This function body runs once per disjoint path\n                  var pathSize = utils.pathSize(n - out.length, numPaths);\n                  var pathProviders = new LimitedPeerList(pathSize);\n                  paths.push(pathProviders); // Here we return the query function to use on this particular disjoint path\n\n                  return /*#__PURE__*/function () {\n                    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(peer) {\n                      var msg, provs;\n                      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                        while (1) {\n                          switch (_context3.prev = _context3.next) {\n                            case 0:\n                              _context3.next = 2;\n                              return findProvidersSingle(peer, key);\n\n                            case 2:\n                              msg = _context3.sent;\n                              provs = msg.providerPeers;\n\n                              dht._log('(%s) found %s provider entries', dht.peerInfo.id.toB58String(), provs.length);\n\n                              provs.forEach(function (prov) {\n                                pathProviders.push(dht.peerStore.put(prov));\n                              }); // hooray we have all that we want\n\n                              if (!(pathProviders.length >= pathSize)) {\n                                _context3.next = 8;\n                                break;\n                              }\n\n                              return _context3.abrupt(\"return\", {\n                                pathComplete: true\n                              });\n\n                            case 8:\n                              return _context3.abrupt(\"return\", {\n                                closerPeers: msg.closerPeers\n                              });\n\n                            case 9:\n                            case \"end\":\n                              return _context3.stop();\n                          }\n                        }\n                      }, _callee3);\n                    }));\n\n                    return function (_x3) {\n                      return _ref2.apply(this, arguments);\n                    };\n                  }();\n                });\n                peers = dht.routingTable.closestPeers(key.buffer, dht.kBucketSize);\n                _context4.prev = 30;\n                _context4.next = 33;\n                return _awaitAsyncGenerator(pTimeout(query.run(peers), providerTimeout));\n\n              case 33:\n                _context4.next = 39;\n                break;\n\n              case 35:\n                _context4.prev = 35;\n                _context4.t1 = _context4[\"catch\"](30);\n\n                if (!(_context4.t1.name !== pTimeout.TimeoutError.name)) {\n                  _context4.next = 39;\n                  break;\n                }\n\n                throw _context4.t1;\n\n              case 39:\n                _context4.prev = 39;\n                query.stop();\n                return _context4.finish(39);\n\n              case 42:\n                // combine peers from each path\n                paths.forEach(function (path) {\n                  path.toArray().forEach(function (peer) {\n                    out.push(peer);\n                  });\n                });\n\n                if (!(out.length === 0)) {\n                  _context4.next = 45;\n                  break;\n                }\n\n                throw errcode(new Error('no providers found'), 'ERR_NOT_FOUND');\n\n              case 45:\n                _iterator3 = _createForOfIteratorHelper(out.toArray());\n                _context4.prev = 46;\n\n                _iterator3.s();\n\n              case 48:\n                if ((_step3 = _iterator3.n()).done) {\n                  _context4.next = 54;\n                  break;\n                }\n\n                _pInfo = _step3.value;\n                _context4.next = 52;\n                return _pInfo;\n\n              case 52:\n                _context4.next = 48;\n                break;\n\n              case 54:\n                _context4.next = 59;\n                break;\n\n              case 56:\n                _context4.prev = 56;\n                _context4.t2 = _context4[\"catch\"](46);\n\n                _iterator3.e(_context4.t2);\n\n              case 59:\n                _context4.prev = 59;\n\n                _iterator3.f();\n\n                return _context4.finish(59);\n\n              case 62:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, null, [[10, 20, 23, 26], [30, 35, 39, 42], [46, 56, 59, 62]]);\n      }))();\n    }\n  };\n};","map":null,"metadata":{},"sourceType":"script"}