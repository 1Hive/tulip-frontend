{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar events_1 = require(\"events\");\n\nvar store_1 = __importDefault(require(\"store\"));\n\nvar did_jwt_1 = require(\"did-jwt\");\n\nvar ipfs_did_document_1 = __importDefault(require(\"ipfs-did-document\"));\n\nvar _3id_blockchain_utils_1 = require(\"3id-blockchain-utils\");\n\nvar crypto_1 = require(\"./crypto\");\n\nvar did_provider_1 = require(\"./did-provider\");\n\nvar keyring_1 = __importDefault(require(\"./keyring\"));\n\nvar threeIdProvider_1 = __importDefault(require(\"./threeIdProvider\"));\n\nvar utils_1 = require(\"./utils\");\n\nvar DID_METHOD_NAME = '3';\n\nvar IdentityWallet = /*#__PURE__*/function () {\n  function IdentityWallet(getConsent) {\n    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, IdentityWallet);\n\n    this.events = new events_1.EventEmitter();\n    if (typeof getConsent !== 'function') throw new Error('getConsent parameter has to be a function');\n    this._getConsent = getConsent;\n\n    if (config.seed) {\n      this._seed = config.seed;\n    } else if (config.authSecret) {\n      this._authSecret = config.authSecret;\n    } else if (config.externalAuth) {\n      this._externalAuth = config.externalAuth;\n    } else {\n      throw new Error('Either seed, or authSecret has to be passed to create an IdentityWallet instance');\n    }\n  }\n\n  _createClass(IdentityWallet, [{\n    key: \"get3idProvider\",\n    value: function get3idProvider() {\n      return new threeIdProvider_1.default(this);\n    }\n  }, {\n    key: \"getDidProvider\",\n    value: function getDidProvider() {\n      return new did_provider_1.DidProvider(this);\n    }\n  }, {\n    key: \"hasConsent\",\n    value: function hasConsent() {\n      var spaces = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var origin = arguments.length > 1 ? arguments[1] : undefined;\n\n      var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n          address = _ref.address;\n\n      var _a;\n\n      var key = (_a = address !== null && address !== void 0 ? address : this._keyring.getPublicKeys().managementKey) !== null && _a !== void 0 ? _a : '';\n      var prefix = \"3id_consent_\".concat(key, \"_\").concat(origin !== null && origin !== void 0 ? origin : '', \"_\");\n\n      var consentExists = function consentExists() {\n        var space = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n        return Boolean(store_1.default.get(prefix + space));\n      };\n\n      return spaces.reduce(function (acc, space) {\n        return acc && consentExists(space);\n      }, consentExists());\n    }\n  }, {\n    key: \"getConsent\",\n    value: function getConsent() {\n      var spaces = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var origin = arguments.length > 1 ? arguments[1] : undefined;\n\n      var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n          address = _ref2.address;\n\n      var _a;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var consent, key, prefix, saveConsent;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (this.hasConsent(spaces, origin, {\n                  address: address\n                })) {\n                  _context.next = 11;\n                  break;\n                }\n\n                _context.next = 3;\n                return this._getConsent({\n                  type: 'authenticate',\n                  origin: origin,\n                  spaces: spaces,\n                  opts: {\n                    address: address\n                  }\n                });\n\n              case 3:\n                consent = _context.sent;\n\n                if (consent) {\n                  _context.next = 6;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", false);\n\n              case 6:\n                key = (_a = address !== null && address !== void 0 ? address : this._keyring.getPublicKeys().managementKey) !== null && _a !== void 0 ? _a : '';\n                prefix = \"3id_consent_\".concat(key, \"_\").concat(origin !== null && origin !== void 0 ? origin : '', \"_\");\n\n                saveConsent = function saveConsent() {\n                  var space = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n                  return store_1.default.set(prefix + space, true);\n                };\n\n                saveConsent();\n                spaces.map(saveConsent);\n\n              case 11:\n                return _context.abrupt(\"return\", true);\n\n              case 12:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n  }, {\n    key: \"getLink\",\n    value: function getLink() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!this._seed) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                this._keyring = new keyring_1.default(this._seed);\n                _context2.next = 4;\n                return this._get3id();\n\n              case 4:\n                this.DID = _context2.sent;\n                delete this._seed;\n                _context2.next = 8;\n                return this._linkManagementAddress();\n\n              case 8:\n                return _context2.abrupt(\"return\", this._keyring ? this._keyring.getPublicKeys().managementKey : keyring_1.default.walletForAuthSecret(this._authSecret).address);\n\n              case 9:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n  }, {\n    key: \"getRootSigner\",\n    value: function getRootSigner(pubKeyId) {\n      if (pubKeyId == null) {\n        return this._keyring.getRootSigner();\n      }\n\n      var _pubKeyId$split = pubKeyId.split('#'),\n          _pubKeyId$split2 = _slicedToArray(_pubKeyId$split, 2),\n          did = _pubKeyId$split2[0],\n          keyId = _pubKeyId$split2[1];\n\n      if (this.DID == null || did !== this.DID) {\n        throw new Error('Invalid DID');\n      }\n\n      return this._keyring.getRootSigner(keyId);\n    }\n  }, {\n    key: \"_linkManagementAddress\",\n    value: function _linkManagementAddress() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var managementWallet;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                managementWallet = this._keyring.managementWallet();\n                _context3.t0 = this.events;\n                _context3.next = 4;\n                return _3id_blockchain_utils_1.createLink(this.DID, managementWallet.address, utils_1.fakeEthProvider(managementWallet));\n\n              case 4:\n                _context3.t1 = _context3.sent;\n\n                _context3.t0.emit.call(_context3.t0, 'new-link-proof', _context3.t1);\n\n              case 6:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n    }\n  }, {\n    key: \"linkAddress\",\n    value: function linkAddress(address, provider) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var proof;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (this._keyring) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                throw new Error('This method can only be called after authenticate has been called');\n\n              case 2:\n                _context4.next = 4;\n                return _3id_blockchain_utils_1.createLink(this.DID, address, provider);\n\n              case 4:\n                proof = _context4.sent;\n                this.events.emit('new-link-proof', proof);\n                return _context4.abrupt(\"return\", proof);\n\n              case 7:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n    }\n  }, {\n    key: \"linkManagementKey\",\n    value: function linkManagementKey() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        var timestamp, msg;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (!this._externalAuth) {\n                  _context5.next = 2;\n                  break;\n                }\n\n                return _context5.abrupt(\"return\", null);\n\n              case 2:\n                timestamp = Math.floor(new Date().getTime() / 1000);\n                msg = \"Create a new 3Box profile\\n\\n- \\nYour unique profile ID is \".concat(this.DID, \" \\nTimestamp: \").concat(timestamp);\n                _context5.t0 = msg;\n                _context5.t1 = timestamp;\n                _context5.next = 8;\n                return this._keyring.managementPersonalSign(msg);\n\n              case 8:\n                _context5.t2 = _context5.sent;\n                return _context5.abrupt(\"return\", {\n                  msg: _context5.t0,\n                  timestamp: _context5.t1,\n                  sig: _context5.t2\n                });\n\n              case 10:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n    }\n  }, {\n    key: \"_initKeyring\",\n    value: function _initKeyring(authData, address, spaces) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        var _this = this;\n\n        var seed, migratedKeys, proof, _seed;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (!this._seed) {\n                  _context6.next = 5;\n                  break;\n                }\n\n                _context6.next = 3;\n                return this.getLink();\n\n              case 3:\n                _context6.next = 38;\n                break;\n\n              case 5:\n                if (!(authData && authData.length > 0)) {\n                  _context6.next = 15;\n                  break;\n                }\n\n                authData.find(function (_ref3) {\n                  var ciphertext = _ref3.ciphertext,\n                      nonce = _ref3.nonce;\n                  seed = keyring_1.default.decryptWithAuthSecret(ciphertext, nonce, _this._authSecret);\n                  return Boolean(seed);\n                });\n\n                if (seed) {\n                  _context6.next = 9;\n                  break;\n                }\n\n                throw new Error('No valid auth-secret for this identity');\n\n              case 9:\n                this._keyring = new keyring_1.default(seed);\n                _context6.next = 12;\n                return this._get3id();\n\n              case 12:\n                this.DID = _context6.sent;\n                _context6.next = 38;\n                break;\n\n              case 15:\n                if (!this._externalAuth) {\n                  _context6.next = 31;\n                  break;\n                }\n\n                if (address) {\n                  _context6.next = 18;\n                  break;\n                }\n\n                throw new Error('External authentication requires an address');\n\n              case 18:\n                _context6.next = 20;\n                return this._externalAuth({\n                  address: address,\n                  spaces: spaces,\n                  type: '3id_migration'\n                });\n\n              case 20:\n                migratedKeys = _context6.sent;\n                this._keyring = new keyring_1.default(null, migratedKeys);\n                _context6.next = 24;\n                return this._get3id();\n\n              case 24:\n                this.DID = _context6.sent;\n                _context6.next = 27;\n                return this._externalAuth({\n                  address: address,\n                  type: '3id_createLink',\n                  did: this.DID\n                });\n\n              case 27:\n                proof = _context6.sent;\n                if (proof) this.events.emit('new-link-proof', proof);\n                _context6.next = 38;\n                break;\n\n              case 31:\n                _seed = '0x' + Buffer.from(crypto_1.naclRandom(32)).toString('hex');\n                this._keyring = new keyring_1.default(_seed);\n                _context6.next = 35;\n                return this._get3id();\n\n              case 35:\n                this.DID = _context6.sent;\n                _context6.next = 38;\n                return this.addAuthMethod(this._authSecret);\n\n              case 38:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n    }\n  }, {\n    key: \"authenticate\",\n    value: function authenticate() {\n      var spaces = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          authData = _ref4.authData,\n          address = _ref4.address,\n          mgmtPub = _ref4.mgmtPub;\n\n      var origin = arguments.length > 2 ? arguments[2] : undefined;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n        var _this2 = this;\n\n        var consent;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (!address) {\n                  _context7.next = 4;\n                  break;\n                }\n\n                _context7.next = 3;\n                return this.getConsent(spaces, origin, {\n                  address: address\n                });\n\n              case 3:\n                consent = _context7.sent;\n\n              case 4:\n                if (!(!this._keyring || this._externalAuth)) {\n                  _context7.next = 7;\n                  break;\n                }\n\n                _context7.next = 7;\n                return this._initKeyring(authData, address, spaces);\n\n              case 7:\n                if (!address) consent = this.getConsent(spaces, origin);\n\n                if (consent) {\n                  _context7.next = 10;\n                  break;\n                }\n\n                throw new Error('Authentication not authorized by user');\n\n              case 10:\n                return _context7.abrupt(\"return\", {\n                  main: this._keyring.getPublicKeys({\n                    mgmtPub: mgmtPub\n                  }),\n                  spaces: spaces.reduce(function (acc, space) {\n                    acc[space] = _this2._keyring.getPublicKeys({\n                      space: space,\n                      uncompressed: true\n                    });\n                    return acc;\n                  }, {})\n                });\n\n              case 11:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n    }\n  }, {\n    key: \"isAuthenticated\",\n    value: function isAuthenticated() {\n      var spaces = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var origin = arguments.length > 1 ? arguments[1] : undefined;\n\n      var _ref5 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n          address = _ref5.address;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                return _context8.abrupt(\"return\", Boolean(this._keyring) && this.hasConsent(spaces, origin, {\n                  address: address\n                }));\n\n              case 1:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n    }\n  }, {\n    key: \"addAuthMethod\",\n    value: function addAuthMethod(authSecret) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n        var message, encAuthData, authWallet;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                if (this._keyring) {\n                  _context9.next = 2;\n                  break;\n                }\n\n                throw new Error('This method can only be called after authenticate has been called');\n\n              case 2:\n                message = this._keyring.serialize();\n                encAuthData = keyring_1.default.encryptWithAuthSecret(message, authSecret);\n                this.events.emit('new-auth-method', encAuthData);\n                authWallet = keyring_1.default.walletForAuthSecret(authSecret);\n                _context9.t0 = this.events;\n                _context9.next = 9;\n                return _3id_blockchain_utils_1.createLink(this.DID, authWallet.address, utils_1.fakeEthProvider(authWallet));\n\n              case 9:\n                _context9.t1 = _context9.sent;\n\n                _context9.t0.emit.call(_context9.t0, 'new-link-proof', _context9.t1);\n\n              case 11:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n    }\n  }, {\n    key: \"signClaim\",\n    value: function signClaim(payload) {\n      var _ref6 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          DID = _ref6.DID,\n          space = _ref6.space,\n          expiresIn = _ref6.expiresIn,\n          useMgmt = _ref6.useMgmt;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {\n        var issuer, settings;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                if (this._keyring) {\n                  _context10.next = 2;\n                  break;\n                }\n\n                throw new Error('This method can only be called after authenticate has been called');\n\n              case 2:\n                _context10.t0 = DID;\n\n                if (_context10.t0) {\n                  _context10.next = 7;\n                  break;\n                }\n\n                _context10.next = 6;\n                return this._get3id(space);\n\n              case 6:\n                _context10.t0 = _context10.sent;\n\n              case 7:\n                issuer = _context10.t0;\n                settings = {\n                  signer: this._keyring.getJWTSigner(space, useMgmt),\n                  issuer: issuer,\n                  expiresIn: expiresIn\n                };\n                return _context10.abrupt(\"return\", did_jwt_1.createJWT(payload, settings));\n\n              case 10:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n    }\n  }, {\n    key: \"encrypt\",\n    value: function encrypt(message, space) {\n      var _ref7 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n          nonce = _ref7.nonce,\n          blockSize = _ref7.blockSize,\n          to = _ref7.to;\n\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee11() {\n        var paddedMsg;\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                if (this._keyring) {\n                  _context11.next = 2;\n                  break;\n                }\n\n                throw new Error('This method can only be called after authenticate has been called');\n\n              case 2:\n                paddedMsg = typeof message === 'string' ? utils_1.pad(message, blockSize) : message;\n\n                if (!to) {\n                  _context11.next = 7;\n                  break;\n                }\n\n                return _context11.abrupt(\"return\", this._keyring.asymEncrypt(paddedMsg, to, {\n                  nonce: nonce\n                }));\n\n              case 7:\n                return _context11.abrupt(\"return\", this._keyring.symEncrypt(paddedMsg, {\n                  space: space,\n                  nonce: nonce\n                }));\n\n              case 8:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n    }\n  }, {\n    key: \"decrypt\",\n    value: function decrypt(encObj, space, toBuffer) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee12() {\n        var paddedMsg;\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                if (this._keyring) {\n                  _context12.next = 2;\n                  break;\n                }\n\n                throw new Error('This method can only be called after authenticate has been called');\n\n              case 2:\n                if (encObj.ephemeralFrom) {\n                  paddedMsg = this._keyring.asymDecrypt(encObj.ciphertext, encObj.ephemeralFrom, encObj.nonce, {\n                    space: space,\n                    toBuffer: toBuffer\n                  });\n                } else {\n                  paddedMsg = this._keyring.symDecrypt(encObj.ciphertext, encObj.nonce, {\n                    space: space,\n                    toBuffer: toBuffer\n                  });\n                }\n\n                if (paddedMsg) {\n                  _context12.next = 5;\n                  break;\n                }\n\n                throw new Error('IdentityWallet: Could not decrypt message');\n\n              case 5:\n                return _context12.abrupt(\"return\", toBuffer ? paddedMsg : utils_1.unpad(paddedMsg));\n\n              case 6:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n    }\n  }, {\n    key: \"hashDBKey\",\n    value: function hashDBKey(key, space) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee13() {\n        var salt;\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                salt = this._keyring.getDBSalt(space);\n                return _context13.abrupt(\"return\", utils_1.sha256Multihash(salt + key));\n\n              case 2:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n    }\n  }, {\n    key: \"_get3id\",\n    value: function _get3id(space) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee14() {\n        var pubkeys, doc, payload, signature;\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                pubkeys = this._keyring.getPublicKeys({\n                  space: space,\n                  uncompressed: true\n                });\n                doc = new ipfs_did_document_1.default(utils_1.fakeIpfs, DID_METHOD_NAME);\n\n                if (space) {\n                  _context14.next = 11;\n                  break;\n                }\n\n                if (!this.DID) {\n                  _context14.next = 5;\n                  break;\n                }\n\n                return _context14.abrupt(\"return\", this.DID);\n\n              case 5:\n                doc.addPublicKey('signingKey', 'Secp256k1VerificationKey2018', 'publicKeyHex', pubkeys.signingKey);\n                doc.addPublicKey('encryptionKey', 'Curve25519EncryptionPublicKey', 'publicKeyBase64', pubkeys.asymEncryptionKey);\n                doc.addPublicKey('managementKey', 'Secp256k1VerificationKey2018', 'ethereumAddress', pubkeys.managementKey);\n                doc.addAuthentication('Secp256k1SignatureAuthentication2018', 'signingKey');\n                _context14.next = 21;\n                break;\n\n              case 11:\n                doc.addPublicKey('subSigningKey', 'Secp256k1VerificationKey2018', 'publicKeyHex', pubkeys.signingKey);\n                doc.addPublicKey('subEncryptionKey', 'Curve25519EncryptionPublicKey', 'publicKeyBase64', pubkeys.asymEncryptionKey);\n                doc.addAuthentication('Secp256k1SignatureAuthentication2018', 'subSigningKey');\n                doc.addCustomProperty('space', space);\n                doc.addCustomProperty('root', this.DID);\n                payload = {\n                  subSigningKey: pubkeys.signingKey,\n                  subEncryptionKey: pubkeys.asymEncryptionKey,\n                  space: space,\n                  iat: null\n                };\n                _context14.next = 19;\n                return this.signClaim(payload);\n\n              case 19:\n                signature = _context14.sent.split('.')[2];\n                doc.addCustomProperty('proof', {\n                  alg: 'ES256K',\n                  signature: signature\n                });\n\n              case 21:\n                _context14.next = 23;\n                return doc.commit({\n                  noTimestamp: true\n                });\n\n              case 23:\n                return _context14.abrupt(\"return\", doc.DID);\n\n              case 24:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n    }\n  }]);\n\n  return IdentityWallet;\n}();\n\nexports.default = IdentityWallet;","map":null,"metadata":{},"sourceType":"script"}