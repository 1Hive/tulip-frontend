{"ast":null,"code":"'use strict';\n\nvar _createForOfIteratorHelper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar errcode = require('err-code');\n\nvar mergeOptions = require('merge-options');\n\nvar LatencyMonitor = require('./latency-monitor');\n\nvar debug = require('debug')('libp2p:connection-manager');\n\nvar retimer = require('retimer');\n\nvar _require = require('../errors'),\n    ERR_INVALID_PARAMETERS = _require.ERR_INVALID_PARAMETERS;\n\nvar defaultOptions = {\n  maxConnections: Infinity,\n  minConnections: 0,\n  maxData: Infinity,\n  maxSentData: Infinity,\n  maxReceivedData: Infinity,\n  maxEventLoopDelay: Infinity,\n  pollInterval: 2000,\n  movingAverageInterval: 60000,\n  defaultPeerValue: 1\n};\n\nvar ConnectionManager = /*#__PURE__*/function () {\n  /**\n   * @constructor\n   * @param {Libp2p} libp2p\n   * @param {object} options\n   * @param {Number} options.maxConnections The maximum number of connections allowed. Default=Infinity\n   * @param {Number} options.minConnections The minimum number of connections to avoid pruning. Default=0\n   * @param {Number} options.maxData The max data (in and out), per average interval to allow. Default=Infinity\n   * @param {Number} options.maxSentData The max outgoing data, per average interval to allow. Default=Infinity\n   * @param {Number} options.maxReceivedData The max incoming data, per average interval to allow.. Default=Infinity\n   * @param {Number} options.maxEventLoopDelay The upper limit the event loop can take to run. Default=Infinity\n   * @param {Number} options.pollInterval How often, in milliseconds, metrics and latency should be checked. Default=2000\n   * @param {Number} options.movingAverageInterval How often, in milliseconds, to compute averages. Default=60000\n   * @param {Number} options.defaultPeerValue The value of the peer. Default=1\n   */\n  function ConnectionManager(libp2p, options) {\n    _classCallCheck(this, ConnectionManager);\n\n    this._libp2p = libp2p;\n    this._registrar = libp2p.registrar;\n    this._peerId = libp2p.peerInfo.id.toB58String();\n    this._options = mergeOptions.call({\n      ignoreUndefined: true\n    }, defaultOptions, options);\n\n    if (this._options.maxConnections < this._options.minConnections) {\n      throw errcode(new Error('Connection Manager maxConnections must be greater than minConnections'), ERR_INVALID_PARAMETERS);\n    }\n\n    debug('options: %j', this._options);\n    this._metrics = libp2p.metrics;\n    this._peerValues = new Map();\n    this._connections = new Map();\n    this._timer = null;\n    this._checkMetrics = this._checkMetrics.bind(this);\n  }\n  /**\n   * Starts the Connection Manager. If Metrics are not enabled on libp2p\n   * only event loop and connection limits will be monitored.\n   */\n\n\n  _createClass(ConnectionManager, [{\n    key: \"start\",\n    value: function start() {\n      if (this._metrics) {\n        this._timer = this._timer || retimer(this._checkMetrics, this._options.pollInterval);\n      } // latency monitor\n\n\n      this._latencyMonitor = new LatencyMonitor({\n        latencyCheckIntervalMs: this._options.pollInterval,\n        dataEmitIntervalMs: this._options.pollInterval\n      });\n      this._onLatencyMeasure = this._onLatencyMeasure.bind(this);\n\n      this._latencyMonitor.on('data', this._onLatencyMeasure);\n\n      debug('started');\n    }\n    /**\n     * Stops the Connection Manager\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this._timer && this._timer.clear();\n      this._latencyMonitor && this._latencyMonitor.removeListener('data', this._onLatencyMeasure);\n      debug('stopped');\n    }\n    /**\n     * Sets the value of the given peer. Peers with lower values\n     * will be disconnected first.\n     * @param {PeerId} peerId\n     * @param {number} value A number between 0 and 1\n     */\n\n  }, {\n    key: \"setPeerValue\",\n    value: function setPeerValue(peerId, value) {\n      if (value < 0 || value > 1) {\n        throw new Error('value should be a number between 0 and 1');\n      }\n\n      if (peerId.toB58String) {\n        peerId = peerId.toB58String();\n      }\n\n      this._peerValues.set(peerId, value);\n    }\n    /**\n     * Checks the libp2p metrics to determine if any values have exceeded\n     * the configured maximums.\n     * @private\n     */\n\n  }, {\n    key: \"_checkMetrics\",\n    value: function _checkMetrics() {\n      var movingAverages = this._metrics.global.movingAverages;\n\n      var received = movingAverages.dataReceived[this._options.movingAverageInterval].movingAverage();\n\n      this._checkLimit('maxReceivedData', received);\n\n      var sent = movingAverages.dataSent[this._options.movingAverageInterval].movingAverage();\n\n      this._checkLimit('maxSentData', sent);\n\n      var total = received + sent;\n\n      this._checkLimit('maxData', total);\n\n      debug('metrics update', total);\n\n      this._timer.reschedule(this._options.pollInterval);\n    }\n    /**\n     * Tracks the incoming connection and check the connection limit\n     * @param {Connection} connection\n     */\n\n  }, {\n    key: \"onConnect\",\n    value: function onConnect(connection) {\n      var peerId = connection.remotePeer.toB58String();\n\n      this._connections.set(connection.id, connection);\n\n      if (!this._peerValues.has(peerId)) {\n        this._peerValues.set(peerId, this._options.defaultPeerValue);\n      }\n\n      this._checkLimit('maxConnections', this._connections.size);\n    }\n    /**\n     * Removes the connection from tracking\n     * @param {Connection} connection\n     */\n\n  }, {\n    key: \"onDisconnect\",\n    value: function onDisconnect(connection) {\n      this._connections.delete(connection.id);\n\n      this._peerValues.delete(connection.remotePeer.toB58String());\n    }\n    /**\n     * If the event loop is slow, maybe close a connection\n     * @private\n     * @param {*} summary The LatencyMonitor summary\n     */\n\n  }, {\n    key: \"_onLatencyMeasure\",\n    value: function _onLatencyMeasure(summary) {\n      this._checkLimit('maxEventLoopDelay', summary.avgMs);\n    }\n    /**\n     * If the `value` of `name` has exceeded its limit, maybe close a connection\n     * @private\n     * @param {string} name The name of the field to check limits for\n     * @param {number} value The current value of the field\n     */\n\n  }, {\n    key: \"_checkLimit\",\n    value: function _checkLimit(name, value) {\n      var limit = this._options[name];\n      debug('checking limit of %s. current value: %d of %d', name, value, limit);\n\n      if (value > limit) {\n        debug('%s: limit exceeded: %s, %d', this._peerId, name, value);\n\n        this._maybeDisconnectOne();\n      }\n    }\n    /**\n     * If we have more connections than our maximum, close a connection\n     * to the lowest valued peer.\n     * @private\n     */\n\n  }, {\n    key: \"_maybeDisconnectOne\",\n    value: function _maybeDisconnectOne() {\n      if (this._options.minConnections < this._connections.size) {\n        var peerValues = Array.from(this._peerValues).sort(byPeerValue);\n        debug('%s: sorted peer values: %j', this._peerId, peerValues);\n        var disconnectPeer = peerValues[0];\n\n        if (disconnectPeer) {\n          var peerId = disconnectPeer[0];\n          debug('%s: lowest value peer is %s', this._peerId, peerId);\n          debug('%s: closing a connection to %j', this._peerId, peerId);\n\n          var _iterator = _createForOfIteratorHelper(this._connections.values()),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var connection = _step.value;\n\n              if (connection.remotePeer.toB58String() === peerId) {\n                connection.close();\n                break;\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }\n      }\n    }\n  }]);\n\n  return ConnectionManager;\n}();\n\nmodule.exports = ConnectionManager;\n\nfunction byPeerValue(peerValueEntryA, peerValueEntryB) {\n  return peerValueEntryA[1] - peerValueEntryB[1];\n}","map":null,"metadata":{},"sourceType":"script"}