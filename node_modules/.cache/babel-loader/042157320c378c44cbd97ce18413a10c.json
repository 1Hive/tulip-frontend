{"ast":null,"code":"'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst debug = require('debug');\n\nconst pb = require('it-protocol-buffers');\n\nconst lp = require('it-length-prefixed');\n\nconst pipe = require('it-pipe');\n\nconst {\n  collect,\n  take,\n  consume\n} = require('streaming-iterables');\n\nconst PeerInfo = require('peer-info');\n\nconst PeerId = require('peer-id');\n\nconst multiaddr = require('multiaddr');\n\nconst {\n  toBuffer\n} = require('it-buffer');\n\nconst Message = require('./message');\n\nconst log = debug('libp2p:identify');\nlog.error = debug('libp2p:identify:error');\n\nconst {\n  MULTICODEC_IDENTIFY,\n  MULTICODEC_IDENTIFY_PUSH,\n  AGENT_VERSION,\n  PROTOCOL_VERSION\n} = require('./consts');\n\nconst errCode = require('err-code');\n\nconst {\n  codes\n} = require('../errors');\n\nclass IdentifyService {\n  /**\n   * Replaces the multiaddrs on the given `peerInfo`,\n   * with the provided `multiaddrs`\n   * @param {PeerInfo} peerInfo\n   * @param {Array<Multiaddr>|Array<Buffer>} multiaddrs\n   */\n  static updatePeerAddresses(peerInfo, multiaddrs) {\n    if (multiaddrs && multiaddrs.length > 0) {\n      peerInfo.multiaddrs.clear();\n      multiaddrs.forEach(ma => {\n        try {\n          peerInfo.multiaddrs.add(ma);\n        } catch (err) {\n          log.error('could not add multiaddr', err);\n        }\n      });\n    }\n  }\n  /**\n   * Replaces the protocols on the given `peerInfo`,\n   * with the provided `protocols`\n   * @static\n   * @param {PeerInfo} peerInfo\n   * @param {Array<string>} protocols\n   */\n\n\n  static updatePeerProtocols(peerInfo, protocols) {\n    if (protocols && protocols.length > 0) {\n      peerInfo.protocols.clear();\n      protocols.forEach(proto => peerInfo.protocols.add(proto));\n    }\n  }\n  /**\n   * Takes the `addr` and converts it to a Multiaddr if possible\n   * @param {Buffer|String} addr\n   * @returns {Multiaddr|null}\n   */\n\n\n  static getCleanMultiaddr(addr) {\n    if (addr && addr.length > 0) {\n      try {\n        return multiaddr(addr);\n      } catch (_) {\n        return null;\n      }\n    }\n\n    return null;\n  }\n  /**\n   * @constructor\n   * @param {object} options\n   * @param {Registrar} options.registrar\n   * @param {Map<string, handler>} options.protocols A reference to the protocols we support\n   * @param {PeerInfo} options.peerInfo The peer running the identify service\n   */\n\n\n  constructor(options) {\n    /**\n     * @property {Registrar}\n     */\n    this.registrar = options.registrar;\n    /**\n     * @property {PeerInfo}\n     */\n\n    this.peerInfo = options.peerInfo;\n    this._protocols = options.protocols;\n    this.handleMessage = this.handleMessage.bind(this);\n  }\n  /**\n   * Send an Identify Push update to the list of connections\n   * @param {Array<Connection>} connections\n   * @returns {Promise<void>}\n   */\n\n\n  push(connections) {\n    const pushes = connections.map(async connection => {\n      try {\n        const {\n          stream\n        } = await connection.newStream(MULTICODEC_IDENTIFY_PUSH);\n        await pipe([{\n          listenAddrs: this.peerInfo.multiaddrs.toArray().map(ma => ma.buffer),\n          protocols: Array.from(this._protocols.keys())\n        }], pb.encode(Message), stream, consume);\n      } catch (err) {\n        // Just log errors\n        log.error('could not push identify update to peer', err);\n      }\n    });\n    return Promise.all(pushes);\n  }\n  /**\n   * Calls `push` for all peers in the `peerStore` that are connected\n   * @param {PeerStore} peerStore\n   */\n\n\n  pushToPeerStore(peerStore) {\n    const connections = [];\n    let connection;\n\n    for (const peer of peerStore.peers.values()) {\n      if (peer.protocols.has(MULTICODEC_IDENTIFY_PUSH) && (connection = this.registrar.getConnection(peer))) {\n        connections.push(connection);\n      }\n    }\n\n    this.push(connections);\n  }\n  /**\n   * Requests the `Identify` message from peer associated with the given `connection`.\n   * If the identified peer does not match the `PeerId` associated with the connection,\n   * an error will be thrown.\n   *\n   * @async\n   * @param {Connection} connection\n   * @returns {Promise<void>}\n   */\n\n\n  async identify(connection) {\n    const {\n      stream\n    } = await connection.newStream(MULTICODEC_IDENTIFY);\n    const [data] = await pipe([], stream, lp.decode(), take(1), toBuffer, collect);\n\n    if (!data) {\n      throw errCode(new Error('No data could be retrieved'), codes.ERR_CONNECTION_ENDED);\n    }\n\n    let message;\n\n    try {\n      message = Message.decode(data);\n    } catch (err) {\n      throw errCode(err, codes.ERR_INVALID_MESSAGE);\n    }\n\n    let {\n      publicKey,\n      listenAddrs,\n      protocols,\n      observedAddr\n    } = message;\n    const id = await PeerId.createFromPubKey(publicKey);\n    const peerInfo = new PeerInfo(id);\n\n    if (connection.remotePeer.toB58String() !== id.toB58String()) {\n      throw errCode(new Error('identified peer does not match the expected peer'), codes.ERR_INVALID_PEER);\n    } // Get the observedAddr if there is one\n\n\n    observedAddr = IdentifyService.getCleanMultiaddr(observedAddr); // Copy the listenAddrs and protocols\n\n    IdentifyService.updatePeerAddresses(peerInfo, listenAddrs);\n    IdentifyService.updatePeerProtocols(peerInfo, protocols);\n    this.registrar.peerStore.replace(peerInfo); // TODO: Track our observed address so that we can score it\n\n    log('received observed address of %s', observedAddr);\n  }\n  /**\n   * A handler to register with Libp2p to process identify messages.\n   *\n   * @param {object} options\n   * @param {String} options.protocol\n   * @param {*} options.stream\n   * @param {Connection} options.connection\n   * @returns {Promise<void>}\n   */\n\n\n  handleMessage({\n    connection,\n    stream,\n    protocol\n  }) {\n    switch (protocol) {\n      case MULTICODEC_IDENTIFY:\n        return this._handleIdentify({\n          connection,\n          stream\n        });\n\n      case MULTICODEC_IDENTIFY_PUSH:\n        return this._handlePush({\n          connection,\n          stream\n        });\n\n      default:\n        log.error('cannot handle unknown protocol %s', protocol);\n    }\n  }\n  /**\n   * Sends the `Identify` response to the requesting peer over the\n   * given `connection`\n   * @private\n   * @param {object} options\n   * @param {*} options.stream\n   * @param {Connection} options.connection\n   */\n\n\n  async _handleIdentify({\n    connection,\n    stream\n  }) {\n    let publicKey = Buffer.alloc(0);\n\n    if (this.peerInfo.id.pubKey) {\n      publicKey = this.peerInfo.id.pubKey.bytes;\n    }\n\n    const message = Message.encode({\n      protocolVersion: PROTOCOL_VERSION,\n      agentVersion: AGENT_VERSION,\n      publicKey,\n      listenAddrs: this.peerInfo.multiaddrs.toArray().map(ma => ma.buffer),\n      observedAddr: connection.remoteAddr.buffer,\n      protocols: Array.from(this._protocols.keys())\n    });\n\n    try {\n      await pipe([message], lp.encode(), stream, consume);\n    } catch (err) {\n      log.error('could not respond to identify request', err);\n    }\n  }\n  /**\n   * Reads the Identify Push message from the given `connection`\n   * @private\n   * @param {object} options\n   * @param {*} options.stream\n   * @param {Connection} options.connection\n   */\n\n\n  async _handlePush({\n    connection,\n    stream\n  }) {\n    let message;\n\n    try {\n      const [data] = await pipe([], stream, lp.decode(), take(1), toBuffer, collect);\n      message = Message.decode(data);\n    } catch (err) {\n      return log.error('received invalid message', err);\n    } // Update the listen addresses\n\n\n    const peerInfo = new PeerInfo(connection.remotePeer);\n\n    try {\n      IdentifyService.updatePeerAddresses(peerInfo, message.listenAddrs);\n    } catch (err) {\n      return log.error('received invalid listen addrs', err);\n    } // Update the protocols\n\n\n    IdentifyService.updatePeerProtocols(peerInfo, message.protocols); // Update the peer in the PeerStore\n\n    this.registrar.peerStore.replace(peerInfo);\n  }\n\n}\n\nmodule.exports.IdentifyService = IdentifyService;\n/**\n * The protocols the IdentifyService supports\n * @property multicodecs\n */\n\nmodule.exports.multicodecs = {\n  IDENTIFY: MULTICODEC_IDENTIFY,\n  IDENTIFY_PUSH: MULTICODEC_IDENTIFY_PUSH\n};\nmodule.exports.Message = Message;","map":null,"metadata":{},"sourceType":"script"}