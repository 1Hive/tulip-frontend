{"ast":null,"code":"'use strict';\n\nconst CID = require('cids');\n\nconst {\n  cidToString\n} = require('../../../utils/cid');\n\nconst log = require('debug')('ipfs:repo:gc');\n\nconst {\n  MFS_ROOT_KEY,\n  withTimeoutOption\n} = require('../../utils');\n\nconst Repo = require('ipfs-repo');\n\nconst {\n  Errors\n} = require('interface-datastore');\n\nconst ERR_NOT_FOUND = Errors.notFoundError().code;\n\nconst {\n  parallelMerge,\n  transform,\n  map\n} = require('streaming-iterables'); // Limit on the number of parallel block remove operations\n\n\nconst BLOCK_RM_CONCURRENCY = 256; // Perform mark and sweep garbage collection\n\nmodule.exports = ({\n  gcLock,\n  pin,\n  pinManager,\n  refs,\n  repo\n}) => {\n  return withTimeoutOption(async function* gc(options = {}) {\n    const start = Date.now();\n    log('Creating set of marked blocks');\n    const release = await gcLock.writeLock();\n\n    try {\n      // Mark all blocks that are being used\n      const markedSet = await createMarkedSet({\n        pin,\n        pinManager,\n        refs,\n        repo\n      }); // Get all blocks keys from the blockstore\n\n      const blockKeys = repo.blocks.query({\n        keysOnly: true\n      }); // Delete blocks that are not being used\n\n      yield* deleteUnmarkedBlocks({\n        repo,\n        refs\n      }, markedSet, blockKeys);\n      log(`Complete (${Date.now() - start}ms)`);\n    } finally {\n      release();\n    }\n  });\n}; // Get Set of CIDs of blocks to keep\n\n\nasync function createMarkedSet({\n  pin,\n  pinManager,\n  refs,\n  repo\n}) {\n  const pinsSource = map(({\n    cid\n  }) => cid, pin.ls());\n\n  const pinInternalsSource = async function* () {\n    const cids = await pinManager.getInternalBlocks();\n    yield* cids;\n  }();\n\n  const mfsSource = async function* () {\n    let mh;\n\n    try {\n      mh = await repo.root.get(MFS_ROOT_KEY);\n    } catch (err) {\n      if (err.code === ERR_NOT_FOUND) {\n        log('No blocks in MFS');\n        return;\n      }\n\n      throw err;\n    }\n\n    const rootCid = new CID(mh);\n    yield rootCid;\n\n    for await (const {\n      ref\n    } of refs(rootCid, {\n      recursive: true\n    })) {\n      yield new CID(ref);\n    }\n  }();\n\n  const output = new Set();\n\n  for await (const cid of parallelMerge(pinsSource, pinInternalsSource, mfsSource)) {\n    output.add(cidToString(cid, {\n      base: 'base32'\n    }));\n  }\n\n  return output;\n} // Delete all blocks that are not marked as in use\n\n\nasync function* deleteUnmarkedBlocks({\n  repo,\n  refs\n}, markedSet, blockKeys) {\n  // Iterate through all blocks and find those that are not in the marked set\n  // blockKeys yields { key: Key() }\n  let blocksCount = 0;\n  let removedBlocksCount = 0;\n\n  const removeBlock = async ({\n    key: k\n  }) => {\n    blocksCount++;\n\n    try {\n      const cid = Repo.utils.blockstore.keyToCid(k);\n      const b32 = cid.toV1().toString('base32');\n      if (markedSet.has(b32)) return null;\n      const res = {\n        cid\n      };\n\n      try {\n        await repo.blocks.delete(cid);\n        removedBlocksCount++;\n      } catch (err) {\n        res.err = new Error(`Could not delete block with CID ${cid}: ${err.message}`);\n      }\n\n      return res;\n    } catch (err) {\n      const msg = `Could not convert block with key '${k}' to CID`;\n      log(msg, err);\n      return {\n        err: new Error(msg + `: ${err.message}`)\n      };\n    }\n  };\n\n  for await (const res of transform(BLOCK_RM_CONCURRENCY, removeBlock, blockKeys)) {\n    // filter nulls (blocks that were retained)\n    if (res) yield res;\n  }\n\n  log(`Marked set has ${markedSet.size} unique blocks. Blockstore has ${blocksCount} blocks. ` + `Deleted ${removedBlocksCount} blocks.`);\n}","map":null,"metadata":{},"sourceType":"script"}