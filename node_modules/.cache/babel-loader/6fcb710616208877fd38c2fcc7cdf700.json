{"ast":null,"code":"'use strict';\n\nconst queue = require('async/queue');\n\nconst promiseToCallback = require('promise-to-callback');\n\nclass WorkerQueue {\n  /**\n   * Creates a new WorkerQueue.\n   *\n   * @param {DHT} dht\n   * @param {Run} run\n   * @param {Object} path\n   * @param {function} log\n   */\n  constructor(dht, run, path, log) {\n    this.dht = dht;\n    this.run = run;\n    this.path = path;\n    this.log = log;\n    this.concurrency = this.dht.concurrency;\n    this.queue = this.setupQueue(); // a container for resolve/reject functions that will be populated\n    // when execute() is called\n\n    this.execution = null;\n  }\n  /**\n   * Create the underlying async queue.\n   *\n   * @returns {Object}\n   */\n\n\n  setupQueue() {\n    const q = queue((peer, cb) => {\n      promiseToCallback(this.processNext(peer))(cb);\n    }, this.concurrency); // If there's an error, stop the worker\n\n    q.error = err => {\n      this.log.error('queue', err);\n      this.stop(err);\n    }; // When all peers in the queue have been processed, stop the worker\n\n\n    q.drain = () => {\n      this.log('queue:drain');\n      this.stop();\n    }; // When a space opens up in the queue, add some more peers\n\n\n    q.unsaturated = () => {\n      if (this.running) {\n        this.fill();\n      }\n    };\n\n    q.buffer = 0;\n    return q;\n  }\n  /**\n   * Stop the worker, optionally providing an error to pass to the worker's\n   * callback.\n   *\n   * @param {Error} err\n   */\n\n\n  stop(err) {\n    if (!this.running) {\n      return;\n    }\n\n    this.running = false;\n    this.queue.kill();\n    this.log('worker:stop, %d workers still running', this.run.workers.filter(w => w.running).length);\n\n    if (err) {\n      this.execution.reject(err);\n    } else {\n      this.execution.resolve();\n    }\n  }\n  /**\n   * Use the queue from async to keep `concurrency` amount items running\n   * per path.\n   *\n   * @return {Promise<void>}\n   */\n\n\n  async execute() {\n    this.running = true; // store the promise resolution functions to be resolved at end of queue\n\n    this.execution = {};\n    const execPromise = new Promise((resolve, reject) => Object.assign(this.execution, {\n      resolve,\n      reject\n    })); // start queue\n\n    this.fill(); // await completion\n\n    await execPromise;\n  }\n  /**\n   * Add peers to the worker queue until there are enough to satisfy the\n   * worker queue concurrency.\n   * Note that we don't want to take any more than those required to satisfy\n   * concurrency from the peers-to-query queue, because we always want to\n   * query the closest peers to the key first, and new peers are continously\n   * being added to the peers-to-query queue.\n   */\n\n\n  fill() {\n    // Note:\n    // - queue.running(): number of items that are currently running\n    // - queue.length(): the number of items that are waiting to be run\n    while (this.queue.running() + this.queue.length() < this.concurrency && this.path.peersToQuery.length > 0) {\n      this.queue.push(this.path.peersToQuery.dequeue());\n    }\n  }\n  /**\n   * Process the next peer in the queue\n   *\n   * @param {PeerId} peer\n   * @returns {Promise<void>}\n   */\n\n\n  async processNext(peer) {\n    if (!this.running) {\n      return;\n    } // The paths must be disjoint, meaning that no two paths in the Query may\n    // traverse the same peer\n\n\n    if (this.run.peersSeen.has(peer.toB58String())) {\n      return;\n    } // Check if we've queried enough peers already\n\n\n    let continueQuerying, continueQueryingError;\n\n    try {\n      continueQuerying = await this.run.continueQuerying(this);\n    } catch (err) {\n      continueQueryingError = err;\n    } // Abort and ignore any error if we're no longer running\n\n\n    if (!this.running) {\n      return;\n    }\n\n    if (continueQueryingError) {\n      throw continueQueryingError;\n    } // No peer we're querying is closer, stop the queue\n    // This will cause queries that may potentially result in\n    // closer nodes to be ended, but it reduces overall query time\n\n\n    if (!continueQuerying) {\n      this.stop();\n      return;\n    } // Check if another path has queried this peer in the mean time\n\n\n    if (this.run.peersSeen.has(peer.toB58String())) {\n      return;\n    }\n\n    this.run.peersSeen.add(peer.toB58String()); // Execute the query on the next peer\n\n    this.log('queue:work');\n    let state, execError;\n\n    try {\n      state = await this.execQuery(peer);\n    } catch (err) {\n      execError = err;\n    } // Abort and ignore any error if we're no longer running\n\n\n    if (!this.running) {\n      return;\n    }\n\n    this.log('queue:work:done', execError, state);\n\n    if (execError) {\n      throw execError;\n    } // If query is complete, stop all workers.\n    // Note: run.stop() calls stop() on all the workers, which kills the\n    // queue and resolves execution\n\n\n    if (state && state.queryComplete) {\n      this.log('query:complete');\n      this.run.stop();\n      return;\n    } // If path is complete, just stop this worker.\n    // Note: this.stop() kills the queue and resolves execution\n\n\n    if (state && state.pathComplete) {\n      this.stop();\n    }\n  }\n  /**\n   * Execute a query on the next peer.\n   *\n   * @param {PeerId} peer\n   * @returns {Promise<void>}\n   * @private\n   */\n\n\n  async execQuery(peer) {\n    let res, queryError;\n\n    try {\n      res = await this.path.queryFunc(peer);\n    } catch (err) {\n      queryError = err;\n    } // Abort and ignore any error if we're no longer running\n\n\n    if (!this.running) {\n      return;\n    }\n\n    if (queryError) {\n      this.run.errors.push(queryError);\n      return;\n    } // Add the peer to the closest peers we have successfully queried\n\n\n    await this.run.peersQueried.add(peer); // If the query indicates that this path or the whole query is complete\n    // set the path result and bail out\n\n    if (res.pathComplete || res.queryComplete) {\n      this.path.res = res;\n      return {\n        pathComplete: res.pathComplete,\n        queryComplete: res.queryComplete\n      };\n    } // If there are closer peers to query, add them to the queue\n\n\n    if (res.closerPeers && res.closerPeers.length > 0) {\n      await Promise.all(res.closerPeers.map(async closer => {\n        // don't add ourselves\n        if (this.dht._isSelf(closer.id)) {\n          return;\n        }\n\n        closer = this.dht.peerStore.put(closer);\n\n        this.dht._peerDiscovered(closer);\n\n        await this.path.addPeerToQuery(closer.id);\n      }));\n    }\n  }\n\n}\n\nmodule.exports = WorkerQueue;","map":null,"metadata":{},"sourceType":"script"}