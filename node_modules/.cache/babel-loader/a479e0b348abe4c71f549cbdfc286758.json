{"ast":null,"code":"'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst mh = require('multihashing-async');\n\nconst crypto = require('libp2p-crypto');\n\nconst {\n  InvalidCryptoExchangeError\n} = require('libp2p-interfaces/src/crypto/errors');\n\nexports.exchanges = ['P-256', 'P-384', 'P-521'];\nexports.ciphers = ['AES-256', 'AES-128'];\nexports.hashes = ['SHA256', 'SHA512']; // Determines which algorithm to use.  Note:  f(a, b) = f(b, a)\n\nexports.theBest = (order, p1, p2) => {\n  let first;\n  let second;\n\n  if (order < 0) {\n    first = p2;\n    second = p1;\n  } else if (order > 0) {\n    first = p1;\n    second = p2;\n  } else {\n    return p1[0];\n  }\n\n  for (const firstCandidate of first) {\n    for (const secondCandidate of second) {\n      if (firstCandidate === secondCandidate) {\n        return firstCandidate;\n      }\n    }\n  }\n\n  throw new InvalidCryptoExchangeError('No algorithms in common!');\n};\n\nexports.makeMacAndCipher = async target => {\n  [target.mac, target.cipher] = await Promise.all([makeMac(target.hashT, target.keys.macKey), makeCipher(target.cipherT, target.keys.iv, target.keys.cipherKey)]);\n};\n\nfunction makeMac(hash, key) {\n  return crypto.hmac.create(hash, key);\n}\n\nfunction makeCipher(cipherType, iv, key) {\n  if (cipherType === 'AES-128' || cipherType === 'AES-256') {\n    return crypto.aes.create(key, iv);\n  } // TODO: figure out if Blowfish is needed and if so find a library for it.\n\n\n  throw new InvalidCryptoExchangeError(`unrecognized cipher type: ${cipherType}`);\n}\n\nexports.selectBest = async (local, remote) => {\n  const oh1 = await exports.digest(Buffer.concat([remote.pubKeyBytes, local.nonce]));\n  const oh2 = await exports.digest(Buffer.concat([local.pubKeyBytes, remote.nonce]));\n  const order = Buffer.compare(oh1, oh2);\n\n  if (order === 0) {\n    throw new InvalidCryptoExchangeError('you are trying to talk to yourself');\n  }\n\n  return {\n    curveT: exports.theBest(order, local.exchanges, remote.exchanges),\n    cipherT: exports.theBest(order, local.ciphers, remote.ciphers),\n    hashT: exports.theBest(order, local.hashes, remote.hashes),\n    order\n  };\n};\n\nexports.digest = buf => {\n  return mh.digest(buf, 'sha2-256', buf.length);\n};","map":null,"metadata":{},"sourceType":"script"}