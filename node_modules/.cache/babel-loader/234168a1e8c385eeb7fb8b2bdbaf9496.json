{"ast":null,"code":"'use strict';\n\nconst applyDefaultOptions = require('./utils/apply-default-options');\n\nconst toMfsPath = require('./utils/to-mfs-path');\n\nconst exporter = require('ipfs-unixfs-exporter');\n\nconst log = require('debug')('ipfs:mfs:stat');\n\nconst errCode = require('err-code');\n\nconst {\n  withTimeoutOption\n} = require('../../utils');\n\nconst defaultOptions = {\n  withLocal: false\n};\n\nmodule.exports = context => {\n  return withTimeoutOption(async function mfsStat(path, options) {\n    options = applyDefaultOptions(options, defaultOptions);\n    log(`Fetching stats for ${path}`);\n    const {\n      type,\n      cid,\n      mfsPath\n    } = await toMfsPath(context, path);\n    const exportPath = type === 'ipfs' && cid ? cid : mfsPath;\n    let file;\n\n    try {\n      file = await exporter(exportPath, context.ipld);\n    } catch (err) {\n      if (err.code === 'ERR_NOT_FOUND') {\n        throw errCode(new Error(`${path} does not exist`), 'ERR_NOT_FOUND');\n      }\n\n      throw err;\n    }\n\n    if (!statters[file.cid.codec]) {\n      throw new Error(`Cannot stat codec ${file.cid.codec}`);\n    }\n\n    return statters[file.cid.codec](file, options);\n  });\n};\n\nconst statters = {\n  raw: file => {\n    return {\n      cid: file.cid,\n      size: file.node.length,\n      cumulativeSize: file.node.length,\n      blocks: 0,\n      type: 'file',\n      // for go compatibility\n      local: undefined,\n      sizeLocal: undefined,\n      withLocality: false\n    };\n  },\n  'dag-pb': file => {\n    const blocks = file.node.Links.length;\n    const size = file.node.size;\n    const cumulativeSize = file.node.size;\n    const output = {\n      cid: file.cid,\n      size: size,\n      cumulativeSize: cumulativeSize,\n      blocks: blocks,\n      local: undefined,\n      sizeLocal: undefined,\n      withLocality: false\n    };\n\n    if (file.unixfs) {\n      output.size = file.unixfs.fileSize(); // for go-ipfs compatibility\n\n      if (file.unixfs.type === 'hamt-sharded-directory') {\n        output.type = 'directory';\n      } else {\n        output.type = file.unixfs.type;\n      }\n\n      output.mode = file.unixfs.mode;\n\n      if (file.unixfs.isDirectory()) {\n        output.size = 0;\n        output.cumulativeSize = file.node.size;\n      }\n\n      if (output.type === 'file') {\n        output.blocks = file.unixfs.blockSizes.length;\n      }\n\n      if (file.unixfs.mtime) {\n        output.mtime = file.unixfs.mtime;\n      }\n    }\n\n    return output;\n  },\n  'dag-cbor': file => {\n    return {\n      cid: file.cid,\n      local: undefined,\n      sizeLocal: undefined,\n      withLocality: false\n    };\n  },\n  identity: file => {\n    return {\n      cid: file.cid,\n      size: file.node.digest.length,\n      cumulativeSize: file.node.digest.length,\n      blocks: 0,\n      type: 'file',\n      // for go compatibility\n      local: undefined,\n      sizeLocal: undefined,\n      withLocality: false\n    };\n  }\n};","map":null,"metadata":{},"sourceType":"script"}