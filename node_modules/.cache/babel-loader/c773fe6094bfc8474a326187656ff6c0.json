{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar ipns = require('ipns');\n\nvar crypto = require('libp2p-crypto');\n\nvar PeerId = require('peer-id');\n\nvar errcode = require('err-code');\n\nvar debug = require('debug');\n\nvar log = debug('ipfs:ipns:resolver');\nlog.error = debug('ipfs:ipns:resolver:error');\n\nvar _require = require('interface-datastore'),\n    Errors = _require.Errors;\n\nvar ERR_NOT_FOUND = Errors.notFoundError().code;\nvar defaultMaximumRecursiveDepth = 32;\n\nvar IpnsResolver = /*#__PURE__*/function () {\n  function IpnsResolver(routing) {\n    _classCallCheck(this, IpnsResolver);\n\n    this._routing = routing;\n  }\n\n  _createClass(IpnsResolver, [{\n    key: \"resolve\",\n    value: function () {\n      var _resolve = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(name, options) {\n        var recursive, nameSegments, key, depth, res;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                options = options || {};\n\n                if (!(typeof name !== 'string')) {\n                  _context.next = 3;\n                  break;\n                }\n\n                throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME');\n\n              case 3:\n                options = options || {};\n                recursive = options.recursive && options.recursive.toString() === 'true';\n                nameSegments = name.split('/');\n\n                if (!(nameSegments.length !== 3 || nameSegments[0] !== '')) {\n                  _context.next = 8;\n                  break;\n                }\n\n                throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME');\n\n              case 8:\n                key = nameSegments[2]; // Define a maximum depth if recursive option enabled\n\n                if (recursive) {\n                  depth = defaultMaximumRecursiveDepth;\n                }\n\n                _context.next = 12;\n                return this.resolver(key, depth);\n\n              case 12:\n                res = _context.sent;\n                log(\"\".concat(name, \" was locally resolved correctly\"));\n                return _context.abrupt(\"return\", res);\n\n              case 15:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function resolve(_x, _x2) {\n        return _resolve.apply(this, arguments);\n      }\n\n      return resolve;\n    }() // Recursive resolver according to the specified depth\n\n  }, {\n    key: \"resolver\",\n    value: function () {\n      var _resolver = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(name, depth) {\n        var errMsg, res, nameSegments;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(depth === 0)) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                errMsg = \"could not resolve name (recursion limit of \".concat(defaultMaximumRecursiveDepth, \" exceeded)\");\n                log.error(errMsg);\n                throw errcode(new Error(errMsg), 'ERR_RESOLVE_RECURSION_LIMIT');\n\n              case 4:\n                _context2.next = 6;\n                return this._resolveName(name);\n\n              case 6:\n                res = _context2.sent;\n                nameSegments = res.split('/'); // If obtained a ipfs cid or recursive option is disabled\n\n                if (!(nameSegments[1] === 'ipfs' || !depth)) {\n                  _context2.next = 10;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", res);\n\n              case 10:\n                return _context2.abrupt(\"return\", this.resolver(nameSegments[2], depth - 1));\n\n              case 11:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function resolver(_x3, _x4) {\n        return _resolver.apply(this, arguments);\n      }\n\n      return resolver;\n    }() // resolve ipns entries from the provided routing\n\n  }, {\n    key: \"_resolveName\",\n    value: function () {\n      var _resolveName2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(name) {\n        var peerId, _ipns$getIdKeys, routingKey, record, ipnsEntry, pubKey;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                peerId = PeerId.createFromCID(name);\n                _ipns$getIdKeys = ipns.getIdKeys(peerId.toBytes()), routingKey = _ipns$getIdKeys.routingKey;\n                _context3.prev = 2;\n                _context3.next = 5;\n                return this._routing.get(routingKey.toBuffer());\n\n              case 5:\n                record = _context3.sent;\n                _context3.next = 14;\n                break;\n\n              case 8:\n                _context3.prev = 8;\n                _context3.t0 = _context3[\"catch\"](2);\n                log.error(_context3.t0);\n\n                if (!(_context3.t0.code === ERR_NOT_FOUND)) {\n                  _context3.next = 13;\n                  break;\n                }\n\n                throw errcode(new Error(\"record requested for \".concat(name, \" was not found in the network\")), 'ERR_NO_RECORD_FOUND');\n\n              case 13:\n                throw errcode(new Error(\"unexpected error getting the ipns record \".concat(peerId.id)), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD');\n\n              case 14:\n                _context3.prev = 14;\n                ipnsEntry = ipns.unmarshal(record);\n                _context3.next = 22;\n                break;\n\n              case 18:\n                _context3.prev = 18;\n                _context3.t1 = _context3[\"catch\"](14);\n                log.error(_context3.t1);\n                throw errcode(new Error('found ipns record that we couldn\\'t convert to a value'), 'ERR_INVALID_RECORD_RECEIVED');\n\n              case 22:\n                if (!ipnsEntry.pubKey) {\n                  _context3.next = 24;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", this._validateRecord(peerId, ipnsEntry));\n\n              case 24:\n                _context3.prev = 24;\n                _context3.next = 27;\n                return this._routing.get(routingKey.toBuffer());\n\n              case 27:\n                pubKey = _context3.sent;\n                _context3.next = 36;\n                break;\n\n              case 30:\n                _context3.prev = 30;\n                _context3.t2 = _context3[\"catch\"](24);\n                log.error(_context3.t2);\n\n                if (!(_context3.t2.code === ERR_NOT_FOUND)) {\n                  _context3.next = 35;\n                  break;\n                }\n\n                throw errcode(new Error(\"public key requested for \".concat(name, \" was not found in the network\")), 'ERR_NO_RECORD_FOUND');\n\n              case 35:\n                throw errcode(new Error(\"unexpected error getting the public key for the ipns record \".concat(peerId.id)), 'ERR_UNEXPECTED_ERROR_GETTING_PUB_KEY');\n\n              case 36:\n                _context3.prev = 36;\n                // Insert it into the peer id, in order to be validated by IPNS validator\n                peerId.pubKey = crypto.keys.unmarshalPublicKey(pubKey);\n                _context3.next = 44;\n                break;\n\n              case 40:\n                _context3.prev = 40;\n                _context3.t3 = _context3[\"catch\"](36);\n                log.error(_context3.t3);\n                throw errcode(new Error('found public key record that we couldn\\'t convert to a value'), 'ERR_INVALID_PUB_KEY_RECEIVED');\n\n              case 44:\n                return _context3.abrupt(\"return\", this._validateRecord(peerId, ipnsEntry));\n\n              case 45:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[2, 8], [14, 18], [24, 30], [36, 40]]);\n      }));\n\n      function _resolveName(_x5) {\n        return _resolveName2.apply(this, arguments);\n      }\n\n      return _resolveName;\n    }() // validate a resolved record\n\n  }, {\n    key: \"_validateRecord\",\n    value: function () {\n      var _validateRecord2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(peerId, ipnsEntry) {\n        var pubKey;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return ipns.extractPublicKey(peerId, ipnsEntry);\n\n              case 2:\n                pubKey = _context4.sent;\n                _context4.next = 5;\n                return ipns.validate(pubKey, ipnsEntry);\n\n              case 5:\n                return _context4.abrupt(\"return\", ipnsEntry.value.toString());\n\n              case 6:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      function _validateRecord(_x6, _x7) {\n        return _validateRecord2.apply(this, arguments);\n      }\n\n      return _validateRecord;\n    }()\n  }]);\n\n  return IpnsResolver;\n}();\n\nexports = module.exports = IpnsResolver;","map":null,"metadata":{},"sourceType":"script"}