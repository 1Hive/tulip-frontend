{"ast":null,"code":"\"use strict\"; // Runtime header offsets\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _defineProperty = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar ID_OFFSET = -8;\nvar SIZE_OFFSET = -4; // Runtime ids\n\nvar ARRAYBUFFER_ID = 0;\nvar STRING_ID = 1;\nvar ARRAYBUFFERVIEW_ID = 2; // Runtime type information\n\nvar ARRAYBUFFERVIEW = 1 << 0;\nvar ARRAY = 1 << 1;\nvar SET = 1 << 2;\nvar MAP = 1 << 3;\nvar VAL_ALIGN_OFFSET = 5;\nvar VAL_ALIGN = 1 << VAL_ALIGN_OFFSET;\nvar VAL_SIGNED = 1 << 10;\nvar VAL_FLOAT = 1 << 11;\nvar VAL_NULLABLE = 1 << 12;\nvar VAL_MANAGED = 1 << 13;\nvar KEY_ALIGN_OFFSET = 14;\nvar KEY_ALIGN = 1 << KEY_ALIGN_OFFSET;\nvar KEY_SIGNED = 1 << 19;\nvar KEY_FLOAT = 1 << 20;\nvar KEY_NULLABLE = 1 << 21;\nvar KEY_MANAGED = 1 << 22; // Array(BufferView) layout\n\nvar ARRAYBUFFERVIEW_BUFFER_OFFSET = 0;\nvar ARRAYBUFFERVIEW_DATASTART_OFFSET = 4;\nvar ARRAYBUFFERVIEW_DATALENGTH_OFFSET = 8;\nvar ARRAYBUFFERVIEW_SIZE = 12;\nvar ARRAY_LENGTH_OFFSET = 12;\nvar ARRAY_SIZE = 16;\nvar BIGINT = typeof BigUint64Array !== \"undefined\";\nvar THIS = Symbol();\nvar CHUNKSIZE = 1024;\n/** Gets a string from an U32 and an U16 view on a memory. */\n\nfunction getStringImpl(buffer, ptr) {\n  var U32 = new Uint32Array(buffer);\n  var U16 = new Uint16Array(buffer);\n  var length = U32[ptr + SIZE_OFFSET >>> 2] >>> 1;\n  var offset = ptr >>> 1;\n  if (length <= CHUNKSIZE) return String.fromCharCode.apply(String, U16.subarray(offset, offset + length));\n  var parts = [];\n\n  do {\n    var last = U16[offset + CHUNKSIZE - 1];\n    var size = last >= 0xD800 && last < 0xDC00 ? CHUNKSIZE - 1 : CHUNKSIZE;\n    parts.push(String.fromCharCode.apply(String, U16.subarray(offset, offset += size)));\n    length -= size;\n  } while (length > CHUNKSIZE);\n\n  return parts.join(\"\") + String.fromCharCode.apply(String, U16.subarray(offset, offset + length));\n}\n/** Prepares the base module prior to instantiation. */\n\n\nfunction preInstantiate(imports) {\n  var baseModule = {};\n\n  function getString(memory, ptr) {\n    if (!memory) return \"<yet unknown>\";\n    return getStringImpl(memory.buffer, ptr);\n  } // add common imports used by stdlib for convenience\n\n\n  var env = imports.env = imports.env || {};\n\n  env.abort = env.abort || function abort(mesg, file, line, colm) {\n    var memory = baseModule.memory || env.memory; // prefer exported, otherwise try imported\n\n    throw Error(\"abort: \" + getString(memory, mesg) + \" at \" + getString(memory, file) + \":\" + line + \":\" + colm);\n  };\n\n  env.trace = env.trace || function trace(mesg, n) {\n    var memory = baseModule.memory || env.memory;\n    console.log(\"trace: \" + getString(memory, mesg) + (n ? \" \" : \"\") + Array.prototype.slice.call(arguments, 2, 2 + n).join(\", \"));\n  };\n\n  imports.Math = imports.Math || Math;\n  imports.Date = imports.Date || Date;\n  return baseModule;\n}\n/** Prepares the final module once instantiation is complete. */\n\n\nfunction postInstantiate(baseModule, instance) {\n  var rawExports = instance.exports;\n  var memory = rawExports.memory;\n  var table = rawExports.table;\n  var alloc = rawExports[\"__alloc\"];\n  var retain = rawExports[\"__retain\"];\n  var rttiBase = rawExports[\"__rtti_base\"] || ~0; // oob if not present\n\n  /** Gets the runtime type info for the given id. */\n\n  function getInfo(id) {\n    var U32 = new Uint32Array(memory.buffer);\n    var count = U32[rttiBase >>> 2];\n    if ((id >>>= 0) >= count) throw Error(\"invalid id: \" + id);\n    return U32[(rttiBase + 4 >>> 2) + id * 2];\n  }\n  /** Gets the runtime base id for the given id. */\n\n\n  function getBase(id) {\n    var U32 = new Uint32Array(memory.buffer);\n    var count = U32[rttiBase >>> 2];\n    if ((id >>>= 0) >= count) throw Error(\"invalid id: \" + id);\n    return U32[(rttiBase + 4 >>> 2) + id * 2 + 1];\n  }\n  /** Gets the runtime alignment of a collection's values. */\n\n\n  function getValueAlign(info) {\n    return 31 - Math.clz32(info >>> VAL_ALIGN_OFFSET & 31); // -1 if none\n  }\n  /** Gets the runtime alignment of a collection's keys. */\n\n\n  function getKeyAlign(info) {\n    return 31 - Math.clz32(info >>> KEY_ALIGN_OFFSET & 31); // -1 if none\n  }\n  /** Allocates a new string in the module's memory and returns its retained pointer. */\n\n\n  function __allocString(str) {\n    var length = str.length;\n    var ptr = alloc(length << 1, STRING_ID);\n    var U16 = new Uint16Array(memory.buffer);\n\n    for (var i = 0, p = ptr >>> 1; i < length; ++i) {\n      U16[p + i] = str.charCodeAt(i);\n    }\n\n    return ptr;\n  }\n\n  baseModule.__allocString = __allocString;\n  /** Reads a string from the module's memory by its pointer. */\n\n  function __getString(ptr) {\n    var buffer = memory.buffer;\n    var id = new Uint32Array(buffer)[ptr + ID_OFFSET >>> 2];\n    if (id !== STRING_ID) throw Error(\"not a string: \" + ptr);\n    return getStringImpl(buffer, ptr);\n  }\n\n  baseModule.__getString = __getString;\n  /** Gets the view matching the specified alignment, signedness and floatness. */\n\n  function getView(alignLog2, signed, float) {\n    var buffer = memory.buffer;\n\n    if (float) {\n      switch (alignLog2) {\n        case 2:\n          return new Float32Array(buffer);\n\n        case 3:\n          return new Float64Array(buffer);\n      }\n    } else {\n      switch (alignLog2) {\n        case 0:\n          return new (signed ? Int8Array : Uint8Array)(buffer);\n\n        case 1:\n          return new (signed ? Int16Array : Uint16Array)(buffer);\n\n        case 2:\n          return new (signed ? Int32Array : Uint32Array)(buffer);\n\n        case 3:\n          return new (signed ? BigInt64Array : BigUint64Array)(buffer);\n      }\n    }\n\n    throw Error(\"unsupported align: \" + alignLog2);\n  }\n  /** Allocates a new array in the module's memory and returns its retained pointer. */\n\n\n  function __allocArray(id, values) {\n    var info = getInfo(id);\n    if (!(info & (ARRAYBUFFERVIEW | ARRAY))) throw Error(\"not an array: \" + id + \" @ \" + info);\n    var align = getValueAlign(info);\n    var length = values.length;\n    var buf = alloc(length << align, ARRAYBUFFER_ID);\n    var arr = alloc(info & ARRAY ? ARRAY_SIZE : ARRAYBUFFERVIEW_SIZE, id);\n    var U32 = new Uint32Array(memory.buffer);\n    U32[arr + ARRAYBUFFERVIEW_BUFFER_OFFSET >>> 2] = retain(buf);\n    U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2] = buf;\n    U32[arr + ARRAYBUFFERVIEW_DATALENGTH_OFFSET >>> 2] = length << align;\n    if (info & ARRAY) U32[arr + ARRAY_LENGTH_OFFSET >>> 2] = length;\n    var view = getView(align, info & VAL_SIGNED, info & VAL_FLOAT);\n\n    if (info & VAL_MANAGED) {\n      for (var i = 0; i < length; ++i) {\n        view[(buf >>> align) + i] = retain(values[i]);\n      }\n    } else {\n      view.set(values, buf >>> align);\n    }\n\n    return arr;\n  }\n\n  baseModule.__allocArray = __allocArray;\n  /** Gets a live view on an array's values in the module's memory. Infers the array type from RTTI. */\n\n  function __getArrayView(arr) {\n    var U32 = new Uint32Array(memory.buffer);\n    var id = U32[arr + ID_OFFSET >>> 2];\n    var info = getInfo(id);\n    if (!(info & ARRAYBUFFERVIEW)) throw Error(\"not an array: \" + id);\n    var align = getValueAlign(info);\n    var buf = U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];\n    var length = info & ARRAY ? U32[arr + ARRAY_LENGTH_OFFSET >>> 2] : U32[buf + SIZE_OFFSET >>> 2] >>> align;\n    return getView(align, info & VAL_SIGNED, info & VAL_FLOAT).subarray(buf >>>= align, buf + length);\n  }\n\n  baseModule.__getArrayView = __getArrayView;\n  /** Copies an array's values from the module's memory. Infers the array type from RTTI. */\n\n  function __getArray(arr) {\n    var input = __getArrayView(arr);\n\n    var len = input.length;\n    var out = new Array(len);\n\n    for (var i = 0; i < len; i++) {\n      out[i] = input[i];\n    }\n\n    return out;\n  }\n\n  baseModule.__getArray = __getArray;\n  /** Copies an ArrayBuffer's value from the module's memory. */\n\n  function __getArrayBuffer(ptr) {\n    var buffer = memory.buffer;\n    var length = new Uint32Array(buffer)[ptr + SIZE_OFFSET >>> 2];\n    return buffer.slice(ptr, ptr + length);\n  }\n\n  baseModule.__getArrayBuffer = __getArrayBuffer;\n  /** Copies a typed array's values from the module's memory. */\n\n  function getTypedArray(Type, alignLog2, ptr) {\n    return new Type(getTypedArrayView(Type, alignLog2, ptr));\n  }\n  /** Gets a live view on a typed array's values in the module's memory. */\n\n\n  function getTypedArrayView(Type, alignLog2, ptr) {\n    var buffer = memory.buffer;\n    var U32 = new Uint32Array(buffer);\n    var bufPtr = U32[ptr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];\n    return new Type(buffer, bufPtr, U32[bufPtr + SIZE_OFFSET >>> 2] >>> alignLog2);\n  }\n\n  baseModule.__getInt8Array = getTypedArray.bind(null, Int8Array, 0);\n  baseModule.__getInt8ArrayView = getTypedArrayView.bind(null, Int8Array, 0);\n  baseModule.__getUint8Array = getTypedArray.bind(null, Uint8Array, 0);\n  baseModule.__getUint8ArrayView = getTypedArrayView.bind(null, Uint8Array, 0);\n  baseModule.__getUint8ClampedArray = getTypedArray.bind(null, Uint8ClampedArray, 0);\n  baseModule.__getUint8ClampedArrayView = getTypedArrayView.bind(null, Uint8ClampedArray, 0);\n  baseModule.__getInt16Array = getTypedArray.bind(null, Int16Array, 1);\n  baseModule.__getInt16ArrayView = getTypedArrayView.bind(null, Int16Array, 1);\n  baseModule.__getUint16Array = getTypedArray.bind(null, Uint16Array, 1);\n  baseModule.__getUint16ArrayView = getTypedArrayView.bind(null, Uint16Array, 1);\n  baseModule.__getInt32Array = getTypedArray.bind(null, Int32Array, 2);\n  baseModule.__getInt32ArrayView = getTypedArrayView.bind(null, Int32Array, 2);\n  baseModule.__getUint32Array = getTypedArray.bind(null, Uint32Array, 2);\n  baseModule.__getUint32ArrayView = getTypedArrayView.bind(null, Uint32Array, 2);\n\n  if (BIGINT) {\n    baseModule.__getInt64Array = getTypedArray.bind(null, BigInt64Array, 3);\n    baseModule.__getInt64ArrayView = getTypedArrayView.bind(null, BigInt64Array, 3);\n    baseModule.__getUint64Array = getTypedArray.bind(null, BigUint64Array, 3);\n    baseModule.__getUint64ArrayView = getTypedArrayView.bind(null, BigUint64Array, 3);\n  }\n\n  baseModule.__getFloat32Array = getTypedArray.bind(null, Float32Array, 2);\n  baseModule.__getFloat32ArrayView = getTypedArrayView.bind(null, Float32Array, 2);\n  baseModule.__getFloat64Array = getTypedArray.bind(null, Float64Array, 3);\n  baseModule.__getFloat64ArrayView = getTypedArrayView.bind(null, Float64Array, 3);\n  /** Tests whether an object is an instance of the class represented by the specified base id. */\n\n  function __instanceof(ptr, baseId) {\n    var U32 = new Uint32Array(memory.buffer);\n    var id = U32[ptr + ID_OFFSET >>> 2];\n\n    if (id <= U32[rttiBase >>> 2]) {\n      do {\n        if (id == baseId) return true;\n      } while (id = getBase(id));\n    }\n\n    return false;\n  }\n\n  baseModule.__instanceof = __instanceof; // Pull basic exports to baseModule so code in preInstantiate can use them\n\n  baseModule.memory = baseModule.memory || memory;\n  baseModule.table = baseModule.table || table; // Demangle exports and provide the usual utility on the prototype\n\n  return demangle(rawExports, baseModule);\n}\n\nfunction isResponse(o) {\n  return typeof Response !== \"undefined\" && o instanceof Response;\n}\n/** Asynchronously instantiates an AssemblyScript module from anything that can be instantiated. */\n\n\nfunction instantiate(_x, _x2) {\n  return _instantiate.apply(this, arguments);\n}\n\nfunction _instantiate() {\n  _instantiate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(source, imports) {\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.t0 = isResponse;\n            _context.next = 3;\n            return source;\n\n          case 3:\n            _context.t1 = source = _context.sent;\n\n            if (!(0, _context.t0)(_context.t1)) {\n              _context.next = 6;\n              break;\n            }\n\n            return _context.abrupt(\"return\", instantiateStreaming(source, imports));\n\n          case 6:\n            _context.t2 = postInstantiate;\n            _context.t3 = preInstantiate(imports || (imports = {}));\n            _context.t4 = WebAssembly;\n\n            if (!(source instanceof WebAssembly.Module)) {\n              _context.next = 13;\n              break;\n            }\n\n            _context.t5 = source;\n            _context.next = 16;\n            break;\n\n          case 13:\n            _context.next = 15;\n            return WebAssembly.compile(source);\n\n          case 15:\n            _context.t5 = _context.sent;\n\n          case 16:\n            _context.t6 = _context.t5;\n            _context.t7 = imports;\n            _context.next = 20;\n            return _context.t4.instantiate.call(_context.t4, _context.t6, _context.t7);\n\n          case 20:\n            _context.t8 = _context.sent;\n            return _context.abrupt(\"return\", (0, _context.t2)(_context.t3, _context.t8));\n\n          case 22:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _instantiate.apply(this, arguments);\n}\n\nexports.instantiate = instantiate;\n/** Synchronously instantiates an AssemblyScript module from a WebAssembly.Module or binary buffer. */\n\nfunction instantiateSync(source, imports) {\n  return postInstantiate(preInstantiate(imports || (imports = {})), new WebAssembly.Instance(source instanceof WebAssembly.Module ? source : new WebAssembly.Module(source), imports));\n}\n\nexports.instantiateSync = instantiateSync;\n/** Asynchronously instantiates an AssemblyScript module from a response, i.e. as obtained by `fetch`. */\n\nfunction instantiateStreaming(_x3, _x4) {\n  return _instantiateStreaming.apply(this, arguments);\n}\n\nfunction _instantiateStreaming() {\n  _instantiateStreaming = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(source, imports) {\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            if (WebAssembly.instantiateStreaming) {\n              _context2.next = 14;\n              break;\n            }\n\n            _context2.t0 = instantiate;\n            _context2.t1 = isResponse;\n            _context2.next = 5;\n            return source;\n\n          case 5:\n            _context2.t2 = source = _context2.sent;\n\n            if (!(0, _context2.t1)(_context2.t2)) {\n              _context2.next = 10;\n              break;\n            }\n\n            _context2.t3 = source.arrayBuffer();\n            _context2.next = 11;\n            break;\n\n          case 10:\n            _context2.t3 = source;\n\n          case 11:\n            _context2.t4 = _context2.t3;\n            _context2.t5 = imports;\n            return _context2.abrupt(\"return\", (0, _context2.t0)(_context2.t4, _context2.t5));\n\n          case 14:\n            _context2.t6 = postInstantiate;\n            _context2.t7 = preInstantiate(imports || (imports = {}));\n            _context2.next = 18;\n            return WebAssembly.instantiateStreaming(source, imports);\n\n          case 18:\n            _context2.t8 = _context2.sent.instance;\n            return _context2.abrupt(\"return\", (0, _context2.t6)(_context2.t7, _context2.t8));\n\n          case 20:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _instantiateStreaming.apply(this, arguments);\n}\n\nexports.instantiateStreaming = instantiateStreaming;\n/** Demangles an AssemblyScript module's exports to a friendly object structure. */\n\nfunction demangle(exports, baseModule) {\n  var module = baseModule ? Object.create(baseModule) : {};\n  var setArgumentsLength = exports[\"__argumentsLength\"] ? function (length) {\n    exports[\"__argumentsLength\"].value = length;\n  } : exports[\"__setArgumentsLength\"] || exports[\"__setargc\"] || function () {};\n\n  var _loop = function _loop(internalName) {\n    if (!Object.prototype.hasOwnProperty.call(exports, internalName)) return \"continue\";\n    var elem = exports[internalName];\n    var parts = internalName.split(\".\");\n    var curr = module;\n\n    while (parts.length > 1) {\n      var part = parts.shift();\n      if (!Object.prototype.hasOwnProperty.call(curr, part)) curr[part] = {};\n      curr = curr[part];\n    }\n\n    var name = parts[0];\n    var hash = name.indexOf(\"#\");\n\n    if (hash >= 0) {\n      var className = name.substring(0, hash);\n      var classElem = curr[className];\n\n      if (typeof classElem === \"undefined\" || !classElem.prototype) {\n        var ctor = function ctor() {\n          var _ctor$prototype;\n\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          return ctor.wrap((_ctor$prototype = ctor.prototype).constructor.apply(_ctor$prototype, [0].concat(args)));\n        };\n\n        ctor.prototype = {\n          valueOf: function valueOf() {\n            return this[THIS];\n          }\n        };\n\n        ctor.wrap = function (thisValue) {\n          return Object.create(ctor.prototype, _defineProperty({}, THIS, {\n            value: thisValue,\n            writable: false\n          }));\n        };\n\n        if (classElem) Object.getOwnPropertyNames(classElem).forEach(function (name) {\n          return Object.defineProperty(ctor, name, Object.getOwnPropertyDescriptor(classElem, name));\n        });\n        curr[className] = ctor;\n      }\n\n      name = name.substring(hash + 1);\n      curr = curr[className].prototype;\n\n      if (/^(get|set):/.test(name)) {\n        if (!Object.prototype.hasOwnProperty.call(curr, name = name.substring(4))) {\n          var getter = exports[internalName.replace(\"set:\", \"get:\")];\n          var setter = exports[internalName.replace(\"get:\", \"set:\")];\n          Object.defineProperty(curr, name, {\n            get: function get() {\n              return getter(this[THIS]);\n            },\n            set: function set(value) {\n              setter(this[THIS], value);\n            },\n            enumerable: true\n          });\n        }\n      } else {\n        if (name === 'constructor') {\n          (curr[name] = function () {\n            setArgumentsLength(arguments.length);\n            return elem.apply(void 0, arguments);\n          }).original = elem;\n        } else {\n          // instance method\n          (curr[name] = function () {\n            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n              args[_key2] = arguments[_key2];\n            }\n\n            // !\n            setArgumentsLength(args.length);\n            return elem.apply(void 0, [this[THIS]].concat(args));\n          }).original = elem;\n        }\n      }\n    } else {\n      if (/^(get|set):/.test(name)) {\n        if (!Object.prototype.hasOwnProperty.call(curr, name = name.substring(4))) {\n          Object.defineProperty(curr, name, {\n            get: exports[internalName.replace(\"set:\", \"get:\")],\n            set: exports[internalName.replace(\"get:\", \"set:\")],\n            enumerable: true\n          });\n        }\n      } else if (typeof elem === \"function\" && elem !== setArgumentsLength) {\n        (curr[name] = function () {\n          setArgumentsLength(arguments.length);\n          return elem.apply(void 0, arguments);\n        }).original = elem;\n      } else {\n        curr[name] = elem;\n      }\n    }\n  };\n\n  for (var internalName in exports) {\n    var _ret = _loop(internalName);\n\n    if (_ret === \"continue\") continue;\n  }\n\n  return module;\n}\n\nexports.demangle = demangle;","map":null,"metadata":{},"sourceType":"script"}