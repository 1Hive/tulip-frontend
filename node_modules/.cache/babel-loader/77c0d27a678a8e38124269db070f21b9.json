{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2[\"default\"])(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar _require = require('@ethersproject/hdnode'),\n    mnemonicToSeed = _require.mnemonicToSeed,\n    entropyToMnemonic = _require.entropyToMnemonic;\n\nvar EventEmitter = require('events');\n\nvar didJWT = require('did-jwt');\n\nvar _require2 = require('did-resolver'),\n    Resolver = _require2.Resolver;\n\nvar get3IdResolver = require('3id-resolver').getResolver;\n\nvar getMuportResolver = require('muport-did-resolver').getResolver;\n\nvar DidDocument = require('ipfs-did-document');\n\nvar localstorage = require('store');\n\nvar Identities = require('orbit-db-identity-provider');\n\nvar _require3 = require('3box-orbitdb-plugins'),\n    OdbIdentityProvider = _require3.OdbIdentityProvider;\n\nIdentities.addIdentityProvider(OdbIdentityProvider);\n\nvar utils = require('../utils/index');\n\nvar Keyring = require('./keyring');\n\nvar config = require('../config.js');\n\nvar nacl = require('tweetnacl');\n\nvar _require4 = require('./utils'),\n    randomNonce = _require4.randomNonce;\n\nvar DID_METHOD_NAME = '3';\nvar STORAGE_KEY = 'serialized3id_';\nvar MUPORT_IPFS = {\n  host: config.muport_ipfs_host,\n  port: config.muport_ipfs_port,\n  protocol: config.muport_ipfs_protocol\n};\nvar POLL_INTERVAL = 500;\n\nvar ThreeId = /*#__PURE__*/function () {\n  function ThreeId(provider, ipfs, keystore) {\n    var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    (0, _classCallCheck2[\"default\"])(this, ThreeId);\n    this.events = new EventEmitter();\n    this._provider = provider;\n    this._has3idProv = Boolean(opts.has3idProv);\n    this._ipfs = ipfs;\n    this._muportIpfs = opts.muportIpfs || MUPORT_IPFS;\n    this._pubkeys = {\n      spaces: {}\n    };\n    this._keystore = keystore;\n    var threeIdResolver = get3IdResolver(ipfs, {\n      pin: true\n    });\n    var muportResolver = getMuportResolver(ipfs);\n    var resolver = new Resolver(_objectSpread(_objectSpread({}, threeIdResolver), muportResolver));\n    OdbIdentityProvider.setDidResolver(resolver);\n  }\n\n  (0, _createClass2[\"default\"])(ThreeId, [{\n    key: \"startUpdatePolling\",\n    value: function startUpdatePolling() {\n      var _this = this;\n\n      if (this._has3idProv) {\n        var poll = /*#__PURE__*/function () {\n          var _ref = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee(method, event) {\n            var result;\n            return _regenerator[\"default\"].wrap(function _callee$(_context) {\n              while (1) {\n                switch (_context.prev = _context.next) {\n                  case 0:\n                    _context.next = 2;\n                    return utils.callRpc(_this._provider, method);\n\n                  case 2:\n                    result = _context.sent;\n                    result.map(function (data) {\n                      _this.events.emit(event, data);\n                    });\n\n                  case 4:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }\n            }, _callee);\n          }));\n\n          return function poll(_x, _x2) {\n            return _ref.apply(this, arguments);\n          };\n        }();\n\n        this._pollInterval = setInterval(function () {\n          poll('3id_newAuthMethodPoll', 'new-auth-method');\n          poll('3id_newLinkPoll', 'new-link-proof');\n        }, POLL_INTERVAL);\n      }\n    }\n  }, {\n    key: \"signJWT\",\n    value: function () {\n      var _signJWT = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee2(payload) {\n        var _ref2,\n            space,\n            expiresIn,\n            issuer,\n            keyring,\n            settings,\n            _args2 = arguments;\n\n        return _regenerator[\"default\"].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _ref2 = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {}, space = _ref2.space, expiresIn = _ref2.expiresIn;\n                issuer = this.DID;\n\n                if (space) {\n                  issuer = this._subDIDs[space];\n                }\n\n                if (!this._has3idProv) {\n                  _context2.next = 7;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", utils.callRpc(this._provider, '3id_signClaim', {\n                  payload: payload,\n                  did: issuer,\n                  space: space,\n                  expiresIn: expiresIn\n                }));\n\n              case 7:\n                keyring = this._keyringBySpace(space);\n                settings = {\n                  signer: keyring.getJWTSigner(),\n                  issuer: issuer,\n                  expiresIn: expiresIn\n                };\n                return _context2.abrupt(\"return\", didJWT.createJWT(payload, settings));\n\n              case 10:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function signJWT(_x3) {\n        return _signJWT.apply(this, arguments);\n      }\n\n      return signJWT;\n    }()\n  }, {\n    key: \"getSubDID\",\n    value: function getSubDID(space) {\n      return this._subDIDs[space];\n    }\n  }, {\n    key: \"getOdbId\",\n    value: function () {\n      var _getOdbId = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee3(space) {\n        return _regenerator[\"default\"].wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", Identities.createIdentity({\n                  type: '3ID',\n                  threeId: this,\n                  space: space,\n                  keystore: this._keystore\n                }));\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function getOdbId(_x4) {\n        return _getOdbId.apply(this, arguments);\n      }\n\n      return getOdbId;\n    }()\n  }, {\n    key: \"serializeState\",\n    value: function serializeState() {\n      var _this2 = this;\n\n      if (this._has3idProv) throw new Error('Can not serializeState of IdentityWallet');\n      var stateObj = {\n        managementAddress: this.managementAddress,\n        seed: this._mainKeyring.serialize(),\n        spaceSeeds: {}\n      };\n      Object.keys(this._keyrings).map(function (name) {\n        stateObj.spaceSeeds[name] = _this2._keyrings[name].serialize();\n      });\n      return JSON.stringify(stateObj);\n    }\n  }, {\n    key: \"_initKeys\",\n    value: function _initKeys(serializedState) {\n      var _this3 = this;\n\n      if (this._has3idProv) throw new Error('Can not initKeys of IdentityWallet');\n      this._keyrings = {};\n      var state = JSON.parse(serializedState); // TODO remove toLowerCase() in future, should be sanitized elsewhere\n      //      this forces existing state to correct state so that address <->\n      //      rootstore relation holds\n\n      this.managementAddress = state.managementAddress.toLowerCase();\n      this._mainKeyring = new Keyring(state.seed);\n      Object.keys(state.spaceSeeds).map(function (name) {\n        _this3._keyrings[name] = new Keyring(state.spaceSeeds[name]);\n      });\n      localstorage.set(STORAGE_KEY + this.managementAddress, this.serializeState());\n    }\n  }, {\n    key: \"_initDID\",\n    value: function () {\n      var _initDID2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee4() {\n        var _this4 = this;\n\n        var muportPromise, spaces, subDIDs;\n        return _regenerator[\"default\"].wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                muportPromise = this._initMuport();\n                _context4.next = 3;\n                return this._init3ID();\n\n              case 3:\n                this._rootDID = _context4.sent;\n\n                if (this._has3idProv) {\n                  spaces = Object.keys(this._pubkeys.spaces);\n                } else {\n                  spaces = Object.keys(this._keyrings);\n                }\n\n                _context4.next = 7;\n                return Promise.all(spaces.map(function (space) {\n                  return _this4._init3ID(space);\n                }));\n\n              case 7:\n                subDIDs = _context4.sent;\n                this._subDIDs = {};\n                spaces.map(function (space, i) {\n                  _this4._subDIDs[space] = subDIDs[i];\n                });\n                _context4.next = 12;\n                return muportPromise;\n\n              case 12:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function _initDID() {\n        return _initDID2.apply(this, arguments);\n      }\n\n      return _initDID;\n    }()\n  }, {\n    key: \"_init3ID\",\n    value: function () {\n      var _init3ID2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee5(spaceName) {\n        var doc, pubkeys, payload, signature;\n        return _regenerator[\"default\"].wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                doc = new DidDocument(this._ipfs, DID_METHOD_NAME);\n                _context5.next = 3;\n                return this.getPublicKeys(spaceName, true);\n\n              case 3:\n                pubkeys = _context5.sent;\n\n                if (spaceName) {\n                  _context5.next = 11;\n                  break;\n                }\n\n                doc.addPublicKey('signingKey', 'Secp256k1VerificationKey2018', 'publicKeyHex', pubkeys.signingKey);\n                doc.addPublicKey('encryptionKey', 'Curve25519EncryptionPublicKey', 'publicKeyBase64', pubkeys.asymEncryptionKey);\n                doc.addPublicKey('managementKey', 'Secp256k1VerificationKey2018', 'ethereumAddress', pubkeys.managementKey);\n                doc.addAuthentication('Secp256k1SignatureAuthentication2018', 'signingKey');\n                _context5.next = 21;\n                break;\n\n              case 11:\n                doc.addPublicKey('subSigningKey', 'Secp256k1VerificationKey2018', 'publicKeyHex', pubkeys.signingKey);\n                doc.addPublicKey('subEncryptionKey', 'Curve25519EncryptionPublicKey', 'publicKeyBase64', pubkeys.asymEncryptionKey);\n                doc.addAuthentication('Secp256k1SignatureAuthentication2018', 'subSigningKey');\n                doc.addCustomProperty('space', spaceName);\n                doc.addCustomProperty('root', this.DID);\n                payload = {\n                  iat: null,\n                  subSigningKey: pubkeys.signingKey,\n                  subEncryptionKey: pubkeys.asymEncryptionKey,\n                  space: spaceName\n                };\n                _context5.next = 19;\n                return this.signJWT(payload, {\n                  use3ID: true\n                });\n\n              case 19:\n                signature = _context5.sent.split('.')[2];\n                doc.addCustomProperty('proof', {\n                  alg: 'ES256K',\n                  signature: signature\n                });\n\n              case 21:\n                _context5.next = 23;\n                return doc.commit({\n                  noTimestamp: true\n                });\n\n              case 23:\n                return _context5.abrupt(\"return\", doc.DID);\n\n              case 24:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function _init3ID(_x5) {\n        return _init3ID2.apply(this, arguments);\n      }\n\n      return _init3ID;\n    }()\n  }, {\n    key: \"_initMuport\",\n    value: function () {\n      var _initMuport2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee6() {\n        var keys, doc, serializedDoc, generator, docCid;\n        return _regenerator[\"default\"].wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return this.getPublicKeys(null);\n\n              case 2:\n                keys = _context6.sent;\n                doc = createMuportDocument(keys.signingKey, keys.managementKey, keys.asymEncryptionKey);\n                serializedDoc = Buffer.from(JSON.stringify(doc));\n                _context6.next = 7;\n                return this._ipfs.add(serializedDoc);\n\n              case 7:\n                generator = _context6.sent;\n                _context6.next = 10;\n                return generator.next();\n\n              case 10:\n                docCid = _context6.sent.value.cid;\n                _context6.next = 13;\n                return generator.next();\n\n              case 13:\n                // we need to do this in order to not block the process in tests\n                this._muportDID = 'did:muport:' + docCid.toString();\n                this.muportFingerprint = utils.sha256Multihash(this.muportDID);\n\n              case 15:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function _initMuport() {\n        return _initMuport2.apply(this, arguments);\n      }\n\n      return _initMuport;\n    }()\n  }, {\n    key: \"getAddress\",\n    value: function () {\n      var _getAddress = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee7() {\n        return _regenerator[\"default\"].wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (!this._has3idProv) {\n                  _context7.next = 4;\n                  break;\n                }\n\n                return _context7.abrupt(\"return\", utils.callRpc(this._provider, '3id_getLink'));\n\n              case 4:\n                return _context7.abrupt(\"return\", this.managementAddress);\n\n              case 5:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function getAddress() {\n        return _getAddress.apply(this, arguments);\n      }\n\n      return getAddress;\n    }()\n  }, {\n    key: \"authenticate\",\n    value: function () {\n      var _authenticate = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee8(spaces) {\n        var opts,\n            pubkeys,\n            _iterator,\n            _step,\n            space,\n            _iterator2,\n            _step2,\n            _space,\n            _args8 = arguments;\n\n        return _regenerator[\"default\"].wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                opts = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : {};\n                spaces = spaces || [];\n\n                if (!this._has3idProv) {\n                  _context8.next = 34;\n                  break;\n                }\n\n                _context8.next = 5;\n                return utils.callRpc(this._provider, '3id_authenticate', {\n                  spaces: spaces,\n                  authData: opts.authData,\n                  address: opts.address\n                });\n\n              case 5:\n                pubkeys = _context8.sent;\n                this._pubkeys.main = pubkeys.main;\n                this._pubkeys.spaces = Object.assign(this._pubkeys.spaces, pubkeys.spaces);\n\n                if (this.DID) {\n                  _context8.next = 13;\n                  break;\n                }\n\n                _context8.next = 11;\n                return this._initDID();\n\n              case 11:\n                _context8.next = 32;\n                break;\n\n              case 13:\n                _iterator = _createForOfIteratorHelper(spaces);\n                _context8.prev = 14;\n\n                _iterator.s();\n\n              case 16:\n                if ((_step = _iterator.n()).done) {\n                  _context8.next = 24;\n                  break;\n                }\n\n                space = _step.value;\n\n                if (this._subDIDs[space]) {\n                  _context8.next = 22;\n                  break;\n                }\n\n                _context8.next = 21;\n                return this._init3ID(space);\n\n              case 21:\n                this._subDIDs[space] = _context8.sent;\n\n              case 22:\n                _context8.next = 16;\n                break;\n\n              case 24:\n                _context8.next = 29;\n                break;\n\n              case 26:\n                _context8.prev = 26;\n                _context8.t0 = _context8[\"catch\"](14);\n\n                _iterator.e(_context8.t0);\n\n              case 29:\n                _context8.prev = 29;\n\n                _iterator.f();\n\n                return _context8.finish(29);\n\n              case 32:\n                _context8.next = 51;\n                break;\n\n              case 34:\n                _iterator2 = _createForOfIteratorHelper(spaces);\n                _context8.prev = 35;\n\n                _iterator2.s();\n\n              case 37:\n                if ((_step2 = _iterator2.n()).done) {\n                  _context8.next = 43;\n                  break;\n                }\n\n                _space = _step2.value;\n                _context8.next = 41;\n                return this._initKeyringByName(_space);\n\n              case 41:\n                _context8.next = 37;\n                break;\n\n              case 43:\n                _context8.next = 48;\n                break;\n\n              case 45:\n                _context8.prev = 45;\n                _context8.t1 = _context8[\"catch\"](35);\n\n                _iterator2.e(_context8.t1);\n\n              case 48:\n                _context8.prev = 48;\n\n                _iterator2.f();\n\n                return _context8.finish(48);\n\n              case 51:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this, [[14, 26, 29, 32], [35, 45, 48, 51]]);\n      }));\n\n      function authenticate(_x6) {\n        return _authenticate.apply(this, arguments);\n      }\n\n      return authenticate;\n    }()\n  }, {\n    key: \"isAuthenticated\",\n    value: function () {\n      var _isAuthenticated = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee9() {\n        var _this5 = this;\n\n        var spaces,\n            _args9 = arguments;\n        return _regenerator[\"default\"].wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                spaces = _args9.length > 0 && _args9[0] !== undefined ? _args9[0] : [];\n                return _context9.abrupt(\"return\", spaces.reduce(function (acc, space) {\n                  return acc && Object.keys(_this5._subDIDs).includes(space);\n                }, true));\n\n              case 2:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9);\n      }));\n\n      function isAuthenticated() {\n        return _isAuthenticated.apply(this, arguments);\n      }\n\n      return isAuthenticated;\n    }()\n  }, {\n    key: \"_initKeyringByName\",\n    value: function () {\n      var _initKeyringByName2 = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee10(name) {\n        var sig, entropy, seed;\n        return _regenerator[\"default\"].wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                if (!this._has3idProv) {\n                  _context10.next = 2;\n                  break;\n                }\n\n                throw new Error('Can not initKeyringByName of IdentityWallet');\n\n              case 2:\n                if (this._keyrings[name]) {\n                  _context10.next = 16;\n                  break;\n                }\n\n                _context10.next = 5;\n                return utils.openSpaceConsent(this.managementAddress, this._provider, name);\n\n              case 5:\n                sig = _context10.sent;\n                entropy = '0x' + utils.sha256(sig.slice(2));\n                seed = mnemonicToSeed(entropyToMnemonic(entropy));\n                this._keyrings[name] = new Keyring(seed);\n                _context10.next = 11;\n                return this._init3ID(name);\n\n              case 11:\n                this._subDIDs[name] = _context10.sent;\n                localstorage.set(STORAGE_KEY + this.managementAddress, this.serializeState());\n                return _context10.abrupt(\"return\", true);\n\n              case 16:\n                return _context10.abrupt(\"return\", false);\n\n              case 17:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function _initKeyringByName(_x7) {\n        return _initKeyringByName2.apply(this, arguments);\n      }\n\n      return _initKeyringByName;\n    }()\n  }, {\n    key: \"getPublicKeys\",\n    value: function () {\n      var _getPublicKeys = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee11(space, uncompressed) {\n        var pubkeys;\n        return _regenerator[\"default\"].wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                if (this._has3idProv) {\n                  pubkeys = Object.assign({}, space ? this._pubkeys.spaces[space] : this._pubkeys.main);\n\n                  if (uncompressed) {\n                    pubkeys.signingKey = Keyring.uncompress(pubkeys.signingKey);\n                  }\n                } else {\n                  pubkeys = this._keyringBySpace(space).getPublicKeys(uncompressed);\n                  pubkeys.managementKey = this.managementAddress;\n                }\n\n                return _context11.abrupt(\"return\", pubkeys);\n\n              case 2:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, this);\n      }));\n\n      function getPublicKeys(_x8, _x9) {\n        return _getPublicKeys.apply(this, arguments);\n      }\n\n      return getPublicKeys;\n    }()\n  }, {\n    key: \"encrypt\",\n    value: function () {\n      var _encrypt = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee12(message, space, to) {\n        var keyring, paddedMsg;\n        return _regenerator[\"default\"].wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                if (!this._has3idProv) {\n                  _context12.next = 4;\n                  break;\n                }\n\n                return _context12.abrupt(\"return\", utils.callRpc(this._provider, '3id_encrypt', {\n                  message: message,\n                  space: space,\n                  to: to\n                }));\n\n              case 4:\n                keyring = this._keyringBySpace(space);\n                paddedMsg = typeof message === 'string' ? utils.pad(message) : message;\n\n                if (!to) {\n                  _context12.next = 10;\n                  break;\n                }\n\n                return _context12.abrupt(\"return\", keyring.asymEncrypt(paddedMsg, to));\n\n              case 10:\n                return _context12.abrupt(\"return\", keyring.symEncrypt(paddedMsg));\n\n              case 11:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function encrypt(_x10, _x11, _x12) {\n        return _encrypt.apply(this, arguments);\n      }\n\n      return encrypt;\n    }()\n  }, {\n    key: \"decrypt\",\n    value: function () {\n      var _decrypt = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee13(encObj, space, toBuffer) {\n        var res, keyring, paddedMsg;\n        return _regenerator[\"default\"].wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                if (!this._has3idProv) {\n                  _context13.next = 7;\n                  break;\n                }\n\n                _context13.next = 3;\n                return utils.callRpc(this._provider, '3id_decrypt', _objectSpread(_objectSpread({}, encObj), {}, {\n                  space: space,\n                  buffer: toBuffer\n                }));\n\n              case 3:\n                res = _context13.sent;\n                return _context13.abrupt(\"return\", toBuffer ? Buffer.from(res) : res);\n\n              case 7:\n                keyring = this._keyringBySpace(space);\n\n                if (encObj.ephemeralFrom) {\n                  paddedMsg = keyring.asymDecrypt(encObj.ciphertext, encObj.ephemeralFrom, encObj.nonce, toBuffer);\n                } else {\n                  paddedMsg = keyring.symDecrypt(encObj.ciphertext, encObj.nonce, toBuffer);\n                }\n\n                return _context13.abrupt(\"return\", toBuffer ? paddedMsg : utils.unpad(paddedMsg));\n\n              case 10:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function decrypt(_x13, _x14, _x15) {\n        return _decrypt.apply(this, arguments);\n      }\n\n      return decrypt;\n    }()\n  }, {\n    key: \"hashDBKey\",\n    value: function () {\n      var _hashDBKey = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee14(key, space) {\n        var salt;\n        return _regenerator[\"default\"].wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                if (!this._has3idProv) {\n                  _context14.next = 4;\n                  break;\n                }\n\n                return _context14.abrupt(\"return\", utils.callRpc(this._provider, '3id_hashEntryKey', {\n                  key: key,\n                  space: space\n                }));\n\n              case 4:\n                salt = this._keyringBySpace(space).getDBSalt();\n                return _context14.abrupt(\"return\", utils.sha256Multihash(salt + key));\n\n              case 6:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14, this);\n      }));\n\n      function hashDBKey(_x16, _x17) {\n        return _hashDBKey.apply(this, arguments);\n      }\n\n      return hashDBKey;\n    }()\n  }, {\n    key: \"_keyringBySpace\",\n    value: function _keyringBySpace(space) {\n      return space ? this._keyrings[space] : this._mainKeyring;\n    }\n  }, {\n    key: \"logout\",\n    value: function logout() {\n      this._rootDID = null;\n      this._subDIDs = {};\n      localstorage.remove(STORAGE_KEY + this.managementAddress);\n      this.stopUpdatePolling();\n    }\n  }, {\n    key: \"stopUpdatePolling\",\n    value: function stopUpdatePolling() {\n      if (this._pollInterval) {\n        clearInterval(this._pollInterval);\n      }\n    }\n  }, {\n    key: \"DID\",\n    get: function get() {\n      return this._rootDID;\n    }\n  }, {\n    key: \"muportDID\",\n    get: function get() {\n      return this._muportDID;\n    }\n  }], [{\n    key: \"isLoggedIn\",\n    value: function isLoggedIn(address) {\n      return Boolean(localstorage.get(STORAGE_KEY + address.toLowerCase()));\n    }\n  }, {\n    key: \"getIdFromEthAddress\",\n    value: function () {\n      var _getIdFromEthAddress = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee15(address, provider, ipfs, keystore) {\n        var opts,\n            normalizedAddress,\n            serialized3id,\n            sig,\n            entropy,\n            mnemonic,\n            seed,\n            threeId,\n            _args15 = arguments;\n        return _regenerator[\"default\"].wrap(function _callee15$(_context15) {\n          while (1) {\n            switch (_context15.prev = _context15.next) {\n              case 0:\n                opts = _args15.length > 4 && _args15[4] !== undefined ? _args15[4] : {};\n                opts.has3idProv = Boolean(provider.is3idProvider);\n\n                if (!opts.has3idProv) {\n                  _context15.next = 6;\n                  break;\n                }\n\n                return _context15.abrupt(\"return\", new ThreeId(provider, ipfs, keystore, opts));\n\n              case 6:\n                normalizedAddress = address.toLowerCase();\n                serialized3id = localstorage.get(STORAGE_KEY + normalizedAddress);\n\n                if (!serialized3id) {\n                  _context15.next = 12;\n                  break;\n                }\n\n                if (opts.consentCallback) opts.consentCallback(false);\n                _context15.next = 24;\n                break;\n\n              case 12:\n                if (!opts.contentSignature) {\n                  _context15.next = 16;\n                  break;\n                }\n\n                sig = opts.contentSignature;\n                _context15.next = 19;\n                break;\n\n              case 16:\n                _context15.next = 18;\n                return utils.openBoxConsent(normalizedAddress, provider);\n\n              case 18:\n                sig = _context15.sent;\n\n              case 19:\n                if (opts.consentCallback) opts.consentCallback(true);\n                entropy = '0x' + utils.sha256(sig.slice(2));\n                mnemonic = entropyToMnemonic(entropy);\n                seed = mnemonicToSeed(mnemonic);\n                serialized3id = JSON.stringify({\n                  managementAddress: normalizedAddress,\n                  seed: seed,\n                  spaceSeeds: {}\n                });\n\n              case 24:\n                threeId = new ThreeId(provider, ipfs, keystore, opts);\n\n                threeId._initKeys(serialized3id);\n\n                _context15.next = 28;\n                return threeId._initDID();\n\n              case 28:\n                return _context15.abrupt(\"return\", threeId);\n\n              case 29:\n              case \"end\":\n                return _context15.stop();\n            }\n          }\n        }, _callee15);\n      }));\n\n      function getIdFromEthAddress(_x18, _x19, _x20, _x21) {\n        return _getIdFromEthAddress.apply(this, arguments);\n      }\n\n      return getIdFromEthAddress;\n    }()\n  }]);\n  return ThreeId;\n}();\n\nvar createMuportDocument = function createMuportDocument(signingKey, managementKey, asymEncryptionKey) {\n  return {\n    version: 1,\n    signingKey: signingKey,\n    managementKey: managementKey,\n    asymEncryptionKey: asymEncryptionKey\n  };\n};\n\nmodule.exports = ThreeId;","map":null,"metadata":{},"sourceType":"script"}