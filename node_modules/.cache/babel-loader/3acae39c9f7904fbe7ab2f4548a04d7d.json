{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _slicedToArray = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _require = require('libp2p-record'),\n    Record = _require.Record;\n\nvar errcode = require('err-code');\n\nvar Message = require('../../message');\n\nvar utils = require('../../utils');\n\nmodule.exports = function (dht) {\n  var log = utils.logger(dht.peerInfo.id, 'rpc:get-value');\n  /**\n   * Process `GetValue` DHT messages.\n   *\n   * @param {PeerInfo} peer\n   * @param {Message} msg\n   * @returns {Promise<Message>}\n   */\n\n  return /*#__PURE__*/function () {\n    var _getValue = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(peer, msg) {\n      var key, response, id, info, _yield$Promise$all, _yield$Promise$all2, record, closer;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              key = msg.key;\n              log('key: %b', key);\n\n              if (!(!key || key.length === 0)) {\n                _context.next = 4;\n                break;\n              }\n\n              throw errcode(new Error('Invalid key'), 'ERR_INVALID_KEY');\n\n            case 4:\n              response = new Message(Message.TYPES.GET_VALUE, key, msg.clusterLevel);\n\n              if (!utils.isPublicKeyKey(key)) {\n                _context.next = 13;\n                break;\n              }\n\n              log('is public key');\n              id = utils.fromPublicKeyKey(key);\n\n              if (dht._isSelf(id)) {\n                info = dht.peerInfo;\n              } else if (dht.peerStore.has(id)) {\n                info = dht.peerStore.get(id);\n              }\n\n              if (!(info && info.id.pubKey)) {\n                _context.next = 13;\n                break;\n              }\n\n              log('returning found public key');\n              response.record = new Record(key, info.id.pubKey.bytes);\n              return _context.abrupt(\"return\", response);\n\n            case 13:\n              _context.next = 15;\n              return Promise.all([dht._checkLocalDatastore(key), dht._betterPeersToQuery(msg, peer)]);\n\n            case 15:\n              _yield$Promise$all = _context.sent;\n              _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n              record = _yield$Promise$all2[0];\n              closer = _yield$Promise$all2[1];\n\n              if (record) {\n                log('got record');\n                response.record = record;\n              }\n\n              if (closer.length > 0) {\n                log('got closer %s', closer.length);\n                response.closerPeers = closer;\n              }\n\n              return _context.abrupt(\"return\", response);\n\n            case 22:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    function getValue(_x, _x2) {\n      return _getValue.apply(this, arguments);\n    }\n\n    return getValue;\n  }();\n};","map":null,"metadata":{},"sourceType":"script"}