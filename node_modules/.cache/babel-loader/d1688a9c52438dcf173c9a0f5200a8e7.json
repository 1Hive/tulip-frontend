{"ast":null,"code":"\"use strict\";\n\nvar _createForOfIteratorHelper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar EventQueue = /*#__PURE__*/function () {\n  function EventQueue() {\n    _classCallCheck(this, EventQueue);\n\n    this.pullQueue = [];\n    this.pushQueue = [];\n    this.eventHandlers = {};\n    this.isPaused = false;\n    this.isStopped = false;\n  }\n\n  _createClass(EventQueue, [{\n    key: \"push\",\n    value: function push(value) {\n      if (this.isStopped) return;\n      var resolution = {\n        value: value,\n        done: false\n      };\n\n      if (this.pullQueue.length) {\n        var placeholder = this.pullQueue.shift();\n        if (placeholder) placeholder.resolve(resolution);\n      } else {\n        this.pushQueue.push(Promise.resolve(resolution));\n\n        if (this.highWaterMark !== undefined && this.pushQueue.length >= this.highWaterMark && !this.isPaused) {\n          this.isPaused = true;\n\n          if (this.eventHandlers.highWater) {\n            this.eventHandlers.highWater();\n          } else if (console) {\n            console.warn(\"EventIterator queue reached \".concat(this.pushQueue.length, \" items\"));\n          }\n        }\n      }\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      if (this.isStopped) return;\n      this.isStopped = true;\n      this.remove();\n\n      var _iterator = _createForOfIteratorHelper(this.pullQueue),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var placeholder = _step.value;\n          placeholder.resolve({\n            value: undefined,\n            done: true\n          });\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      this.pullQueue.length = 0;\n    }\n  }, {\n    key: \"fail\",\n    value: function fail(error) {\n      if (this.isStopped) return;\n      this.isStopped = true;\n      this.remove();\n\n      if (this.pullQueue.length) {\n        var _iterator2 = _createForOfIteratorHelper(this.pullQueue),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var placeholder = _step2.value;\n            placeholder.reject(error);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        this.pullQueue.length = 0;\n      } else {\n        var rejection = Promise.reject(error);\n        /* Attach error handler to avoid leaking an unhandled promise rejection. */\n\n        rejection.catch(function () {});\n        this.pushQueue.push(rejection);\n      }\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var _this = this;\n\n      Promise.resolve().then(function () {\n        if (_this.removeCallback) _this.removeCallback();\n      });\n    }\n  }, {\n    key: Symbol.asyncIterator,\n    value: function value() {\n      var _this2 = this;\n\n      return {\n        next: function next(value) {\n          var result = _this2.pushQueue.shift();\n\n          if (result) {\n            if (_this2.lowWaterMark !== undefined && _this2.pushQueue.length <= _this2.lowWaterMark && _this2.isPaused) {\n              _this2.isPaused = false;\n\n              if (_this2.eventHandlers.lowWater) {\n                _this2.eventHandlers.lowWater();\n              }\n            }\n\n            return result;\n          } else if (_this2.isStopped) {\n            return Promise.resolve({\n              value: undefined,\n              done: true\n            });\n          } else {\n            return new Promise(function (resolve, reject) {\n              _this2.pullQueue.push({\n                resolve: resolve,\n                reject: reject\n              });\n            });\n          }\n        },\n        return: function _return() {\n          _this2.isStopped = true;\n          _this2.pushQueue.length = 0;\n\n          _this2.remove();\n\n          return Promise.resolve({\n            value: undefined,\n            done: true\n          });\n        }\n      };\n    }\n  }]);\n\n  return EventQueue;\n}();\n\nvar EventIterator = function EventIterator(listen) {\n  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$highWaterMark = _ref.highWaterMark,\n      highWaterMark = _ref$highWaterMark === void 0 ? 100 : _ref$highWaterMark,\n      _ref$lowWaterMark = _ref.lowWaterMark,\n      lowWaterMark = _ref$lowWaterMark === void 0 ? 1 : _ref$lowWaterMark;\n\n  _classCallCheck(this, EventIterator);\n\n  var queue = new EventQueue();\n  queue.highWaterMark = highWaterMark;\n  queue.lowWaterMark = lowWaterMark;\n\n  queue.removeCallback = listen({\n    push: function push(value) {\n      return queue.push(value);\n    },\n    stop: function stop() {\n      return queue.stop();\n    },\n    fail: function fail(error) {\n      return queue.fail(error);\n    },\n    on: function on(event, fn) {\n      queue.eventHandlers[event] = fn;\n    }\n  }) || function () {};\n\n  this[Symbol.asyncIterator] = function () {\n    return queue[Symbol.asyncIterator]();\n  };\n\n  Object.freeze(this);\n};\n\nexports.EventIterator = EventIterator;\nexports.default = EventIterator;","map":null,"metadata":{},"sourceType":"script"}