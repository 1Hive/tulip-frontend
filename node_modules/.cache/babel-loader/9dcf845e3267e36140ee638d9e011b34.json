{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _awaitAsyncGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator\");\n\nvar _wrapAsyncGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator\");\n\nvar _asyncIterator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar WantManager = require('./want-manager');\n\nvar Network = require('./network');\n\nvar DecisionEngine = require('./decision-engine');\n\nvar Notifications = require('./notifications');\n\nvar logger = require('./utils').logger;\n\nvar Stats = require('./stats');\n\nvar AbortController = require('abort-controller');\n\nvar anySignal = require('any-signal');\n\nvar defaultOptions = {\n  statsEnabled: false,\n  statsComputeThrottleTimeout: 1000,\n  statsComputeThrottleMaxQueueSize: 1000\n};\nvar statsKeys = ['blocksReceived', 'dataReceived', 'dupBlksReceived', 'dupDataReceived', 'blocksSent', 'dataSent', 'providesBufferLength', 'wantListLength', 'peerCount'];\n/**\n * JavaScript implementation of the Bitswap 'data exchange' protocol\n * used by IPFS.\n *\n * @param {Libp2p} libp2p\n * @param {Blockstore} blockstore\n * @param {Object} options\n */\n\nvar Bitswap = /*#__PURE__*/function () {\n  function Bitswap(libp2p, blockstore, options) {\n    _classCallCheck(this, Bitswap);\n\n    this._libp2p = libp2p;\n    this._log = logger(this.peerInfo.id);\n    this._options = Object.assign({}, defaultOptions, options); // stats\n\n    this._stats = new Stats(statsKeys, {\n      enabled: this._options.statsEnabled,\n      computeThrottleTimeout: this._options.statsComputeThrottleTimeout,\n      computeThrottleMaxQueueSize: this._options.statsComputeThrottleMaxQueueSize\n    }); // the network delivers messages\n\n    this.network = new Network(libp2p, this, {}, this._stats); // local database\n\n    this.blockstore = blockstore;\n    this.engine = new DecisionEngine(this.peerInfo.id, blockstore, this.network, this._stats); // handle message sending\n\n    this.wm = new WantManager(this.peerInfo.id, this.network, this._stats);\n    this.notifications = new Notifications(this.peerInfo.id);\n  }\n\n  _createClass(Bitswap, [{\n    key: \"peerInfo\",\n    get: function get() {\n      return this._libp2p.peerInfo;\n    } // handle messages received through the network\n\n  }, {\n    key: \"_receiveMessage\",\n    value: function () {\n      var _receiveMessage2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(peerId, incoming) {\n        var _this3 = this;\n\n        var blocks, wanted;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.prev = 0;\n                _context2.next = 3;\n                return this.engine.messageReceived(peerId, incoming);\n\n              case 3:\n                _context2.next = 8;\n                break;\n\n              case 5:\n                _context2.prev = 5;\n                _context2.t0 = _context2[\"catch\"](0);\n\n                // Log instead of throwing an error so as to process as much as\n                // possible of the message. Currently `messageReceived` does not\n                // throw any errors, but this could change in the future.\n                this._log('failed to receive message', incoming);\n\n              case 8:\n                if (!(incoming.blocks.size === 0)) {\n                  _context2.next = 10;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 10:\n                blocks = Array.from(incoming.blocks.values()); // quickly send out cancels, reduces chances of duplicate block receives\n\n                wanted = blocks.filter(function (b) {\n                  return _this3.wm.wantlist.contains(b.cid);\n                }).map(function (b) {\n                  return b.cid;\n                });\n                this.wm.cancelWants(wanted);\n                _context2.next = 15;\n                return Promise.all(blocks.map( /*#__PURE__*/function () {\n                  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(b) {\n                    var wasWanted;\n                    return _regeneratorRuntime.wrap(function _callee$(_context) {\n                      while (1) {\n                        switch (_context.prev = _context.next) {\n                          case 0:\n                            wasWanted = wanted.includes(b.cid);\n                            _context.next = 3;\n                            return _this3._handleReceivedBlock(peerId, b, wasWanted);\n\n                          case 3:\n                          case \"end\":\n                            return _context.stop();\n                        }\n                      }\n                    }, _callee);\n                  }));\n\n                  return function (_x3) {\n                    return _ref.apply(this, arguments);\n                  };\n                }()));\n\n              case 15:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[0, 5]]);\n      }));\n\n      function _receiveMessage(_x, _x2) {\n        return _receiveMessage2.apply(this, arguments);\n      }\n\n      return _receiveMessage;\n    }()\n  }, {\n    key: \"_handleReceivedBlock\",\n    value: function () {\n      var _handleReceivedBlock2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(peerId, block, wasWanted) {\n        var has;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                this._log('received block');\n\n                _context3.next = 3;\n                return this.blockstore.has(block.cid);\n\n              case 3:\n                has = _context3.sent;\n\n                this._updateReceiveCounters(peerId.toB58String(), block, has);\n\n                if (wasWanted) {\n                  _context3.next = 7;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\");\n\n              case 7:\n                _context3.next = 9;\n                return this.put(block);\n\n              case 9:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function _handleReceivedBlock(_x4, _x5, _x6) {\n        return _handleReceivedBlock2.apply(this, arguments);\n      }\n\n      return _handleReceivedBlock;\n    }()\n  }, {\n    key: \"_updateReceiveCounters\",\n    value: function _updateReceiveCounters(peerId, block, exists) {\n      this._stats.push(peerId, 'blocksReceived', 1);\n\n      this._stats.push(peerId, 'dataReceived', block.data.length);\n\n      if (exists) {\n        this._stats.push(peerId, 'dupBlksReceived', 1);\n\n        this._stats.push(peerId, 'dupDataReceived', block.data.length);\n      }\n    } // handle errors on the receiving channel\n\n  }, {\n    key: \"_receiveError\",\n    value: function _receiveError(err) {\n      this._log.error('ReceiveError: %s', err.message);\n    } // handle new peers\n\n  }, {\n    key: \"_onPeerConnected\",\n    value: function _onPeerConnected(peerId) {\n      this.wm.connected(peerId);\n    } // handle peers being disconnected\n\n  }, {\n    key: \"_onPeerDisconnected\",\n    value: function _onPeerDisconnected(peerId) {\n      this.wm.disconnected(peerId);\n      this.engine.peerDisconnected(peerId);\n\n      this._stats.disconnected(peerId);\n    }\n    /**\n     * @returns {void}\n     */\n\n  }, {\n    key: \"enableStats\",\n    value: function enableStats() {\n      this._stats.enable();\n    }\n    /**\n     * @returns {void}\n     */\n\n  }, {\n    key: \"disableStats\",\n    value: function disableStats() {\n      this._stats.disable();\n    }\n    /**\n     * Return the current wantlist for a given `peerId`\n     *\n     * @param {PeerId} peerId\n     * @returns {Map}\n     */\n\n  }, {\n    key: \"wantlistForPeer\",\n    value: function wantlistForPeer(peerId) {\n      return this.engine.wantlistForPeer(peerId);\n    }\n    /**\n     * Return ledger information for a given `peerId`\n     *\n     * @param {PeerId} peerId\n     * @returns {Object}\n     */\n\n  }, {\n    key: \"ledgerForPeer\",\n    value: function ledgerForPeer(peerId) {\n      return this.engine.ledgerForPeer(peerId);\n    }\n    /**\n     * Fetch a given block by cid. If the block is in the local\n     * blockstore it is returned, otherwise the block is added to the wantlist and returned once another node sends it to us.\n     *\n     * @param {CID} cid\n     * @param {Object} options\n     * @param {AbortSignal} options.abortSignal\n     * @returns {Promise<Block>}\n     */\n\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(cid) {\n        var _this4 = this;\n\n        var options,\n            fetchFromNetwork,\n            promptedNetwork,\n            loadOrFetchFromNetwork,\n            controller,\n            signal,\n            block,\n            _args5 = arguments;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                options = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : {};\n\n                fetchFromNetwork = function fetchFromNetwork(cid, options) {\n                  // add it to the want list - n.b. later we will abort the AbortSignal\n                  // so no need to remove the blocks from the wantlist after we have it\n                  _this4.wm.wantBlocks([cid], options);\n\n                  return _this4.notifications.wantBlock(cid, options);\n                };\n\n                promptedNetwork = false;\n\n                loadOrFetchFromNetwork = /*#__PURE__*/function () {\n                  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(cid, options) {\n                    var _block;\n\n                    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n                      while (1) {\n                        switch (_context4.prev = _context4.next) {\n                          case 0:\n                            _context4.prev = 0;\n                            _context4.next = 3;\n                            return _this4.blockstore.get(cid, options);\n\n                          case 3:\n                            _block = _context4.sent;\n                            return _context4.abrupt(\"return\", _block);\n\n                          case 7:\n                            _context4.prev = 7;\n                            _context4.t0 = _context4[\"catch\"](0);\n\n                            if (!(_context4.t0.code !== 'ERR_NOT_FOUND')) {\n                              _context4.next = 11;\n                              break;\n                            }\n\n                            throw _context4.t0;\n\n                          case 11:\n                            if (!promptedNetwork) {\n                              promptedNetwork = true;\n\n                              _this4.network.findAndConnect(cid).catch(function (err) {\n                                return _this4._log.error(err);\n                              });\n                            } // we don't have the block locally so fetch it from the network\n\n\n                            return _context4.abrupt(\"return\", fetchFromNetwork(cid, options));\n\n                          case 13:\n                          case \"end\":\n                            return _context4.stop();\n                        }\n                      }\n                    }, _callee4, null, [[0, 7]]);\n                  }));\n\n                  return function loadOrFetchFromNetwork(_x8, _x9) {\n                    return _ref2.apply(this, arguments);\n                  };\n                }(); // depending on implementation it's possible for blocks to come in while\n                // we do the async operations to get them from the blockstore leading to\n                // a race condition, so register for incoming block notifications as well\n                // as trying to get it from the datastore\n\n\n                controller = new AbortController();\n                signal = anySignal([options.signal, controller.signal]);\n                _context5.next = 8;\n                return Promise.race([this.notifications.wantBlock(cid, {\n                  signal: signal\n                }), loadOrFetchFromNetwork(cid, {\n                  signal: signal\n                })]);\n\n              case 8:\n                block = _context5.sent;\n                // since we have the block we can now remove our listener\n                controller.abort();\n                return _context5.abrupt(\"return\", block);\n\n              case 11:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function get(_x7) {\n        return _get.apply(this, arguments);\n      }\n\n      return get;\n    }()\n    /**\n     * Fetch a a list of blocks by cid. If the blocks are in the local\n     * blockstore they are returned, otherwise the blocks are added to the wantlist and returned once another node sends them to us.\n     *\n     * @param {AsyncIterator<CID>} cids\n     * @param {Object} options\n     * @param {AbortSignal} options.abortSignal\n     * @returns {Promise<AsyncIterator<Block>>}\n     */\n\n  }, {\n    key: \"getMany\",\n    value: function getMany(cids) {\n      var _this = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, cid;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _iteratorNormalCompletion = true;\n                _didIteratorError = false;\n                _context6.prev = 2;\n                _iterator = _asyncIterator(cids);\n\n              case 4:\n                _context6.next = 6;\n                return _awaitAsyncGenerator(_iterator.next());\n\n              case 6:\n                _step = _context6.sent;\n                _iteratorNormalCompletion = _step.done;\n                _context6.next = 10;\n                return _awaitAsyncGenerator(_step.value);\n\n              case 10:\n                _value = _context6.sent;\n\n                if (_iteratorNormalCompletion) {\n                  _context6.next = 18;\n                  break;\n                }\n\n                cid = _value;\n                _context6.next = 15;\n                return _this.get(cid, options);\n\n              case 15:\n                _iteratorNormalCompletion = true;\n                _context6.next = 4;\n                break;\n\n              case 18:\n                _context6.next = 24;\n                break;\n\n              case 20:\n                _context6.prev = 20;\n                _context6.t0 = _context6[\"catch\"](2);\n                _didIteratorError = true;\n                _iteratorError = _context6.t0;\n\n              case 24:\n                _context6.prev = 24;\n                _context6.prev = 25;\n\n                if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                  _context6.next = 29;\n                  break;\n                }\n\n                _context6.next = 29;\n                return _awaitAsyncGenerator(_iterator.return());\n\n              case 29:\n                _context6.prev = 29;\n\n                if (!_didIteratorError) {\n                  _context6.next = 32;\n                  break;\n                }\n\n                throw _iteratorError;\n\n              case 32:\n                return _context6.finish(29);\n\n              case 33:\n                return _context6.finish(24);\n\n              case 34:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, null, [[2, 20, 24, 34], [25,, 29, 33]]);\n      }))();\n    }\n    /**\n     * Removes the given CIDs from the wantlist independent of any ref counts.\n     *\n     * This will cause all outstanding promises for a given block to reject.\n     *\n     * If you want to cancel the want for a block without doing that, pass an\n     * AbortSignal in to `.get` or `.getMany` and abort it.\n     *\n     * @param {Iterable<CID>} cids\n     * @returns {void}\n     */\n\n  }, {\n    key: \"unwant\",\n    value: function unwant(cids) {\n      var _this5 = this;\n\n      if (!Array.isArray(cids)) {\n        cids = [cids];\n      }\n\n      this.wm.unwantBlocks(cids);\n      cids.forEach(function (cid) {\n        return _this5.notifications.unwantBlock(cid);\n      });\n    }\n    /**\n     * Removes the given keys from the want list. This may cause pending promises\n     * for blocks to never resolve.  If you wish these promises to abort instead\n     * call `unwant(cids)` instead.\n     *\n     * @param {Iterable<CID>} cids\n     * @returns {void}\n     */\n\n  }, {\n    key: \"cancelWants\",\n    value: function cancelWants(cids) {\n      if (!Array.isArray(cids)) {\n        cids = [cids];\n      }\n\n      this.wm.cancelWants(cids);\n    }\n    /**\n     * Put the given block to the underlying blockstore and\n     * send it to nodes that have it in their wantlist.\n     *\n     * @param {Block} block\n     * @returns {Promise<void>}\n     */\n\n  }, {\n    key: \"put\",\n    value: function () {\n      var _put = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(block) {\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.next = 2;\n                return this.blockstore.put(block);\n\n              case 2:\n                this._sendHaveBlockNotifications(block);\n\n              case 3:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function put(_x10) {\n        return _put.apply(this, arguments);\n      }\n\n      return put;\n    }()\n    /**\n     * Put the given blocks to the underlying blockstore and\n     * send it to nodes that have it them their wantlist.\n     *\n     * @param {AsyncIterable<Block>} blocks\n     * @returns {AsyncIterable<Block>}\n     */\n\n  }, {\n    key: \"putMany\",\n    value: function putMany(blocks) {\n      var _this2 = this;\n\n      return _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n        var _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _value2, block;\n\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _iteratorNormalCompletion2 = true;\n                _didIteratorError2 = false;\n                _context8.prev = 2;\n                _iterator2 = _asyncIterator(_this2.blockstore.putMany(blocks));\n\n              case 4:\n                _context8.next = 6;\n                return _awaitAsyncGenerator(_iterator2.next());\n\n              case 6:\n                _step2 = _context8.sent;\n                _iteratorNormalCompletion2 = _step2.done;\n                _context8.next = 10;\n                return _awaitAsyncGenerator(_step2.value);\n\n              case 10:\n                _value2 = _context8.sent;\n\n                if (_iteratorNormalCompletion2) {\n                  _context8.next = 19;\n                  break;\n                }\n\n                block = _value2;\n\n                _this2._sendHaveBlockNotifications(block);\n\n                _context8.next = 16;\n                return block;\n\n              case 16:\n                _iteratorNormalCompletion2 = true;\n                _context8.next = 4;\n                break;\n\n              case 19:\n                _context8.next = 25;\n                break;\n\n              case 21:\n                _context8.prev = 21;\n                _context8.t0 = _context8[\"catch\"](2);\n                _didIteratorError2 = true;\n                _iteratorError2 = _context8.t0;\n\n              case 25:\n                _context8.prev = 25;\n                _context8.prev = 26;\n\n                if (!(!_iteratorNormalCompletion2 && _iterator2.return != null)) {\n                  _context8.next = 30;\n                  break;\n                }\n\n                _context8.next = 30;\n                return _awaitAsyncGenerator(_iterator2.return());\n\n              case 30:\n                _context8.prev = 30;\n\n                if (!_didIteratorError2) {\n                  _context8.next = 33;\n                  break;\n                }\n\n                throw _iteratorError2;\n\n              case 33:\n                return _context8.finish(30);\n\n              case 34:\n                return _context8.finish(25);\n\n              case 35:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, null, [[2, 21, 25, 35], [26,, 30, 34]]);\n      }))();\n    }\n    /**\n     * Sends notifications about the arrival of a block\n     *\n     * @param {Block} block\n     */\n\n  }, {\n    key: \"_sendHaveBlockNotifications\",\n    value: function _sendHaveBlockNotifications(block) {\n      var _this6 = this;\n\n      this.notifications.hasBlock(block);\n      this.engine.receivedBlocks([block]); // Note: Don't wait for provide to finish before returning\n\n      this.network.provide(block.cid).catch(function (err) {\n        _this6._log.error('Failed to provide: %s', err.message);\n      });\n    }\n    /**\n     * Get the current list of wants.\n     *\n     * @returns {Iterator<WantlistEntry>}\n     */\n\n  }, {\n    key: \"getWantlist\",\n    value: function getWantlist() {\n      return this.wm.wantlist.entries();\n    }\n    /**\n     * Get the current list of partners.\n     *\n     * @returns {Iterator<PeerId>}\n     */\n\n  }, {\n    key: \"peers\",\n    value: function peers() {\n      return this.engine.peers();\n    }\n    /**\n     * Get stats about the bitswap node.\n     *\n     * @returns {Object}\n     */\n\n  }, {\n    key: \"stat\",\n    value: function stat() {\n      return this._stats;\n    }\n    /**\n     * Start the bitswap node.\n     *\n     * @returns {void}\n     */\n\n  }, {\n    key: \"start\",\n    value: function start() {\n      this.wm.start();\n      this.network.start();\n      this.engine.start();\n    }\n    /**\n     * Stop the bitswap node.\n     *\n     * @returns {void}\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this._stats.stop();\n\n      this.wm.stop();\n      this.network.stop();\n      this.engine.stop();\n    }\n  }]);\n\n  return Bitswap;\n}();\n\nmodule.exports = Bitswap;","map":null,"metadata":{},"sourceType":"script"}