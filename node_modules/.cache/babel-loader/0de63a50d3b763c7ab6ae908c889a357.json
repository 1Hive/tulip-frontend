{"ast":null,"code":"/* eslint max-nested-callbacks: [\"error\", 8] */\n'use strict';\n\nconst {\n  parallelMap\n} = require('streaming-iterables');\n\nconst CID = require('cids');\n\nconst {\n  resolvePath\n} = require('../../utils');\n\nconst PinManager = require('./pin-manager');\n\nconst {\n  PinTypes\n} = PinManager;\n\nconst {\n  withTimeoutOption\n} = require('../../utils');\n\nconst PIN_LS_CONCURRENCY = 8;\n\nmodule.exports = ({\n  pinManager,\n  dag\n}) => {\n  return withTimeoutOption(async function* ls(paths, options) {\n    options = options || {};\n    let type = PinTypes.all;\n\n    if (paths && !Array.isArray(paths) && !CID.isCID(paths) && typeof paths !== 'string') {\n      options = paths;\n      paths = null;\n    }\n\n    if (options.type) {\n      type = options.type;\n\n      if (typeof options.type === 'string') {\n        type = options.type.toLowerCase();\n      }\n\n      const err = PinManager.checkPinType(type);\n\n      if (err) {\n        throw err;\n      }\n    }\n\n    if (paths) {\n      paths = Array.isArray(paths) ? paths : [paths]; // check the pinned state of specific hashes\n\n      const cids = await resolvePath(dag, paths);\n      yield* parallelMap(PIN_LS_CONCURRENCY, async cid => {\n        const {\n          reason,\n          pinned\n        } = await pinManager.isPinnedWithType(cid, type);\n\n        if (!pinned) {\n          throw new Error(`path '${paths[cids.indexOf(cid)]}' is not pinned`);\n        }\n\n        if (reason === PinTypes.direct || reason === PinTypes.recursive) {\n          return {\n            cid,\n            type: reason\n          };\n        }\n\n        return {\n          cid,\n          type: `${PinTypes.indirect} through ${reason}`\n        };\n      }, cids);\n      return;\n    } // show all pinned items of type\n\n\n    let pins = [];\n\n    if (type === PinTypes.direct || type === PinTypes.all) {\n      pins = pins.concat(Array.from(pinManager.directPins).map(cid => ({\n        type: PinTypes.direct,\n        cid: new CID(cid)\n      })));\n    }\n\n    if (type === PinTypes.recursive || type === PinTypes.all) {\n      pins = pins.concat(Array.from(pinManager.recursivePins).map(cid => ({\n        type: PinTypes.recursive,\n        cid: new CID(cid)\n      })));\n    }\n\n    if (type === PinTypes.indirect || type === PinTypes.all) {\n      const indirects = await pinManager.getIndirectKeys(options);\n      pins = pins // if something is pinned both directly and indirectly,\n      // report the indirect entry\n      .filter(({\n        cid\n      }) => !indirects.includes(cid.toString()) || !pinManager.directPins.has(cid.toString())).concat(indirects.map(cid => ({\n        type: PinTypes.indirect,\n        cid: new CID(cid)\n      })));\n    } // FIXME: https://github.com/ipfs/js-ipfs/issues/2244\n\n\n    yield* pins;\n  });\n};","map":null,"metadata":{},"sourceType":"script"}