{"ast":null,"code":"'use strict';\n\nconst {\n  map\n} = require('streaming-iterables');\n\nconst errcode = require('err-code');\n/**\n * BlockService is a hybrid block datastore. It stores data in a local\n * datastore and may retrieve data from a remote Exchange.\n * It uses an internal `datastore.Datastore` instance to store values.\n */\n\n\nclass BlockService {\n  /**\n   * Create a new BlockService\n   *\n   * @param {IPFSRepo} ipfsRepo\n   */\n  constructor(ipfsRepo) {\n    this._repo = ipfsRepo;\n    this._bitswap = null;\n  }\n  /**\n   * Add a bitswap instance that communicates with the\n   * network to retreive blocks that are not in the local store.\n   *\n   * If the node is online all requests for blocks first\n   * check locally and afterwards ask the network for the blocks.\n   *\n   * @param {Bitswap} bitswap\n   * @returns {void}\n   */\n\n\n  setExchange(bitswap) {\n    this._bitswap = bitswap;\n  }\n  /**\n   * Go offline, i.e. drop the reference to bitswap.\n   *\n   * @returns {void}\n   */\n\n\n  unsetExchange() {\n    this._bitswap = null;\n  }\n  /**\n   * Is the blockservice online, i.e. is bitswap present.\n   *\n   * @returns {bool}\n   */\n\n\n  hasExchange() {\n    return this._bitswap != null;\n  }\n  /**\n   * Put a block to the underlying datastore.\n   *\n   * @param {Block} block\n   * @param {Object} [options] -  Options is an object with the following properties\n   * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation\n   * @returns {Promise}\n   */\n\n\n  put(block, options) {\n    if (this.hasExchange()) {\n      return this._bitswap.put(block, options);\n    } else {\n      return this._repo.blocks.put(block, options);\n    }\n  }\n  /**\n   * Put a multiple blocks to the underlying datastore.\n   *\n   * @param {AsyncIterator<Block>} blocks\n   * @param {Object} [options] -  Options is an object with the following properties\n   * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation\n   * @returns {Promise}\n   */\n\n\n  putMany(blocks, options) {\n    if (this.hasExchange()) {\n      return this._bitswap.putMany(blocks, options);\n    } else {\n      return this._repo.blocks.putMany(blocks, options);\n    }\n  }\n  /**\n   * Get a block by cid.\n   *\n   * @param {CID} cid\n   * @param {Object} [options] -  Options is an object with the following properties\n   * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation\n   * @returns {Promise<Block>}\n   */\n\n\n  get(cid, options) {\n    if (this.hasExchange()) {\n      return this._bitswap.get(cid, options);\n    } else {\n      return this._repo.blocks.get(cid, options);\n    }\n  }\n  /**\n   * Get multiple blocks back from an array of cids.\n   *\n   * @param {AsyncIterator<CID>} cids\n   * @param {Object} [options] -  Options is an object with the following properties\n   * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation\n   * @returns {AsyncIterator<Block>}\n   */\n\n\n  getMany(cids, options) {\n    if (!Array.isArray(cids)) {\n      throw new Error('first arg must be an array of cids');\n    }\n\n    if (this.hasExchange()) {\n      return this._bitswap.getMany(cids, options);\n    } else {\n      const getRepoBlocks = map(cid => this._repo.blocks.get(cid, options));\n      return getRepoBlocks(cids);\n    }\n  }\n  /**\n   * Delete a block from the blockstore.\n   *\n   * @param {CID} cid\n   * @param {Object} [options] -  Options is an object with the following properties\n   * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation\n   * @returns {Promise}\n   */\n\n\n  async delete(cid, options) {\n    if (!(await this._repo.blocks.has(cid))) {\n      throw errcode(new Error('blockstore: block not found'), 'ERR_BLOCK_NOT_FOUND');\n    }\n\n    return this._repo.blocks.delete(cid, options);\n  }\n  /**\n   * Delete multiple blocks from the blockstore.\n   *\n   * @param {AsyncIterator<CID>} cids\n   * @param {Object} [options] -  Options is an object with the following properties\n   * @param {AbortSignal} [options.signal] - A signal that can be used to abort any long-lived operations that are started as a result of this operation\n   * @returns {Promise}\n   */\n\n\n  deleteMany(cids, options) {\n    const repo = this._repo;\n    return this._repo.blocks.deleteMany(async function* () {\n      for await (const cid of cids) {\n        if (!(await repo.blocks.has(cid))) {\n          throw errcode(new Error('blockstore: block not found'), 'ERR_BLOCK_NOT_FOUND');\n        }\n\n        yield cid;\n      }\n    }(), options);\n  }\n\n}\n\nmodule.exports = BlockService;","map":null,"metadata":{},"sourceType":"script"}