{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@babel/runtime/helpers/classCallCheck'), require('@babel/runtime/helpers/createClass'), require('websocket'), require('xhr2-cookies'), require('url-parse'), require('@babel/runtime/helpers/typeof'), require('lodash/isFunction'), require('lodash/isObject'), require('@babel/runtime/regenerator'), require('@babel/runtime/helpers/asyncToGenerator'), require('@babel/runtime/helpers/possibleConstructorReturn'), require('@babel/runtime/helpers/getPrototypeOf'), require('@babel/runtime/helpers/get'), require('@babel/runtime/helpers/inherits'), require('eventemitter3'), require('lodash/isArray'), require('http'), require('https')) : typeof define === 'function' && define.amd ? define(['exports', '@babel/runtime/helpers/classCallCheck', '@babel/runtime/helpers/createClass', 'websocket', 'xhr2-cookies', 'url-parse', '@babel/runtime/helpers/typeof', 'lodash/isFunction', 'lodash/isObject', '@babel/runtime/regenerator', '@babel/runtime/helpers/asyncToGenerator', '@babel/runtime/helpers/possibleConstructorReturn', '@babel/runtime/helpers/getPrototypeOf', '@babel/runtime/helpers/get', '@babel/runtime/helpers/inherits', 'eventemitter3', 'lodash/isArray', 'http', 'https'], factory) : (global = global || self, factory(global.Web3Providers = {}, global._classCallCheck, global._createClass, global.websocket, global.xhr2Cookies, global.URL, global._typeof, global.isFunction, global.isObject, global._regeneratorRuntime, global._asyncToGenerator, global._possibleConstructorReturn, global._getPrototypeOf, global._get, global._inherits, global.EventEmitter, global.isArray, global.http, global.https));\n})(this, function (exports, _classCallCheck, _createClass, websocket, xhr2Cookies, URL, _typeof, isFunction, isObject, _regeneratorRuntime, _asyncToGenerator, _possibleConstructorReturn, _getPrototypeOf, _get, _inherits, EventEmitter, isArray, http, https) {\n  'use strict';\n\n  _classCallCheck = _classCallCheck && _classCallCheck.hasOwnProperty('default') ? _classCallCheck['default'] : _classCallCheck;\n  _createClass = _createClass && _createClass.hasOwnProperty('default') ? _createClass['default'] : _createClass;\n  URL = URL && URL.hasOwnProperty('default') ? URL['default'] : URL;\n  _typeof = _typeof && _typeof.hasOwnProperty('default') ? _typeof['default'] : _typeof;\n  isFunction = isFunction && isFunction.hasOwnProperty('default') ? isFunction['default'] : isFunction;\n  isObject = isObject && isObject.hasOwnProperty('default') ? isObject['default'] : isObject;\n  _regeneratorRuntime = _regeneratorRuntime && _regeneratorRuntime.hasOwnProperty('default') ? _regeneratorRuntime['default'] : _regeneratorRuntime;\n  _asyncToGenerator = _asyncToGenerator && _asyncToGenerator.hasOwnProperty('default') ? _asyncToGenerator['default'] : _asyncToGenerator;\n  _possibleConstructorReturn = _possibleConstructorReturn && _possibleConstructorReturn.hasOwnProperty('default') ? _possibleConstructorReturn['default'] : _possibleConstructorReturn;\n  _getPrototypeOf = _getPrototypeOf && _getPrototypeOf.hasOwnProperty('default') ? _getPrototypeOf['default'] : _getPrototypeOf;\n  _get = _get && _get.hasOwnProperty('default') ? _get['default'] : _get;\n  _inherits = _inherits && _inherits.hasOwnProperty('default') ? _inherits['default'] : _inherits;\n  EventEmitter = EventEmitter && EventEmitter.hasOwnProperty('default') ? EventEmitter['default'] : EventEmitter;\n  isArray = isArray && isArray.hasOwnProperty('default') ? isArray['default'] : isArray;\n  http = http && http.hasOwnProperty('default') ? http['default'] : http;\n  https = https && https.hasOwnProperty('default') ? https['default'] : https;\n\n  var global = function () {\n    return this || (typeof self === \"undefined\" ? \"undefined\" : _typeof(self)) === 'object' && self;\n  }() || new Function('return this')();\n\n  var ProviderResolver = function () {\n    function ProviderResolver(providersModuleFactory) {\n      _classCallCheck(this, ProviderResolver);\n\n      this.providersModuleFactory = providersModuleFactory;\n    }\n\n    _createClass(ProviderResolver, [{\n      key: \"resolve\",\n      value: function resolve(provider, net) {\n        if (!provider) {\n          return provider;\n        }\n\n        if (typeof provider === 'string') {\n          if (/^http(s)?:\\/\\//i.test(provider)) {\n            return this.providersModuleFactory.createHttpProvider(provider);\n          }\n\n          if (/^ws(s)?:\\/\\//i.test(provider)) {\n            return this.providersModuleFactory.createWebsocketProvider(provider);\n          }\n\n          if (provider && isObject(net) && isFunction(net.connect)) {\n            return this.providersModuleFactory.createIpcProvider(provider, net);\n          }\n        }\n\n        if (provider.sendPayload && provider.subscribe) {\n          return provider;\n        }\n\n        if (provider.host === 'Web3EthereumProvider') {\n          return provider;\n        }\n\n        if (typeof global.mist !== 'undefined' && provider.constructor.name === 'EthereumProvider') {\n          return this.providersModuleFactory.createMistEthereumProvider(provider);\n        }\n\n        if (provider.isEIP1193) {\n          return this.providersModuleFactory.createWeb3EthereumProvider(provider);\n        }\n\n        if (this.isMetamaskInpageProvider(provider)) {\n          return this.providersModuleFactory.createMetamaskProvider(provider);\n        }\n\n        return this.providersModuleFactory.createCustomProvider(provider);\n      }\n    }, {\n      key: \"isMetamaskInpageProvider\",\n      value: function isMetamaskInpageProvider(provider) {\n        return provider.constructor.name === 'MetamaskInpageProvider';\n      }\n    }]);\n\n    return ProviderResolver;\n  }();\n\n  var messageId = 0;\n\n  var JsonRpcMapper = function () {\n    function JsonRpcMapper() {\n      _classCallCheck(this, JsonRpcMapper);\n    }\n\n    _createClass(JsonRpcMapper, null, [{\n      key: \"toPayload\",\n      value: function toPayload(method, params) {\n        if (!method) {\n          throw new Error(\"JSONRPC method should be specified for params: \\\"\".concat(JSON.stringify(params), \"\\\"!\"));\n        }\n\n        var id = messageId;\n        messageId++;\n        return {\n          jsonrpc: '2.0',\n          id: id,\n          method: method,\n          params: params || []\n        };\n      }\n    }]);\n\n    return JsonRpcMapper;\n  }();\n\n  var JsonRpcResponseValidator = function () {\n    function JsonRpcResponseValidator() {\n      _classCallCheck(this, JsonRpcResponseValidator);\n    }\n\n    _createClass(JsonRpcResponseValidator, null, [{\n      key: \"validate\",\n      value: function validate(response) {\n        var payload = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n        if (isObject(response)) {\n          if (response.error) {\n            if (response.error instanceof Error) {\n              return new Error(\"Node error: \".concat(response.error.message));\n            }\n\n            return new Error(\"Node error: \".concat(JSON.stringify(response.error)));\n          }\n\n          if (payload && response.id !== payload.id) {\n            return new Error(\"Validation error: Invalid JSON-RPC response ID (request: \".concat(payload.id, \" / response: \").concat(response.id, \")\"));\n          }\n\n          if (response.result === undefined) {\n            return new Error('Validation error: Undefined JSON-RPC result');\n          }\n\n          return true;\n        }\n\n        return new Error('Validation error: Response should be of type Object');\n      }\n    }]);\n\n    return JsonRpcResponseValidator;\n  }();\n\n  var AbstractSocketProvider = function (_EventEmitter) {\n    _inherits(AbstractSocketProvider, _EventEmitter);\n\n    function AbstractSocketProvider(connection, timeout) {\n      var _this;\n\n      _classCallCheck(this, AbstractSocketProvider);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(AbstractSocketProvider).call(this));\n      _this.connection = connection;\n      _this.timeout = timeout;\n      _this.subscriptions = new Map();\n\n      _this.registerEventListeners();\n\n      _this.READY = 'ready';\n      _this.CONNECT = 'connect';\n      _this.ERROR = 'error';\n      _this.CLOSE = 'close';\n      _this.SOCKET_MESSAGE = 'socket_message';\n      _this.SOCKET_READY = 'socket_ready';\n      _this.SOCKET_CLOSE = 'socket_close';\n      _this.SOCKET_ERROR = 'socket_error';\n      _this.SOCKET_CONNECT = 'socket_connect';\n      _this.SOCKET_NETWORK_CHANGED = 'socket_networkChanged';\n      _this.SOCKET_ACCOUNTS_CHANGED = 'socket_accountsChanged';\n      return _this;\n    }\n\n    _createClass(AbstractSocketProvider, [{\n      key: \"supportsSubscriptions\",\n      value: function supportsSubscriptions() {\n        return true;\n      }\n    }, {\n      key: \"registerEventListeners\",\n      value: function registerEventListeners() {}\n    }, {\n      key: \"removeAllSocketListeners\",\n      value: function removeAllSocketListeners() {\n        this.removeAllListeners(this.SOCKET_MESSAGE);\n        this.removeAllListeners(this.SOCKET_READY);\n        this.removeAllListeners(this.SOCKET_CLOSE);\n        this.removeAllListeners(this.SOCKET_ERROR);\n        this.removeAllListeners(this.SOCKET_CONNECT);\n      }\n    }, {\n      key: \"disconnect\",\n      value: function disconnect(code, reason) {}\n    }, {\n      key: \"send\",\n      value: function () {\n        var _send = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(method, parameters) {\n          var response, validationResult;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.next = 2;\n                  return this.sendPayload(JsonRpcMapper.toPayload(method, parameters));\n\n                case 2:\n                  response = _context.sent;\n                  validationResult = JsonRpcResponseValidator.validate(response);\n\n                  if (!(validationResult instanceof Error)) {\n                    _context.next = 6;\n                    break;\n                  }\n\n                  throw validationResult;\n\n                case 6:\n                  return _context.abrupt(\"return\", response.result);\n\n                case 7:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this);\n        }));\n\n        function send(_x, _x2) {\n          return _send.apply(this, arguments);\n        }\n\n        return send;\n      }()\n    }, {\n      key: \"sendBatch\",\n      value: function sendBatch(methods, moduleInstance) {\n        var payload = [];\n        methods.forEach(function (method) {\n          method.beforeExecution(moduleInstance);\n          payload.push(JsonRpcMapper.toPayload(method.rpcMethod, method.parameters));\n        });\n        return this.sendPayload(payload);\n      }\n    }, {\n      key: \"onReady\",\n      value: function onReady(event) {\n        this.emit(this.READY, event);\n        this.emit(this.SOCKET_READY, event);\n      }\n    }, {\n      key: \"onError\",\n      value: function onError(error) {\n        this.emit(this.ERROR, error);\n        this.emit(this.SOCKET_ERROR, error);\n        this.removeAllSocketListeners();\n      }\n    }, {\n      key: \"onClose\",\n      value: function onClose() {\n        var error = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n        this.emit(this.CLOSE, error);\n        this.emit(this.SOCKET_CLOSE, error);\n        this.removeAllSocketListeners();\n        this.removeAllListeners();\n      }\n    }, {\n      key: \"onConnect\",\n      value: function () {\n        var _onConnect = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2() {\n          var subscriptionId, value, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, item;\n\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  if (!(this.subscriptions.size > 0)) {\n                    _context2.next = 31;\n                    break;\n                  }\n\n                  _iteratorNormalCompletion = true;\n                  _didIteratorError = false;\n                  _iteratorError = undefined;\n                  _context2.prev = 4;\n                  _iterator = this.subscriptions[Symbol.iterator]();\n\n                case 6:\n                  if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                    _context2.next = 17;\n                    break;\n                  }\n\n                  item = _step.value;\n                  value = item[1];\n                  _context2.next = 11;\n                  return this.subscribe(value.subscribeMethod, value.parameters[0], value.parameters.slice(1));\n\n                case 11:\n                  subscriptionId = _context2.sent;\n\n                  if (item[0] !== subscriptionId) {\n                    this.subscriptions.delete(subscriptionId);\n                  }\n\n                  value.id = subscriptionId;\n\n                case 14:\n                  _iteratorNormalCompletion = true;\n                  _context2.next = 6;\n                  break;\n\n                case 17:\n                  _context2.next = 23;\n                  break;\n\n                case 19:\n                  _context2.prev = 19;\n                  _context2.t0 = _context2[\"catch\"](4);\n                  _didIteratorError = true;\n                  _iteratorError = _context2.t0;\n\n                case 23:\n                  _context2.prev = 23;\n                  _context2.prev = 24;\n\n                  if (!_iteratorNormalCompletion && _iterator.return != null) {\n                    _iterator.return();\n                  }\n\n                case 26:\n                  _context2.prev = 26;\n\n                  if (!_didIteratorError) {\n                    _context2.next = 29;\n                    break;\n                  }\n\n                  throw _iteratorError;\n\n                case 29:\n                  return _context2.finish(26);\n\n                case 30:\n                  return _context2.finish(23);\n\n                case 31:\n                  this.emit(this.SOCKET_CONNECT);\n                  this.emit(this.CONNECT);\n\n                case 33:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, this, [[4, 19, 23, 31], [24,, 26, 30]]);\n        }));\n\n        function onConnect() {\n          return _onConnect.apply(this, arguments);\n        }\n\n        return onConnect;\n      }()\n    }, {\n      key: \"onMessage\",\n      value: function onMessage(response) {\n        var event;\n\n        if (!isObject(response)) {\n          response = JSON.parse(response);\n        }\n\n        if (isArray(response)) {\n          event = response[0].id;\n        } else if (typeof response.id === 'undefined') {\n          event = this.getSubscriptionEvent(response.params.subscription);\n          response = response.params;\n        } else {\n          event = response.id;\n        }\n\n        this.emit(this.SOCKET_MESSAGE, response);\n        this.emit(event, response);\n      }\n    }, {\n      key: \"reset\",\n      value: function reset() {\n        this.removeAllListeners();\n        this.registerEventListeners();\n      }\n    }, {\n      key: \"subscribe\",\n      value: function subscribe(subscribeMethod, subscriptionMethod, parameters) {\n        var _this2 = this;\n\n        parameters.unshift(subscriptionMethod);\n        return this.send(subscribeMethod, parameters).then(function (subscriptionId) {\n          _this2.subscriptions.set(subscriptionId, {\n            id: subscriptionId,\n            subscribeMethod: subscribeMethod,\n            parameters: parameters\n          });\n\n          return subscriptionId;\n        }).catch(function (error) {\n          throw new Error(\"Provider error: \".concat(error));\n        });\n      }\n    }, {\n      key: \"unsubscribe\",\n      value: function unsubscribe(subscriptionId, unsubscribeMethod) {\n        var _this3 = this;\n\n        if (this.hasSubscription(subscriptionId)) {\n          return this.send(unsubscribeMethod, [subscriptionId]).then(function (response) {\n            if (response) {\n              _this3.removeAllListeners(_this3.getSubscriptionEvent(subscriptionId));\n\n              _this3.subscriptions.delete(subscriptionId);\n            }\n\n            return response;\n          });\n        }\n\n        return Promise.reject(new Error(\"Provider error: Subscription with ID \".concat(subscriptionId, \" does not exist.\")));\n      }\n    }, {\n      key: \"clearSubscriptions\",\n      value: function clearSubscriptions() {\n        var _this4 = this;\n\n        var unsubscribeMethod = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\n        if (this.subscriptions.size > 0) {\n          var unsubscribePromises = [];\n          var type = unsubscribeMethod.slice(0, 3);\n          this.subscriptions.forEach(function (value) {\n            if (type === '') {\n              unsubscribePromises.push(_this4.unsubscribe(value.id, \"\".concat(value.subscribeMethod.slice(0, 3), \"_unsubscribe\")));\n            } else if (type === value.subscribeMethod.slice(0, 3)) {\n              unsubscribePromises.push(_this4.unsubscribe(value.id, unsubscribeMethod));\n            }\n          });\n          return Promise.all(unsubscribePromises).then(function (results) {\n            if (results.includes(false)) {\n              throw new Error(\"Could not unsubscribe all subscriptions: \".concat(JSON.stringify(results)));\n            }\n\n            return true;\n          });\n        }\n\n        return Promise.resolve(true);\n      }\n    }, {\n      key: \"hasSubscription\",\n      value: function hasSubscription(subscriptionId) {\n        return typeof this.getSubscriptionEvent(subscriptionId) !== 'undefined';\n      }\n    }, {\n      key: \"getSubscriptionEvent\",\n      value: function getSubscriptionEvent(subscriptionId) {\n        if (this.subscriptions.get(subscriptionId)) {\n          return subscriptionId;\n        }\n\n        var event;\n        this.subscriptions.forEach(function (value, key) {\n          if (value.id === subscriptionId) {\n            event = key;\n          }\n        });\n        return event;\n      }\n    }, {\n      key: \"connected\",\n      get: function get() {}\n    }]);\n\n    return AbstractSocketProvider;\n  }(EventEmitter);\n\n  var WebsocketProvider = function (_AbstractSocketProvid) {\n    _inherits(WebsocketProvider, _AbstractSocketProvid);\n\n    function WebsocketProvider(connection, timeout) {\n      var _this;\n\n      var reconnectDelay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 5000;\n\n      _classCallCheck(this, WebsocketProvider);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(WebsocketProvider).call(this, connection, timeout));\n      _this.host = _this.connection.url;\n      _this.reconnectDelay = reconnectDelay;\n      _this.reconnecting = false;\n      return _this;\n    }\n\n    _createClass(WebsocketProvider, [{\n      key: \"onConnect\",\n      value: function () {\n        var _onConnect = _asyncToGenerator(_regeneratorRuntime.mark(function _callee() {\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  if (this.reconnecting) {\n                    this.emit('reconnected');\n                  }\n\n                  _context.next = 3;\n                  return _get(_getPrototypeOf(WebsocketProvider.prototype), \"onConnect\", this).call(this);\n\n                case 3:\n                  this.reconnecting = false;\n\n                case 4:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this);\n        }));\n\n        function onConnect() {\n          return _onConnect.apply(this, arguments);\n        }\n\n        return onConnect;\n      }()\n    }, {\n      key: \"onMessage\",\n      value: function onMessage(messageEvent) {\n        _get(_getPrototypeOf(WebsocketProvider.prototype), \"onMessage\", this).call(this, messageEvent.data);\n      }\n    }, {\n      key: \"onError\",\n      value: function onError(event) {\n        if (event.code === 'ECONNREFUSED') {\n          this.reconnect();\n          return;\n        }\n\n        _get(_getPrototypeOf(WebsocketProvider.prototype), \"onError\", this).call(this, event);\n      }\n    }, {\n      key: \"onClose\",\n      value: function onClose(closeEvent) {\n        if (closeEvent.code !== 1000 || closeEvent.wasClean === false) {\n          this.reconnect();\n          return;\n        }\n\n        _get(_getPrototypeOf(WebsocketProvider.prototype), \"onClose\", this).call(this);\n      }\n    }, {\n      key: \"reconnect\",\n      value: function reconnect() {\n        var _this2 = this;\n\n        this.reconnecting = true;\n        setTimeout(function () {\n          _this2.removeAllSocketListeners();\n\n          var connection = [];\n\n          if (_this2.connection.constructor.name === 'W3CWebSocket') {\n            connection = new _this2.connection.constructor(_this2.host, _this2.connection._client.protocol, null, _this2.connection._client.headers, _this2.connection._client.requestOptions, _this2.connection._client.config);\n          } else {\n            connection = new _this2.connection.constructor(_this2.host, _this2.connection.protocol || undefined);\n          }\n\n          _this2.connection = connection;\n\n          _this2.registerEventListeners();\n        }, this.reconnectDelay);\n      }\n    }, {\n      key: \"disconnect\",\n      value: function disconnect() {\n        var code = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n        var reason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n        this.connection.close(code, reason);\n      }\n    }, {\n      key: \"registerEventListeners\",\n      value: function registerEventListeners() {\n        this.connection.addEventListener('message', this.onMessage.bind(this));\n        this.connection.addEventListener('open', this.onReady.bind(this));\n        this.connection.addEventListener('open', this.onConnect.bind(this));\n        this.connection.addEventListener('close', this.onClose.bind(this));\n        this.connection.addEventListener('error', this.onError.bind(this));\n      }\n    }, {\n      key: \"removeAllListeners\",\n      value: function removeAllListeners(event) {\n        switch (event) {\n          case this.SOCKET_MESSAGE:\n            this.connection.removeEventListener('message', this.onMessage);\n            break;\n\n          case this.SOCKET_READY:\n            this.connection.removeEventListener('open', this.onReady);\n            break;\n\n          case this.SOCKET_CLOSE:\n            this.connection.removeEventListener('close', this.onClose);\n            break;\n\n          case this.SOCKET_ERROR:\n            this.connection.removeEventListener('error', this.onError);\n            break;\n\n          case this.SOCKET_CONNECT:\n            this.connection.removeEventListener('connect', this.onConnect);\n            break;\n        }\n\n        _get(_getPrototypeOf(WebsocketProvider.prototype), \"removeAllListeners\", this).call(this, event);\n      }\n    }, {\n      key: \"isConnecting\",\n      value: function isConnecting() {\n        return this.connection.readyState === this.connection.CONNECTING;\n      }\n    }, {\n      key: \"sendPayload\",\n      value: function sendPayload(payload) {\n        var _this3 = this;\n\n        return new Promise(function (resolve, reject) {\n          _this3.once('error', reject);\n\n          if (!_this3.isConnecting()) {\n            var timeout, id;\n\n            if (_this3.connection.readyState !== _this3.connection.OPEN) {\n              _this3.removeListener('error', reject);\n\n              return reject(new Error('Connection error: Connection is not open on send()'));\n            }\n\n            try {\n              _this3.connection.send(JSON.stringify(payload));\n            } catch (error) {\n              _this3.removeListener('error', reject);\n\n              return reject(error);\n            }\n\n            if (isArray(payload)) {\n              id = payload[0].id;\n            } else {\n              id = payload.id;\n            }\n\n            if (_this3.timeout) {\n              timeout = setTimeout(function () {\n                _this3.removeListener('error', reject);\n\n                _this3.removeAllListeners(id);\n\n                reject(new Error('Connection error: Timeout exceeded'));\n              }, _this3.timeout);\n            }\n\n            _this3.once(id, function (response) {\n              if (timeout) {\n                clearTimeout(timeout);\n              }\n\n              _this3.removeListener('error', reject);\n\n              return resolve(response);\n            });\n\n            return;\n          }\n\n          _this3.once('connect', function () {\n            _this3.sendPayload(payload).then(function (response) {\n              _this3.removeListener('error', reject);\n\n              return resolve(response);\n            }).catch(function (error) {\n              _this3.removeListener('error', reject);\n\n              return reject(error);\n            });\n          });\n        });\n      }\n    }, {\n      key: \"connected\",\n      get: function get() {\n        return this.connection.readyState === this.connection.OPEN;\n      }\n    }]);\n\n    return WebsocketProvider;\n  }(AbstractSocketProvider);\n\n  var IpcProvider = function (_AbstractSocketProvid) {\n    _inherits(IpcProvider, _AbstractSocketProvid);\n\n    function IpcProvider(connection, path) {\n      var _this;\n\n      _classCallCheck(this, IpcProvider);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(IpcProvider).call(this, connection, null));\n      _this.host = path;\n      _this.lastChunk = '';\n      return _this;\n    }\n\n    _createClass(IpcProvider, [{\n      key: \"disconnect\",\n      value: function disconnect() {\n        this.connection.destroy();\n      }\n    }, {\n      key: \"reconnect\",\n      value: function reconnect() {\n        this.connection.connect({\n          path: this.path\n        });\n      }\n    }, {\n      key: \"onMessage\",\n      value: function onMessage(message) {\n        var _this2 = this;\n\n        var result = null;\n        var returnValues = [];\n        var dechunkedData = message.toString().replace(/\\}[\\n\\r]?\\{/g, '}|--|{').replace(/\\}\\][\\n\\r]?\\[\\{/g, '}]|--|[{').replace(/\\}[\\n\\r]?\\[\\{/g, '}|--|[{').replace(/\\}\\][\\n\\r]?\\{/g, '}]|--|{').split('|--|');\n        dechunkedData.forEach(function (data) {\n          result = null;\n\n          if (_this2.lastChunk) {\n            data = _this2.lastChunk + data;\n          }\n\n          try {\n            result = JSON.parse(data);\n          } catch (error) {\n            _this2.lastChunk = data;\n            return;\n          }\n\n          _this2.lastChunk = null;\n          returnValues.push(result);\n        });\n        returnValues.forEach(function (chunk) {\n          _get(_getPrototypeOf(IpcProvider.prototype), \"onMessage\", _this2).call(_this2, chunk);\n        });\n      }\n    }, {\n      key: \"registerEventListeners\",\n      value: function registerEventListeners() {\n        this.connection.on('data', this.onMessage.bind(this));\n        this.connection.on('connect', this.onConnect.bind(this));\n        this.connection.on('error', this.onError.bind(this));\n        this.connection.on('close', this.onClose.bind(this));\n        this.connection.on('timeout', this.onClose.bind(this));\n        this.connection.on('ready', this.onReady.bind(this));\n      }\n    }, {\n      key: \"removeAllListeners\",\n      value: function removeAllListeners(event) {\n        switch (event) {\n          case this.SOCKET_MESSAGE:\n            this.connection.removeListener('data', this.onMessage);\n            break;\n\n          case this.SOCKET_READY:\n            this.connection.removeListener('ready', this.onReady);\n            break;\n\n          case this.SOCKET_CLOSE:\n            this.connection.removeListener('close', this.onClose);\n            break;\n\n          case this.SOCKET_ERROR:\n            this.connection.removeListener('error', this.onError);\n            break;\n\n          case this.SOCKET_CONNECT:\n            this.connection.removeListener('connect', this.onConnect);\n            break;\n        }\n\n        _get(_getPrototypeOf(IpcProvider.prototype), \"removeAllListeners\", this).call(this, event);\n      }\n    }, {\n      key: \"sendPayload\",\n      value: function sendPayload(payload) {\n        var _this3 = this;\n\n        return new Promise(function (resolve, reject) {\n          _this3.once('error', reject);\n\n          if (!_this3.connection.writable) {\n            _this3.connection.connect({\n              path: _this3.path\n            });\n          }\n\n          if (_this3.connection.write(JSON.stringify(payload))) {\n            var id;\n\n            if (isArray(payload)) {\n              id = payload[0].id;\n            } else {\n              id = payload.id;\n            }\n\n            _this3.once(id, function (response) {\n              resolve(response);\n\n              _this3.removeListener('error', reject);\n            });\n\n            return;\n          }\n\n          _this3.removeListener('error', reject);\n\n          return reject(new Error(\"Connection error: Couldn't write on the socket with Socket.write(payload)\"));\n        });\n      }\n    }, {\n      key: \"connected\",\n      get: function get() {\n        return !this.connection.pending;\n      }\n    }]);\n\n    return IpcProvider;\n  }(AbstractSocketProvider);\n\n  var HttpProvider = function () {\n    function HttpProvider() {\n      var host = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'http://localhost:8545';\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var providersModuleFactory = arguments.length > 2 ? arguments[2] : undefined;\n\n      _classCallCheck(this, HttpProvider);\n\n      this.host = host;\n      this.timeout = options.timeout || 0;\n      this.headers = options.headers;\n      this.withCredentials = options.withCredentials || false;\n      this.connected = true;\n      this.providersModuleFactory = providersModuleFactory;\n      this.agent = {};\n      var keepAlive = false;\n\n      if (options.keepAlive === true || options.keepAlive !== false) {\n        keepAlive = true;\n      }\n\n      if (host.substring(0, 5) === 'https') {\n        this.agent['httpsAgent'] = new https.Agent({\n          keepAlive: keepAlive\n        });\n      } else {\n        this.agent['httpAgent'] = new http.Agent({\n          keepAlive: keepAlive\n        });\n      }\n    }\n\n    _createClass(HttpProvider, [{\n      key: \"supportsSubscriptions\",\n      value: function supportsSubscriptions() {\n        return false;\n      }\n    }, {\n      key: \"subscribe\",\n      value: function subscribe() {\n        throw new Error('Subscriptions are not supported with the HttpProvider.');\n      }\n    }, {\n      key: \"unsubscribe\",\n      value: function unsubscribe() {\n        throw new Error('Subscriptions are not supported with the HttpProvider.');\n      }\n    }, {\n      key: \"disconnect\",\n      value: function disconnect() {\n        return true;\n      }\n    }, {\n      key: \"send\",\n      value: function () {\n        var _send = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(method, parameters) {\n          var response, validationResult;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.next = 2;\n                  return this.sendPayload(JsonRpcMapper.toPayload(method, parameters));\n\n                case 2:\n                  response = _context.sent;\n                  validationResult = JsonRpcResponseValidator.validate(response);\n\n                  if (!(validationResult instanceof Error)) {\n                    _context.next = 6;\n                    break;\n                  }\n\n                  throw validationResult;\n\n                case 6:\n                  return _context.abrupt(\"return\", response.result);\n\n                case 7:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this);\n        }));\n\n        function send(_x, _x2) {\n          return _send.apply(this, arguments);\n        }\n\n        return send;\n      }()\n    }, {\n      key: \"sendBatch\",\n      value: function sendBatch(methods, moduleInstance) {\n        var payload = [];\n        methods.forEach(function (method) {\n          method.beforeExecution(moduleInstance);\n          payload.push(JsonRpcMapper.toPayload(method.rpcMethod, method.parameters));\n        });\n        return this.sendPayload(payload);\n      }\n    }, {\n      key: \"sendPayload\",\n      value: function sendPayload(payload) {\n        var _this = this;\n\n        return new Promise(function (resolve, reject) {\n          var request = _this.providersModuleFactory.createXMLHttpRequest(_this.host, _this.timeout, _this.headers, _this.agent, _this.withCredentials);\n\n          request.onreadystatechange = function () {\n            if (request.readyState !== 0 && request.readyState !== 1) {\n              _this.connected = true;\n            }\n\n            if (request.readyState === 4) {\n              if (request.status === 200) {\n                try {\n                  return resolve(JSON.parse(request.responseText));\n                } catch (error) {\n                  reject(new Error(\"Invalid JSON as response: \".concat(request.responseText)));\n                }\n              }\n\n              if (_this.isInvalidHttpEndpoint(request)) {\n                reject(new Error(\"Connection refused or URL couldn't be resolved: \".concat(_this.host)));\n              }\n\n              if (request.status >= 400 && request.status <= 499) {\n                reject(new Error(\"HttpProvider ERROR: \".concat(request.responseText, \" (code: \").concat(request.status, \")\")));\n              }\n            }\n          };\n\n          request.ontimeout = function () {\n            _this.connected = false;\n            reject(new Error(\"Connection error: Timeout exceeded after \".concat(_this.timeout, \"ms\")));\n          };\n\n          try {\n            request.send(JSON.stringify(payload));\n          } catch (error) {\n            _this.connected = false;\n            reject(error);\n          }\n        });\n      }\n    }, {\n      key: \"isInvalidHttpEndpoint\",\n      value: function isInvalidHttpEndpoint(request) {\n        return request.response === null && request.status === 0;\n      }\n    }]);\n\n    return HttpProvider;\n  }();\n\n  var BatchRequest = function () {\n    function BatchRequest(moduleInstance) {\n      _classCallCheck(this, BatchRequest);\n\n      this.moduleInstance = moduleInstance;\n      this.methods = [];\n      this.accounts = [];\n    }\n\n    _createClass(BatchRequest, [{\n      key: \"add\",\n      value: function add(method) {\n        if (!isObject(method) && method) {\n          throw new Error('Please provide a object of type AbstractMethod.');\n        }\n\n        this.methods.push(method);\n      }\n    }, {\n      key: \"execute\",\n      value: function () {\n        var _execute = _asyncToGenerator(_regeneratorRuntime.mark(function _callee() {\n          var _this = this;\n\n          var payload, response, hasCallbacks, errors;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.next = 2;\n                  return this.toPayload();\n\n                case 2:\n                  payload = _context.sent;\n                  _context.next = 5;\n                  return this.moduleInstance.currentProvider.sendPayload(payload);\n\n                case 5:\n                  response = _context.sent;\n                  hasCallbacks = false;\n                  errors = [];\n                  this.methods.forEach(function (method, index) {\n                    if (!hasCallbacks && method.callback) {\n                      hasCallbacks = true;\n                    }\n\n                    if (!isArray(response)) {\n                      if (method.callback) {\n                        method.callback(new Error(\"BatchRequest error: Response should be of type Array but is: \".concat(_typeof(response))), null);\n                        return;\n                      }\n\n                      throw new Error(\"BatchRequest error: Response should be of type Array but is: \".concat(_typeof(response)));\n                    }\n\n                    var responseItem = response[index] || null;\n                    var validationResult = JsonRpcResponseValidator.validate(responseItem);\n\n                    if (validationResult === true) {\n                      try {\n                        var mappedResult;\n\n                        if (method.Type === 'eth-send-transaction-method' || method.Type === 'observed-transaction-method') {\n                          mappedResult = responseItem.result;\n                        } else {\n                          mappedResult = method.afterExecution(responseItem.result);\n                        }\n\n                        response[index] = mappedResult;\n\n                        if (method.callback) {\n                          method.callback(false, mappedResult);\n                        }\n                      } catch (error) {\n                        errors[index] = {\n                          method: method,\n                          error: error\n                        };\n\n                        if (method.callback) {\n                          method.callback(error, null);\n                        }\n                      }\n\n                      return;\n                    }\n\n                    errors[index] = {\n                      method: method,\n                      error: validationResult\n                    };\n\n                    if (_this.accounts[index] && _this.accounts[index].nonce) {\n                      _this.accounts[index].nonce--;\n                    }\n\n                    if (method.callback) {\n                      method.callback(validationResult, null);\n                    }\n                  });\n\n                  if (!(errors.length > 0 && !hasCallbacks)) {\n                    _context.next = 11;\n                    break;\n                  }\n\n                  throw {\n                    errors: errors,\n                    response: response\n                  };\n\n                case 11:\n                  return _context.abrupt(\"return\", {\n                    methods: this.methods,\n                    response: response\n                  });\n\n                case 12:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this);\n        }));\n\n        function execute() {\n          return _execute.apply(this, arguments);\n        }\n\n        return execute;\n      }()\n    }, {\n      key: \"toPayload\",\n      value: function () {\n        var _toPayload = _asyncToGenerator(_regeneratorRuntime.mark(function _callee2() {\n          var payload, i, method, account, response;\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  payload = [];\n                  i = 0;\n\n                case 2:\n                  if (!(i < this.methods.length)) {\n                    _context2.next = 18;\n                    break;\n                  }\n\n                  method = this.methods[i];\n                  method.beforeExecution(this.moduleInstance);\n\n                  if (!(this.moduleInstance.accounts && method.Type === 'eth-send-transaction-method' && method.hasAccounts())) {\n                    _context2.next = 14;\n                    break;\n                  }\n\n                  account = this.moduleInstance.accounts.wallet[method.parameters[0].from];\n\n                  if (!account) {\n                    _context2.next = 14;\n                    break;\n                  }\n\n                  _context2.next = 10;\n                  return method.signTransaction(account);\n\n                case 10:\n                  response = _context2.sent;\n                  method.parameters = [response.rawTransaction];\n                  method.rpcMethod = 'eth_sendRawTransaction';\n                  this.accounts[i] = account;\n\n                case 14:\n                  payload.push(JsonRpcMapper.toPayload(method.rpcMethod, method.parameters));\n\n                case 15:\n                  i++;\n                  _context2.next = 2;\n                  break;\n\n                case 18:\n                  return _context2.abrupt(\"return\", payload);\n\n                case 19:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, this);\n        }));\n\n        function toPayload() {\n          return _toPayload.apply(this, arguments);\n        }\n\n        return toPayload;\n      }()\n    }]);\n\n    return BatchRequest;\n  }();\n\n  var Web3EthereumProvider = function (_AbstractSocketProvid) {\n    _inherits(Web3EthereumProvider, _AbstractSocketProvid);\n\n    function Web3EthereumProvider(connection) {\n      var _this;\n\n      _classCallCheck(this, Web3EthereumProvider);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(Web3EthereumProvider).call(this, connection, null));\n      _this.host = 'Web3EthereumProvider';\n      return _this;\n    }\n\n    _createClass(Web3EthereumProvider, [{\n      key: \"registerEventListeners\",\n      value: function registerEventListeners() {\n        this.connection.on('notification', this.onMessage.bind(this));\n        this.connection.on('connect', this.onConnect.bind(this));\n        this.connection.on('connect', this.onReady.bind(this));\n        this.connection.on('close', this.onClose.bind(this));\n        this.connection.on('networkChanged', this.onNetworkChanged.bind(this));\n        this.connection.on('accountsChanged', this.onAccountsChanged.bind(this));\n      }\n    }, {\n      key: \"removeAllListeners\",\n      value: function removeAllListeners(event) {\n        switch (event) {\n          case this.SOCKET_NETWORK_CHANGED:\n            this.connection.removeListener('networkChanged', this.onNetworkChanged);\n            break;\n\n          case this.SOCKET_ACCOUNTS_CHANGED:\n            this.connection.removeListener('accountsChanged', this.onAccountsChanged);\n            break;\n\n          case this.SOCKET_MESSAGE:\n            this.connection.removeListener('notification', this.onMessage);\n            break;\n\n          case this.SOCKET_READY:\n            this.connection.removeListener('connect', this.onReady);\n            break;\n\n          case this.SOCKET_CLOSE:\n            this.connection.removeListener('close', this.onClose);\n            break;\n\n          case this.SOCKET_ERROR:\n            this.connection.removeListener('close', this.onError);\n            break;\n\n          case this.SOCKET_CONNECT:\n            this.connection.removeListener('connect', this.onConnect);\n            break;\n        }\n\n        _get(_getPrototypeOf(Web3EthereumProvider.prototype), \"removeAllListeners\", this).call(this, event);\n      }\n    }, {\n      key: \"removeAllSocketListeners\",\n      value: function removeAllSocketListeners() {\n        this.removeAllListeners(this.SOCKET_ACCOUNTS_CHANGED);\n        this.removeAllListeners(this.SOCKET_NETWORK_CHANGED);\n\n        _get(_getPrototypeOf(Web3EthereumProvider.prototype), \"removeAllSocketListeners\", this).call(this);\n      }\n    }, {\n      key: \"onNetworkChanged\",\n      value: function onNetworkChanged(networkId) {\n        this.emit('networkChanged', networkId);\n      }\n    }, {\n      key: \"onAccountsChanged\",\n      value: function onAccountsChanged(accounts) {\n        this.emit('accountsChanged', accounts);\n      }\n    }, {\n      key: \"onMessage\",\n      value: function onMessage(response) {\n        this.emit(this.getSubscriptionEvent(response.subscription), response);\n      }\n    }, {\n      key: \"send\",\n      value: function () {\n        var _send = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(method, parameters) {\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.prev = 0;\n                  _context.next = 3;\n                  return this.connection.send(method, parameters);\n\n                case 3:\n                  return _context.abrupt(\"return\", _context.sent);\n\n                case 6:\n                  _context.prev = 6;\n                  _context.t0 = _context[\"catch\"](0);\n                  throw new Error(\"Node error: \".concat(_context.t0.message));\n\n                case 9:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this, [[0, 6]]);\n        }));\n\n        function send(_x, _x2) {\n          return _send.apply(this, arguments);\n        }\n\n        return send;\n      }()\n    }, {\n      key: \"sendBatch\",\n      value: function sendBatch(methods, moduleInstance) {\n        var _this2 = this;\n\n        var methodCalls = [];\n        methods.forEach(function (method) {\n          method.beforeExecution(moduleInstance);\n          methodCalls.push(_this2.connection.send(method.rpcMethod, method.parameters));\n        });\n        return Promise.all(methodCalls);\n      }\n    }]);\n\n    return Web3EthereumProvider;\n  }(AbstractSocketProvider);\n\n  var MetamaskProvider = function (_AbstractSocketProvid) {\n    _inherits(MetamaskProvider, _AbstractSocketProvid);\n\n    function MetamaskProvider(inpageProvider) {\n      var _this;\n\n      _classCallCheck(this, MetamaskProvider);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(MetamaskProvider).call(this, inpageProvider, null));\n      _this.host = 'metamask';\n      return _this;\n    }\n\n    _createClass(MetamaskProvider, [{\n      key: \"registerEventListeners\",\n      value: function registerEventListeners() {\n        this.connection.on('accountsChanged', this.onAccountsChanged.bind(this));\n        this.connection.on('networkChanged', this.onReady.bind(this));\n        this.connection.on('networkChanged', this.onNetworkChanged.bind(this));\n        this.connection.on('data', this.onMessage.bind(this));\n        this.connection.on('error', this.onError.bind(this));\n      }\n    }, {\n      key: \"onMessage\",\n      value: function onMessage(metamaskParam, payload) {\n        _get(_getPrototypeOf(MetamaskProvider.prototype), \"onMessage\", this).call(this, payload);\n      }\n    }, {\n      key: \"removeAllListeners\",\n      value: function removeAllListeners(event) {\n        switch (event) {\n          case this.SOCKET_NETWORK_CHANGED:\n            this.connection.removeListener('networkChanged', this.onNetworkChanged);\n            break;\n\n          case this.SOCKET_ACCOUNTS_CHANGED:\n            this.connection.removeListener('accountsChanged', this.onAccountsChanged);\n            break;\n\n          case this.SOCKET_MESSAGE:\n            this.connection.removeListener('data', this.onMessage);\n            break;\n\n          case this.SOCKET_ERROR:\n            this.connection.removeListener('error', this.onError);\n            break;\n        }\n\n        _get(_getPrototypeOf(MetamaskProvider.prototype), \"removeAllListeners\", this).call(this, event);\n      }\n    }, {\n      key: \"removeAllSocketListeners\",\n      value: function removeAllSocketListeners() {\n        this.removeAllListeners(this.SOCKET_ACCOUNTS_CHANGED);\n        this.removeAllListeners(this.SOCKET_NETWORK_CHANGED);\n\n        _get(_getPrototypeOf(MetamaskProvider.prototype), \"removeAllSocketListeners\", this).call(this);\n      }\n    }, {\n      key: \"onNetworkChanged\",\n      value: function onNetworkChanged(networkId) {\n        this.emit('networkChanged', networkId);\n      }\n    }, {\n      key: \"onAccountsChanged\",\n      value: function onAccountsChanged(accounts) {\n        this.emit('accountsChanged', accounts);\n      }\n    }, {\n      key: \"disconnect\",\n      value: function disconnect() {\n        return true;\n      }\n    }, {\n      key: \"sendPayload\",\n      value: function sendPayload(payload) {\n        var _this2 = this;\n\n        return new Promise(function (resolve, reject) {\n          _this2.connection.send(payload, function (error, response) {\n            if (!error) {\n              return resolve(response);\n            }\n\n            reject(error);\n          });\n        });\n      }\n    }, {\n      key: \"connected\",\n      get: function get() {\n        return this.connection.isConnected();\n      }\n    }]);\n\n    return MetamaskProvider;\n  }(AbstractSocketProvider);\n\n  var MistEthereumProvider = function (_AbstractSocketProvid) {\n    _inherits(MistEthereumProvider, _AbstractSocketProvid);\n\n    function MistEthereumProvider(connection) {\n      var _this;\n\n      _classCallCheck(this, MistEthereumProvider);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(MistEthereumProvider).call(this, connection, null));\n      _this.host = 'mist';\n      return _this;\n    }\n\n    _createClass(MistEthereumProvider, [{\n      key: \"registerEventListeners\",\n      value: function registerEventListeners() {\n        this.connection.on('data', this.onMessage.bind(this));\n        this.connection.on('error', this.onError.bind(this));\n        this.connection.on('connect', this.onConnect.bind(this));\n        this.connection.on('connect', this.onReady.bind(this));\n        this.connection.on('end', this.onClose.bind(this));\n      }\n    }, {\n      key: \"removeAllListeners\",\n      value: function removeAllListeners(event) {\n        switch (event) {\n          case this.SOCKET_MESSAGE:\n            this.connection.removeListener('data', this.onMessage);\n            break;\n\n          case this.SOCKET_ERROR:\n            this.connection.removeListener('error', this.onError);\n            break;\n\n          case this.SOCKET_CONNECT:\n            this.connection.removeListener('connect', this.onConnect);\n            break;\n\n          case this.SOCKET_READY:\n            this.connection.removeListener('connect', this.onConnect);\n            break;\n\n          case this.SOCKET_CLOSE:\n            this.connection.removeListener('end', this.onClose);\n            break;\n        }\n\n        _get(_getPrototypeOf(MistEthereumProvider.prototype), \"removeAllListeners\", this).call(this, event);\n      }\n    }, {\n      key: \"disconnect\",\n      value: function disconnect() {\n        return true;\n      }\n    }, {\n      key: \"sendPayload\",\n      value: function sendPayload(payload) {\n        var _this2 = this;\n\n        return new Promise(function (resolve, reject) {\n          _this2.connection.send(payload, function (error, response) {\n            if (!error) {\n              return resolve(response);\n            }\n\n            reject(error);\n          });\n        });\n      }\n    }, {\n      key: \"connected\",\n      get: function get() {\n        return this.connection.isConnected();\n      }\n    }]);\n\n    return MistEthereumProvider;\n  }(AbstractSocketProvider);\n\n  var CustomProvider = function () {\n    function CustomProvider(connection) {\n      _classCallCheck(this, CustomProvider);\n\n      this.host = 'CustomProvider';\n      this.connection = connection;\n      this.checkConnectionMethods();\n    }\n\n    _createClass(CustomProvider, [{\n      key: \"supportsSubscriptions\",\n      value: function supportsSubscriptions() {\n        return false;\n      }\n    }, {\n      key: \"checkConnectionMethods\",\n      value: function checkConnectionMethods() {\n        if (this.connection.send || this.connection.sendAsync) {\n          return true;\n        }\n\n        throw new Error('Invalid provider injected!');\n      }\n    }, {\n      key: \"subscribe\",\n      value: function subscribe() {\n        throw new Error('Subscriptions are not supported with the CustomProvider.');\n      }\n    }, {\n      key: \"unsubscribe\",\n      value: function unsubscribe() {\n        throw new Error('Subscriptions are not supported with the CustomProvider.');\n      }\n    }, {\n      key: \"send\",\n      value: function () {\n        var _send = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(method, parameters) {\n          var response, validationResult;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.next = 2;\n                  return this.sendPayload(JsonRpcMapper.toPayload(method, parameters));\n\n                case 2:\n                  response = _context.sent;\n                  validationResult = JsonRpcResponseValidator.validate(response);\n\n                  if (!(validationResult instanceof Error)) {\n                    _context.next = 6;\n                    break;\n                  }\n\n                  throw validationResult;\n\n                case 6:\n                  return _context.abrupt(\"return\", response.result);\n\n                case 7:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this);\n        }));\n\n        function send(_x, _x2) {\n          return _send.apply(this, arguments);\n        }\n\n        return send;\n      }()\n    }, {\n      key: \"sendBatch\",\n      value: function sendBatch(methods, moduleInstance) {\n        var payload = [];\n        methods.forEach(function (method) {\n          method.beforeExecution(moduleInstance);\n          payload.push(JsonRpcMapper.toPayload(method.rpcMethod, method.parameters));\n        });\n        return this.sendPayload(payload);\n      }\n    }, {\n      key: \"sendPayload\",\n      value: function sendPayload(payload) {\n        var _this = this;\n\n        return new Promise(function (resolve, reject) {\n          if (_this.connection.sendAsync) {\n            _this.connection.sendAsync(payload, function (error, response) {\n              if (!error) {\n                resolve(response);\n              }\n\n              reject(error);\n            });\n\n            return;\n          }\n\n          _this.connection.send(payload, function (error, response) {\n            if (!error) {\n              resolve(response);\n            }\n\n            reject(error);\n          });\n        });\n      }\n    }]);\n\n    return CustomProvider;\n  }();\n\n  var ProvidersModuleFactory = function () {\n    function ProvidersModuleFactory() {\n      _classCallCheck(this, ProvidersModuleFactory);\n    }\n\n    _createClass(ProvidersModuleFactory, [{\n      key: \"createBatchRequest\",\n      value: function createBatchRequest(moduleInstance) {\n        return new BatchRequest(moduleInstance);\n      }\n    }, {\n      key: \"createProviderResolver\",\n      value: function createProviderResolver() {\n        return new ProviderResolver(this);\n      }\n    }, {\n      key: \"createHttpProvider\",\n      value: function createHttpProvider(url) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        return new HttpProvider(url, options, this);\n      }\n    }, {\n      key: \"createXMLHttpRequest\",\n      value: function createXMLHttpRequest(host, timeout, headers, agent, withCredentials) {\n        var request;\n\n        if (typeof process !== 'undefined' && process.versions != null && process.versions.node != null) {\n          request = new xhr2Cookies.XMLHttpRequest();\n          request.nodejsSet(agent);\n        } else {\n          request = new XMLHttpRequest();\n        }\n\n        request.open('POST', host, true);\n        request.setRequestHeader('Content-Type', 'application/json');\n        request.timeout = timeout;\n        request.withCredentials = withCredentials;\n\n        if (headers) {\n          headers.forEach(function (header) {\n            request.setRequestHeader(header.name, header.value);\n          });\n        }\n\n        return request;\n      }\n    }, {\n      key: \"createWebsocketProvider\",\n      value: function createWebsocketProvider(url) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var headers = options.headers || {};\n\n        if (typeof process !== 'undefined' && process.versions != null && process.versions.node != null) {\n          var urlObject = new URL(url);\n\n          if (!headers.authorization && urlObject.username && urlObject.password) {\n            var authToken = Buffer.from(\"\".concat(urlObject.username, \":\").concat(urlObject.password)).toString('base64');\n            headers.authorization = \"Basic \".concat(authToken);\n          }\n        }\n\n        return new WebsocketProvider(new websocket.w3cwebsocket(url, options.protocol, options.origin, headers, options.requestOptions, options.clientConfig), options.timeout, options.reconnectDelay);\n      }\n    }, {\n      key: \"createIpcProvider\",\n      value: function createIpcProvider(path, net) {\n        return new IpcProvider(net.connect({\n          path: path\n        }), path);\n      }\n    }, {\n      key: \"createWeb3EthereumProvider\",\n      value: function createWeb3EthereumProvider(connection) {\n        return new Web3EthereumProvider(connection);\n      }\n    }, {\n      key: \"createMetamaskProvider\",\n      value: function createMetamaskProvider(inpageProvider) {\n        return new MetamaskProvider(inpageProvider);\n      }\n    }, {\n      key: \"createMistEthereumProvider\",\n      value: function createMistEthereumProvider(mistEthereumProvider) {\n        return new MistEthereumProvider(mistEthereumProvider);\n      }\n    }, {\n      key: \"createCustomProvider\",\n      value: function createCustomProvider(connection) {\n        return new CustomProvider(connection);\n      }\n    }]);\n\n    return ProvidersModuleFactory;\n  }();\n\n  var global$1 = function () {\n    return this || (typeof self === \"undefined\" ? \"undefined\" : _typeof(self)) === 'object' && self;\n  }() || new Function('return this')();\n\n  var ProviderDetector = function () {\n    function ProviderDetector() {\n      _classCallCheck(this, ProviderDetector);\n    }\n\n    _createClass(ProviderDetector, null, [{\n      key: \"detect\",\n      value: function detect() {\n        if (typeof global$1.ethereumProvider !== 'undefined' && global$1.ethereumProvider.constructor.name === 'EthereumProvider') {\n          return global$1.ethereumProvider;\n        }\n\n        if (typeof global$1.web3 !== 'undefined' && global$1.web3.currentProvider) {\n          return global$1.web3.currentProvider;\n        }\n\n        return null;\n      }\n    }]);\n\n    return ProviderDetector;\n  }();\n\n  function HttpProvider$1(url) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return new ProvidersModuleFactory().createHttpProvider(url, options);\n  }\n\n  function WebsocketProvider$1(url) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return new ProvidersModuleFactory().createWebsocketProvider(url, options);\n  }\n\n  function IpcProvider$1(path, net) {\n    return new ProvidersModuleFactory().createIpcProvider(path, net);\n  }\n\n  function BatchRequest$1(moduleInstance) {\n    return new ProvidersModuleFactory().createBatchRequest(moduleInstance);\n  }\n\n  function ProviderResolver$1() {\n    return new ProvidersModuleFactory().createProviderResolver();\n  }\n\n  exports.BatchRequest = BatchRequest$1;\n  exports.HttpProvider = HttpProvider$1;\n  exports.IpcProvider = IpcProvider$1;\n  exports.ProviderDetector = ProviderDetector;\n  exports.ProviderResolver = ProviderResolver$1;\n  exports.ProvidersModuleFactory = ProvidersModuleFactory;\n  exports.Web3EthereumProvider = Web3EthereumProvider;\n  exports.WebsocketProvider = WebsocketProvider$1;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":null,"metadata":{},"sourceType":"script"}