{"ast":null,"code":"'use strict';\n\nconst Clock = require('./lamport-clock');\n/**\n * Sort two entries as Last-Write-Wins (LWW).\n *\n * Last Write Wins is a conflict resolution strategy for sorting elements\n * where the element with a greater clock (latest) is chosen as the winner.\n *\n * @param {Entry} a First entry\n * @param {Entry} b Second entry\n * @returns {number} 1 if a is latest, -1 if b is latest\n */\n\n\nfunction LastWriteWins(a, b) {\n  // Ultimate conflict resolution (take the first/left arg)\n  const First = (a, b) => a; // Sort two entries by their clock id, if the same always take the first\n\n\n  const sortById = (a, b) => SortByClockId(a, b, First); // Sort two entries by their clock time, if concurrent,\n  // determine sorting using provided conflict resolution function\n\n\n  const sortByEntryClocks = (a, b) => SortByClocks(a, b, sortById); // Sort entries by clock time as the primary sort criteria\n\n\n  return sortByEntryClocks(a, b);\n}\n/**\n * Sort two entries by their hash.\n *\n * @param {Entry} a First entry\n * @param {Entry} b Second entry\n * @returns {number} 1 if a is latest, -1 if b is latest\n */\n\n\nfunction SortByEntryHash(a, b) {\n  // Ultimate conflict resolution (compare hashes)\n  const compareHash = (a, b) => a.hash < b.hash ? -1 : 1; // Sort two entries by their clock id, if the same then compare hashes\n\n\n  const sortById = (a, b) => SortByClockId(a, b, compareHash); // Sort two entries by their clock time, if concurrent,\n  // determine sorting using provided conflict resolution function\n\n\n  const sortByEntryClocks = (a, b) => SortByClocks(a, b, sortById); // Sort entries by clock time as the primary sort criteria\n\n\n  return sortByEntryClocks(a, b);\n}\n/**\n * Sort two entries by their clock time.\n * @param {Entry} a First entry to compare\n * @param {Entry} b Second entry to compare\n * @param {function(a, b)} resolveConflict A function to call if entries are concurrent (happened at the same time). The function should take in two entries and return 1 if the first entry should be chosen and -1 if the second entry should be chosen.\n * @returns {number} 1 if a is greater, -1 if b is greater\n */\n\n\nfunction SortByClocks(a, b, resolveConflict) {\n  // Compare the clocks\n  const diff = Clock.compare(a.clock, b.clock); // If the clocks are concurrent, use the provided\n  // conflict resolution function to determine which comes first\n\n  return diff === 0 ? resolveConflict(a, b) : diff;\n}\n/**\n * Sort two entries by their clock id.\n * @param {Entry} a First entry to compare\n * @param {Entry} b Second entry to compare\n * @param {function(a, b)} resolveConflict A function to call if the clocks ids are the same. The function should take in two entries and return 1 if the first entry should be chosen and -1 if the second entry should be chosen.\n * @returns {number} 1 if a is greater, -1 if b is greater\n */\n\n\nfunction SortByClockId(a, b, resolveConflict) {\n  // Sort by ID if clocks are concurrent,\n  // take the entry with a \"greater\" clock id\n  return a.clock.id === b.clock.id ? resolveConflict(a, b) : a.clock.id < b.clock.id ? -1 : 1;\n}\n/**\n * A wrapper function to throw an error if the results of a passed function return zero\n * @param {function(a, b)} [tiebreaker] The tiebreaker function to validate.\n * @returns {function(a, b)} 1 if a is greater, -1 if b is greater\n * @throws {Error} if func ever returns 0\n */\n\n\nfunction NoZeroes(func) {\n  const msg = `Your log's tiebreaker function, ${func.name}, has returned zero and therefore cannot be`;\n\n  const comparator = (a, b) => {\n    // Validate by calling the function\n    const result = func(a, b);\n\n    if (result === 0) {\n      throw Error(msg);\n    }\n\n    return result;\n  };\n\n  return comparator;\n}\n\nexports.SortByClocks = SortByClocks;\nexports.SortByClockId = SortByClockId;\nexports.LastWriteWins = LastWriteWins;\nexports.SortByEntryHash = SortByEntryHash;\nexports.NoZeroes = NoZeroes;","map":null,"metadata":{},"sourceType":"script"}