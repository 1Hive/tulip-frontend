{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar diff = require('hyperdiff');\n\nvar EventEmitter = require('events');\n\nvar clone = require('lodash.clonedeep');\n\nvar PROTOCOL = require('./protocol');\n\nvar Connection = require('./connection');\n\nvar encoding = require('./encoding');\n\nvar directConnection = require('./direct-connection-handler');\n\nvar DEFAULT_OPTIONS = {\n  pollInterval: 1000\n};\nvar index = 0;\n\nvar PubSubRoom = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(PubSubRoom, _EventEmitter);\n\n  var _super = _createSuper(PubSubRoom);\n\n  function PubSubRoom(libp2p, topic, options) {\n    var _this;\n\n    _classCallCheck(this, PubSubRoom);\n\n    _this = _super.call(this);\n    _this._libp2p = libp2p.libp2p || libp2p;\n    _this._topic = topic;\n    _this._options = Object.assign({}, clone(DEFAULT_OPTIONS), clone(options));\n    _this._peers = [];\n    _this._connections = {};\n    _this._handleDirectMessage = _this._handleDirectMessage.bind(_assertThisInitialized(_this));\n    _this._handleMessage = _this._onMessage.bind(_assertThisInitialized(_this));\n\n    if (!_this._libp2p.pubsub) {\n      throw new Error('pubsub has not been configured');\n    }\n\n    _this._interval = setInterval(_this._pollPeers.bind(_assertThisInitialized(_this)), _this._options.pollInterval);\n\n    _this._libp2p.handle(PROTOCOL, directConnection.handler);\n\n    directConnection.emitter.on(_this._topic, _this._handleDirectMessage);\n\n    _this._libp2p.pubsub.subscribe(_this._topic, _this._handleMessage);\n\n    _this._idx = index++;\n    return _this;\n  }\n\n  _createClass(PubSubRoom, [{\n    key: \"getPeers\",\n    value: function getPeers() {\n      return this._peers.slice(0);\n    }\n  }, {\n    key: \"hasPeer\",\n    value: function hasPeer(peer) {\n      return Boolean(this._peers.find(function (p) {\n        return p.toString() === peer.toString();\n      }));\n    }\n  }, {\n    key: \"leave\",\n    value: function () {\n      var _leave = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this2 = this;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                clearInterval(this._interval);\n                Object.keys(this._connections).forEach(function (peer) {\n                  _this2._connections[peer].stop();\n                });\n                directConnection.emitter.removeListener(this._topic, this._handleDirectMessage);\n\n                this._libp2p.unhandle(PROTOCOL, directConnection.handler);\n\n                _context.next = 6;\n                return this._libp2p.pubsub.unsubscribe(this._topic, this._handleMessage);\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function leave() {\n        return _leave.apply(this, arguments);\n      }\n\n      return leave;\n    }()\n  }, {\n    key: \"broadcast\",\n    value: function () {\n      var _broadcast = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_message) {\n        var message;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                message = encoding(_message);\n                _context2.next = 3;\n                return this._libp2p.pubsub.publish(this._topic, message);\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function broadcast(_x) {\n        return _broadcast.apply(this, arguments);\n      }\n\n      return broadcast;\n    }()\n  }, {\n    key: \"sendTo\",\n    value: function sendTo(peer, message) {\n      var _this3 = this;\n\n      var conn = this._connections[peer];\n\n      if (!conn) {\n        conn = new Connection(peer, this._libp2p, this);\n        conn.on('error', function (err) {\n          return _this3.emit('error', err);\n        });\n        this._connections[peer] = conn;\n        conn.once('disconnect', function () {\n          delete _this3._connections[peer];\n          _this3._peers = _this3._peers.filter(function (p) {\n            return p.toString() !== peer.toString();\n          });\n\n          _this3.emit('peer left', peer);\n        });\n      } // We should use the same sequence number generation as js-libp2p-floosub does:\n      // const seqno = Buffer.from(utils.randomSeqno())\n      // Until we figure out a good way to bring in the js-libp2p-floosub's randomSeqno\n      // generator, let's use 0 as the sequence number for all private messages\n      // const seqno = Buffer.from([0])\n\n\n      var seqno = Buffer.from([0]);\n      var msg = {\n        to: peer,\n        from: this._libp2p.peerInfo.id.toB58String(),\n        data: Buffer.from(message).toString('hex'),\n        seqno: seqno.toString('hex'),\n        topicIDs: [this._topic],\n        topicCIDs: [this._topic]\n      };\n      conn.push(Buffer.from(JSON.stringify(msg)));\n    }\n  }, {\n    key: \"_pollPeers\",\n    value: function () {\n      var _pollPeers2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var newPeers;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this._libp2p.pubsub.getSubscribers(this._topic);\n\n              case 2:\n                newPeers = _context3.sent.sort();\n\n                if (this._emitChanges(newPeers)) {\n                  this._peers = newPeers;\n                }\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function _pollPeers() {\n        return _pollPeers2.apply(this, arguments);\n      }\n\n      return _pollPeers;\n    }()\n  }, {\n    key: \"_emitChanges\",\n    value: function _emitChanges(newPeers) {\n      var _this4 = this;\n\n      var differences = diff(this._peers, newPeers);\n      differences.added.forEach(function (peer) {\n        return _this4.emit('peer joined', peer);\n      });\n      differences.removed.forEach(function (peer) {\n        return _this4.emit('peer left', peer);\n      });\n      return differences.added.length > 0 || differences.removed.length > 0;\n    }\n  }, {\n    key: \"_onMessage\",\n    value: function _onMessage(message) {\n      this.emit('message', message);\n    }\n  }, {\n    key: \"_handleDirectMessage\",\n    value: function _handleDirectMessage(message) {\n      if (message.to.toString() === this._libp2p.peerInfo.id.toB58String()) {\n        var m = Object.assign({}, message);\n        delete m.to;\n        this.emit('message', m);\n      }\n    }\n  }]);\n\n  return PubSubRoom;\n}(EventEmitter);\n\nmodule.exports = PubSubRoom;","map":null,"metadata":{},"sourceType":"script"}