{"ast":null,"code":"'use strict';\n\nconst PeerInfo = require('peer-info');\n\nconst PeerId = require('peer-id');\n\nconst protons = require('protons');\n\nconst {\n  Record\n} = require('libp2p-record');\n\nconst {\n  Buffer\n} = require('buffer');\n\nconst pbm = protons(require('./dht.proto'));\nconst MESSAGE_TYPE = pbm.Message.MessageType;\nconst CONNECTION_TYPE = pbm.Message.ConnectionType;\n/**\n * Represents a single DHT control message.\n */\n\nclass Message {\n  /**\n   * @param {MessageType} type\n   * @param {Buffer} key\n   * @param {number} level\n   */\n  constructor(type, key, level) {\n    if (key && !Buffer.isBuffer(key)) {\n      throw new Error('Key must be a buffer');\n    }\n\n    this.type = type;\n    this.key = key;\n    this._clusterLevelRaw = level;\n    this.closerPeers = [];\n    this.providerPeers = [];\n    this.record = null;\n  }\n  /**\n   * @type {number}\n   */\n\n\n  get clusterLevel() {\n    const level = this._clusterLevelRaw - 1;\n\n    if (level < 0) {\n      return 0;\n    }\n\n    return level;\n  }\n\n  set clusterLevel(level) {\n    this._clusterLevelRaw = level;\n  }\n  /**\n   * Encode into protobuf\n   * @returns {Buffer}\n   */\n\n\n  serialize() {\n    const obj = {\n      key: this.key,\n      type: this.type,\n      clusterLevelRaw: this._clusterLevelRaw,\n      closerPeers: this.closerPeers.map(toPbPeer),\n      providerPeers: this.providerPeers.map(toPbPeer)\n    };\n\n    if (this.record) {\n      if (Buffer.isBuffer(this.record)) {\n        obj.record = this.record;\n      } else {\n        obj.record = this.record.serialize();\n      }\n    }\n\n    return pbm.Message.encode(obj);\n  }\n  /**\n   * Decode from protobuf\n   *\n   * @param {Buffer} raw\n   * @returns {Message}\n   */\n\n\n  static deserialize(raw) {\n    const dec = pbm.Message.decode(raw);\n    const msg = new Message(dec.type, dec.key, dec.clusterLevelRaw);\n    msg.closerPeers = dec.closerPeers.map(fromPbPeer);\n    msg.providerPeers = dec.providerPeers.map(fromPbPeer);\n\n    if (dec.record) {\n      msg.record = Record.deserialize(dec.record);\n    }\n\n    return msg;\n  }\n\n}\n\nMessage.TYPES = MESSAGE_TYPE;\nMessage.CONNECTION_TYPES = CONNECTION_TYPE;\n\nfunction toPbPeer(peer) {\n  const res = {\n    id: peer.id.id,\n    addrs: peer.multiaddrs.toArray().map(m => m.buffer)\n  };\n\n  if (peer.isConnected()) {\n    res.connection = CONNECTION_TYPE.CONNECTED;\n  } else {\n    res.connection = CONNECTION_TYPE.NOT_CONNECTED;\n  }\n\n  return res;\n}\n\nfunction fromPbPeer(peer) {\n  const info = new PeerInfo(new PeerId(peer.id));\n  peer.addrs.forEach(a => info.multiaddrs.add(a));\n  return info;\n}\n\nmodule.exports = Message;","map":null,"metadata":{},"sourceType":"script"}