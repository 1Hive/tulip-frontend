{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _classCallCheck from \"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _wrapNativeSuper from \"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper\";\n\nvar JSBI = /*#__PURE__*/function (_Array) {\n  _inherits(JSBI, _Array);\n\n  var _super = _createSuper(JSBI);\n\n  function JSBI(a, b) {\n    var _this;\n\n    _classCallCheck(this, JSBI);\n\n    if (a > JSBI.__kMaxLength) throw new RangeError(\"Maximum BigInt size exceeded\");\n    _this = _super.call(this, a), _this.sign = b;\n    return _this;\n  }\n\n  _createClass(JSBI, [{\n    key: \"toDebugString\",\n    value: function toDebugString() {\n      var a = [\"BigInt[\"];\n\n      var _iterator = _createForOfIteratorHelper(this),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var b = _step.value;\n          a.push((b ? (b >>> 0).toString(16) : b) + \", \");\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return a.push(\"]\"), a.join(\"\");\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n      if (2 > a || 36 < a) throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n      return 0 === this.length ? \"0\" : 0 == (a & a - 1) ? JSBI.__toStringBasePowerOfTwo(this, a) : JSBI.__toStringGeneric(this, a, !1);\n    }\n  }, {\n    key: \"__copy\",\n    value: function __copy() {\n      var a = new JSBI(this.length, this.sign);\n\n      for (var b = 0; b < this.length; b++) {\n        a[b] = this[b];\n      }\n\n      return a;\n    }\n  }, {\n    key: \"__trim\",\n    value: function __trim() {\n      var a = this.length,\n          b = this[a - 1];\n\n      for (; 0 === b;) {\n        a--, b = this[a - 1], this.pop();\n      }\n\n      return 0 === a && (this.sign = !1), this;\n    }\n  }, {\n    key: \"__initializeDigits\",\n    value: function __initializeDigits() {\n      for (var a = 0; a < this.length; a++) {\n        this[a] = 0;\n      }\n    }\n  }, {\n    key: \"__clzmsd\",\n    value: function __clzmsd() {\n      return Math.clz32(this[this.length - 1]);\n    }\n  }, {\n    key: \"__inplaceMultiplyAdd\",\n    value: function __inplaceMultiplyAdd(a, b, c) {\n      var e = Math.imul;\n      c > this.length && (c = this.length);\n      var f = 65535 & a,\n          g = a >>> 16;\n      var h = 0,\n          j = 65535 & b,\n          k = b >>> 16;\n\n      for (var l = 0; l < c; l++) {\n        var _a = this.__digit(l),\n            _b = 65535 & _a,\n            _c = _a >>> 16,\n            d = e(_b, f),\n            i = e(_b, g),\n            m = e(_c, f),\n            n = e(_c, g),\n            o = j + (65535 & d),\n            p = k + h + (o >>> 16) + (d >>> 16) + (65535 & i) + (65535 & m);\n\n        j = (i >>> 16) + (m >>> 16) + (65535 & n) + (p >>> 16), h = j >>> 16, j &= 65535, k = n >>> 16;\n\n        this.__setDigit(l, 65535 & o | p << 16);\n      }\n\n      if (0 != h || 0 !== j || 0 !== k) throw new Error(\"implementation bug\");\n    }\n  }, {\n    key: \"__inplaceAdd\",\n    value: function __inplaceAdd(a, b, c) {\n      var d = 0;\n\n      for (var e = 0; e < c; e++) {\n        var _c2 = this.__halfDigit(b + e) + a.__halfDigit(e) + d;\n\n        d = _c2 >>> 16, this.__setHalfDigit(b + e, _c2);\n      }\n\n      return d;\n    }\n  }, {\n    key: \"__inplaceSub\",\n    value: function __inplaceSub(a, b, c) {\n      var d = 0;\n\n      if (1 & b) {\n        b >>= 1;\n\n        var e = this.__digit(b),\n            f = 65535 & e,\n            g = 0;\n\n        for (; g < c - 1 >>> 1; g++) {\n          var _c3 = a.__digit(g),\n              _h = (e >>> 16) - (65535 & _c3) - d;\n\n          d = 1 & _h >>> 16, this.__setDigit(b + g, _h << 16 | 65535 & f), e = this.__digit(b + g + 1), f = (65535 & e) - (_c3 >>> 16) - d, d = 1 & f >>> 16;\n        }\n\n        var h = a.__digit(g),\n            i = (e >>> 16) - (65535 & h) - d;\n\n        d = 1 & i >>> 16, this.__setDigit(b + g, i << 16 | 65535 & f);\n        if (b + g + 1 >= this.length) throw new RangeError(\"out of bounds\");\n        0 == (1 & c) && (e = this.__digit(b + g + 1), f = (65535 & e) - (h >>> 16) - d, d = 1 & f >>> 16, this.__setDigit(b + a.length, 4294901760 & e | 65535 & f));\n      } else {\n        b >>= 1;\n        var _e = 0;\n\n        for (; _e < a.length - 1; _e++) {\n          var _c4 = this.__digit(b + _e),\n              _f2 = a.__digit(_e),\n              _g2 = (65535 & _c4) - (65535 & _f2) - d;\n\n          d = 1 & _g2 >>> 16;\n\n          var _h3 = (_c4 >>> 16) - (_f2 >>> 16) - d;\n\n          d = 1 & _h3 >>> 16, this.__setDigit(b + _e, _h3 << 16 | 65535 & _g2);\n        }\n\n        var _f = this.__digit(b + _e),\n            _g = a.__digit(_e),\n            _h2 = (65535 & _f) - (65535 & _g) - d;\n\n        d = 1 & _h2 >>> 16;\n        var _i = 0;\n        0 == (1 & c) && (_i = (_f >>> 16) - (_g >>> 16) - d, d = 1 & _i >>> 16), this.__setDigit(b + _e, _i << 16 | 65535 & _h2);\n      }\n\n      return d;\n    }\n  }, {\n    key: \"__inplaceRightShift\",\n    value: function __inplaceRightShift(a) {\n      if (0 === a) return;\n      var b = this.__digit(0) >>> a;\n      var c = this.length - 1;\n\n      for (var e = 0; e < c; e++) {\n        var _c5 = this.__digit(e + 1);\n\n        this.__setDigit(e, _c5 << 32 - a | b), b = _c5 >>> a;\n      }\n\n      this.__setDigit(c, b);\n    }\n  }, {\n    key: \"__digit\",\n    value: function __digit(a) {\n      return this[a];\n    }\n  }, {\n    key: \"__unsignedDigit\",\n    value: function __unsignedDigit(a) {\n      return this[a] >>> 0;\n    }\n  }, {\n    key: \"__setDigit\",\n    value: function __setDigit(a, b) {\n      this[a] = 0 | b;\n    }\n  }, {\n    key: \"__setDigitGrow\",\n    value: function __setDigitGrow(a, b) {\n      this[a] = 0 | b;\n    }\n  }, {\n    key: \"__halfDigitLength\",\n    value: function __halfDigitLength() {\n      var a = this.length;\n      return 65535 >= this.__unsignedDigit(a - 1) ? 2 * a - 1 : 2 * a;\n    }\n  }, {\n    key: \"__halfDigit\",\n    value: function __halfDigit(a) {\n      return 65535 & this[a >>> 1] >>> ((1 & a) << 4);\n    }\n  }, {\n    key: \"__setHalfDigit\",\n    value: function __setHalfDigit(a, b) {\n      var c = a >>> 1,\n          d = this.__digit(c),\n          e = 1 & a ? 65535 & d | b << 16 : 4294901760 & d | 65535 & b;\n\n      this.__setDigit(c, e);\n    }\n  }], [{\n    key: \"BigInt\",\n    value: function BigInt(a) {\n      var b = Math.floor,\n          c = Number.isFinite;\n\n      if (\"number\" == typeof a) {\n        if (0 === a) return JSBI.__zero();\n        if ((0 | a) === a) return 0 > a ? JSBI.__oneDigit(-a, !0) : JSBI.__oneDigit(a, !1);\n        if (!c(a) || b(a) !== a) throw new RangeError(\"The number \" + a + \" cannot be converted to BigInt because it is not an integer\");\n        return JSBI.__fromDouble(a);\n      }\n\n      if (\"string\" == typeof a) {\n        var _b2 = JSBI.__fromString(a);\n\n        if (null === _b2) throw new SyntaxError(\"Cannot convert \" + a + \" to a BigInt\");\n        return _b2;\n      }\n\n      if (\"boolean\" == typeof a) return !0 === a ? JSBI.__oneDigit(1, !1) : JSBI.__zero();\n\n      if (\"object\" == typeof a) {\n        if (a.constructor === JSBI) return a;\n\n        var _b3 = JSBI.__toPrimitive(a);\n\n        return JSBI.BigInt(_b3);\n      }\n\n      throw new TypeError(\"Cannot convert \" + a + \" to a BigInt\");\n    }\n  }, {\n    key: \"toNumber\",\n    value: function toNumber(a) {\n      var b = Math.clz32;\n      var c = a.length;\n      if (0 === c) return 0;\n\n      if (1 === c) {\n        var _b4 = a.__unsignedDigit(0);\n\n        return a.sign ? -_b4 : _b4;\n      }\n\n      var d = a.__digit(c - 1),\n          e = b(d),\n          f = 32 * c - e;\n\n      if (1024 < f) return a.sign ? -Infinity : 1 / 0;\n      var g = f - 1,\n          h = d,\n          i = c - 1;\n      var j = e + 1;\n      var k = 32 === j ? 0 : h << j;\n      k >>>= 12;\n      var l = j - 12;\n      var m = 12 <= j ? 0 : h << 20 + j,\n          n = 20 + j;\n      0 < l && 0 < i && (i--, h = a.__digit(i), k |= h >>> 32 - l, m = h << l, n = l), 0 < n && 0 < i && (i--, h = a.__digit(i), m |= h >>> 32 - n, n -= 32);\n\n      var o = JSBI.__decideRounding(a, n, i, h);\n\n      if ((1 === o || 0 === o && 1 == (1 & m)) && (m = m + 1 >>> 0, 0 == m && (k++, 0 != k >>> 20 && (k = 0, g++, 1023 < g)))) return a.sign ? -Infinity : 1 / 0;\n      var p = a.sign ? -2147483648 : 0;\n      return g = g + 1023 << 20, JSBI.__kBitConversionInts[1] = p | g | k, JSBI.__kBitConversionInts[0] = m, JSBI.__kBitConversionDouble[0];\n    }\n  }, {\n    key: \"unaryMinus\",\n    value: function unaryMinus(a) {\n      if (0 === a.length) return a;\n\n      var b = a.__copy();\n\n      return b.sign = !a.sign, b;\n    }\n  }, {\n    key: \"bitwiseNot\",\n    value: function bitwiseNot(a) {\n      return a.sign ? JSBI.__absoluteSubOne(a).__trim() : JSBI.__absoluteAddOne(a, !0);\n    }\n  }, {\n    key: \"exponentiate\",\n    value: function exponentiate(a, b) {\n      if (b.sign) throw new RangeError(\"Exponent must be positive\");\n      if (0 === b.length) return JSBI.__oneDigit(1, !1);\n      if (0 === a.length) return a;\n      if (1 === a.length && 1 === a.__digit(0)) return a.sign && 0 == (1 & b.__digit(0)) ? JSBI.unaryMinus(a) : a;\n      if (1 < b.length) throw new RangeError(\"BigInt too big\");\n\n      var c = b.__unsignedDigit(0);\n\n      if (1 === c) return a;\n      if (c >= JSBI.__kMaxLengthBits) throw new RangeError(\"BigInt too big\");\n\n      if (1 === a.length && 2 === a.__digit(0)) {\n        var _b5 = 1 + (c >>> 5),\n            _d = a.sign && 0 != (1 & c),\n            _e2 = new JSBI(_b5, _d);\n\n        _e2.__initializeDigits();\n\n        var f = 1 << (31 & c);\n        return _e2.__setDigit(_b5 - 1, f), _e2;\n      }\n\n      var d = null,\n          e = a;\n\n      for (0 != (1 & c) && (d = a), c >>= 1; 0 !== c; c >>= 1) {\n        e = JSBI.multiply(e, e), 0 != (1 & c) && (null === d ? d = e : d = JSBI.multiply(d, e));\n      }\n\n      return d;\n    }\n  }, {\n    key: \"multiply\",\n    value: function multiply(a, b) {\n      if (0 === a.length) return a;\n      if (0 === b.length) return b;\n      var c = a.length + b.length;\n      32 <= a.__clzmsd() + b.__clzmsd() && c--;\n      var d = new JSBI(c, a.sign !== b.sign);\n\n      d.__initializeDigits();\n\n      for (var _c6 = 0; _c6 < a.length; _c6++) {\n        JSBI.__multiplyAccumulate(b, a.__digit(_c6), d, _c6);\n      }\n\n      return d.__trim();\n    }\n  }, {\n    key: \"divide\",\n    value: function divide(a, b) {\n      if (0 === b.length) throw new RangeError(\"Division by zero\");\n      if (0 > JSBI.__absoluteCompare(a, b)) return JSBI.__zero();\n\n      var c = a.sign !== b.sign,\n          d = b.__unsignedDigit(0);\n\n      var e;\n\n      if (1 === b.length && 65535 >= d) {\n        if (1 === d) return c === a.sign ? a : JSBI.unaryMinus(a);\n        e = JSBI.__absoluteDivSmall(a, d, null);\n      } else e = JSBI.__absoluteDivLarge(a, b, !0, !1);\n\n      return e.sign = c, e.__trim();\n    }\n  }, {\n    key: \"remainder\",\n    value: function remainder(a, b) {\n      if (0 === b.length) throw new RangeError(\"Division by zero\");\n      if (0 > JSBI.__absoluteCompare(a, b)) return a;\n\n      var c = b.__unsignedDigit(0);\n\n      if (1 === b.length && 65535 >= c) {\n        if (1 === c) return JSBI.__zero();\n\n        var _b6 = JSBI.__absoluteModSmall(a, c);\n\n        return 0 === _b6 ? JSBI.__zero() : JSBI.__oneDigit(_b6, a.sign);\n      }\n\n      var d = JSBI.__absoluteDivLarge(a, b, !1, !0);\n\n      return d.sign = a.sign, d.__trim();\n    }\n  }, {\n    key: \"add\",\n    value: function add(a, b) {\n      var c = a.sign;\n      return c === b.sign ? JSBI.__absoluteAdd(a, b, c) : 0 <= JSBI.__absoluteCompare(a, b) ? JSBI.__absoluteSub(a, b, c) : JSBI.__absoluteSub(b, a, !c);\n    }\n  }, {\n    key: \"subtract\",\n    value: function subtract(a, b) {\n      var c = a.sign;\n      return c === b.sign ? 0 <= JSBI.__absoluteCompare(a, b) ? JSBI.__absoluteSub(a, b, c) : JSBI.__absoluteSub(b, a, !c) : JSBI.__absoluteAdd(a, b, c);\n    }\n  }, {\n    key: \"leftShift\",\n    value: function leftShift(a, b) {\n      return 0 === b.length || 0 === a.length ? a : b.sign ? JSBI.__rightShiftByAbsolute(a, b) : JSBI.__leftShiftByAbsolute(a, b);\n    }\n  }, {\n    key: \"signedRightShift\",\n    value: function signedRightShift(a, b) {\n      return 0 === b.length || 0 === a.length ? a : b.sign ? JSBI.__leftShiftByAbsolute(a, b) : JSBI.__rightShiftByAbsolute(a, b);\n    }\n  }, {\n    key: \"unsignedRightShift\",\n    value: function unsignedRightShift() {\n      throw new TypeError(\"BigInts have no unsigned right shift; use >> instead\");\n    }\n  }, {\n    key: \"lessThan\",\n    value: function lessThan(a, b) {\n      return 0 > JSBI.__compareToBigInt(a, b);\n    }\n  }, {\n    key: \"lessThanOrEqual\",\n    value: function lessThanOrEqual(a, b) {\n      return 0 >= JSBI.__compareToBigInt(a, b);\n    }\n  }, {\n    key: \"greaterThan\",\n    value: function greaterThan(a, b) {\n      return 0 < JSBI.__compareToBigInt(a, b);\n    }\n  }, {\n    key: \"greaterThanOrEqual\",\n    value: function greaterThanOrEqual(a, b) {\n      return 0 <= JSBI.__compareToBigInt(a, b);\n    }\n  }, {\n    key: \"equal\",\n    value: function equal(a, b) {\n      if (a.sign !== b.sign) return !1;\n      if (a.length !== b.length) return !1;\n\n      for (var c = 0; c < a.length; c++) {\n        if (a.__digit(c) !== b.__digit(c)) return !1;\n      }\n\n      return !0;\n    }\n  }, {\n    key: \"notEqual\",\n    value: function notEqual(a, b) {\n      return !JSBI.equal(a, b);\n    }\n  }, {\n    key: \"bitwiseAnd\",\n    value: function bitwiseAnd(a, b) {\n      var _ref;\n\n      var c = Math.max;\n      if (!a.sign && !b.sign) return JSBI.__absoluteAnd(a, b).__trim();\n\n      if (a.sign && b.sign) {\n        var d = c(a.length, b.length) + 1;\n\n        var e = JSBI.__absoluteSubOne(a, d);\n\n        var f = JSBI.__absoluteSubOne(b);\n\n        return e = JSBI.__absoluteOr(e, f, e), JSBI.__absoluteAddOne(e, !0, e).__trim();\n      }\n\n      return a.sign && (_ref = [b, a], a = _ref[0], b = _ref[1], _ref), JSBI.__absoluteAndNot(a, JSBI.__absoluteSubOne(b)).__trim();\n    }\n  }, {\n    key: \"bitwiseXor\",\n    value: function bitwiseXor(a, b) {\n      var _ref2;\n\n      var c = Math.max;\n      if (!a.sign && !b.sign) return JSBI.__absoluteXor(a, b).__trim();\n\n      if (a.sign && b.sign) {\n        var _d2 = c(a.length, b.length),\n            _e3 = JSBI.__absoluteSubOne(a, _d2),\n            f = JSBI.__absoluteSubOne(b);\n\n        return JSBI.__absoluteXor(_e3, f, _e3).__trim();\n      }\n\n      var d = c(a.length, b.length) + 1;\n      a.sign && (_ref2 = [b, a], a = _ref2[0], b = _ref2[1], _ref2);\n\n      var e = JSBI.__absoluteSubOne(b, d);\n\n      return e = JSBI.__absoluteXor(e, a, e), JSBI.__absoluteAddOne(e, !0, e).__trim();\n    }\n  }, {\n    key: \"bitwiseOr\",\n    value: function bitwiseOr(a, b) {\n      var _ref3;\n\n      var c = Math.max;\n      var d = c(a.length, b.length);\n      if (!a.sign && !b.sign) return JSBI.__absoluteOr(a, b).__trim();\n\n      if (a.sign && b.sign) {\n        var _c7 = JSBI.__absoluteSubOne(a, d);\n\n        var _e4 = JSBI.__absoluteSubOne(b);\n\n        return _c7 = JSBI.__absoluteAnd(_c7, _e4, _c7), JSBI.__absoluteAddOne(_c7, !0, _c7).__trim();\n      }\n\n      a.sign && (_ref3 = [b, a], a = _ref3[0], b = _ref3[1], _ref3);\n\n      var e = JSBI.__absoluteSubOne(b, d);\n\n      return e = JSBI.__absoluteAndNot(e, a, e), JSBI.__absoluteAddOne(e, !0, e).__trim();\n    }\n  }, {\n    key: \"asIntN\",\n    value: function asIntN(a, b) {\n      if (0 === b.length) return b;\n      if (0 === a) return JSBI.__zero();\n      if (a >= JSBI.__kMaxLengthBits) return b;\n      var c = a + 31 >>> 5;\n      if (b.length < c) return b;\n\n      var d = b.__unsignedDigit(c - 1),\n          e = 1 << (31 & a - 1);\n\n      if (b.length === c && d < e) return b;\n      if (!((d & e) === e)) return JSBI.__truncateToNBits(a, b);\n      if (!b.sign) return JSBI.__truncateAndSubFromPowerOfTwo(a, b, !0);\n\n      if (0 == (d & e - 1)) {\n        for (var _d3 = c - 2; 0 <= _d3; _d3--) {\n          if (0 !== b.__digit(_d3)) return JSBI.__truncateAndSubFromPowerOfTwo(a, b, !1);\n        }\n\n        return b.length === c && d === e ? b : JSBI.__truncateToNBits(a, b);\n      }\n\n      return JSBI.__truncateAndSubFromPowerOfTwo(a, b, !1);\n    }\n  }, {\n    key: \"asUintN\",\n    value: function asUintN(a, b) {\n      if (0 === b.length) return b;\n      if (0 === a) return JSBI.__zero();\n\n      if (b.sign) {\n        if (a > JSBI.__kMaxLengthBits) throw new RangeError(\"BigInt too big\");\n        return JSBI.__truncateAndSubFromPowerOfTwo(a, b, !1);\n      }\n\n      if (a >= JSBI.__kMaxLengthBits) return b;\n      var c = a + 31 >>> 5;\n      if (b.length < c) return b;\n      var d = 31 & a;\n\n      if (b.length == c) {\n        if (0 == d) return b;\n\n        var _a2 = b.__digit(c - 1);\n\n        if (0 == _a2 >>> d) return b;\n      }\n\n      return JSBI.__truncateToNBits(a, b);\n    }\n  }, {\n    key: \"ADD\",\n    value: function ADD(a, b) {\n      if (a = JSBI.__toPrimitive(a), b = JSBI.__toPrimitive(b), \"string\" == typeof a) return \"string\" != typeof b && (b = b.toString()), a + b;\n      if (\"string\" == typeof b) return a.toString() + b;\n      if (a = JSBI.__toNumeric(a), b = JSBI.__toNumeric(b), JSBI.__isBigInt(a) && JSBI.__isBigInt(b)) return JSBI.add(a, b);\n      if (\"number\" == typeof a && \"number\" == typeof b) return a + b;\n      throw new TypeError(\"Cannot mix BigInt and other types, use explicit conversions\");\n    }\n  }, {\n    key: \"LT\",\n    value: function LT(a, b) {\n      return JSBI.__compare(a, b, 0);\n    }\n  }, {\n    key: \"LE\",\n    value: function LE(a, b) {\n      return JSBI.__compare(a, b, 1);\n    }\n  }, {\n    key: \"GT\",\n    value: function GT(a, b) {\n      return JSBI.__compare(a, b, 2);\n    }\n  }, {\n    key: \"GE\",\n    value: function GE(a, b) {\n      return JSBI.__compare(a, b, 3);\n    }\n  }, {\n    key: \"EQ\",\n    value: function EQ(a, b) {\n      for (;;) {\n        if (JSBI.__isBigInt(a)) return JSBI.__isBigInt(b) ? JSBI.equal(a, b) : JSBI.EQ(b, a);\n\n        if (\"number\" == typeof a) {\n          if (JSBI.__isBigInt(b)) return JSBI.__equalToNumber(b, a);\n          if (\"object\" != typeof b) return a == b;\n          b = JSBI.__toPrimitive(b);\n        } else if (\"string\" == typeof a) {\n          if (JSBI.__isBigInt(b)) return a = JSBI.__fromString(a), null !== a && JSBI.equal(a, b);\n          if (\"object\" != typeof b) return a == b;\n          b = JSBI.__toPrimitive(b);\n        } else if (\"boolean\" == typeof a) {\n          if (JSBI.__isBigInt(b)) return JSBI.__equalToNumber(b, +a);\n          if (\"object\" != typeof b) return a == b;\n          b = JSBI.__toPrimitive(b);\n        } else if (\"symbol\" == typeof a) {\n          if (JSBI.__isBigInt(b)) return !1;\n          if (\"object\" != typeof b) return a == b;\n          b = JSBI.__toPrimitive(b);\n        } else if (\"object\" == typeof a) {\n          if (\"object\" == typeof b && b.constructor !== JSBI) return a == b;\n          a = JSBI.__toPrimitive(a);\n        } else return a == b;\n      }\n    }\n  }, {\n    key: \"NE\",\n    value: function NE(a, b) {\n      return !JSBI.EQ(a, b);\n    }\n  }, {\n    key: \"__zero\",\n    value: function __zero() {\n      return new JSBI(0, !1);\n    }\n  }, {\n    key: \"__oneDigit\",\n    value: function __oneDigit(a, b) {\n      var c = new JSBI(1, b);\n      return c.__setDigit(0, a), c;\n    }\n  }, {\n    key: \"__decideRounding\",\n    value: function __decideRounding(a, b, c, d) {\n      if (0 < b) return -1;\n      var e;\n      if (0 > b) e = -b - 1;else {\n        if (0 === c) return -1;\n        c--, d = a.__digit(c), e = 31;\n      }\n      var f = 1 << e;\n      if (0 == (d & f)) return -1;\n      if (f -= 1, 0 != (d & f)) return 1;\n\n      for (; 0 < c;) {\n        if (c--, 0 !== a.__digit(c)) return 1;\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"__fromDouble\",\n    value: function __fromDouble(a) {\n      JSBI.__kBitConversionDouble[0] = a;\n      var b = 2047 & JSBI.__kBitConversionInts[1] >>> 20,\n          c = b - 1023,\n          d = (c >>> 5) + 1,\n          e = new JSBI(d, 0 > a);\n      var f = 1048575 & JSBI.__kBitConversionInts[1] | 1048576,\n          g = JSBI.__kBitConversionInts[0];\n      var h = 20,\n          i = 31 & c;\n      var j,\n          k = 0;\n\n      if (i < 20) {\n        var _a3 = h - i;\n\n        k = _a3 + 32, j = f >>> _a3, f = f << 32 - _a3 | g >>> _a3, g <<= 32 - _a3;\n      } else if (i === 20) k = 32, j = f, f = g;else {\n        var _a4 = i - h;\n\n        k = 32 - _a4, j = f << _a4 | g >>> 32 - _a4, f = g << _a4;\n      }\n\n      e.__setDigit(d - 1, j);\n\n      for (var _b7 = d - 2; 0 <= _b7; _b7--) {\n        0 < k ? (k -= 32, j = f, f = g) : j = 0, e.__setDigit(_b7, j);\n      }\n\n      return e.__trim();\n    }\n  }, {\n    key: \"__isWhitespace\",\n    value: function __isWhitespace(a) {\n      return !!(13 >= a && 9 <= a) || (159 >= a ? 32 == a : 131071 >= a ? 160 == a || 5760 == a : 196607 >= a ? (a &= 131071, 10 >= a || 40 == a || 41 == a || 47 == a || 95 == a || 4096 == a) : 65279 == a);\n    }\n  }, {\n    key: \"__fromString\",\n    value: function __fromString(a) {\n      var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var c = 0;\n      var e = a.length;\n      var f = 0;\n      if (f === e) return JSBI.__zero();\n      var g = a.charCodeAt(f);\n\n      for (; JSBI.__isWhitespace(g);) {\n        if (++f === e) return JSBI.__zero();\n        g = a.charCodeAt(f);\n      }\n\n      if (43 === g) {\n        if (++f === e) return null;\n        g = a.charCodeAt(f), c = 1;\n      } else if (45 === g) {\n        if (++f === e) return null;\n        g = a.charCodeAt(f), c = -1;\n      }\n\n      if (0 === b) {\n        if (b = 10, 48 === g) {\n          if (++f === e) return JSBI.__zero();\n\n          if (g = a.charCodeAt(f), 88 === g || 120 === g) {\n            if (b = 16, ++f === e) return null;\n            g = a.charCodeAt(f);\n          } else if (79 === g || 111 === g) {\n            if (b = 8, ++f === e) return null;\n            g = a.charCodeAt(f);\n          } else if (66 === g || 98 === g) {\n            if (b = 2, ++f === e) return null;\n            g = a.charCodeAt(f);\n          }\n        }\n      } else if (16 === b && 48 === g) {\n        if (++f === e) return JSBI.__zero();\n\n        if (g = a.charCodeAt(f), 88 === g || 120 === g) {\n          if (++f === e) return null;\n          g = a.charCodeAt(f);\n        }\n      }\n\n      for (; 48 === g;) {\n        if (++f === e) return JSBI.__zero();\n        g = a.charCodeAt(f);\n      }\n\n      var h = e - f;\n      var i = JSBI.__kMaxBitsPerChar[b],\n          j = JSBI.__kBitsPerCharTableMultiplier - 1;\n      if (h > 1073741824 / i) return null;\n      var k = i * h + j >>> JSBI.__kBitsPerCharTableShift,\n          l = new JSBI(k + 31 >>> 5, !1),\n          n = 10 > b ? b : 10,\n          o = 10 < b ? b - 10 : 0;\n\n      if (0 == (b & b - 1)) {\n        i >>= JSBI.__kBitsPerCharTableShift;\n        var _b8 = [],\n            _c8 = [];\n        var d = !1;\n\n        do {\n          var _h4 = 0,\n              _j = 0;\n\n          for (;;) {\n            var _b9 = void 0;\n\n            if (g - 48 >>> 0 < n) _b9 = g - 48;else if ((32 | g) - 97 >>> 0 < o) _b9 = (32 | g) - 87;else {\n              d = !0;\n              break;\n            }\n\n            if (_j += i, _h4 = _h4 << i | _b9, ++f === e) {\n              d = !0;\n              break;\n            }\n\n            if (g = a.charCodeAt(f), 32 < _j + i) break;\n          }\n\n          _b8.push(_h4), _c8.push(_j);\n        } while (!d);\n\n        JSBI.__fillFromParts(l, _b8, _c8);\n      } else {\n        l.__initializeDigits();\n\n        var _c9 = !1,\n            _h5 = 0;\n\n        do {\n          var _k = 0,\n              p = 1;\n\n          for (;;) {\n            var _i2 = void 0;\n\n            if (g - 48 >>> 0 < n) _i2 = g - 48;else if ((32 | g) - 97 >>> 0 < o) _i2 = (32 | g) - 87;else {\n              _c9 = !0;\n              break;\n            }\n\n            var _d4 = p * b;\n\n            if (4294967295 < _d4) break;\n\n            if (p = _d4, _k = _k * b + _i2, _h5++, ++f === e) {\n              _c9 = !0;\n              break;\n            }\n\n            g = a.charCodeAt(f);\n          }\n\n          j = 32 * JSBI.__kBitsPerCharTableMultiplier - 1;\n          var q = i * _h5 + j >>> JSBI.__kBitsPerCharTableShift + 5;\n\n          l.__inplaceMultiplyAdd(p, _k, q);\n        } while (!_c9);\n      }\n\n      if (f !== e) {\n        if (!JSBI.__isWhitespace(g)) return null;\n\n        for (f++; f < e; f++) {\n          if (g = a.charCodeAt(f), !JSBI.__isWhitespace(g)) return null;\n        }\n      }\n\n      return 0 != c && 10 !== b ? null : (l.sign = -1 == c, l.__trim());\n    }\n  }, {\n    key: \"__fillFromParts\",\n    value: function __fillFromParts(a, b, c) {\n      var d = 0,\n          e = 0,\n          f = 0;\n\n      for (var g = b.length - 1; 0 <= g; g--) {\n        var h = b[g],\n            i = c[g];\n        e |= h << f, f += i, 32 === f ? (a.__setDigit(d++, e), f = 0, e = 0) : 32 < f && (a.__setDigit(d++, e), f -= 32, e = h >>> i - f);\n      }\n\n      if (0 !== e) {\n        if (d >= a.length) throw new Error(\"implementation bug\");\n\n        a.__setDigit(d++, e);\n      }\n\n      for (; d < a.length; d++) {\n        a.__setDigit(d, 0);\n      }\n    }\n  }, {\n    key: \"__toStringBasePowerOfTwo\",\n    value: function __toStringBasePowerOfTwo(a, b) {\n      var c = Math.clz32;\n      var d = a.length;\n      var e = b - 1;\n      e = (85 & e >>> 1) + (85 & e), e = (51 & e >>> 2) + (51 & e), e = (15 & e >>> 4) + (15 & e);\n\n      var f = e,\n          g = b - 1,\n          h = a.__digit(d - 1),\n          i = c(h);\n\n      var j = 0 | (32 * d - i + f - 1) / f;\n      if (a.sign && j++, 268435456 < j) throw new Error(\"string too long\");\n      var k = Array(j);\n      var l = j - 1,\n          m = 0,\n          n = 0;\n\n      for (var _c10 = 0; _c10 < d - 1; _c10++) {\n        var _b10 = a.__digit(_c10),\n            _d5 = (m | _b10 << n) & g;\n\n        k[l--] = JSBI.__kConversionChars[_d5];\n\n        var _e5 = f - n;\n\n        for (m = _b10 >>> _e5, n = 32 - _e5; n >= f;) {\n          k[l--] = JSBI.__kConversionChars[m & g], m >>>= f, n -= f;\n        }\n      }\n\n      var o = (m | h << n) & g;\n\n      for (k[l--] = JSBI.__kConversionChars[o], m = h >>> f - n; 0 !== m;) {\n        k[l--] = JSBI.__kConversionChars[m & g], m >>>= f;\n      }\n\n      if (a.sign && (k[l--] = \"-\"), -1 != l) throw new Error(\"implementation bug\");\n      return k.join(\"\");\n    }\n  }, {\n    key: \"__toStringGeneric\",\n    value: function __toStringGeneric(a, b, c) {\n      var d = Math.clz32;\n      var e = a.length;\n      if (0 === e) return \"\";\n\n      if (1 === e) {\n        var _d6 = a.__unsignedDigit(0).toString(b);\n\n        return !1 === c && a.sign && (_d6 = \"-\" + _d6), _d6;\n      }\n\n      var f = 32 * e - d(a.__digit(e - 1)),\n          g = JSBI.__kMaxBitsPerChar[b],\n          h = g - 1;\n      var i = f * JSBI.__kBitsPerCharTableMultiplier;\n      i += h - 1, i = 0 | i / h;\n      var j = i + 1 >> 1,\n          k = JSBI.exponentiate(JSBI.__oneDigit(b, !1), JSBI.__oneDigit(j, !1));\n      var l, m;\n\n      var n = k.__unsignedDigit(0);\n\n      if (1 === k.length && 65535 >= n) {\n        l = new JSBI(a.length, !1), l.__initializeDigits();\n        var _c11 = 0;\n\n        for (var _b11 = 2 * a.length - 1; 0 <= _b11; _b11--) {\n          var _d7 = _c11 << 16 | a.__halfDigit(_b11);\n\n          l.__setHalfDigit(_b11, 0 | _d7 / n), _c11 = 0 | _d7 % n;\n        }\n\n        m = _c11.toString(b);\n      } else {\n        var _c12 = JSBI.__absoluteDivLarge(a, k, !0, !0);\n\n        l = _c12.quotient;\n\n        var _d8 = _c12.remainder.__trim();\n\n        m = JSBI.__toStringGeneric(_d8, b, !0);\n      }\n\n      l.__trim();\n\n      var o = JSBI.__toStringGeneric(l, b, !0);\n\n      for (; m.length < j;) {\n        m = \"0\" + m;\n      }\n\n      return !1 === c && a.sign && (o = \"-\" + o), o + m;\n    }\n  }, {\n    key: \"__unequalSign\",\n    value: function __unequalSign(a) {\n      return a ? -1 : 1;\n    }\n  }, {\n    key: \"__absoluteGreater\",\n    value: function __absoluteGreater(a) {\n      return a ? -1 : 1;\n    }\n  }, {\n    key: \"__absoluteLess\",\n    value: function __absoluteLess(a) {\n      return a ? 1 : -1;\n    }\n  }, {\n    key: \"__compareToBigInt\",\n    value: function __compareToBigInt(a, b) {\n      var c = a.sign;\n      if (c !== b.sign) return JSBI.__unequalSign(c);\n\n      var d = JSBI.__absoluteCompare(a, b);\n\n      return 0 < d ? JSBI.__absoluteGreater(c) : 0 > d ? JSBI.__absoluteLess(c) : 0;\n    }\n  }, {\n    key: \"__compareToNumber\",\n    value: function __compareToNumber(a, b) {\n      if (b | !0) {\n        var c = a.sign,\n            d = 0 > b;\n        if (c !== d) return JSBI.__unequalSign(c);\n\n        if (0 === a.length) {\n          if (d) throw new Error(\"implementation bug\");\n          return 0 === b ? 0 : -1;\n        }\n\n        if (1 < a.length) return JSBI.__absoluteGreater(c);\n\n        var e = Math.abs(b),\n            f = a.__unsignedDigit(0);\n\n        return f > e ? JSBI.__absoluteGreater(c) : f < e ? JSBI.__absoluteLess(c) : 0;\n      }\n\n      return JSBI.__compareToDouble(a, b);\n    }\n  }, {\n    key: \"__compareToDouble\",\n    value: function __compareToDouble(a, b) {\n      var c = Math.clz32;\n      if (b !== b) return b;\n      if (b === 1 / 0) return -1;\n      if (b === -Infinity) return 1;\n      var d = a.sign;\n      if (d !== 0 > b) return JSBI.__unequalSign(d);\n      if (0 === b) throw new Error(\"implementation bug: should be handled elsewhere\");\n      if (0 === a.length) return -1;\n      JSBI.__kBitConversionDouble[0] = b;\n      var e = 2047 & JSBI.__kBitConversionInts[1] >>> 20;\n      if (2047 == e) throw new Error(\"implementation bug: handled elsewhere\");\n      var f = e - 1023;\n      if (0 > f) return JSBI.__absoluteGreater(d);\n      var g = a.length;\n\n      var h = a.__digit(g - 1);\n\n      var i = c(h),\n          j = 32 * g - i,\n          k = f + 1;\n      if (j < k) return JSBI.__absoluteLess(d);\n      if (j > k) return JSBI.__absoluteGreater(d);\n      var l = 1048576 | 1048575 & JSBI.__kBitConversionInts[1],\n          m = JSBI.__kBitConversionInts[0];\n      var n = 20,\n          o = 31 - i;\n      if (o !== (j - 1) % 31) throw new Error(\"implementation bug\");\n      var p,\n          q = 0;\n\n      if (20 > o) {\n        var _a5 = n - o;\n\n        q = _a5 + 32, p = l >>> _a5, l = l << 32 - _a5 | m >>> _a5, m <<= 32 - _a5;\n      } else if (20 === o) q = 32, p = l, l = m;else {\n        var _a6 = o - n;\n\n        q = 32 - _a6, p = l << _a6 | m >>> 32 - _a6, l = m << _a6;\n      }\n\n      if (h >>>= 0, p >>>= 0, h > p) return JSBI.__absoluteGreater(d);\n      if (h < p) return JSBI.__absoluteLess(d);\n\n      for (var _c13 = g - 2; 0 <= _c13; _c13--) {\n        0 < q ? (q -= 32, p = l >>> 0, l = m, m = 0) : p = 0;\n\n        var _b12 = a.__unsignedDigit(_c13);\n\n        if (_b12 > p) return JSBI.__absoluteGreater(d);\n        if (_b12 < p) return JSBI.__absoluteLess(d);\n      }\n\n      if (0 !== l || 0 !== m) {\n        if (0 === q) throw new Error(\"implementation bug\");\n        return JSBI.__absoluteLess(d);\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"__equalToNumber\",\n    value: function __equalToNumber(a, b) {\n      var c = Math.abs;\n      return b | 0 === b ? 0 === b ? 0 === a.length : 1 === a.length && a.sign === 0 > b && a.__unsignedDigit(0) === c(b) : 0 === JSBI.__compareToDouble(a, b);\n    }\n  }, {\n    key: \"__comparisonResultToBool\",\n    value: function __comparisonResultToBool(a, b) {\n      switch (b) {\n        case 0:\n          return 0 > a;\n\n        case 1:\n          return 0 >= a;\n\n        case 2:\n          return 0 < a;\n\n        case 3:\n          return 0 <= a;\n      }\n\n      throw new Error(\"unreachable\");\n    }\n  }, {\n    key: \"__compare\",\n    value: function __compare(a, b, c) {\n      if (a = JSBI.__toPrimitive(a), b = JSBI.__toPrimitive(b), \"string\" == typeof a && \"string\" == typeof b) switch (c) {\n        case 0:\n          return a < b;\n\n        case 1:\n          return a <= b;\n\n        case 2:\n          return a > b;\n\n        case 3:\n          return a >= b;\n      }\n      if (JSBI.__isBigInt(a) && \"string\" == typeof b) return b = JSBI.__fromString(b), null !== b && JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(a, b), c);\n      if (\"string\" == typeof a && JSBI.__isBigInt(b)) return a = JSBI.__fromString(a), null !== a && JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(a, b), c);\n\n      if (a = JSBI.__toNumeric(a), b = JSBI.__toNumeric(b), JSBI.__isBigInt(a)) {\n        if (JSBI.__isBigInt(b)) return JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(a, b), c);\n        if (\"number\" != typeof b) throw new Error(\"implementation bug\");\n        return JSBI.__comparisonResultToBool(JSBI.__compareToNumber(a, b), c);\n      }\n\n      if (\"number\" != typeof a) throw new Error(\"implementation bug\");\n      if (JSBI.__isBigInt(b)) return JSBI.__comparisonResultToBool(JSBI.__compareToNumber(b, a), 2 ^ c);\n      if (\"number\" != typeof b) throw new Error(\"implementation bug\");\n      return 0 === c ? a < b : 1 === c ? a <= b : 2 === c ? a > b : 3 === c ? a >= b : void 0;\n    }\n  }, {\n    key: \"__absoluteAdd\",\n    value: function __absoluteAdd(a, b, c) {\n      if (a.length < b.length) return JSBI.__absoluteAdd(b, a, c);\n      if (0 === a.length) return a;\n      if (0 === b.length) return a.sign === c ? a : JSBI.unaryMinus(a);\n      var d = a.length;\n      (0 === a.__clzmsd() || b.length === a.length && 0 === b.__clzmsd()) && d++;\n      var e = new JSBI(d, c);\n      var f = 0,\n          g = 0;\n\n      for (; g < b.length; g++) {\n        var _c14 = b.__digit(g),\n            _d9 = a.__digit(g),\n            h = (65535 & _d9) + (65535 & _c14) + f,\n            i = (_d9 >>> 16) + (_c14 >>> 16) + (h >>> 16);\n\n        f = i >>> 16, e.__setDigit(g, 65535 & h | i << 16);\n      }\n\n      for (; g < a.length; g++) {\n        var _b13 = a.__digit(g),\n            _c15 = (65535 & _b13) + f,\n            _d10 = (_b13 >>> 16) + (_c15 >>> 16);\n\n        f = _d10 >>> 16, e.__setDigit(g, 65535 & _c15 | _d10 << 16);\n      }\n\n      return g < e.length && e.__setDigit(g, f), e.__trim();\n    }\n  }, {\n    key: \"__absoluteSub\",\n    value: function __absoluteSub(a, b, c) {\n      if (0 === a.length) return a;\n      if (0 === b.length) return a.sign === c ? a : JSBI.unaryMinus(a);\n      var d = new JSBI(a.length, c);\n      var e = 0,\n          f = 0;\n\n      for (; f < b.length; f++) {\n        var _c16 = a.__digit(f),\n            g = b.__digit(f),\n            h = (65535 & _c16) - (65535 & g) - e;\n\n        e = 1 & h >>> 16;\n        var i = (_c16 >>> 16) - (g >>> 16) - e;\n        e = 1 & i >>> 16, d.__setDigit(f, 65535 & h | i << 16);\n      }\n\n      for (; f < a.length; f++) {\n        var _b14 = a.__digit(f),\n            _c17 = (65535 & _b14) - e;\n\n        e = 1 & _c17 >>> 16;\n\n        var _g3 = (_b14 >>> 16) - e;\n\n        e = 1 & _g3 >>> 16, d.__setDigit(f, 65535 & _c17 | _g3 << 16);\n      }\n\n      return d.__trim();\n    }\n  }, {\n    key: \"__absoluteAddOne\",\n    value: function __absoluteAddOne(a, b) {\n      var c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var d = a.length;\n      null === c ? c = new JSBI(d, b) : c.sign = b;\n      var e = !0;\n\n      for (var f, g = 0; g < d; g++) {\n        f = a.__digit(g);\n\n        var _b15 = -1 === f;\n\n        e && (f = 0 | f + 1), e = _b15, c.__setDigit(g, f);\n      }\n\n      return e && c.__setDigitGrow(d, 1), c;\n    }\n  }, {\n    key: \"__absoluteSubOne\",\n    value: function __absoluteSubOne(a, b) {\n      var c = a.length;\n      b = b || c;\n      var d = new JSBI(b, !1);\n      var e = !0;\n\n      for (var f, g = 0; g < c; g++) {\n        f = a.__digit(g);\n\n        var _b16 = 0 === f;\n\n        e && (f = 0 | f - 1), e = _b16, d.__setDigit(g, f);\n      }\n\n      for (var _e6 = c; _e6 < b; _e6++) {\n        d.__setDigit(_e6, 0);\n      }\n\n      return d;\n    }\n  }, {\n    key: \"__absoluteAnd\",\n    value: function __absoluteAnd(a, b) {\n      var c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var d = a.length,\n          e = b.length,\n          f = e;\n\n      if (d < e) {\n        f = d;\n        var _c18 = a,\n            _g4 = d;\n        a = b, d = e, b = _c18, e = _g4;\n      }\n\n      var g = f;\n      null === c ? c = new JSBI(g, !1) : g = c.length;\n      var h = 0;\n\n      for (; h < f; h++) {\n        c.__setDigit(h, a.__digit(h) & b.__digit(h));\n      }\n\n      for (; h < g; h++) {\n        c.__setDigit(h, 0);\n      }\n\n      return c;\n    }\n  }, {\n    key: \"__absoluteAndNot\",\n    value: function __absoluteAndNot(a, b) {\n      var c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var d = a.length,\n          e = b.length;\n      var f = e;\n      d < e && (f = d);\n      var g = d;\n      null === c ? c = new JSBI(g, !1) : g = c.length;\n      var h = 0;\n\n      for (; h < f; h++) {\n        c.__setDigit(h, a.__digit(h) & ~b.__digit(h));\n      }\n\n      for (; h < d; h++) {\n        c.__setDigit(h, a.__digit(h));\n      }\n\n      for (; h < g; h++) {\n        c.__setDigit(h, 0);\n      }\n\n      return c;\n    }\n  }, {\n    key: \"__absoluteOr\",\n    value: function __absoluteOr(a, b) {\n      var c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var d = a.length,\n          e = b.length,\n          f = e;\n\n      if (d < e) {\n        f = d;\n        var _c19 = a,\n            _g5 = d;\n        a = b, d = e, b = _c19, e = _g5;\n      }\n\n      var g = d;\n      null === c ? c = new JSBI(g, !1) : g = c.length;\n      var h = 0;\n\n      for (; h < f; h++) {\n        c.__setDigit(h, a.__digit(h) | b.__digit(h));\n      }\n\n      for (; h < d; h++) {\n        c.__setDigit(h, a.__digit(h));\n      }\n\n      for (; h < g; h++) {\n        c.__setDigit(h, 0);\n      }\n\n      return c;\n    }\n  }, {\n    key: \"__absoluteXor\",\n    value: function __absoluteXor(a, b) {\n      var c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var d = a.length,\n          e = b.length,\n          f = e;\n\n      if (d < e) {\n        f = d;\n        var _c20 = a,\n            _g6 = d;\n        a = b, d = e, b = _c20, e = _g6;\n      }\n\n      var g = d;\n      null === c ? c = new JSBI(g, !1) : g = c.length;\n      var h = 0;\n\n      for (; h < f; h++) {\n        c.__setDigit(h, a.__digit(h) ^ b.__digit(h));\n      }\n\n      for (; h < d; h++) {\n        c.__setDigit(h, a.__digit(h));\n      }\n\n      for (; h < g; h++) {\n        c.__setDigit(h, 0);\n      }\n\n      return c;\n    }\n  }, {\n    key: \"__absoluteCompare\",\n    value: function __absoluteCompare(a, b) {\n      var c = a.length - b.length;\n      if (0 != c) return c;\n      var d = a.length - 1;\n\n      for (; 0 <= d && a.__digit(d) === b.__digit(d);) {\n        d--;\n      }\n\n      return 0 > d ? 0 : a.__unsignedDigit(d) > b.__unsignedDigit(d) ? 1 : -1;\n    }\n  }, {\n    key: \"__multiplyAccumulate\",\n    value: function __multiplyAccumulate(a, b, c, d) {\n      var e = Math.imul;\n      if (0 === b) return;\n      var f = 65535 & b,\n          g = b >>> 16;\n      var h = 0,\n          j = 0,\n          k = 0;\n\n      for (var l = 0; l < a.length; l++, d++) {\n        var _b17 = c.__digit(d),\n            i = 65535 & _b17,\n            m = _b17 >>> 16;\n\n        var n = a.__digit(l),\n            o = 65535 & n,\n            p = n >>> 16,\n            q = e(o, f),\n            r = e(o, g),\n            s = e(p, f),\n            t = e(p, g);\n\n        i += j + (65535 & q), m += k + h + (i >>> 16) + (q >>> 16) + (65535 & r) + (65535 & s), h = m >>> 16, j = (r >>> 16) + (s >>> 16) + (65535 & t) + h, h = j >>> 16, j &= 65535, k = t >>> 16, _b17 = 65535 & i | m << 16, c.__setDigit(d, _b17);\n      }\n\n      for (; 0 != h || 0 !== j || 0 !== k; d++) {\n        var _a7 = c.__digit(d);\n\n        var _b18 = (65535 & _a7) + j,\n            _e7 = (_a7 >>> 16) + (_b18 >>> 16) + k + h;\n\n        j = 0, k = 0, h = _e7 >>> 16, _a7 = 65535 & _b18 | _e7 << 16, c.__setDigit(d, _a7);\n      }\n    }\n  }, {\n    key: \"__internalMultiplyAdd\",\n    value: function __internalMultiplyAdd(a, b, c, d, e) {\n      var f = Math.imul;\n      var g = c,\n          h = 0;\n\n      for (var j = 0; j < d; j++) {\n        var _c21 = a.__digit(j),\n            _d11 = f(65535 & _c21, b),\n            i = (65535 & _d11) + h + g;\n\n        g = i >>> 16;\n        var k = f(_c21 >>> 16, b),\n            l = (65535 & k) + (_d11 >>> 16) + g;\n        g = l >>> 16, h = k >>> 16, e.__setDigit(j, l << 16 | 65535 & i);\n      }\n\n      if (e.length > d) for (e.__setDigit(d++, g + h); d < e.length;) {\n        e.__setDigit(d++, 0);\n      } else if (0 !== g + h) throw new Error(\"implementation bug\");\n    }\n  }, {\n    key: \"__absoluteDivSmall\",\n    value: function __absoluteDivSmall(a, b, c) {\n      null === c && (c = new JSBI(a.length, !1));\n      var d = 0;\n\n      for (var e, f = 2 * a.length - 1; 0 <= f; f -= 2) {\n        e = (d << 16 | a.__halfDigit(f)) >>> 0;\n        var g = 0 | e / b;\n        d = 0 | e % b, e = (d << 16 | a.__halfDigit(f - 1)) >>> 0;\n        var h = 0 | e / b;\n        d = 0 | e % b, c.__setDigit(f >>> 1, g << 16 | h);\n      }\n\n      return c;\n    }\n  }, {\n    key: \"__absoluteModSmall\",\n    value: function __absoluteModSmall(a, b) {\n      var c = 0;\n\n      for (var d = 2 * a.length - 1; 0 <= d; d--) {\n        var e = (c << 16 | a.__halfDigit(d)) >>> 0;\n        c = 0 | e % b;\n      }\n\n      return c;\n    }\n  }, {\n    key: \"__absoluteDivLarge\",\n    value: function __absoluteDivLarge(a, b, d, e) {\n      var f = Math.imul;\n\n      var g = b.__halfDigitLength(),\n          h = b.length,\n          c = a.__halfDigitLength() - g;\n\n      var i = null;\n      d && (i = new JSBI(c + 2 >>> 1, !1), i.__initializeDigits());\n      var k = new JSBI(g + 2 >>> 1, !1);\n\n      k.__initializeDigits();\n\n      var l = JSBI.__clz16(b.__halfDigit(g - 1));\n\n      0 < l && (b = JSBI.__specialLeftShift(b, l, 0));\n\n      var m = JSBI.__specialLeftShift(a, l, 1),\n          n = b.__halfDigit(g - 1);\n\n      var o = 0;\n\n      for (var _l, p = c; 0 <= p; p--) {\n        _l = 65535;\n\n        var _a8 = m.__halfDigit(p + g);\n\n        if (_a8 !== n) {\n          var _c22 = (_a8 << 16 | m.__halfDigit(p + g - 1)) >>> 0;\n\n          _l = 0 | _c22 / n;\n\n          var _d12 = 0 | _c22 % n;\n\n          var _e9 = b.__halfDigit(g - 2),\n              _h6 = m.__halfDigit(p + g - 2);\n\n          for (; f(_l, _e9) >>> 0 > (_d12 << 16 | _h6) >>> 0 && (_l--, _d12 += n, !(65535 < _d12));) {\n            ;\n          }\n        }\n\n        JSBI.__internalMultiplyAdd(b, _l, 0, h, k);\n\n        var _e8 = m.__inplaceSub(k, p, g + 1);\n\n        0 !== _e8 && (_e8 = m.__inplaceAdd(b, p, g), m.__setHalfDigit(p + g, m.__halfDigit(p + g) + _e8), _l--), d && (1 & p ? o = _l << 16 : i.__setDigit(p >>> 1, o | _l));\n      }\n\n      return e ? (m.__inplaceRightShift(l), d ? {\n        quotient: i,\n        remainder: m\n      } : m) : d ? i : void 0;\n    }\n  }, {\n    key: \"__clz16\",\n    value: function __clz16(a) {\n      return Math.clz32(a) - 16;\n    }\n  }, {\n    key: \"__specialLeftShift\",\n    value: function __specialLeftShift(a, b, c) {\n      var d = a.length,\n          e = new JSBI(d + c, !1);\n\n      if (0 === b) {\n        for (var _b19 = 0; _b19 < d; _b19++) {\n          e.__setDigit(_b19, a.__digit(_b19));\n        }\n\n        return 0 < c && e.__setDigit(d, 0), e;\n      }\n\n      var f = 0;\n\n      for (var g = 0; g < d; g++) {\n        var _c23 = a.__digit(g);\n\n        e.__setDigit(g, _c23 << b | f), f = _c23 >>> 32 - b;\n      }\n\n      return 0 < c && e.__setDigit(d, f), e;\n    }\n  }, {\n    key: \"__leftShiftByAbsolute\",\n    value: function __leftShiftByAbsolute(a, b) {\n      var c = JSBI.__toShiftAmount(b);\n\n      if (0 > c) throw new RangeError(\"BigInt too big\");\n      var e = c >>> 5,\n          f = 31 & c,\n          g = a.length,\n          h = 0 !== f && 0 != a.__digit(g - 1) >>> 32 - f,\n          j = g + e + (h ? 1 : 0),\n          k = new JSBI(j, a.sign);\n\n      if (0 === f) {\n        var _b20 = 0;\n\n        for (; _b20 < e; _b20++) {\n          k.__setDigit(_b20, 0);\n        }\n\n        for (; _b20 < j; _b20++) {\n          k.__setDigit(_b20, a.__digit(_b20 - e));\n        }\n      } else {\n        var _b21 = 0;\n\n        for (var _a9 = 0; _a9 < e; _a9++) {\n          k.__setDigit(_a9, 0);\n        }\n\n        for (var _c24 = 0; _c24 < g; _c24++) {\n          var _g7 = a.__digit(_c24);\n\n          k.__setDigit(_c24 + e, _g7 << f | _b21), _b21 = _g7 >>> 32 - f;\n        }\n\n        if (h) k.__setDigit(g + e, _b21);else if (0 != _b21) throw new Error(\"implementation bug\");\n      }\n\n      return k.__trim();\n    }\n  }, {\n    key: \"__rightShiftByAbsolute\",\n    value: function __rightShiftByAbsolute(a, b) {\n      var c = a.length,\n          d = a.sign,\n          e = JSBI.__toShiftAmount(b);\n\n      if (0 > e) return JSBI.__rightShiftByMaximum(d);\n      var f = e >>> 5,\n          g = 31 & e;\n      var h = c - f;\n      if (0 >= h) return JSBI.__rightShiftByMaximum(d);\n      var i = !1;\n\n      if (d) {\n        if (0 != (a.__digit(f) & (1 << g) - 1)) i = !0;else for (var _b22 = 0; _b22 < f; _b22++) {\n          if (0 !== a.__digit(_b22)) {\n            i = !0;\n            break;\n          }\n        }\n      }\n\n      if (i && 0 === g) {\n        var _b23 = a.__digit(c - 1);\n\n        0 == ~_b23 && h++;\n      }\n\n      var j = new JSBI(h, d);\n      if (0 === g) for (var _b24 = f; _b24 < c; _b24++) {\n        j.__setDigit(_b24 - f, a.__digit(_b24));\n      } else {\n        var _b25 = a.__digit(f) >>> g;\n\n        var _d13 = c - f - 1;\n\n        for (var _c25 = 0; _c25 < _d13; _c25++) {\n          var _e10 = a.__digit(_c25 + f + 1);\n\n          j.__setDigit(_c25, _e10 << 32 - g | _b25), _b25 = _e10 >>> g;\n        }\n\n        j.__setDigit(_d13, _b25);\n      }\n      return i && (j = JSBI.__absoluteAddOne(j, !0, j)), j.__trim();\n    }\n  }, {\n    key: \"__rightShiftByMaximum\",\n    value: function __rightShiftByMaximum(a) {\n      return a ? JSBI.__oneDigit(1, !0) : JSBI.__zero();\n    }\n  }, {\n    key: \"__toShiftAmount\",\n    value: function __toShiftAmount(a) {\n      if (1 < a.length) return -1;\n\n      var b = a.__unsignedDigit(0);\n\n      return b > JSBI.__kMaxLengthBits ? -1 : b;\n    }\n  }, {\n    key: \"__toPrimitive\",\n    value: function __toPrimitive(a) {\n      var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"default\";\n      if (\"object\" != typeof a) return a;\n      if (a.constructor === JSBI) return a;\n      var c = a[Symbol.toPrimitive];\n\n      if (c) {\n        var _a10 = c(b);\n\n        if (\"object\" != typeof _a10) return _a10;\n        throw new TypeError(\"Cannot convert object to primitive value\");\n      }\n\n      var d = a.valueOf;\n\n      if (d) {\n        var _b26 = d.call(a);\n\n        if (\"object\" != typeof _b26) return _b26;\n      }\n\n      var e = a.toString;\n\n      if (e) {\n        var _b27 = e.call(a);\n\n        if (\"object\" != typeof _b27) return _b27;\n      }\n\n      throw new TypeError(\"Cannot convert object to primitive value\");\n    }\n  }, {\n    key: \"__toNumeric\",\n    value: function __toNumeric(a) {\n      return JSBI.__isBigInt(a) ? a : +a;\n    }\n  }, {\n    key: \"__isBigInt\",\n    value: function __isBigInt(a) {\n      return \"object\" == typeof a && a.constructor === JSBI;\n    }\n  }, {\n    key: \"__truncateToNBits\",\n    value: function __truncateToNBits(a, b) {\n      var c = a + 31 >>> 5,\n          d = new JSBI(c, b.sign),\n          e = c - 1;\n\n      for (var _c26 = 0; _c26 < e; _c26++) {\n        d.__setDigit(_c26, b.__digit(_c26));\n      }\n\n      var f = b.__digit(e);\n\n      if (0 != (31 & a)) {\n        var _b28 = 32 - (31 & a);\n\n        f = f << _b28 >>> _b28;\n      }\n\n      return d.__setDigit(e, f), d.__trim();\n    }\n  }, {\n    key: \"__truncateAndSubFromPowerOfTwo\",\n    value: function __truncateAndSubFromPowerOfTwo(a, b, c) {\n      var d = Math.min;\n      var e = a + 31 >>> 5,\n          f = new JSBI(e, c);\n      var g = 0;\n      var h = e - 1;\n      var j = 0;\n\n      for (var _e11 = d(h, b.length); g < _e11; g++) {\n        var _a11 = b.__digit(g),\n            _c27 = 0 - (65535 & _a11) - j;\n\n        j = 1 & _c27 >>> 16;\n\n        var _d14 = 0 - (_a11 >>> 16) - j;\n\n        j = 1 & _d14 >>> 16, f.__setDigit(g, 65535 & _c27 | _d14 << 16);\n      }\n\n      for (; g < h; g++) {\n        f.__setDigit(g, 0 | -j);\n      }\n\n      var k = h < b.length ? b.__digit(h) : 0;\n      var l = 31 & a;\n      var m;\n\n      if (0 == l) {\n        var _a12 = 0 - (65535 & k) - j;\n\n        j = 1 & _a12 >>> 16;\n\n        var _b29 = 0 - (k >>> 16) - j;\n\n        m = 65535 & _a12 | _b29 << 16;\n      } else {\n        var _a13 = 32 - l;\n\n        k = k << _a13 >>> _a13;\n\n        var _b30 = 1 << 32 - _a13,\n            _c28 = (65535 & _b30) - (65535 & k) - j;\n\n        j = 1 & _c28 >>> 16;\n\n        var _d15 = (_b30 >>> 16) - (k >>> 16) - j;\n\n        m = 65535 & _c28 | _d15 << 16, m &= _b30 - 1;\n      }\n\n      return f.__setDigit(h, m), f.__trim();\n    }\n  }, {\n    key: \"__digitPow\",\n    value: function __digitPow(a, b) {\n      var c = 1;\n\n      for (; 0 < b;) {\n        1 & b && (c *= a), b >>>= 1, a *= a;\n      }\n\n      return c;\n    }\n  }]);\n\n  return JSBI;\n}( /*#__PURE__*/_wrapNativeSuper(Array));\n\nJSBI.__kMaxLength = 33554432, JSBI.__kMaxLengthBits = JSBI.__kMaxLength << 5, JSBI.__kMaxBitsPerChar = [0, 0, 32, 51, 64, 75, 83, 90, 96, 102, 107, 111, 115, 119, 122, 126, 128, 131, 134, 136, 139, 141, 143, 145, 147, 149, 151, 153, 154, 156, 158, 159, 160, 162, 163, 165, 166], JSBI.__kBitsPerCharTableShift = 5, JSBI.__kBitsPerCharTableMultiplier = 1 << JSBI.__kBitsPerCharTableShift, JSBI.__kConversionChars = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"], JSBI.__kBitConversionBuffer = new ArrayBuffer(8), JSBI.__kBitConversionDouble = new Float64Array(JSBI.__kBitConversionBuffer), JSBI.__kBitConversionInts = new Int32Array(JSBI.__kBitConversionBuffer);\n/**\n * Re-maps a number from one range to another.\n *\n * In the example above, the number '25' is converted from a value in the range\n * 0..100 into a value that ranges from the left edge (0) to the right edge\n * (width) of the screen. Numbers outside the range are not clamped to 0 and 1,\n * because out-of-range values are often intentional and useful.\n *\n * From Processing.js\n *\n * @param {Number} value        The incoming value to be converted\n * @param {Number} istart       Lower bound of the value's current range\n * @param {Number} istop        Upper bound of the value's current range\n * @param {Number} ostart       Lower bound of the value's target range\n * @param {Number} ostop        Upper bound of the value's target range\n * @returns {Number}\n */\n\nfunction map(value, istart, istop, ostart, ostop) {\n  return ostart + (ostop - ostart) * ((value - istart) / (istop - istart));\n}\n/**\n * Normalizes a number from another range into a value between 0 and 1.\n *\n * Identical to map(value, low, high, 0, 1)\n * Numbers outside the range are not clamped to 0 and 1, because out-of-range\n * values are often intentional and useful.\n *\n * From Processing.js\n *\n * @param {Number} aNumber    The incoming value to be converted\n * @param {Number} low        Lower bound of the value's current range\n * @param {Number} high       Upper bound of the value's current range\n * @returns {Number}\n */\n\n\nfunction norm(aNumber, low, high) {\n  return (aNumber - low) / (high - low);\n}\n/**\n * Calculates a number between two numbers at a specific increment. The\n * progress parameter is the amount to interpolate between the two values where\n * 0.0 equal to the first point, 0.1 is very near the first point, 0.5 is\n * half-way in between, etc. The lerp function is convenient for creating\n * motion along a straight path and for drawing dotted lines.\n *\n * From Processing.js\n *\n * @param {Number} progress     between 0.0 and 1.0\n * @param {Number} value1       first value\n * @param {Number} value2       second value\n * @returns {Number}\n */\n\n\nfunction lerp(progress, value1, value2) {\n  return (value2 - value1) * progress + value1;\n}\n/**\n * Constrains a value to not exceed a maximum and minimum value.\n *\n * From Processing.js\n *\n * @param {Number} value   the value to constrain\n * @param {Number} value   minimum limit\n * @param {Number} value   maximum limit\n * @returns {Number}\n */\n\n\nfunction clamp(value) {\n  var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  return Math.min(max, Math.max(min, value));\n}\n/**\n * Returns a random integer between min (included) and max (excluded)\n * Note: Using Math.round() would give a non-uniform distribution\n *\n * From Mozilla MDN\n *\n * @param {Number} min    The minimum number (included)\n * @param {Number} max    The maximum number (excluded)\n * @returns {Number}\n */\n\n\nfunction randomInt(min, max) {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min)) + min;\n}\n/**\n * Random number between two values.\n *\n * From Mozilla MDN\n *\n * @param {Number} min The minimum number (included)\n * @param {Number} max The maximum number (excluded)\n * @returns {Number}\n */\n\n\nfunction random() {\n  var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  return Math.floor(Math.random() * (max - min)) + min;\n}\n/**\n * Divide and round two big integers.\n *\n * @param {BigInt|string|number} dividend Integer to be divided + rounded\n * @param {BigInt|string|number} divisor  Divisor\n * @returns {string}\n */\n\n\nfunction divideRoundBigInt(dividend, divisor) {\n  dividend = JSBI.BigInt(String(dividend));\n  divisor = JSBI.BigInt(String(divisor));\n  return JSBI.divide(JSBI.add(dividend, JSBI.divide(divisor, JSBI.BigInt(2))), divisor).toString();\n}\n\nexport { JSBI as J, random as a, clamp as c, divideRoundBigInt as d, lerp as l, map as m, norm as n, randomInt as r };","map":null,"metadata":{},"sourceType":"module"}