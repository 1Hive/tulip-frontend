{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _require = require('buffer'),\n    Buffer = _require.Buffer;\n\nvar webcrypto = require('../webcrypto');\n\nvar randomBytes = require('../random-bytes');\n\nexports.utils = require('./rsa-utils');\n\nexports.generateKey = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(bits) {\n    var pair, keys;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return webcrypto.get().subtle.generateKey({\n              name: 'RSASSA-PKCS1-v1_5',\n              modulusLength: bits,\n              publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n              hash: {\n                name: 'SHA-256'\n              }\n            }, true, ['sign', 'verify']);\n\n          case 2:\n            pair = _context.sent;\n            _context.next = 5;\n            return exportKey(pair);\n\n          case 5:\n            keys = _context.sent;\n            return _context.abrupt(\"return\", {\n              privateKey: keys[0],\n              publicKey: keys[1]\n            });\n\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function (_x) {\n    return _ref.apply(this, arguments);\n  };\n}(); // Takes a jwk key\n\n\nexports.unmarshalPrivateKey = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(key) {\n    var privateKey, pair, keys;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return webcrypto.get().subtle.importKey('jwk', key, {\n              name: 'RSASSA-PKCS1-v1_5',\n              hash: {\n                name: 'SHA-256'\n              }\n            }, true, ['sign']);\n\n          case 2:\n            privateKey = _context2.sent;\n            _context2.t0 = privateKey;\n            _context2.next = 6;\n            return derivePublicFromPrivate(key);\n\n          case 6:\n            _context2.t1 = _context2.sent;\n            pair = [_context2.t0, _context2.t1];\n            _context2.next = 10;\n            return exportKey({\n              privateKey: pair[0],\n              publicKey: pair[1]\n            });\n\n          case 10:\n            keys = _context2.sent;\n            return _context2.abrupt(\"return\", {\n              privateKey: keys[0],\n              publicKey: keys[1]\n            });\n\n          case 12:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function (_x2) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nexports.getRandomValues = randomBytes;\n\nexports.hashAndSign = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(key, msg) {\n    var privateKey, sig;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.next = 2;\n            return webcrypto.get().subtle.importKey('jwk', key, {\n              name: 'RSASSA-PKCS1-v1_5',\n              hash: {\n                name: 'SHA-256'\n              }\n            }, false, ['sign']);\n\n          case 2:\n            privateKey = _context3.sent;\n            _context3.next = 5;\n            return webcrypto.get().subtle.sign({\n              name: 'RSASSA-PKCS1-v1_5'\n            }, privateKey, Uint8Array.from(msg));\n\n          case 5:\n            sig = _context3.sent;\n            return _context3.abrupt(\"return\", Buffer.from(sig));\n\n          case 7:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n\n  return function (_x3, _x4) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nexports.hashAndVerify = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(key, sig, msg) {\n    var publicKey;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            _context4.next = 2;\n            return webcrypto.get().subtle.importKey('jwk', key, {\n              name: 'RSASSA-PKCS1-v1_5',\n              hash: {\n                name: 'SHA-256'\n              }\n            }, false, ['verify']);\n\n          case 2:\n            publicKey = _context4.sent;\n            return _context4.abrupt(\"return\", webcrypto.get().subtle.verify({\n              name: 'RSASSA-PKCS1-v1_5'\n            }, publicKey, sig, msg));\n\n          case 4:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n\n  return function (_x5, _x6, _x7) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\nfunction exportKey(pair) {\n  return Promise.all([webcrypto.get().subtle.exportKey('jwk', pair.privateKey), webcrypto.get().subtle.exportKey('jwk', pair.publicKey)]);\n}\n\nfunction derivePublicFromPrivate(jwKey) {\n  return webcrypto.get().subtle.importKey('jwk', {\n    kty: jwKey.kty,\n    n: jwKey.n,\n    e: jwKey.e\n  }, {\n    name: 'RSASSA-PKCS1-v1_5',\n    hash: {\n      name: 'SHA-256'\n    }\n  }, true, ['verify']);\n}\n/*\n\nRSA encryption/decryption for the browser with webcrypto workarround\n\"bloody dark magic. webcrypto's why.\"\n\nExplanation:\n  - Convert JWK to nodeForge\n  - Convert msg buffer to nodeForge buffer: ByteBuffer is a \"binary-string backed buffer\", so let's make our buffer a binary string\n  - Convert resulting nodeForge buffer to buffer: it returns a binary string, turn that into a uint8array(buffer)\n\n*/\n\n\nvar _require2 = require('./jwk2pem'),\n    jwk2pub = _require2.jwk2pub,\n    jwk2priv = _require2.jwk2priv;\n\nfunction convertKey(key, pub, msg, handle) {\n  var fkey = pub ? jwk2pub(key) : jwk2priv(key);\n  var fmsg = Buffer.from(msg).toString('binary');\n  var fomsg = handle(fmsg, fkey);\n  return Buffer.from(fomsg, 'binary');\n}\n\nexports.encrypt = function (key, msg) {\n  return convertKey(key, true, msg, function (msg, key) {\n    return key.encrypt(msg);\n  });\n};\n\nexports.decrypt = function (key, msg) {\n  return convertKey(key, false, msg, function (msg, key) {\n    return key.decrypt(msg);\n  });\n};","map":null,"metadata":{},"sourceType":"script"}