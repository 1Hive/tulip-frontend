{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _createForOfIteratorHelper = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar debug = require('debug');\n\nvar errcode = require('err-code');\n\nvar log = debug('libp2p:peer-store');\nlog.error = debug('libp2p:peer-store:error');\n\nvar _require = require('./errors'),\n    ERR_INVALID_PARAMETERS = _require.ERR_INVALID_PARAMETERS;\n\nvar Topology = require('libp2p-interfaces/src/topology');\n\nvar _require2 = require('libp2p-interfaces/src/connection'),\n    Connection = _require2.Connection;\n\nvar PeerInfo = require('peer-info');\n/**\n * Responsible for notifying registered protocols of events in the network.\n */\n\n\nvar Registrar = /*#__PURE__*/function () {\n  /**\n   * @param {Object} props\n   * @param {PeerStore} props.peerStore\n   * @constructor\n   */\n  function Registrar(_ref) {\n    var peerStore = _ref.peerStore;\n\n    _classCallCheck(this, Registrar);\n\n    this.peerStore = peerStore;\n    /**\n     * Map of connections per peer\n     * TODO: this should be handled by connectionManager\n     * @type {Map<string, Array<conn>>}\n     */\n\n    this.connections = new Map();\n    /**\n     * Map of topologies\n     *\n     * @type {Map<string, object>}\n     */\n\n    this.topologies = new Map();\n    this._handle = undefined;\n  }\n\n  _createClass(Registrar, [{\n    key: \"handle\",\n    get: function get() {\n      return this._handle;\n    },\n    set: function set(handle) {\n      this._handle = handle;\n    }\n    /**\n     * Cleans up the registrar\n     * @async\n     */\n\n  }, {\n    key: \"close\",\n    value: function () {\n      var _close = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var tasks, _iterator, _step, connectionList, _iterator2, _step2, connection;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                // Close all connections we're tracking\n                tasks = [];\n                _iterator = _createForOfIteratorHelper(this.connections.values());\n\n                try {\n                  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                    connectionList = _step.value;\n                    _iterator2 = _createForOfIteratorHelper(connectionList);\n\n                    try {\n                      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                        connection = _step2.value;\n                        tasks.push(connection.close());\n                      }\n                    } catch (err) {\n                      _iterator2.e(err);\n                    } finally {\n                      _iterator2.f();\n                    }\n                  }\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n\n                _context.next = 5;\n                return tasks;\n\n              case 5:\n                this.connections.clear();\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function close() {\n        return _close.apply(this, arguments);\n      }\n\n      return close;\n    }()\n    /**\n     * Add a new connected peer to the record\n     * TODO: this should live in the ConnectionManager\n     * @param {PeerInfo} peerInfo\n     * @param {Connection} conn\n     * @returns {void}\n     */\n\n  }, {\n    key: \"onConnect\",\n    value: function onConnect(peerInfo, conn) {\n      if (!PeerInfo.isPeerInfo(peerInfo)) {\n        throw errcode(new Error('peerInfo must be an instance of peer-info'), ERR_INVALID_PARAMETERS);\n      }\n\n      if (!Connection.isConnection(conn)) {\n        throw errcode(new Error('conn must be an instance of interface-connection'), ERR_INVALID_PARAMETERS);\n      }\n\n      var id = peerInfo.id.toB58String();\n      var storedConn = this.connections.get(id);\n\n      if (storedConn) {\n        storedConn.push(conn);\n      } else {\n        this.connections.set(id, [conn]);\n      }\n    }\n    /**\n     * Remove a disconnected peer from the record\n     * TODO: this should live in the ConnectionManager\n     * @param {PeerInfo} peerInfo\n     * @param {Connection} connection\n     * @param {Error} [error]\n     * @returns {void}\n     */\n\n  }, {\n    key: \"onDisconnect\",\n    value: function onDisconnect(peerInfo, connection, error) {\n      if (!PeerInfo.isPeerInfo(peerInfo)) {\n        throw errcode(new Error('peerInfo must be an instance of peer-info'), ERR_INVALID_PARAMETERS);\n      }\n\n      var id = peerInfo.id.toB58String();\n      var storedConn = this.connections.get(id);\n\n      if (storedConn && storedConn.length > 1) {\n        storedConn = storedConn.filter(function (conn) {\n          return conn.id !== connection.id;\n        });\n        this.connections.set(id, storedConn);\n      } else if (storedConn) {\n        var _iterator3 = _createForOfIteratorHelper(this.topologies),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var _step3$value = _slicedToArray(_step3.value, 2),\n                topology = _step3$value[1];\n\n            topology.disconnect(peerInfo, error);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n\n        this.connections.delete(peerInfo.id.toB58String());\n      }\n    }\n    /**\n     * Get a connection with a peer.\n     * @param {PeerInfo} peerInfo\n     * @returns {Connection}\n     */\n\n  }, {\n    key: \"getConnection\",\n    value: function getConnection(peerInfo) {\n      if (!PeerInfo.isPeerInfo(peerInfo)) {\n        throw errcode(new Error('peerInfo must be an instance of peer-info'), ERR_INVALID_PARAMETERS);\n      }\n\n      var connections = this.connections.get(peerInfo.id.toB58String()); // Return the first, open connection\n\n      if (connections) {\n        return connections.find(function (connection) {\n          return connection.stat.status === 'open';\n        });\n      }\n\n      return null;\n    }\n    /**\n     * Register handlers for a set of multicodecs given\n     * @param {Topology} topology protocol topology\n     * @return {string} registrar identifier\n     */\n\n  }, {\n    key: \"register\",\n    value: function register(topology) {\n      if (!Topology.isTopology(topology)) {\n        throw errcode(new Error('topology must be an instance of interfaces/topology'), ERR_INVALID_PARAMETERS);\n      } // Create topology\n\n\n      var id = parseInt(Math.random() * 1e9).toString(36) + Date.now();\n      this.topologies.set(id, topology); // Set registrar\n\n      topology.registrar = this;\n      return id;\n    }\n    /**\n     * Unregister topology.\n     * @param {string} id registrar identifier\n     * @return {boolean} unregistered successfully\n     */\n\n  }, {\n    key: \"unregister\",\n    value: function unregister(id) {\n      return this.topologies.delete(id);\n    }\n  }]);\n\n  return Registrar;\n}();\n\nmodule.exports = Registrar;","map":null,"metadata":{},"sourceType":"script"}