{"ast":null,"code":"'use strict';\n\nconst WantManager = require('./want-manager');\n\nconst Network = require('./network');\n\nconst DecisionEngine = require('./decision-engine');\n\nconst Notifications = require('./notifications');\n\nconst logger = require('./utils').logger;\n\nconst Stats = require('./stats');\n\nconst AbortController = require('abort-controller');\n\nconst anySignal = require('any-signal');\n\nconst defaultOptions = {\n  statsEnabled: false,\n  statsComputeThrottleTimeout: 1000,\n  statsComputeThrottleMaxQueueSize: 1000\n};\nconst statsKeys = ['blocksReceived', 'dataReceived', 'dupBlksReceived', 'dupDataReceived', 'blocksSent', 'dataSent', 'providesBufferLength', 'wantListLength', 'peerCount'];\n/**\n * JavaScript implementation of the Bitswap 'data exchange' protocol\n * used by IPFS.\n *\n * @param {Libp2p} libp2p\n * @param {Blockstore} blockstore\n * @param {Object} options\n */\n\nclass Bitswap {\n  constructor(libp2p, blockstore, options) {\n    this._libp2p = libp2p;\n    this._log = logger(this.peerInfo.id);\n    this._options = Object.assign({}, defaultOptions, options); // stats\n\n    this._stats = new Stats(statsKeys, {\n      enabled: this._options.statsEnabled,\n      computeThrottleTimeout: this._options.statsComputeThrottleTimeout,\n      computeThrottleMaxQueueSize: this._options.statsComputeThrottleMaxQueueSize\n    }); // the network delivers messages\n\n    this.network = new Network(libp2p, this, {}, this._stats); // local database\n\n    this.blockstore = blockstore;\n    this.engine = new DecisionEngine(this.peerInfo.id, blockstore, this.network, this._stats); // handle message sending\n\n    this.wm = new WantManager(this.peerInfo.id, this.network, this._stats);\n    this.notifications = new Notifications(this.peerInfo.id);\n  }\n\n  get peerInfo() {\n    return this._libp2p.peerInfo;\n  } // handle messages received through the network\n\n\n  async _receiveMessage(peerId, incoming) {\n    try {\n      // Note: this allows the engine to respond to any wants in the message.\n      // Processing of the blocks in the message happens below, after the\n      // blocks have been added to the blockstore.\n      await this.engine.messageReceived(peerId, incoming);\n    } catch (err) {\n      // Log instead of throwing an error so as to process as much as\n      // possible of the message. Currently `messageReceived` does not\n      // throw any errors, but this could change in the future.\n      this._log('failed to receive message', incoming);\n    }\n\n    if (incoming.blocks.size === 0) {\n      return;\n    }\n\n    const blocks = Array.from(incoming.blocks.values()); // quickly send out cancels, reduces chances of duplicate block receives\n\n    const wanted = blocks.filter(b => this.wm.wantlist.contains(b.cid)).map(b => b.cid);\n    this.wm.cancelWants(wanted);\n    await Promise.all(blocks.map(async b => {\n      const wasWanted = wanted.includes(b.cid);\n      await this._handleReceivedBlock(peerId, b, wasWanted);\n    }));\n  }\n\n  async _handleReceivedBlock(peerId, block, wasWanted) {\n    this._log('received block');\n\n    const has = await this.blockstore.has(block.cid);\n\n    this._updateReceiveCounters(peerId.toB58String(), block, has);\n\n    if (!wasWanted) {\n      return;\n    }\n\n    await this.put(block);\n  }\n\n  _updateReceiveCounters(peerId, block, exists) {\n    this._stats.push(peerId, 'blocksReceived', 1);\n\n    this._stats.push(peerId, 'dataReceived', block.data.length);\n\n    if (exists) {\n      this._stats.push(peerId, 'dupBlksReceived', 1);\n\n      this._stats.push(peerId, 'dupDataReceived', block.data.length);\n    }\n  } // handle errors on the receiving channel\n\n\n  _receiveError(err) {\n    this._log.error('ReceiveError: %s', err.message);\n  } // handle new peers\n\n\n  _onPeerConnected(peerId) {\n    this.wm.connected(peerId);\n  } // handle peers being disconnected\n\n\n  _onPeerDisconnected(peerId) {\n    this.wm.disconnected(peerId);\n    this.engine.peerDisconnected(peerId);\n\n    this._stats.disconnected(peerId);\n  }\n  /**\n   * @returns {void}\n   */\n\n\n  enableStats() {\n    this._stats.enable();\n  }\n  /**\n   * @returns {void}\n   */\n\n\n  disableStats() {\n    this._stats.disable();\n  }\n  /**\n   * Return the current wantlist for a given `peerId`\n   *\n   * @param {PeerId} peerId\n   * @returns {Map}\n   */\n\n\n  wantlistForPeer(peerId) {\n    return this.engine.wantlistForPeer(peerId);\n  }\n  /**\n   * Return ledger information for a given `peerId`\n   *\n   * @param {PeerId} peerId\n   * @returns {Object}\n   */\n\n\n  ledgerForPeer(peerId) {\n    return this.engine.ledgerForPeer(peerId);\n  }\n  /**\n   * Fetch a given block by cid. If the block is in the local\n   * blockstore it is returned, otherwise the block is added to the wantlist and returned once another node sends it to us.\n   *\n   * @param {CID} cid\n   * @param {Object} options\n   * @param {AbortSignal} options.abortSignal\n   * @returns {Promise<Block>}\n   */\n\n\n  async get(cid, options = {}) {\n    const fetchFromNetwork = (cid, options) => {\n      // add it to the want list - n.b. later we will abort the AbortSignal\n      // so no need to remove the blocks from the wantlist after we have it\n      this.wm.wantBlocks([cid], options);\n      return this.notifications.wantBlock(cid, options);\n    };\n\n    let promptedNetwork = false;\n\n    const loadOrFetchFromNetwork = async (cid, options) => {\n      try {\n        // have to await here as we want to handle ERR_NOT_FOUND\n        const block = await this.blockstore.get(cid, options);\n        return block;\n      } catch (err) {\n        if (err.code !== 'ERR_NOT_FOUND') {\n          throw err;\n        }\n\n        if (!promptedNetwork) {\n          promptedNetwork = true;\n          this.network.findAndConnect(cid).catch(err => this._log.error(err));\n        } // we don't have the block locally so fetch it from the network\n\n\n        return fetchFromNetwork(cid, options);\n      }\n    }; // depending on implementation it's possible for blocks to come in while\n    // we do the async operations to get them from the blockstore leading to\n    // a race condition, so register for incoming block notifications as well\n    // as trying to get it from the datastore\n\n\n    const controller = new AbortController();\n    const signal = anySignal([options.signal, controller.signal]);\n    const block = await Promise.race([this.notifications.wantBlock(cid, {\n      signal\n    }), loadOrFetchFromNetwork(cid, {\n      signal\n    })]); // since we have the block we can now remove our listener\n\n    controller.abort();\n    return block;\n  }\n  /**\n   * Fetch a a list of blocks by cid. If the blocks are in the local\n   * blockstore they are returned, otherwise the blocks are added to the wantlist and returned once another node sends them to us.\n   *\n   * @param {AsyncIterator<CID>} cids\n   * @param {Object} options\n   * @param {AbortSignal} options.abortSignal\n   * @returns {Promise<AsyncIterator<Block>>}\n   */\n\n\n  async *getMany(cids, options = {}) {\n    for await (const cid of cids) {\n      yield this.get(cid, options);\n    }\n  }\n  /**\n   * Removes the given CIDs from the wantlist independent of any ref counts.\n   *\n   * This will cause all outstanding promises for a given block to reject.\n   *\n   * If you want to cancel the want for a block without doing that, pass an\n   * AbortSignal in to `.get` or `.getMany` and abort it.\n   *\n   * @param {Iterable<CID>} cids\n   * @returns {void}\n   */\n\n\n  unwant(cids) {\n    if (!Array.isArray(cids)) {\n      cids = [cids];\n    }\n\n    this.wm.unwantBlocks(cids);\n    cids.forEach(cid => this.notifications.unwantBlock(cid));\n  }\n  /**\n   * Removes the given keys from the want list. This may cause pending promises\n   * for blocks to never resolve.  If you wish these promises to abort instead\n   * call `unwant(cids)` instead.\n   *\n   * @param {Iterable<CID>} cids\n   * @returns {void}\n   */\n\n\n  cancelWants(cids) {\n    if (!Array.isArray(cids)) {\n      cids = [cids];\n    }\n\n    this.wm.cancelWants(cids);\n  }\n  /**\n   * Put the given block to the underlying blockstore and\n   * send it to nodes that have it in their wantlist.\n   *\n   * @param {Block} block\n   * @returns {Promise<void>}\n   */\n\n\n  async put(block) {\n    await this.blockstore.put(block);\n\n    this._sendHaveBlockNotifications(block);\n  }\n  /**\n   * Put the given blocks to the underlying blockstore and\n   * send it to nodes that have it them their wantlist.\n   *\n   * @param {AsyncIterable<Block>} blocks\n   * @returns {AsyncIterable<Block>}\n   */\n\n\n  async *putMany(blocks) {\n    for await (const block of this.blockstore.putMany(blocks)) {\n      this._sendHaveBlockNotifications(block);\n\n      yield block;\n    }\n  }\n  /**\n   * Sends notifications about the arrival of a block\n   *\n   * @param {Block} block\n   */\n\n\n  _sendHaveBlockNotifications(block) {\n    this.notifications.hasBlock(block);\n    this.engine.receivedBlocks([block]); // Note: Don't wait for provide to finish before returning\n\n    this.network.provide(block.cid).catch(err => {\n      this._log.error('Failed to provide: %s', err.message);\n    });\n  }\n  /**\n   * Get the current list of wants.\n   *\n   * @returns {Iterator<WantlistEntry>}\n   */\n\n\n  getWantlist() {\n    return this.wm.wantlist.entries();\n  }\n  /**\n   * Get the current list of partners.\n   *\n   * @returns {Iterator<PeerId>}\n   */\n\n\n  peers() {\n    return this.engine.peers();\n  }\n  /**\n   * Get stats about the bitswap node.\n   *\n   * @returns {Object}\n   */\n\n\n  stat() {\n    return this._stats;\n  }\n  /**\n   * Start the bitswap node.\n   *\n   * @returns {void}\n   */\n\n\n  start() {\n    this.wm.start();\n    this.network.start();\n    this.engine.start();\n  }\n  /**\n   * Stop the bitswap node.\n   *\n   * @returns {void}\n   */\n\n\n  stop() {\n    this._stats.stop();\n\n    this.wm.stop();\n    this.network.stop();\n    this.engine.stop();\n  }\n\n}\n\nmodule.exports = Bitswap;","map":null,"metadata":{},"sourceType":"script"}