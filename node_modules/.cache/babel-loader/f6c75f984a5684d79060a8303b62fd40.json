{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar PeerId = require('peer-id');\n\nvar _require = require('interface-datastore'),\n    Key = _require.Key,\n    Errors = _require.Errors;\n\nvar errcode = require('err-code');\n\nvar debug = require('debug');\n\nvar log = debug('ipfs:ipns:publisher');\nlog.error = debug('ipfs:ipns:publisher:error');\n\nvar ipns = require('ipns');\n\nvar ERR_NOT_FOUND = Errors.notFoundError().code;\nvar defaultRecordLifetime = 60 * 60 * 1000; // IpnsPublisher is capable of publishing and resolving names to the IPFS routing system.\n\nvar IpnsPublisher = /*#__PURE__*/function () {\n  function IpnsPublisher(routing, datastore) {\n    _classCallCheck(this, IpnsPublisher);\n\n    this._routing = routing;\n    this._datastore = datastore;\n  } // publish record with a eol\n\n\n  _createClass(IpnsPublisher, [{\n    key: \"publishWithEOL\",\n    value: function () {\n      var _publishWithEOL = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(privKey, value, lifetime) {\n        var peerId, record;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(!privKey || !privKey.bytes)) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw errcode(new Error('invalid private key'), 'ERR_INVALID_PRIVATE_KEY');\n\n              case 2:\n                _context.next = 4;\n                return PeerId.createFromPrivKey(privKey.bytes);\n\n              case 4:\n                peerId = _context.sent;\n                _context.next = 7;\n                return this._updateOrCreateRecord(privKey, value, lifetime, peerId);\n\n              case 7:\n                record = _context.sent;\n                return _context.abrupt(\"return\", this._putRecordToRouting(record, peerId));\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function publishWithEOL(_x, _x2, _x3) {\n        return _publishWithEOL.apply(this, arguments);\n      }\n\n      return publishWithEOL;\n    }() // Accepts a keypair, as well as a value (ipfsPath), and publishes it out to the routing system\n\n  }, {\n    key: \"publish\",\n    value: function () {\n      var _publish = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(privKey, value) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                return _context2.abrupt(\"return\", this.publishWithEOL(privKey, value, defaultRecordLifetime));\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function publish(_x4, _x5) {\n        return _publish.apply(this, arguments);\n      }\n\n      return publish;\n    }()\n  }, {\n    key: \"_putRecordToRouting\",\n    value: function () {\n      var _putRecordToRouting2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(record, peerId) {\n        var errMsg, publicKey, embedPublicKeyRecord, keys;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (PeerId.isPeerId(peerId)) {\n                  _context3.next = 4;\n                  break;\n                }\n\n                errMsg = 'peerId received is not valid';\n                log.error(errMsg);\n                throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID');\n\n              case 4:\n                publicKey = peerId._pubKey;\n                _context3.next = 7;\n                return ipns.embedPublicKey(publicKey, record);\n\n              case 7:\n                embedPublicKeyRecord = _context3.sent;\n                keys = ipns.getIdKeys(peerId.toBytes());\n                _context3.next = 11;\n                return this._publishEntry(keys.routingKey, embedPublicKeyRecord || record, peerId);\n\n              case 11:\n                _context3.next = 13;\n                return this._publishPublicKey(keys.routingPubKey, publicKey);\n\n              case 13:\n                return _context3.abrupt(\"return\", embedPublicKeyRecord || record);\n\n              case 14:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function _putRecordToRouting(_x6, _x7) {\n        return _putRecordToRouting2.apply(this, arguments);\n      }\n\n      return _putRecordToRouting;\n    }()\n  }, {\n    key: \"_publishEntry\",\n    value: function () {\n      var _publishEntry2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(key, entry) {\n        var errMsg, entryData, res, _errMsg;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (Key.isKey(key)) {\n                  _context4.next = 4;\n                  break;\n                }\n\n                errMsg = 'datastore key does not have a valid format';\n                log.error(errMsg);\n                throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY');\n\n              case 4:\n                _context4.prev = 4;\n                // Marshal record\n                entryData = ipns.marshal(entry);\n                _context4.next = 12;\n                break;\n\n              case 8:\n                _context4.prev = 8;\n                _context4.t0 = _context4[\"catch\"](4);\n                log.error(_context4.t0);\n                throw _context4.t0;\n\n              case 12:\n                _context4.prev = 12;\n                _context4.next = 15;\n                return this._routing.put(key.toBuffer(), entryData);\n\n              case 15:\n                res = _context4.sent;\n                log(\"ipns record for \".concat(key.toString('base64'), \" was stored in the routing\"));\n                return _context4.abrupt(\"return\", res);\n\n              case 20:\n                _context4.prev = 20;\n                _context4.t1 = _context4[\"catch\"](12);\n                _errMsg = \"ipns record for \".concat(key.toString('base64'), \" could not be stored in the routing\");\n                log.error(_errMsg);\n                log.error(_context4.t1);\n                throw errcode(new Error(_errMsg), 'ERR_PUTTING_TO_ROUTING');\n\n              case 26:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[4, 8], [12, 20]]);\n      }));\n\n      function _publishEntry(_x8, _x9) {\n        return _publishEntry2.apply(this, arguments);\n      }\n\n      return _publishEntry;\n    }()\n  }, {\n    key: \"_publishPublicKey\",\n    value: function () {\n      var _publishPublicKey2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(key, publicKey) {\n        var errMsg, _errMsg2, res, _errMsg3;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (Key.isKey(key)) {\n                  _context5.next = 4;\n                  break;\n                }\n\n                errMsg = 'datastore key does not have a valid format';\n                log.error(errMsg);\n                throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY');\n\n              case 4:\n                if (!(!publicKey || !publicKey.bytes)) {\n                  _context5.next = 8;\n                  break;\n                }\n\n                _errMsg2 = 'one or more of the provided parameters are not defined';\n                log.error(_errMsg2);\n                throw errcode(new Error(_errMsg2), 'ERR_UNDEFINED_PARAMETER');\n\n              case 8:\n                _context5.prev = 8;\n                _context5.next = 11;\n                return this._routing.put(key.toBuffer(), publicKey.bytes);\n\n              case 11:\n                res = _context5.sent;\n                log(\"public key for \".concat(key.toString('base64'), \" was stored in the routing\"));\n                return _context5.abrupt(\"return\", res);\n\n              case 16:\n                _context5.prev = 16;\n                _context5.t0 = _context5[\"catch\"](8);\n                _errMsg3 = \"public key for \".concat(key.toString('base64'), \" could not be stored in the routing\");\n                log.error(_errMsg3);\n                log.error(_context5.t0);\n                throw errcode(new Error(_errMsg3), 'ERR_PUTTING_TO_ROUTING');\n\n              case 22:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[8, 16]]);\n      }));\n\n      function _publishPublicKey(_x10, _x11) {\n        return _publishPublicKey2.apply(this, arguments);\n      }\n\n      return _publishPublicKey;\n    }() // Returns the record this node has published corresponding to the given peer ID.\n    // If `checkRouting` is true and we have no existing record, this method will check the routing system for any existing records.\n\n  }, {\n    key: \"_getPublished\",\n    value: function () {\n      var _getPublished2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(peerId, options) {\n        var errMsg, checkRouting, dsVal, _errMsg4, keys, res;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (PeerId.isPeerId(peerId)) {\n                  _context6.next = 4;\n                  break;\n                }\n\n                errMsg = 'peerId received is not valid';\n                log.error(errMsg);\n                throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID');\n\n              case 4:\n                options = options || {};\n                checkRouting = options.checkRouting !== false;\n                _context6.prev = 6;\n                _context6.next = 9;\n                return this._datastore.get(ipns.getLocalKey(peerId.id));\n\n              case 9:\n                dsVal = _context6.sent;\n                return _context6.abrupt(\"return\", this._unmarshalData(dsVal));\n\n              case 13:\n                _context6.prev = 13;\n                _context6.t0 = _context6[\"catch\"](6);\n\n                if (!(_context6.t0.code !== ERR_NOT_FOUND)) {\n                  _context6.next = 19;\n                  break;\n                }\n\n                _errMsg4 = \"unexpected error getting the ipns record \".concat(peerId.id, \" from datastore\");\n                log.error(_errMsg4);\n                throw errcode(new Error(_errMsg4), 'ERR_UNEXPECTED_DATASTORE_RESPONSE');\n\n              case 19:\n                if (checkRouting) {\n                  _context6.next = 21;\n                  break;\n                }\n\n                throw errcode(_context6.t0);\n\n              case 21:\n                _context6.prev = 21;\n                keys = ipns.getIdKeys(peerId.toBytes());\n                _context6.next = 25;\n                return this._routing.get(keys.routingKey.toBuffer());\n\n              case 25:\n                res = _context6.sent;\n                return _context6.abrupt(\"return\", this._unmarshalData(res));\n\n              case 29:\n                _context6.prev = 29;\n                _context6.t1 = _context6[\"catch\"](21);\n                log.error(_context6.t1);\n                throw _context6.t1;\n\n              case 33:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this, [[6, 13], [21, 29]]);\n      }));\n\n      function _getPublished(_x12, _x13) {\n        return _getPublished2.apply(this, arguments);\n      }\n\n      return _getPublished;\n    }()\n  }, {\n    key: \"_unmarshalData\",\n    value: function _unmarshalData(data) {\n      try {\n        return ipns.unmarshal(data);\n      } catch (err) {\n        throw errcode(err, 'ERR_INVALID_RECORD_DATA');\n      }\n    }\n  }, {\n    key: \"_updateOrCreateRecord\",\n    value: function () {\n      var _updateOrCreateRecord2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(privKey, value, validity, peerId) {\n        var errMsg, getPublishedOptions, record, _errMsg5, seqNumber, entryData, _errMsg6, data, _errMsg7;\n\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (PeerId.isPeerId(peerId)) {\n                  _context7.next = 4;\n                  break;\n                }\n\n                errMsg = 'peerId received is not valid';\n                log.error(errMsg);\n                throw errcode(new Error(errMsg), 'ERR_INVALID_PEER_ID');\n\n              case 4:\n                getPublishedOptions = {\n                  checkRouting: true\n                };\n                _context7.prev = 5;\n                _context7.next = 8;\n                return this._getPublished(peerId, getPublishedOptions);\n\n              case 8:\n                record = _context7.sent;\n                _context7.next = 17;\n                break;\n\n              case 11:\n                _context7.prev = 11;\n                _context7.t0 = _context7[\"catch\"](5);\n\n                if (!(_context7.t0.code !== ERR_NOT_FOUND)) {\n                  _context7.next = 17;\n                  break;\n                }\n\n                _errMsg5 = \"unexpected error when determining the last published IPNS record for \".concat(peerId.id);\n                log.error(_errMsg5);\n                throw errcode(new Error(_errMsg5), 'ERR_DETERMINING_PUBLISHED_RECORD');\n\n              case 17:\n                // Determinate the record sequence number\n                seqNumber = 0;\n\n                if (record && record.sequence !== undefined) {\n                  seqNumber = record.value.toString() !== value ? record.sequence + 1 : record.sequence;\n                }\n\n                _context7.prev = 19;\n                _context7.next = 22;\n                return ipns.create(privKey, value, seqNumber, validity);\n\n              case 22:\n                entryData = _context7.sent;\n                _context7.next = 30;\n                break;\n\n              case 25:\n                _context7.prev = 25;\n                _context7.t1 = _context7[\"catch\"](19);\n                _errMsg6 = \"ipns record for \".concat(value, \" could not be created\");\n                log.error(_context7.t1);\n                throw errcode(new Error(_errMsg6), 'ERR_CREATING_IPNS_RECORD');\n\n              case 30:\n                _context7.prev = 30;\n                // Marshal record\n                data = ipns.marshal(entryData); // Store the new record\n\n                _context7.next = 34;\n                return this._datastore.put(ipns.getLocalKey(peerId.id), data);\n\n              case 34:\n                log(\"ipns record for \".concat(value, \" was stored in the datastore\"));\n                return _context7.abrupt(\"return\", entryData);\n\n              case 38:\n                _context7.prev = 38;\n                _context7.t2 = _context7[\"catch\"](30);\n                _errMsg7 = \"ipns record for \".concat(value, \" could not be stored in the datastore\");\n                log.error(_errMsg7);\n                throw errcode(new Error(_errMsg7), 'ERR_STORING_IN_DATASTORE');\n\n              case 43:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this, [[5, 11], [19, 25], [30, 38]]);\n      }));\n\n      function _updateOrCreateRecord(_x14, _x15, _x16, _x17) {\n        return _updateOrCreateRecord2.apply(this, arguments);\n      }\n\n      return _updateOrCreateRecord;\n    }()\n  }]);\n\n  return IpnsPublisher;\n}();\n\nIpnsPublisher.defaultRecordLifetime = defaultRecordLifetime;\nexports = module.exports = IpnsPublisher;","map":null,"metadata":{},"sourceType":"script"}