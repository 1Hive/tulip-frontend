{"ast":null,"code":"function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport x25519 from 'bcrypto/lib/js/x25519';\nimport { Buffer } from \"buffer\";\nimport Wrap from 'it-pb-rpc';\nimport DuplexPair from 'it-pair/duplex';\nimport ensureBuffer from 'it-buffer';\nimport pipe from 'it-pipe';\nimport { encode, decode } from 'it-length-prefixed';\nimport { XXHandshake } from \"./handshake-xx\";\nimport { IKHandshake } from \"./handshake-ik\";\nimport { XXFallbackHandshake } from \"./handshake-xx-fallback\";\nimport { generateKeypair, getPayload } from \"./utils\";\nimport { uint16BEDecode, uint16BEEncode } from \"./encoder\";\nimport { decryptStream, encryptStream } from \"./crypto\";\nimport { KeyCache } from \"./keycache\";\nimport { logger } from \"./logger\";\nimport { NOISE_MSG_MAX_LENGTH_BYTES } from \"./constants\";\nexport class Noise {\n  /**\n   *\n   * @param staticNoiseKey x25519 private key, reuse for faster handshakes\n   * @param earlyData\n   */\n  constructor(staticNoiseKey, earlyData) {\n    _defineProperty(this, \"protocol\", \"/noise\");\n\n    _defineProperty(this, \"prologue\", Buffer.alloc(0));\n\n    _defineProperty(this, \"staticKeys\", void 0);\n\n    _defineProperty(this, \"earlyData\", void 0);\n\n    _defineProperty(this, \"useNoisePipes\", void 0);\n\n    this.earlyData = earlyData || Buffer.alloc(0); //disabled until properly specked\n\n    this.useNoisePipes = false;\n\n    if (staticNoiseKey) {\n      const publicKey = x25519.publicKeyCreate(staticNoiseKey);\n      this.staticKeys = {\n        privateKey: staticNoiseKey,\n        publicKey\n      };\n    } else {\n      this.staticKeys = generateKeypair();\n    }\n  }\n  /**\n   * Encrypt outgoing data to the remote party (handshake as initiator)\n   * @param {PeerId} localPeer - PeerId of the receiving peer\n   * @param connection - streaming iterable duplex that will be encrypted\n   * @param {PeerId} remotePeer - PeerId of the remote peer. Used to validate the integrity of the remote peer.\n   * @returns {Promise<SecureOutbound>}\n   */\n\n\n  async secureOutbound(localPeer, connection, remotePeer) {\n    const wrappedConnection = Wrap(connection, {\n      lengthEncoder: uint16BEEncode,\n      lengthDecoder: uint16BEDecode,\n      maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES\n    });\n    const handshake = await this.performHandshake({\n      connection: wrappedConnection,\n      isInitiator: true,\n      localPeer,\n      remotePeer\n    });\n    const conn = await this.createSecureConnection(wrappedConnection, handshake);\n    return {\n      conn,\n      remoteEarlyData: handshake.remoteEarlyData,\n      remotePeer: handshake.remotePeer\n    };\n  }\n  /**\n   * Decrypt incoming data (handshake as responder).\n   * @param {PeerId} localPeer - PeerId of the receiving peer.\n   * @param connection - streaming iterable duplex that will be encryption.\n   * @param {PeerId} remotePeer - optional PeerId of the initiating peer, if known. This may only exist during transport upgrades.\n   * @returns {Promise<SecureOutbound>}\n   */\n\n\n  async secureInbound(localPeer, connection, remotePeer) {\n    const wrappedConnection = Wrap(connection, {\n      lengthEncoder: uint16BEEncode,\n      lengthDecoder: uint16BEDecode,\n      maxDataLength: NOISE_MSG_MAX_LENGTH_BYTES\n    });\n    const handshake = await this.performHandshake({\n      connection: wrappedConnection,\n      isInitiator: false,\n      localPeer,\n      remotePeer\n    });\n    const conn = await this.createSecureConnection(wrappedConnection, handshake);\n    return {\n      conn,\n      remoteEarlyData: handshake.remoteEarlyData,\n      remotePeer: handshake.remotePeer\n    };\n  }\n  /**\n   * If Noise pipes supported, tries IK handshake first with XX as fallback if it fails.\n   * If noise pipes disabled or remote peer static key is unknown, use XX.\n   * @param params\n   */\n\n\n  async performHandshake(params) {\n    const payload = await getPayload(params.localPeer, this.staticKeys.publicKey, this.earlyData);\n    let tryIK = this.useNoisePipes;\n\n    if (params.isInitiator && KeyCache.load(params.remotePeer) === null) {\n      //if we are initiator and remote static key is unknown, don't try IK\n      tryIK = false;\n    } // Try IK if acting as responder or initiator that has remote's static key.\n\n\n    if (tryIK) {\n      // Try IK first\n      const {\n        remotePeer,\n        connection,\n        isInitiator\n      } = params;\n      const ikHandshake = new IKHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, //safe to cast as we did checks\n      KeyCache.load(params.remotePeer) || Buffer.alloc(32), remotePeer);\n\n      try {\n        return await this.performIKHandshake(ikHandshake);\n      } catch (e) {\n        // IK failed, go to XX fallback\n        let ephemeralKeys;\n\n        if (params.isInitiator) {\n          ephemeralKeys = ikHandshake.getLocalEphemeralKeys();\n        }\n\n        return await this.performXXFallbackHandshake(params, payload, e.initialMsg, ephemeralKeys);\n      }\n    } else {\n      // run XX handshake\n      return await this.performXXHandshake(params, payload);\n    }\n  }\n\n  async performXXFallbackHandshake(params, payload, initialMsg, ephemeralKeys) {\n    const {\n      isInitiator,\n      remotePeer,\n      connection\n    } = params;\n    const handshake = new XXFallbackHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, initialMsg, remotePeer, ephemeralKeys);\n\n    try {\n      await handshake.propose();\n      await handshake.exchange();\n      await handshake.finish();\n    } catch (e) {\n      logger(e);\n      throw new Error(\"Error occurred during XX Fallback handshake: \".concat(e.message));\n    }\n\n    return handshake;\n  }\n\n  async performXXHandshake(params, payload) {\n    const {\n      isInitiator,\n      remotePeer,\n      connection\n    } = params;\n    const handshake = new XXHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, remotePeer);\n\n    try {\n      await handshake.propose();\n      await handshake.exchange();\n      await handshake.finish();\n\n      if (this.useNoisePipes && handshake.remotePeer) {\n        KeyCache.store(handshake.remotePeer, handshake.getRemoteStaticKey());\n      }\n    } catch (e) {\n      throw new Error(\"Error occurred during XX handshake: \".concat(e.message));\n    }\n\n    return handshake;\n  }\n\n  async performIKHandshake(handshake) {\n    await handshake.stage0();\n    await handshake.stage1();\n    return handshake;\n  }\n\n  async createSecureConnection(connection, handshake) {\n    // Create encryption box/unbox wrapper\n    const [secure, user] = DuplexPair();\n    const network = connection.unwrap();\n    pipe(secure, // write to wrapper\n    ensureBuffer, // ensure any type of data is converted to buffer\n    encryptStream(handshake), // data is encrypted\n    encode({\n      lengthEncoder: uint16BEEncode\n    }), // prefix with message length\n    network, // send to the remote peer\n    decode({\n      lengthDecoder: uint16BEDecode\n    }), // read message length prefix\n    ensureBuffer, // ensure any type of data is converted to buffer\n    decryptStream(handshake), // decrypt the incoming data\n    secure // pipe to the wrapper\n    );\n    return user;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}