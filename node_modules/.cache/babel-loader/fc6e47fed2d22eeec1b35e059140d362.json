{"ast":null,"code":"'use strict';\n\nconst constants = require('./constants');\n\nconst errcode = require('err-code');\n\nclass Heartbeat {\n  /**\n   * @param {Object} gossipsub\n   * @constructor\n   */\n  constructor(gossipsub) {\n    this.gossipsub = gossipsub;\n  }\n\n  start() {\n    if (this._heartbeatTimer) {\n      const errMsg = 'Heartbeat timer is already running';\n      this.gossipsub.log(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_HEARTBEAT_ALREADY_RUNNING');\n    }\n\n    const heartbeat = this._heartbeat.bind(this);\n\n    const timeout = setTimeout(() => {\n      heartbeat();\n\n      this._heartbeatTimer.runPeriodically(heartbeat, constants.GossipSubHeartbeatInterval);\n    }, constants.GossipSubHeartbeatInitialDelay);\n    this._heartbeatTimer = {\n      _onCancel: null,\n      _intervalId: null,\n      runPeriodically: (fn, period) => {\n        this._heartbeatTimer._intervalId = setInterval(fn, period);\n      },\n      cancel: () => {\n        clearTimeout(timeout);\n        clearInterval(this._heartbeatTimer._intervalId);\n      }\n    };\n  }\n  /**\n   * Unmounts the gossipsub protocol and shuts down every connection\n   * @override\n   * @returns {void}\n   */\n\n\n  stop() {\n    if (!this._heartbeatTimer) {\n      const errMsg = 'Heartbeat timer is not running';\n      this.gossipsub.log(errMsg);\n      throw errcode(new Error(errMsg), 'ERR_HEARTBEAT_NO_RUNNING');\n    }\n\n    this._heartbeatTimer.cancel();\n\n    this._heartbeatTimer = null;\n  }\n  /**\n   * Maintains the mesh and fanout maps in gossipsub.\n   *\n   * @returns {void}\n   */\n\n\n  _heartbeat() {\n    // flush pending control message from retries and gossip\n    // that hasn't been piggybacked since the last heartbeat\n    this.gossipsub._flush();\n    /**\n     * @type {Map<Peer, Array<String>>}\n     */\n\n\n    const tograft = new Map();\n    const toprune = new Map(); // maintain the mesh for topics we have joined\n\n    this.gossipsub.mesh.forEach((peers, topic) => {\n      // do we have enough peers?\n      if (peers.size < constants.GossipSubDlo) {\n        const ineed = constants.GossipSubD - peers.size;\n\n        const peersSet = this.gossipsub._getPeers(topic, ineed);\n\n        peersSet.forEach(peer => {\n          // add topic peers not already in mesh\n          if (peers.has(peer)) {\n            return;\n          }\n\n          this.gossipsub.log('HEARTBEAT: Add mesh link to %s in %s', peer.info.id.toB58String(), topic);\n          peers.add(peer);\n          const peerGrafts = tograft.get(peer);\n\n          if (!peerGrafts) {\n            tograft.set(peer, [topic]);\n          } else {\n            peerGrafts.push(topic);\n          }\n        });\n      } // do we have to many peers?\n\n\n      if (peers.size > constants.GossipSubDhi) {\n        const idontneed = peers.size - constants.GossipSubD;\n        let peersArray = Array.from(peers);\n        peersArray = this.gossipsub._shufflePeers(peersArray);\n        peersArray = peersArray.slice(0, idontneed);\n        peersArray.forEach(peer => {\n          this.gossipsub.log('HEARTBEAT: Remove mesh link to %s in %s', peer.info.id.toB58String(), topic);\n          peers.delete(peer);\n          const peerPrunes = toprune.get(peer);\n\n          if (!peerPrunes) {\n            toprune.set(peer, [topic]);\n          } else {\n            peerPrunes.push(topic);\n          }\n        });\n      }\n\n      this.gossipsub._emitGossip(topic, peers);\n    }); // expire fanout for topics we haven't published to in a while\n\n    const now = this.gossipsub._now();\n\n    this.gossipsub.lastpub.forEach((lastpb, topic) => {\n      if (lastpb + constants.GossipSubFanoutTTL < now) {\n        this.gossipsub.fanout.delete(topic);\n        this.gossipsub.lastpub.delete(topic);\n      }\n    }); // maintain our fanout for topics we are publishing but we have not joined\n\n    this.gossipsub.fanout.forEach((peers, topic) => {\n      // checks whether our peers are still in the topic\n      peers.forEach(peer => {\n        if (this.gossipsub.topics.has(peer)) {\n          peers.delete(peer);\n        }\n      }); // do we need more peers?\n\n      if (peers.size < constants.GossipSubD) {\n        const ineed = constants.GossipSubD - peers.size;\n\n        const peersSet = this.gossipsub._getPeers(topic, ineed);\n\n        peersSet.forEach(peer => {\n          if (!peers.has(peer)) {\n            return;\n          }\n\n          peers.add(peer);\n        });\n      }\n\n      this.gossipsub._emitGossip(topic, peers);\n    }); // send coalesced GRAFT/PRUNE messages (will piggyback gossip)\n\n    this.gossipsub._sendGraftPrune(tograft, toprune); // advance the message history window\n\n\n    this.gossipsub.messageCache.shift();\n    this.gossipsub.emit('gossipsub:heartbeat');\n  }\n\n}\n\nmodule.exports = Heartbeat;","map":null,"metadata":{},"sourceType":"script"}