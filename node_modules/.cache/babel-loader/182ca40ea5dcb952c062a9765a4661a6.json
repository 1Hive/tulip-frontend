{"ast":null,"code":"import { CourtModuleType } from '../types/court-module-types';\nimport { bigNum } from '../lib/math-utils';\nimport { transformSubscriptionModuleDataAttributes } from './subscription-utils';\nimport { toMs } from './date-utils';\nexport function transformCourtConfigDataAttributes(courtConfig) {\n  const {\n    subscriptions: subscriptionModule\n  } = courtConfig;\n  return { ...courtConfig,\n    draftFee: bigNum(courtConfig.draftFee),\n    settleFee: bigNum(courtConfig.settleFee),\n    jurorFee: bigNum(courtConfig.jurorFee),\n    minActiveBalance: bigNum(courtConfig.minActiveBalance),\n    maxRegularAppealRounds: parseInt(courtConfig.maxRegularAppealRounds, 10),\n    termDuration: toMs(parseInt(courtConfig.termDuration, 10)),\n    currentTerm: parseInt(courtConfig.currentTerm, 10),\n    evidenceTerms: parseInt(courtConfig.evidenceTerms, 10),\n    commitTerms: parseInt(courtConfig.commitTerms, 10),\n    revealTerms: parseInt(courtConfig.revealTerms, 10),\n    appealTerms: parseInt(courtConfig.appealTerms, 10),\n    appealConfirmationTerms: parseInt(courtConfig.appealConfirmationTerms, 10),\n    terms: courtConfig.terms.map(term => ({ ...term,\n      startTime: toMs(parseInt(term.startTime, 10))\n    })),\n    subscriptionModule: transformSubscriptionModuleDataAttributes(subscriptionModule)\n  };\n}\n\nfunction getFirstTermStartTime(terms) {\n  if (terms.length === 0) {\n    throw new Error('Terms cannot be empty');\n  }\n\n  return terms[0].startTime;\n}\n\nexport function getExpectedCurrentTermId(now, {\n  terms,\n  termDuration\n}) {\n  const firstTermStartTime = getFirstTermStartTime(terms);\n  return Math.floor((now.valueOf() - firstTermStartTime) / termDuration);\n}\nexport function getTermStartTime(termId, {\n  terms,\n  termDuration\n}) {\n  const firstTermStartTime = getFirstTermStartTime(terms);\n  return termId * termDuration + firstTermStartTime;\n}\nexport function getTermEndTime(termId, {\n  terms,\n  termDuration\n}) {\n  const termStartTime = getTermStartTime(termId, {\n    terms,\n    termDuration\n  });\n  return termStartTime + (termDuration - 1);\n}\nexport function getTermPeriod(termId, {\n  terms,\n  termDuration\n}) {\n  return [getTermStartTime, getTermEndTime].map(f => f(termId, {\n    terms,\n    termDuration\n  }));\n}\nexport function getModuleAddress(modules, moduleType) {\n  const courtModule = modules.find(mod => CourtModuleType[mod.type] === moduleType);\n  return courtModule ? courtModule.address : null;\n}","map":{"version":3,"sources":["/Users/fabianmolina/Documents/1hive/tulip-frontend/src/utils/court-utils.js"],"names":["CourtModuleType","bigNum","transformSubscriptionModuleDataAttributes","toMs","transformCourtConfigDataAttributes","courtConfig","subscriptions","subscriptionModule","draftFee","settleFee","jurorFee","minActiveBalance","maxRegularAppealRounds","parseInt","termDuration","currentTerm","evidenceTerms","commitTerms","revealTerms","appealTerms","appealConfirmationTerms","terms","map","term","startTime","getFirstTermStartTime","length","Error","getExpectedCurrentTermId","now","firstTermStartTime","Math","floor","valueOf","getTermStartTime","termId","getTermEndTime","termStartTime","getTermPeriod","f","getModuleAddress","modules","moduleType","courtModule","find","mod","type","address"],"mappings":"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","sourcesContent":["import { CourtModuleType } from '../types/court-module-types'\r\nimport { bigNum } from '../lib/math-utils'\r\nimport { transformSubscriptionModuleDataAttributes } from './subscription-utils'\r\nimport { toMs } from './date-utils'\r\n\r\nexport function transformCourtConfigDataAttributes(courtConfig) {\r\n  const { subscriptions: subscriptionModule } = courtConfig\r\n  return {\r\n    ...courtConfig,\r\n    draftFee: bigNum(courtConfig.draftFee),\r\n    settleFee: bigNum(courtConfig.settleFee),\r\n    jurorFee: bigNum(courtConfig.jurorFee),\r\n    minActiveBalance: bigNum(courtConfig.minActiveBalance),\r\n    maxRegularAppealRounds: parseInt(courtConfig.maxRegularAppealRounds, 10),\r\n    termDuration: toMs(parseInt(courtConfig.termDuration, 10)),\r\n    currentTerm: parseInt(courtConfig.currentTerm, 10),\r\n    evidenceTerms: parseInt(courtConfig.evidenceTerms, 10),\r\n    commitTerms: parseInt(courtConfig.commitTerms, 10),\r\n    revealTerms: parseInt(courtConfig.revealTerms, 10),\r\n    appealTerms: parseInt(courtConfig.appealTerms, 10),\r\n    appealConfirmationTerms: parseInt(courtConfig.appealConfirmationTerms, 10),\r\n    terms: courtConfig.terms.map(term => ({\r\n      ...term,\r\n      startTime: toMs(parseInt(term.startTime, 10)),\r\n    })),\r\n    subscriptionModule: transformSubscriptionModuleDataAttributes(\r\n      subscriptionModule\r\n    ),\r\n  }\r\n}\r\n\r\nfunction getFirstTermStartTime(terms) {\r\n  if (terms.length === 0) {\r\n    throw new Error('Terms cannot be empty')\r\n  }\r\n\r\n  return terms[0].startTime\r\n}\r\n\r\nexport function getExpectedCurrentTermId(now, { terms, termDuration }) {\r\n  const firstTermStartTime = getFirstTermStartTime(terms)\r\n  return Math.floor((now.valueOf() - firstTermStartTime) / termDuration)\r\n}\r\n\r\nexport function getTermStartTime(termId, { terms, termDuration }) {\r\n  const firstTermStartTime = getFirstTermStartTime(terms)\r\n  return termId * termDuration + firstTermStartTime\r\n}\r\n\r\nexport function getTermEndTime(termId, { terms, termDuration }) {\r\n  const termStartTime = getTermStartTime(termId, { terms, termDuration })\r\n\r\n  return termStartTime + (termDuration - 1)\r\n}\r\n\r\nexport function getTermPeriod(termId, { terms, termDuration }) {\r\n  return [getTermStartTime, getTermEndTime].map(f =>\r\n    f(termId, { terms, termDuration })\r\n  )\r\n}\r\n\r\nexport function getModuleAddress(modules, moduleType) {\r\n  const courtModule = modules.find(\r\n    mod => CourtModuleType[mod.type] === moduleType\r\n  )\r\n\r\n  return courtModule ? courtModule.address : null\r\n}\r\n"]},"metadata":{},"sourceType":"module"}