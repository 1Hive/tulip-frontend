{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _asyncIterator = require(\"/Users/fabianmolina/Documents/1hive/tulip-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncIterator\");\n\nvar abortable = require('abortable-iterator');\n\nvar AbortController = require('abort-controller');\n\nvar log = require('debug')('libp2p:mplex:stream');\n\nvar pushable = require('it-pushable');\n\nvar BufferList = require('bl/BufferList');\n\nvar _require = require('./restrict-size'),\n    MAX_MSG_SIZE = _require.MAX_MSG_SIZE;\n\nvar _require2 = require('./message-types'),\n    InitiatorMessageTypes = _require2.InitiatorMessageTypes,\n    ReceiverMessageTypes = _require2.ReceiverMessageTypes;\n/**\n * @param {object} options\n * @param {number} options.id\n * @param {string} options.name\n * @param {function(*)} options.send Called to send data through the stream\n * @param {function(Error)} [options.onEnd] Called whenever the stream ends\n * @param {string} [options.type] One of ['initiator','receiver']. Defaults to 'initiator'\n * @param {number} [options.maxMsgSize] Max size of an mplex message in bytes. Writes > size are automatically split. Defaults to 1MB\n * @returns {*} A muxed stream\n */\n\n\nmodule.exports = function (_ref) {\n  var id = _ref.id,\n      name = _ref.name,\n      send = _ref.send,\n      _ref$onEnd = _ref.onEnd,\n      onEnd = _ref$onEnd === void 0 ? function () {} : _ref$onEnd,\n      _ref$type = _ref.type,\n      type = _ref$type === void 0 ? 'initiator' : _ref$type,\n      _ref$maxMsgSize = _ref.maxMsgSize,\n      maxMsgSize = _ref$maxMsgSize === void 0 ? MAX_MSG_SIZE : _ref$maxMsgSize;\n  var abortController = new AbortController();\n  var resetController = new AbortController();\n  var Types = type === 'initiator' ? InitiatorMessageTypes : ReceiverMessageTypes;\n  var externalId = type === 'initiator' ? \"i\".concat(id) : \"r\".concat(id);\n  name = String(name == null ? id : name);\n  var sourceEnded = false;\n  var sinkEnded = false;\n  var endErr;\n\n  var onSourceEnd = function onSourceEnd(err) {\n    sourceEnded = true;\n    log('%s stream %s source end', type, name, err);\n    if (err && !endErr) endErr = err;\n\n    if (sinkEnded) {\n      stream.timeline.close = Date.now();\n      onEnd(endErr);\n    }\n  };\n\n  var onSinkEnd = function onSinkEnd(err) {\n    sinkEnded = true;\n    log('%s stream %s sink end', type, name, err);\n    if (err && !endErr) endErr = err;\n\n    if (sourceEnded) {\n      stream.timeline.close = Date.now();\n      onEnd(endErr);\n    }\n  };\n\n  var stream = {\n    // Close for reading\n    close: function close() {\n      return stream.source.end();\n    },\n    // Close for reading and writing (local error)\n    abort: function abort(err) {\n      log('%s stream %s abort', type, name, err); // End the source with the passed error\n\n      stream.source.end(err);\n      abortController.abort();\n    },\n    // Close immediately for reading and writing (remote error)\n    reset: function reset() {\n      return resetController.abort();\n    },\n    sink: function () {\n      var _sink = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(source) {\n        var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, data;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                source = abortable(source, [{\n                  signal: abortController.signal,\n                  options: {\n                    abortMessage: 'stream aborted',\n                    abortCode: 'ERR_MPLEX_STREAM_ABORT'\n                  }\n                }, {\n                  signal: resetController.signal,\n                  options: {\n                    abortMessage: 'stream reset',\n                    abortCode: 'ERR_MPLEX_STREAM_RESET'\n                  }\n                }]);\n\n                if (type === 'initiator') {\n                  // If initiator, open a new stream\n                  send({\n                    id: id,\n                    type: Types.NEW_STREAM,\n                    data: name\n                  });\n                }\n\n                _context.prev = 2;\n                _iteratorNormalCompletion = true;\n                _didIteratorError = false;\n                _context.prev = 5;\n                _iterator = _asyncIterator(source);\n\n              case 7:\n                _context.next = 9;\n                return _iterator.next();\n\n              case 9:\n                _step = _context.sent;\n                _iteratorNormalCompletion = _step.done;\n                _context.next = 13;\n                return _step.value;\n\n              case 13:\n                _value = _context.sent;\n\n                if (_iteratorNormalCompletion) {\n                  _context.next = 28;\n                  break;\n                }\n\n                data = _value;\n\n              case 16:\n                if (!data.length) {\n                  _context.next = 25;\n                  break;\n                }\n\n                if (!(data.length <= maxMsgSize)) {\n                  _context.next = 20;\n                  break;\n                }\n\n                send({\n                  id: id,\n                  type: Types.MESSAGE,\n                  data: data\n                });\n                return _context.abrupt(\"break\", 25);\n\n              case 20:\n                data = BufferList.isBufferList(data) ? data : new BufferList(data);\n                send({\n                  id: id,\n                  type: Types.MESSAGE,\n                  data: data.shallowSlice(0, maxMsgSize)\n                });\n                data.consume(maxMsgSize);\n                _context.next = 16;\n                break;\n\n              case 25:\n                _iteratorNormalCompletion = true;\n                _context.next = 7;\n                break;\n\n              case 28:\n                _context.next = 34;\n                break;\n\n              case 30:\n                _context.prev = 30;\n                _context.t0 = _context[\"catch\"](5);\n                _didIteratorError = true;\n                _iteratorError = _context.t0;\n\n              case 34:\n                _context.prev = 34;\n                _context.prev = 35;\n\n                if (!(!_iteratorNormalCompletion && _iterator.return != null)) {\n                  _context.next = 39;\n                  break;\n                }\n\n                _context.next = 39;\n                return _iterator.return();\n\n              case 39:\n                _context.prev = 39;\n\n                if (!_didIteratorError) {\n                  _context.next = 42;\n                  break;\n                }\n\n                throw _iteratorError;\n\n              case 42:\n                return _context.finish(39);\n\n              case 43:\n                return _context.finish(34);\n\n              case 44:\n                _context.next = 51;\n                break;\n\n              case 46:\n                _context.prev = 46;\n                _context.t1 = _context[\"catch\"](2);\n\n                // Send no more data if this stream was remotely reset\n                if (_context.t1.code === 'ERR_MPLEX_STREAM_RESET') {\n                  log('%s stream %s reset', type, name);\n                } else {\n                  log('%s stream %s error', type, name, _context.t1);\n                  send({\n                    id: id,\n                    type: Types.RESET\n                  });\n                }\n\n                stream.source.end(_context.t1);\n                return _context.abrupt(\"return\", onSinkEnd(_context.t1));\n\n              case 51:\n                send({\n                  id: id,\n                  type: Types.CLOSE\n                });\n                onSinkEnd();\n\n              case 53:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[2, 46], [5, 30, 34, 44], [35,, 39, 43]]);\n      }));\n\n      function sink(_x) {\n        return _sink.apply(this, arguments);\n      }\n\n      return sink;\n    }(),\n    source: pushable(onSourceEnd),\n    timeline: {\n      open: Date.now(),\n      close: null\n    },\n    id: externalId\n  };\n  return stream;\n};","map":null,"metadata":{},"sourceType":"script"}