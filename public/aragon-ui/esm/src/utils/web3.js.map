{"version":3,"file":"web3.js","sources":["../../../../src/utils/web3.js"],"sourcesContent":["import sha3 from 'js-sha3'\nimport { warn } from './environment'\n\nconst { keccak_256: keccak256 } = sha3\n\nconst EMPTY_ADDRESS = '0x0000000000000000000000000000000000000000'\nconst TRANSACTION_REGEX = /^0x[A-Fa-f0-9]{64}$/\nconst ADDRESS_REGEX = /^0x[0-9a-fA-F]{40}$/\n\nconst TRUST_WALLET_BASE_URL =\n  'https://raw.githubusercontent.com/trustwallet/assets/master/blockchains/ethereum'\n\nconst ETHERSCAN_NETWORK_TYPES = new Map([\n  ['main', ''],\n  ['kovan', 'kovan.'],\n  ['rinkeby', 'rinkeby.'],\n  ['ropsten', 'ropsten.'],\n  ['goerli', 'goerli.'],\n])\nconst ETHERSCAN_TYPES = new Map([\n  ['block', 'block'],\n  ['transaction', 'tx'],\n  ['address', 'address'],\n  ['token', 'token'],\n])\n\nconst BLOCK_EXPLORERS = {\n  etherscan: ({ type, value, networkType }) => {\n    if (networkType === 'private') {\n      return ''\n    }\n\n    if (!ETHERSCAN_NETWORK_TYPES.has(networkType)) {\n      throw new Error('provider not supported.')\n    }\n    if (!ETHERSCAN_TYPES.has(type)) {\n      throw new Error('type not supported.')\n    }\n\n    const subdomain = ETHERSCAN_NETWORK_TYPES.get(networkType)\n    const typePart = ETHERSCAN_TYPES.get(type)\n    return `https://${subdomain}etherscan.io/${typePart}/${value}`\n  },\n}\n\n/**\n * Converts to a checksum address\n *\n * This function is taken from web3-utils:\n * https://github.com/ethereum/web3.js/blob/22df832303e349f8ae02f0392e56abe10e1dfaac/packages/web3-utils/src/index.js#L287-L315\n * And was adapted to use js-sha3 rather than soliditySha3.js from web3.js, in\n * order to avoid adding the BN.js and underscore dependencies.\n *\n * @method toChecksumAddress\n * @param {String} address the given HEX address\n * @returns {String}\n */\nfunction toChecksumAddress(address) {\n  if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {\n    throw new Error(\n      'Given address \"' + address + '\" is not a valid Ethereum address.'\n    )\n  }\n\n  address = address.toLowerCase().replace(/^0x/i, '')\n\n  const addressHash = keccak256(address).replace(/^0x/i, '')\n  let checksumAddress = '0x'\n\n  for (let i = 0; i < address.length; i++) {\n    // If ith character is 9 to f then make it uppercase\n    if (parseInt(addressHash[i], 16) > 7) {\n      checksumAddress += address[i].toUpperCase()\n    } else {\n      checksumAddress += address[i]\n    }\n  }\n\n  return checksumAddress\n}\n\n/**\n * Check address equality without checksums\n * @param {string} first First address\n * @param {string} second Second address\n * @returns {boolean} Address equality\n */\nexport function addressesEqual(first, second) {\n  first = first && first.toLowerCase()\n  second = second && second.toLowerCase()\n  return first === second\n}\n\n/**\n * Shorten an Ethereum address. `charsLength` allows to change the number of\n * characters on both sides of the ellipsis.\n *\n * Examples:\n *   shortenAddress('0x19731977931271')    // 0x1973…1271\n *   shortenAddress('0x19731977931271', 2) // 0x19…71\n *   shortenAddress('0x197319')            // 0x197319 (already short enough)\n *\n * @param {string} address The address to shorten\n * @param {number} [charsLength=4] The number of characters to change on both sides of the ellipsis\n * @returns {string} The shortened address\n */\nexport function shortenAddress(address, charsLength = 4) {\n  const prefixLength = 2 // \"0x\"\n  if (!address) {\n    return ''\n  }\n  if (address.length < charsLength * 2 + prefixLength) {\n    return address\n  }\n  return (\n    address.slice(0, charsLength + prefixLength) +\n    '…' +\n    address.slice(-charsLength)\n  )\n}\n\n/**\n * Alias for shortenAddress (to generalize its use)\n */\nexport const shortenTransaction = shortenAddress\n\n/**\n *\n * Checks if the given string is an address\n *\n * @method isAddress\n * @param {string} address the given HEX address\n * @returns {boolean}\n */\nexport function isAddress(address) {\n  return ADDRESS_REGEX.test(address)\n}\n\n/**\n *\n * Checks if the given string is a transaction\n *\n * @method isTransaction\n * @param {string} address the given HEX address\n * @returns {boolean}\n */\nexport function isTransaction(transaction) {\n  return TRANSACTION_REGEX.test(transaction)\n}\n\n/**\n * Generates an etherscan URL\n *\n * @param {string} type The type of URL (block, transaction, address or token).\n * @param {string} value Identifier of the object, depending on the type (block number, transaction hash, …).\n * @param {object} options The optional parameters.\n * @param {string} options.networkType The Ethereum network type (main, kovan, rinkeby, ropsten, goerli, or private).\n * @param {string} options.provider The explorer provider (e.g. etherscan).\n * @returns {string} The generated URL, or an empty string if the parameters are invalid.\n */\nexport function blockExplorerUrl(\n  type,\n  value,\n  { networkType = 'main', provider = 'etherscan' } = {}\n) {\n  const explorer = BLOCK_EXPLORERS[provider]\n\n  if (!explorer) {\n    warn('blockExplorerUrl(): provider not supported.')\n    return ''\n  }\n\n  try {\n    return explorer({ type, value, networkType })\n  } catch (err) {\n    warn(`blockExplorerUrl(): ${err.message}`)\n    return ''\n  }\n}\n\n/**\n * Get the address of a token icon\n *\n * @param {string} address The contract address of the token, or the zero address (0x000…) to get the Ethereum icon.\n * @returns {string} The generated URL, or an empty string if the parameters are invalid.\n */\nexport function tokenIconUrl(address = '') {\n  try {\n    address = toChecksumAddress(address.trim())\n  } catch (err) {\n    return ''\n  }\n\n  if (address === EMPTY_ADDRESS) {\n    return `${TRUST_WALLET_BASE_URL}/info/logo.png`\n  }\n\n  return `${TRUST_WALLET_BASE_URL}/assets/${address}/logo.png`\n}\n"],"names":["keccak256","sha3","keccak_256","EMPTY_ADDRESS","TRANSACTION_REGEX","ADDRESS_REGEX","TRUST_WALLET_BASE_URL","ETHERSCAN_NETWORK_TYPES","Map","ETHERSCAN_TYPES","BLOCK_EXPLORERS","etherscan","type","value","networkType","has","Error","subdomain","get","typePart","toChecksumAddress","address","test","toLowerCase","replace","addressHash","checksumAddress","i","length","parseInt","toUpperCase","addressesEqual","first","second","shortenAddress","charsLength","prefixLength","slice","shortenTransaction","isAddress","isTransaction","transaction","blockExplorerUrl","provider","explorer","warn","err","message","tokenIconUrl","trim"],"mappings":";;;IAGoBA,YAAcC,KAA1BC;AAER,IAAMC,aAAa,GAAG,4CAAtB;AACA,IAAMC,iBAAiB,GAAG,qBAA1B;AACA,IAAMC,aAAa,GAAG,qBAAtB;AAEA,IAAMC,qBAAqB,GACzB,kFADF;AAGA,IAAMC,uBAAuB,GAAG,IAAIC,GAAJ,CAAQ,CACtC,CAAC,MAAD,EAAS,EAAT,CADsC,EAEtC,CAAC,OAAD,EAAU,QAAV,CAFsC,EAGtC,CAAC,SAAD,EAAY,UAAZ,CAHsC,EAItC,CAAC,SAAD,EAAY,UAAZ,CAJsC,EAKtC,CAAC,QAAD,EAAW,SAAX,CALsC,CAAR,CAAhC;AAOA,IAAMC,eAAe,GAAG,IAAID,GAAJ,CAAQ,CAC9B,CAAC,OAAD,EAAU,OAAV,CAD8B,EAE9B,CAAC,aAAD,EAAgB,IAAhB,CAF8B,EAG9B,CAAC,SAAD,EAAY,SAAZ,CAH8B,EAI9B,CAAC,OAAD,EAAU,OAAV,CAJ8B,CAAR,CAAxB;AAOA,IAAME,eAAe,GAAG;AACtBC,EAAAA,SAAS,EAAE,yBAAkC;AAAA,QAA/BC,IAA+B,QAA/BA,IAA+B;AAAA,QAAzBC,KAAyB,QAAzBA,KAAyB;AAAA,QAAlBC,WAAkB,QAAlBA,WAAkB;;AAC3C,QAAIA,WAAW,KAAK,SAApB,EAA+B;AAC7B,aAAO,EAAP;AACD;;AAED,QAAI,CAACP,uBAAuB,CAACQ,GAAxB,CAA4BD,WAA5B,CAAL,EAA+C;AAC7C,YAAM,IAAIE,KAAJ,CAAU,yBAAV,CAAN;AACD;;AACD,QAAI,CAACP,eAAe,CAACM,GAAhB,CAAoBH,IAApB,CAAL,EAAgC;AAC9B,YAAM,IAAII,KAAJ,CAAU,qBAAV,CAAN;AACD;;AAED,QAAMC,SAAS,GAAGV,uBAAuB,CAACW,GAAxB,CAA4BJ,WAA5B,CAAlB;AACA,QAAMK,QAAQ,GAAGV,eAAe,CAACS,GAAhB,CAAoBN,IAApB,CAAjB;AACA,6BAAkBK,SAAlB,0BAA2CE,QAA3C,cAAuDN,KAAvD;AACD;AAhBqB,CAAxB;AAmBA;;;;;;;;;;;;;AAYA,SAASO,iBAAT,CAA2BC,OAA3B,EAAoC;AAClC,MAAI,CAAC,uBAAuBC,IAAvB,CAA4BD,OAA5B,CAAL,EAA2C;AACzC,UAAM,IAAIL,KAAJ,CACJ,oBAAoBK,OAApB,GAA8B,oCAD1B,CAAN;AAGD;;AAEDA,EAAAA,OAAO,GAAGA,OAAO,CAACE,WAAR,GAAsBC,OAAtB,CAA8B,MAA9B,EAAsC,EAAtC,CAAV;AAEA,MAAMC,WAAW,GAAGzB,SAAS,CAACqB,OAAD,CAAT,CAAmBG,OAAnB,CAA2B,MAA3B,EAAmC,EAAnC,CAApB;AACA,MAAIE,eAAe,GAAG,IAAtB;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,OAAO,CAACO,MAA5B,EAAoCD,CAAC,EAArC,EAAyC;AACvC;AACA,QAAIE,QAAQ,CAACJ,WAAW,CAACE,CAAD,CAAZ,EAAiB,EAAjB,CAAR,GAA+B,CAAnC,EAAsC;AACpCD,MAAAA,eAAe,IAAIL,OAAO,CAACM,CAAD,CAAP,CAAWG,WAAX,EAAnB;AACD,KAFD,MAEO;AACLJ,MAAAA,eAAe,IAAIL,OAAO,CAACM,CAAD,CAA1B;AACD;AACF;;AAED,SAAOD,eAAP;AACD;AAED;;;;;;;;AAMO,SAASK,cAAT,CAAwBC,KAAxB,EAA+BC,MAA/B,EAAuC;AAC5CD,EAAAA,KAAK,GAAGA,KAAK,IAAIA,KAAK,CAACT,WAAN,EAAjB;AACAU,EAAAA,MAAM,GAAGA,MAAM,IAAIA,MAAM,CAACV,WAAP,EAAnB;AACA,SAAOS,KAAK,KAAKC,MAAjB;AACD;AAED;;;;;;;;;;;;;;AAaO,SAASC,cAAT,CAAwBb,OAAxB,EAAkD;AAAA,MAAjBc,WAAiB,uEAAH,CAAG;AACvD,MAAMC,YAAY,GAAG,CAArB,CADuD;;AAEvD,MAAI,CAACf,OAAL,EAAc;AACZ,WAAO,EAAP;AACD;;AACD,MAAIA,OAAO,CAACO,MAAR,GAAiBO,WAAW,GAAG,CAAd,GAAkBC,YAAvC,EAAqD;AACnD,WAAOf,OAAP;AACD;;AACD,SACEA,OAAO,CAACgB,KAAR,CAAc,CAAd,EAAiBF,WAAW,GAAGC,YAA/B,IACA,GADA,GAEAf,OAAO,CAACgB,KAAR,CAAc,CAACF,WAAf,CAHF;AAKD;AAED;;;;IAGaG,kBAAkB,GAAGJ;AAElC;;;;;;;;;AAQO,SAASK,SAAT,CAAmBlB,OAAnB,EAA4B;AACjC,SAAOhB,aAAa,CAACiB,IAAd,CAAmBD,OAAnB,CAAP;AACD;AAED;;;;;;;;;AAQO,SAASmB,aAAT,CAAuBC,WAAvB,EAAoC;AACzC,SAAOrC,iBAAiB,CAACkB,IAAlB,CAAuBmB,WAAvB,CAAP;AACD;AAED;;;;;;;;;;;AAUO,SAASC,gBAAT,CACL9B,IADK,EAELC,KAFK,EAIL;AAAA,kFADmD,EACnD;AAAA,gCADEC,WACF;AAAA,MADEA,WACF,kCADgB,MAChB;AAAA,6BADwB6B,QACxB;AAAA,MADwBA,QACxB,+BADmC,WACnC;;AACA,MAAMC,QAAQ,GAAGlC,eAAe,CAACiC,QAAD,CAAhC;;AAEA,MAAI,CAACC,QAAL,EAAe;AACbC,IAAAA,IAAI,CAAC,6CAAD,CAAJ;AACA,WAAO,EAAP;AACD;;AAED,MAAI;AACF,WAAOD,QAAQ,CAAC;AAAEhC,MAAAA,IAAI,EAAJA,IAAF;AAAQC,MAAAA,KAAK,EAALA,KAAR;AAAeC,MAAAA,WAAW,EAAXA;AAAf,KAAD,CAAf;AACD,GAFD,CAEE,OAAOgC,GAAP,EAAY;AACZD,IAAAA,IAAI,+BAAwBC,GAAG,CAACC,OAA5B,EAAJ;AACA,WAAO,EAAP;AACD;AACF;AAED;;;;;;;AAMO,SAASC,YAAT,GAAoC;AAAA,MAAd3B,OAAc,uEAAJ,EAAI;;AACzC,MAAI;AACFA,IAAAA,OAAO,GAAGD,iBAAiB,CAACC,OAAO,CAAC4B,IAAR,EAAD,CAA3B;AACD,GAFD,CAEE,OAAOH,GAAP,EAAY;AACZ,WAAO,EAAP;AACD;;AAED,MAAIzB,OAAO,KAAKlB,aAAhB,EAA+B;AAC7B,qBAAUG,qBAAV;AACD;;AAED,mBAAUA,qBAAV,qBAA0Ce,OAA1C;AACD;;;;"}